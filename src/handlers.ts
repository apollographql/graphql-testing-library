import { gql } from "graphql-tag";
import { execute } from "@graphql-tools/executor";
import type { ExecutionResult, GraphQLSchema, ASTNode } from "graphql";
import { visit, BREAK } from "graphql";
import { HttpResponse, graphql } from "msw";

const encoder = new TextEncoder();

export function hasDirectives(names: string[], root: ASTNode, all?: boolean) {
  const nameSet = new Set(names);
  const uniqueCount = nameSet.size;

  visit(root, {
    Directive(node) {
      if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
        return BREAK;
      }
    },
  });

  // If we found all the names, nameSet will be empty. If we only care about
  // finding some of them, the < condition is sufficient.
  return all ? !nameSet.size : nameSet.size < uniqueCount;
}

let testSchema: GraphQLSchema;

export function replaceSchema(newSchema: GraphQLSchema) {
  const oldSchema = testSchema;
  testSchema = newSchema;

  function restore() {
    testSchema = oldSchema;
  }

  return Object.assign(restore, {
    [Symbol.dispose]() {
      restore();
    },
  });
}

const wait = (time: number) =>
  new Promise((resolve) => setTimeout(resolve, time));

// TODO: take second arg with options: min/max time

export const createHandler = (schema: GraphQLSchema) => {
  testSchema = schema;
  // Intercept all GraphQL operations and return a response generated by the
  // test schema. Add additional handlers as needed.
  return graphql.operation<
    ExecutionResult<Record<string, unknown>, Record<string, unknown>>
    // @ts-expect-error FIXME: mismatch on the return type between HttpResponse
    // with a stream vs. json
  >(async ({ query, variables, operationName }) => {
    const document = gql(query);
    const hasDefer = hasDirectives(["defer"], document);
    const boundaryStr = "-";

    if (hasDefer) {
      // create ReadableStream with result
      const result = await execute({
        document,
        operationName,
        schema: testSchema,
        variableValues: variables,
      });

      const contentType = "Content-Type: application/json";
      const boundary = `--${boundaryStr}`;
      const terminatingBoundary = `--${boundaryStr}--`;
      const CRLF = "\r\n";

      const chunks: Array<string> = [];

      if ("initialResult" in result) {
        chunks.push(
          CRLF,
          boundary,
          CRLF,
          contentType,
          CRLF,
          CRLF,
          JSON.stringify(result.initialResult)
        );
      }

      let finished = false;
      if ("subsequentResults" in result) {
        while (!finished) {
          // eslint-disable-next-line no-await-in-loop
          const nextResult = await result.subsequentResults.next();
          const currentResult = [
            CRLF,
            boundary,
            CRLF,
            contentType,
            CRLF,
            CRLF,
            JSON.stringify(nextResult.value),
          ];

          // @ts-expect-error
          if (!nextResult.hasNext) {
            finished = true;
            currentResult.push(CRLF, terminatingBoundary, CRLF);
          }
          chunks.push(...currentResult);
        }
      }

      const stream = new ReadableStream({
        async start(controller) {
          try {
            for (const c of chunks) {
              await wait(100);
              controller.enqueue(encoder.encode(c));
            }
          } finally {
            controller.close();
          }
        },
      });

      return new HttpResponse(stream, {
        headers: {
          "Content-Type": "multipart/mixed",
        },
      });
    } else {
      const result = await execute({
        document,
        operationName,
        schema: testSchema,
        variableValues: variables,
      });
      // @ts-expect-error error type mismatch
      return HttpResponse.json(result);
    }
  });
};
