import {
  type GraphQLResolveInfo,
  GraphQLScalarType,
  type GraphQLScalarTypeConfig,
} from "graphql";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T,
> = { [_ in K]?: never };
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends " $fragmentName" | "__typename" ? T[P] : never;
    };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & {
  [P in K]-?: NonNullable<T[P]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  /** A (potentially binary) string encoded using base64. */
  Base64String: { input: any; output: any };
  /**
   * Represents non-fractional signed whole numeric values. Since the value may
   * exceed the size of a 32-bit integer, it's encoded as a string.
   */
  BigInt: { input: any; output: any };
  /** An ISO-8601 encoded date string. */
  Date: { input: any; output: any };
  /** An ISO-8601 encoded UTC date string. */
  DateTime: { input: any; output: any };
  /** A Git object ID. */
  GitObjectID: { input: any; output: any };
  /** A fully qualified reference name (e.g. `refs/heads/master`). */
  GitRefname: { input: any; output: any };
  /** Git SSH string */
  GitSSHRemote: { input: any; output: any };
  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
  GitTimestamp: { input: any; output: any };
  /** A string containing HTML code. */
  HTML: { input: any; output: any };
  /** An ISO-8601 encoded UTC date string with millisecond precision. */
  PreciseDateTime: { input: any; output: any };
  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
  URI: { input: any; output: any };
  /** A valid x509 certificate string */
  X509Certificate: { input: any; output: any };
};

/** Autogenerated input type of AbortQueuedMigrations */
export type AbortQueuedMigrationsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the organization that is running the migrations. */
  ownerId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AbortQueuedMigrations. */
export type AbortQueuedMigrationsPayload = {
  __typename?: "AbortQueuedMigrationsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars["Boolean"]["output"]>;
};

/** Autogenerated input type of AbortRepositoryMigration */
export type AbortRepositoryMigrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the migration to be aborted. */
  migrationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AbortRepositoryMigration. */
export type AbortRepositoryMigrationPayload = {
  __typename?: "AbortRepositoryMigrationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars["Boolean"]["output"]>;
};

/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */
export type AcceptEnterpriseAdministratorInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The id of the invitation being accepted */
  invitationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AcceptEnterpriseAdministratorInvitation. */
export type AcceptEnterpriseAdministratorInvitationPayload = {
  __typename?: "AcceptEnterpriseAdministratorInvitationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The invitation that was accepted. */
  invitation?: Maybe<EnterpriseAdministratorInvitation>;
  /** A message confirming the result of accepting an administrator invitation. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of AcceptEnterpriseMemberInvitation */
export type AcceptEnterpriseMemberInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The id of the invitation being accepted */
  invitationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AcceptEnterpriseMemberInvitation. */
export type AcceptEnterpriseMemberInvitationPayload = {
  __typename?: "AcceptEnterpriseMemberInvitationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The invitation that was accepted. */
  invitation?: Maybe<EnterpriseMemberInvitation>;
  /** A message confirming the result of accepting an unaffiliated member invitation. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of AcceptTopicSuggestion */
export type AcceptTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The name of the suggested topic.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `name` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The Node ID of the repository.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `repositoryId` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of AcceptTopicSuggestion. */
export type AcceptTopicSuggestionPayload = {
  __typename?: "AcceptTopicSuggestionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /**
   * The accepted topic.
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  topic?: Maybe<Topic>;
};

/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type Actor = {
  /** A URL pointing to the actor's public avatar. */
  avatarUrl: Scalars["URI"]["output"];
  /** The username of the actor. */
  login: Scalars["String"]["output"];
  /** The HTTP path for this actor. */
  resourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for this actor. */
  url: Scalars["URI"]["output"];
};

/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type ActorAvatarUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Location information for an actor */
export type ActorLocation = {
  __typename?: "ActorLocation";
  /** City */
  city?: Maybe<Scalars["String"]["output"]>;
  /** Country name */
  country?: Maybe<Scalars["String"]["output"]>;
  /** Country code */
  countryCode?: Maybe<Scalars["String"]["output"]>;
  /** Region name */
  region?: Maybe<Scalars["String"]["output"]>;
  /** Region or state code */
  regionCode?: Maybe<Scalars["String"]["output"]>;
};

/** The actor's type. */
export enum ActorType {
  /** Indicates a team actor. */
  Team = "TEAM",
  /** Indicates a user actor. */
  User = "USER",
}

/** Autogenerated input type of AddAssigneesToAssignable */
export type AddAssigneesToAssignableInput = {
  /** The id of the assignable object to add assignees to. */
  assignableId: Scalars["ID"]["input"];
  /** The id of users to add as assignees. */
  assigneeIds: Array<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of AddAssigneesToAssignable. */
export type AddAssigneesToAssignablePayload = {
  __typename?: "AddAssigneesToAssignablePayload";
  /** The item that was assigned. */
  assignable?: Maybe<Assignable>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of AddComment */
export type AddCommentInput = {
  /** The contents of the comment. */
  body: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AddComment. */
export type AddCommentPayload = {
  __typename?: "AddCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The edge from the subject's comment connection. */
  commentEdge?: Maybe<IssueCommentEdge>;
  /** The subject */
  subject?: Maybe<Node>;
  /** The edge from the subject's timeline connection. */
  timelineEdge?: Maybe<IssueTimelineItemEdge>;
};

/** Autogenerated input type of AddDiscussionComment */
export type AddDiscussionCommentInput = {
  /** The contents of the comment. */
  body: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the discussion to comment on. */
  discussionId: Scalars["ID"]["input"];
  /** The Node ID of the discussion comment within this discussion to reply to. */
  replyToId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of AddDiscussionComment. */
export type AddDiscussionCommentPayload = {
  __typename?: "AddDiscussionCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The newly created discussion comment. */
  comment?: Maybe<DiscussionComment>;
};

/** Autogenerated input type of AddDiscussionPollVote */
export type AddDiscussionPollVoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the discussion poll option to vote for. */
  pollOptionId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AddDiscussionPollVote. */
export type AddDiscussionPollVotePayload = {
  __typename?: "AddDiscussionPollVotePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The poll option that a vote was added to. */
  pollOption?: Maybe<DiscussionPollOption>;
};

/** Autogenerated input type of AddEnterpriseOrganizationMember */
export type AddEnterpriseOrganizationMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise which owns the organization. */
  enterpriseId: Scalars["ID"]["input"];
  /** The ID of the organization the users will be added to. */
  organizationId: Scalars["ID"]["input"];
  /** The role to assign the users in the organization */
  role?: InputMaybe<OrganizationMemberRole>;
  /** The IDs of the enterprise members to add. */
  userIds: Array<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of AddEnterpriseOrganizationMember. */
export type AddEnterpriseOrganizationMemberPayload = {
  __typename?: "AddEnterpriseOrganizationMemberPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The users who were added to the organization. */
  users?: Maybe<Array<User>>;
};

/** Autogenerated input type of AddEnterpriseSupportEntitlement */
export type AddEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars["ID"]["input"];
  /** The login of a member who will receive the support entitlement. */
  login: Scalars["String"]["input"];
};

/** Autogenerated return type of AddEnterpriseSupportEntitlement. */
export type AddEnterpriseSupportEntitlementPayload = {
  __typename?: "AddEnterpriseSupportEntitlementPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** A message confirming the result of adding the support entitlement. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of AddLabelsToLabelable */
export type AddLabelsToLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ids of the labels to add. */
  labelIds: Array<Scalars["ID"]["input"]>;
  /** The id of the labelable object to add labels to. */
  labelableId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AddLabelsToLabelable. */
export type AddLabelsToLabelablePayload = {
  __typename?: "AddLabelsToLabelablePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The item that was labeled. */
  labelable?: Maybe<Labelable>;
};

/** Autogenerated input type of AddProjectCard */
export type AddProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The content of the card. Must be a member of the ProjectCardItem union */
  contentId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The note on the card. */
  note?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the ProjectColumn. */
  projectColumnId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AddProjectCard. */
export type AddProjectCardPayload = {
  __typename?: "AddProjectCardPayload";
  /** The edge from the ProjectColumn's card connection. */
  cardEdge?: Maybe<ProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The ProjectColumn */
  projectColumn?: Maybe<ProjectColumn>;
};

/** Autogenerated input type of AddProjectColumn */
export type AddProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the column. */
  name: Scalars["String"]["input"];
  /** The Node ID of the project. */
  projectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AddProjectColumn. */
export type AddProjectColumnPayload = {
  __typename?: "AddProjectColumnPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The edge from the project's column connection. */
  columnEdge?: Maybe<ProjectColumnEdge>;
  /** The project */
  project?: Maybe<Project>;
};

/** Autogenerated input type of AddProjectV2DraftIssue */
export type AddProjectV2DraftIssueInput = {
  /** The IDs of the assignees of the draft issue. */
  assigneeIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The body of the draft issue. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Project to add the draft issue to. */
  projectId: Scalars["ID"]["input"];
  /**
   * The title of the draft issue. A project item can also be created by providing
   * the URL of an Issue or Pull Request if you have access.
   */
  title: Scalars["String"]["input"];
};

/** Autogenerated return type of AddProjectV2DraftIssue. */
export type AddProjectV2DraftIssuePayload = {
  __typename?: "AddProjectV2DraftIssuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The draft issue added to the project. */
  projectItem?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of AddProjectV2ItemById */
export type AddProjectV2ItemByIdInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The id of the Issue or Pull Request to add. */
  contentId: Scalars["ID"]["input"];
  /** The ID of the Project to add the item to. */
  projectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AddProjectV2ItemById. */
export type AddProjectV2ItemByIdPayload = {
  __typename?: "AddProjectV2ItemByIdPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The item added to the project. */
  item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of AddPullRequestReviewComment */
export type AddPullRequestReviewCommentInput = {
  /**
   * The text of the comment. This field is required
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `body` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The SHA of the commit to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `commitOID` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  commitOID?: InputMaybe<Scalars["GitObjectID"]["input"]>;
  /**
   * The comment id to reply to.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `inReplyTo` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  inReplyTo?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * The relative path of the file to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `path` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  path?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The line index in the diff to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `position` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  position?: InputMaybe<Scalars["Int"]["input"]>;
  /**
   * The node ID of the pull request reviewing
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `pullRequestId` will be removed. use
   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  pullRequestId?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * The Node ID of the review to modify.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `pullRequestReviewId` will be removed. use
   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  pullRequestReviewId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of AddPullRequestReviewComment. */
export type AddPullRequestReviewCommentPayload = {
  __typename?: "AddPullRequestReviewCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The newly created comment. */
  comment?: Maybe<PullRequestReviewComment>;
  /** The edge from the review's comment connection. */
  commentEdge?: Maybe<PullRequestReviewCommentEdge>;
};

/** Autogenerated input type of AddPullRequestReview */
export type AddPullRequestReviewInput = {
  /** The contents of the review body comment. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The review line comments.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `comments` will be removed. use the `threads` argument instead
   * **Reason:** We are deprecating comment fields that use diff-relative positioning
   */
  comments?: InputMaybe<Array<InputMaybe<DraftPullRequestReviewComment>>>;
  /** The commit OID the review pertains to. */
  commitOID?: InputMaybe<Scalars["GitObjectID"]["input"]>;
  /** The event to perform on the pull request review. */
  event?: InputMaybe<PullRequestReviewEvent>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars["ID"]["input"];
  /** The review line comment threads. */
  threads?: InputMaybe<Array<InputMaybe<DraftPullRequestReviewThread>>>;
};

/** Autogenerated return type of AddPullRequestReview. */
export type AddPullRequestReviewPayload = {
  __typename?: "AddPullRequestReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The newly created pull request review. */
  pullRequestReview?: Maybe<PullRequestReview>;
  /** The edge from the pull request's review connection. */
  reviewEdge?: Maybe<PullRequestReviewEdge>;
};

/** Autogenerated input type of AddPullRequestReviewThread */
export type AddPullRequestReviewThreadInput = {
  /** Body of the thread's first comment. */
  body: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The line of the blob to which the thread refers, required for line-level
   * threads. The end of the line range for multi-line comments.
   */
  line?: InputMaybe<Scalars["Int"]["input"]>;
  /** Path to the file being commented on. */
  path: Scalars["String"]["input"];
  /** The node ID of the pull request reviewing */
  pullRequestId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The Node ID of the review to modify. */
  pullRequestReviewId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: InputMaybe<DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: InputMaybe<Scalars["Int"]["input"]>;
  /** The side of the diff on which the start line resides. */
  startSide?: InputMaybe<DiffSide>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  subjectType?: InputMaybe<PullRequestReviewThreadSubjectType>;
};

/** Autogenerated return type of AddPullRequestReviewThread. */
export type AddPullRequestReviewThreadPayload = {
  __typename?: "AddPullRequestReviewThreadPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The newly created thread. */
  thread?: Maybe<PullRequestReviewThread>;
};

/** Autogenerated input type of AddPullRequestReviewThreadReply */
export type AddPullRequestReviewThreadReplyInput = {
  /** The text of the reply. */
  body: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the pending review to which the reply will belong. */
  pullRequestReviewId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The Node ID of the thread to which this reply is being written. */
  pullRequestReviewThreadId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AddPullRequestReviewThreadReply. */
export type AddPullRequestReviewThreadReplyPayload = {
  __typename?: "AddPullRequestReviewThreadReplyPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The newly created reply. */
  comment?: Maybe<PullRequestReviewComment>;
};

/** Autogenerated input type of AddReaction */
export type AddReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the emoji to react with. */
  content: ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AddReaction. */
export type AddReactionPayload = {
  __typename?: "AddReactionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The reaction object. */
  reaction?: Maybe<Reaction>;
  /** The reaction groups for the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** The reactable subject. */
  subject?: Maybe<Reactable>;
};

/** Autogenerated input type of AddStar */
export type AddStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Starrable ID to star. */
  starrableId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AddStar. */
export type AddStarPayload = {
  __typename?: "AddStarPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The starrable. */
  starrable?: Maybe<Starrable>;
};

/** Autogenerated input type of AddUpvote */
export type AddUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the discussion or comment to upvote. */
  subjectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AddUpvote. */
export type AddUpvotePayload = {
  __typename?: "AddUpvotePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The votable subject. */
  subject?: Maybe<Votable>;
};

/** Autogenerated input type of AddVerifiableDomain */
export type AddVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The URL of the domain */
  domain: Scalars["URI"]["input"];
  /** The ID of the owner to add the domain to */
  ownerId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AddVerifiableDomain. */
export type AddVerifiableDomainPayload = {
  __typename?: "AddVerifiableDomainPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The verifiable domain that was added. */
  domain?: Maybe<VerifiableDomain>;
};

/** Represents an 'added_to_merge_queue' event on a given pull request. */
export type AddedToMergeQueueEvent = Node & {
  __typename?: "AddedToMergeQueueEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The user who added this Pull Request to the merge queue */
  enqueuer?: Maybe<User>;
  /** The Node ID of the AddedToMergeQueueEvent object */
  id: Scalars["ID"]["output"];
  /** The merge queue where this pull request was added to. */
  mergeQueue?: Maybe<MergeQueue>;
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'added_to_project' event on a given issue or pull request. */
export type AddedToProjectEvent = Node & {
  __typename?: "AddedToProjectEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the AddedToProjectEvent object */
  id: Scalars["ID"]["output"];
  /** Project referenced by event. */
  project?: Maybe<Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<ProjectCard>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars["String"]["output"];
};

/** Represents an announcement banner. */
export type AnnouncementBanner = {
  /** The text of the announcement */
  announcement?: Maybe<Scalars["String"]["output"]>;
  /** The date the announcement was created */
  announcementCreatedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The expiration date of the announcement, if any */
  announcementExpiresAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** Whether the announcement can be dismissed by the user */
  announcementUserDismissible?: Maybe<Scalars["Boolean"]["output"]>;
};

/** A GitHub App. */
export type App = Node & {
  __typename?: "App";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The description of the app. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The Node ID of the App object */
  id: Scalars["ID"]["output"];
  /** The IP addresses of the app. */
  ipAllowListEntries: IpAllowListEntryConnection;
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars["String"]["output"];
  /** A URL pointing to the app's logo. */
  logoUrl: Scalars["URI"]["output"];
  /** The name of the app. */
  name: Scalars["String"]["output"];
  /** A slug based on the name of the app for use in URLs. */
  slug: Scalars["String"]["output"];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** The URL to the app's homepage. */
  url: Scalars["URI"]["output"];
};

/** A GitHub App. */
export type AppIpAllowListEntriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IpAllowListEntryOrder>;
};

/** A GitHub App. */
export type AppLogoUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Autogenerated input type of ApproveDeployments */
export type ApproveDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Optional comment for approving deployments */
  comment?: InputMaybe<Scalars["String"]["input"]>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars["ID"]["input"]>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars["ID"]["input"];
};

/** Autogenerated return type of ApproveDeployments. */
export type ApproveDeploymentsPayload = {
  __typename?: "ApproveDeploymentsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The affected deployments. */
  deployments?: Maybe<Array<Deployment>>;
};

/** Autogenerated input type of ApproveVerifiableDomain */
export type ApproveVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the verifiable domain to approve. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of ApproveVerifiableDomain. */
export type ApproveVerifiableDomainPayload = {
  __typename?: "ApproveVerifiableDomainPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The verifiable domain that was approved. */
  domain?: Maybe<VerifiableDomain>;
};

/** Autogenerated input type of ArchiveProjectV2Item */
export type ArchiveProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the ProjectV2Item to archive. */
  itemId: Scalars["ID"]["input"];
  /** The ID of the Project to archive the item from. */
  projectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of ArchiveProjectV2Item. */
export type ArchiveProjectV2ItemPayload = {
  __typename?: "ArchiveProjectV2ItemPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The item archived from the project. */
  item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of ArchiveRepository */
export type ArchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the repository to mark as archived. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of ArchiveRepository. */
export type ArchiveRepositoryPayload = {
  __typename?: "ArchiveRepositoryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The repository that was marked as archived. */
  repository?: Maybe<Repository>;
};

/** An object that can have users assigned to it. */
export type Assignable = {
  /** A list of Users assigned to this object. */
  assignees: UserConnection;
};

/** An object that can have users assigned to it. */
export type AssignableAssigneesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents an 'assigned' event on any assignable object. */
export type AssignedEvent = Node & {
  __typename?: "AssignedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the assignable associated with the event. */
  assignable: Assignable;
  /** Identifies the user or mannequin that was assigned. */
  assignee?: Maybe<Assignee>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the AssignedEvent object */
  id: Scalars["ID"]["output"];
  /**
   * Identifies the user who was assigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  user?: Maybe<User>;
};

/** Types that can be assigned to issues. */
export type Assignee = Bot | Mannequin | Organization | User;

/** An entry in the audit log. */
export type AuditEntry = {
  /** The action name */
  action: Scalars["String"]["output"];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars["String"]["output"]>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars["String"]["output"]>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars["URI"]["output"]>;
  /** The time the action was initiated */
  createdAt: Scalars["PreciseDateTime"]["output"];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars["String"]["output"]>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars["URI"]["output"]>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars["URI"]["output"]>;
};

/** Types that can initiate an audit log event. */
export type AuditEntryActor = Bot | Organization | User;

/** Ordering options for Audit Log connections. */
export type AuditLogOrder = {
  /** The ordering direction. */
  direction?: InputMaybe<OrderDirection>;
  /** The field to order Audit Logs by. */
  field?: InputMaybe<AuditLogOrderField>;
};

/** Properties by which Audit Log connections can be ordered. */
export enum AuditLogOrderField {
  /** Order audit log entries by timestamp */
  CreatedAt = "CREATED_AT",
}

/** Represents a 'auto_merge_disabled' event on a given pull request. */
export type AutoMergeDisabledEvent = Node & {
  __typename?: "AutoMergeDisabledEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The user who disabled auto-merge for this Pull Request */
  disabler?: Maybe<User>;
  /** The Node ID of the AutoMergeDisabledEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event */
  pullRequest?: Maybe<PullRequest>;
  /** The reason auto-merge was disabled */
  reason?: Maybe<Scalars["String"]["output"]>;
  /** The reason_code relating to why auto-merge was disabled */
  reasonCode?: Maybe<Scalars["String"]["output"]>;
};

/** Represents a 'auto_merge_enabled' event on a given pull request. */
export type AutoMergeEnabledEvent = Node & {
  __typename?: "AutoMergeEnabledEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The user who enabled auto-merge for this Pull Request */
  enabler?: Maybe<User>;
  /** The Node ID of the AutoMergeEnabledEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents an auto-merge request for a pull request */
export type AutoMergeRequest = {
  __typename?: "AutoMergeRequest";
  /** The email address of the author of this auto-merge request. */
  authorEmail?: Maybe<Scalars["String"]["output"]>;
  /**
   * The commit message of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging.
   */
  commitBody?: Maybe<Scalars["String"]["output"]>;
  /**
   * The commit title of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging
   */
  commitHeadline?: Maybe<Scalars["String"]["output"]>;
  /** When was this auto-merge request was enabled. */
  enabledAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The actor who created the auto-merge request. */
  enabledBy?: Maybe<Actor>;
  /**
   * The merge method of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging.
   */
  mergeMethod: PullRequestMergeMethod;
  /** The pull request that this auto-merge request is set against. */
  pullRequest: PullRequest;
};

/** Represents a 'auto_rebase_enabled' event on a given pull request. */
export type AutoRebaseEnabledEvent = Node & {
  __typename?: "AutoRebaseEnabledEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The user who enabled auto-merge (rebase) for this Pull Request */
  enabler?: Maybe<User>;
  /** The Node ID of the AutoRebaseEnabledEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'auto_squash_enabled' event on a given pull request. */
export type AutoSquashEnabledEvent = Node & {
  __typename?: "AutoSquashEnabledEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The user who enabled auto-merge (squash) for this Pull Request */
  enabler?: Maybe<User>;
  /** The Node ID of the AutoSquashEnabledEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'automatic_base_change_failed' event on a given pull request. */
export type AutomaticBaseChangeFailedEvent = Node & {
  __typename?: "AutomaticBaseChangeFailedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the AutomaticBaseChangeFailedEvent object */
  id: Scalars["ID"]["output"];
  /** The new base for this PR */
  newBase: Scalars["String"]["output"];
  /** The old base for this PR */
  oldBase: Scalars["String"]["output"];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
export type AutomaticBaseChangeSucceededEvent = Node & {
  __typename?: "AutomaticBaseChangeSucceededEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the AutomaticBaseChangeSucceededEvent object */
  id: Scalars["ID"]["output"];
  /** The new base for this PR */
  newBase: Scalars["String"]["output"];
  /** The old base for this PR */
  oldBase: Scalars["String"]["output"];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Represents a 'base_ref_changed' event on a given issue or pull request. */
export type BaseRefChangedEvent = Node & {
  __typename?: "BaseRefChangedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the name of the base ref for the pull request after it was changed. */
  currentRefName: Scalars["String"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the BaseRefChangedEvent object */
  id: Scalars["ID"]["output"];
  /** Identifies the name of the base ref for the pull request before it was changed. */
  previousRefName: Scalars["String"]["output"];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Represents a 'base_ref_deleted' event on a given pull request. */
export type BaseRefDeletedEvent = Node & {
  __typename?: "BaseRefDeletedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the name of the Ref associated with the `base_ref_deleted` event. */
  baseRefName?: Maybe<Scalars["String"]["output"]>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the BaseRefDeletedEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'base_ref_force_pushed' event on a given pull request. */
export type BaseRefForcePushedEvent = Node & {
  __typename?: "BaseRefForcePushedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */
  afterCommit?: Maybe<Commit>;
  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */
  beforeCommit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the BaseRefForcePushedEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */
  ref?: Maybe<Ref>;
};

/** Represents a Git blame. */
export type Blame = {
  __typename?: "Blame";
  /** The list of ranges from a Git blame. */
  ranges: Array<BlameRange>;
};

/** Represents a range of information from a Git blame. */
export type BlameRange = {
  __typename?: "BlameRange";
  /**
   * Identifies the recency of the change, from 1 (new) to 10 (old). This is
   * calculated as a 2-quantile and determines the length of distance between the
   * median age of all the changes in the file and the recency of the current
   * range's change.
   */
  age: Scalars["Int"]["output"];
  /** Identifies the line author */
  commit: Commit;
  /** The ending line for the range */
  endingLine: Scalars["Int"]["output"];
  /** The starting line for the range */
  startingLine: Scalars["Int"]["output"];
};

/** Represents a Git blob. */
export type Blob = GitObject &
  Node & {
    __typename?: "Blob";
    /** An abbreviated version of the Git object ID */
    abbreviatedOid: Scalars["String"]["output"];
    /** Byte size of Blob object */
    byteSize: Scalars["Int"]["output"];
    /** The HTTP path for this Git object */
    commitResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for this Git object */
    commitUrl: Scalars["URI"]["output"];
    /** The Node ID of the Blob object */
    id: Scalars["ID"]["output"];
    /** Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding. */
    isBinary?: Maybe<Scalars["Boolean"]["output"]>;
    /** Indicates whether the contents is truncated */
    isTruncated: Scalars["Boolean"]["output"];
    /** The Git object ID */
    oid: Scalars["GitObjectID"]["output"];
    /** The Repository the Git object belongs to */
    repository: Repository;
    /** UTF8 text data or null if the Blob is binary */
    text?: Maybe<Scalars["String"]["output"]>;
  };

/** A special type of user which takes actions on behalf of GitHub Apps. */
export type Bot = Actor &
  Node &
  UniformResourceLocatable & {
    __typename?: "Bot";
    /** A URL pointing to the GitHub App's public avatar. */
    avatarUrl: Scalars["URI"]["output"];
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The Node ID of the Bot object */
    id: Scalars["ID"]["output"];
    /** The username of the actor. */
    login: Scalars["String"]["output"];
    /** The HTTP path for this bot */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this bot */
    url: Scalars["URI"]["output"];
  };

/** A special type of user which takes actions on behalf of GitHub Apps. */
export type BotAvatarUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Types which can be actors for `BranchActorAllowance` objects. */
export type BranchActorAllowanceActor = App | Team | User;

/** Parameters to be used for the branch_name_pattern rule */
export type BranchNamePatternParameters = {
  __typename?: "BranchNamePatternParameters";
  /** How this rule will appear to users. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars["Boolean"]["output"];
  /** The operator to use for matching. */
  operator: Scalars["String"]["output"];
  /** The pattern to match with. */
  pattern: Scalars["String"]["output"];
};

/** Parameters to be used for the branch_name_pattern rule */
export type BranchNamePatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The operator to use for matching. */
  operator: Scalars["String"]["input"];
  /** The pattern to match with. */
  pattern: Scalars["String"]["input"];
};

/** A branch protection rule. */
export type BranchProtectionRule = Node & {
  __typename?: "BranchProtectionRule";
  /** Can this branch be deleted. */
  allowsDeletions: Scalars["Boolean"]["output"];
  /** Are force pushes allowed on this branch. */
  allowsForcePushes: Scalars["Boolean"]["output"];
  /** Is branch creation a protected operation. */
  blocksCreations: Scalars["Boolean"]["output"];
  /** A list of conflicts matching branches protection rule and other branch protection rules */
  branchProtectionRuleConflicts: BranchProtectionRuleConflictConnection;
  /** A list of actors able to force push for this branch protection rule. */
  bypassForcePushAllowances: BypassForcePushAllowanceConnection;
  /** A list of actors able to bypass PRs for this branch protection rule. */
  bypassPullRequestAllowances: BypassPullRequestAllowanceConnection;
  /** The actor who created this branch protection rule. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews: Scalars["Boolean"]["output"];
  /** The Node ID of the BranchProtectionRule object */
  id: Scalars["ID"]["output"];
  /** Can admins override branch protection. */
  isAdminEnforced: Scalars["Boolean"]["output"];
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge: Scalars["Boolean"]["output"];
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch: Scalars["Boolean"]["output"];
  /** Repository refs that are protected by this rule */
  matchingRefs: RefConnection;
  /** Identifies the protection rule pattern. */
  pattern: Scalars["String"]["output"];
  /** A list push allowances for this branch protection rule. */
  pushAllowances: PushAllowanceConnection;
  /** The repository associated with this branch protection rule. */
  repository?: Maybe<Repository>;
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval: Scalars["Boolean"]["output"];
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars["Int"]["output"]>;
  /** List of required deployment environments that must be deployed successfully to update matching branches */
  requiredDeploymentEnvironments?: Maybe<
    Array<Maybe<Scalars["String"]["output"]>>
  >;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<
    Array<Maybe<Scalars["String"]["output"]>>
  >;
  /** List of required status checks that must pass for commits to be accepted to matching branches. */
  requiredStatusChecks?: Maybe<Array<RequiredStatusCheckDescription>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews: Scalars["Boolean"]["output"];
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews: Scalars["Boolean"]["output"];
  /** Are commits required to be signed. */
  requiresCommitSignatures: Scalars["Boolean"]["output"];
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution: Scalars["Boolean"]["output"];
  /** Does this branch require deployment to specific environments before merging */
  requiresDeployments: Scalars["Boolean"]["output"];
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory: Scalars["Boolean"]["output"];
  /** Are status checks required to update matching branches. */
  requiresStatusChecks: Scalars["Boolean"]["output"];
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks: Scalars["Boolean"]["output"];
  /** Is pushing to matching branches restricted. */
  restrictsPushes: Scalars["Boolean"]["output"];
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals: Scalars["Boolean"]["output"];
  /** A list review dismissal allowances for this branch protection rule. */
  reviewDismissalAllowances: ReviewDismissalAllowanceConnection;
};

/** A branch protection rule. */
export type BranchProtectionRuleBranchProtectionRuleConflictsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A branch protection rule. */
export type BranchProtectionRuleBypassForcePushAllowancesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A branch protection rule. */
export type BranchProtectionRuleBypassPullRequestAllowancesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A branch protection rule. */
export type BranchProtectionRuleMatchingRefsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** A branch protection rule. */
export type BranchProtectionRulePushAllowancesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A branch protection rule. */
export type BranchProtectionRuleReviewDismissalAllowancesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A conflict between two branch protection rules. */
export type BranchProtectionRuleConflict = {
  __typename?: "BranchProtectionRuleConflict";
  /** Identifies the branch protection rule. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** Identifies the conflicting branch protection rule. */
  conflictingBranchProtectionRule?: Maybe<BranchProtectionRule>;
  /** Identifies the branch ref that has conflicting rules */
  ref?: Maybe<Ref>;
};

/** The connection type for BranchProtectionRuleConflict. */
export type BranchProtectionRuleConflictConnection = {
  __typename?: "BranchProtectionRuleConflictConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BranchProtectionRuleConflictEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BranchProtectionRuleConflict>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type BranchProtectionRuleConflictEdge = {
  __typename?: "BranchProtectionRuleConflictEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<BranchProtectionRuleConflict>;
};

/** The connection type for BranchProtectionRule. */
export type BranchProtectionRuleConnection = {
  __typename?: "BranchProtectionRuleConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BranchProtectionRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BranchProtectionRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type BranchProtectionRuleEdge = {
  __typename?: "BranchProtectionRuleEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<BranchProtectionRule>;
};

/**
 * Information about a sponsorship to make for a user or organization with a GitHub
 * Sponsors profile, as part of sponsoring many users or organizations at once.
 */
export type BulkSponsorship = {
  /** The amount to pay to the sponsorable in US dollars. Valid values: 1-12000. */
  amount: Scalars["Int"]["input"];
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars["String"]["input"]>;
};

/** Types that can represent a repository ruleset bypass actor. */
export type BypassActor = App | Team;

/** A user, team, or app who has the ability to bypass a force push requirement on a protected branch. */
export type BypassForcePushAllowance = Node & {
  __typename?: "BypassForcePushAllowance";
  /** The actor that can force push. */
  actor?: Maybe<BranchActorAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** The Node ID of the BypassForcePushAllowance object */
  id: Scalars["ID"]["output"];
};

/** The connection type for BypassForcePushAllowance. */
export type BypassForcePushAllowanceConnection = {
  __typename?: "BypassForcePushAllowanceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BypassForcePushAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BypassForcePushAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type BypassForcePushAllowanceEdge = {
  __typename?: "BypassForcePushAllowanceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<BypassForcePushAllowance>;
};

/** A user, team, or app who has the ability to bypass a pull request requirement on a protected branch. */
export type BypassPullRequestAllowance = Node & {
  __typename?: "BypassPullRequestAllowance";
  /** The actor that can bypass. */
  actor?: Maybe<BranchActorAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** The Node ID of the BypassPullRequestAllowance object */
  id: Scalars["ID"]["output"];
};

/** The connection type for BypassPullRequestAllowance. */
export type BypassPullRequestAllowanceConnection = {
  __typename?: "BypassPullRequestAllowanceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BypassPullRequestAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BypassPullRequestAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type BypassPullRequestAllowanceEdge = {
  __typename?: "BypassPullRequestAllowanceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<BypassPullRequestAllowance>;
};

/** The Common Vulnerability Scoring System */
export type Cvss = {
  __typename?: "CVSS";
  /** The CVSS score associated with this advisory */
  score: Scalars["Float"]["output"];
  /** The CVSS vector string associated with this advisory */
  vectorString?: Maybe<Scalars["String"]["output"]>;
};

/** A common weakness enumeration */
export type Cwe = Node & {
  __typename?: "CWE";
  /** The id of the CWE */
  cweId: Scalars["String"]["output"];
  /** A detailed description of this CWE */
  description: Scalars["String"]["output"];
  /** The Node ID of the CWE object */
  id: Scalars["ID"]["output"];
  /** The name of this CWE */
  name: Scalars["String"]["output"];
};

/** The connection type for CWE. */
export type CweConnection = {
  __typename?: "CWEConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CweEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Cwe>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CweEdge = {
  __typename?: "CWEEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Cwe>;
};

/** Autogenerated input type of CancelEnterpriseAdminInvitation */
export type CancelEnterpriseAdminInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the pending enterprise administrator invitation. */
  invitationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of CancelEnterpriseAdminInvitation. */
export type CancelEnterpriseAdminInvitationPayload = {
  __typename?: "CancelEnterpriseAdminInvitationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The invitation that was canceled. */
  invitation?: Maybe<EnterpriseAdministratorInvitation>;
  /** A message confirming the result of canceling an administrator invitation. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of CancelEnterpriseMemberInvitation */
export type CancelEnterpriseMemberInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the pending enterprise member invitation. */
  invitationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of CancelEnterpriseMemberInvitation. */
export type CancelEnterpriseMemberInvitationPayload = {
  __typename?: "CancelEnterpriseMemberInvitationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The invitation that was canceled. */
  invitation?: Maybe<EnterpriseMemberInvitation>;
  /** A message confirming the result of canceling an member invitation. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of CancelSponsorship */
export type CancelSponsorshipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of CancelSponsorship. */
export type CancelSponsorshipPayload = {
  __typename?: "CancelSponsorshipPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The tier that was being used at the time of cancellation. */
  sponsorsTier?: Maybe<SponsorsTier>;
};

/** Autogenerated input type of ChangeUserStatus */
export type ChangeUserStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */
  emoji?: InputMaybe<Scalars["String"]["input"]>;
  /** If set, the user status will not be shown after this date. */
  expiresAt?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */
  limitedAvailability?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A short description of your current status. */
  message?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The ID of the organization whose members will be allowed to see the status. If
   * omitted, the status will be publicly visible.
   */
  organizationId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of ChangeUserStatus. */
export type ChangeUserStatusPayload = {
  __typename?: "ChangeUserStatusPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Your updated status. */
  status?: Maybe<UserStatus>;
};

/** A single check annotation. */
export type CheckAnnotation = {
  __typename?: "CheckAnnotation";
  /** The annotation's severity level. */
  annotationLevel?: Maybe<CheckAnnotationLevel>;
  /** The path to the file that this annotation was made on. */
  blobUrl: Scalars["URI"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The position of this annotation. */
  location: CheckAnnotationSpan;
  /** The annotation's message. */
  message: Scalars["String"]["output"];
  /** The path that this annotation was made on. */
  path: Scalars["String"]["output"];
  /** Additional information about the annotation. */
  rawDetails?: Maybe<Scalars["String"]["output"]>;
  /** The annotation's title */
  title?: Maybe<Scalars["String"]["output"]>;
};

/** The connection type for CheckAnnotation. */
export type CheckAnnotationConnection = {
  __typename?: "CheckAnnotationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckAnnotationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckAnnotation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Information from a check run analysis to specific lines of code. */
export type CheckAnnotationData = {
  /** Represents an annotation's information level */
  annotationLevel: CheckAnnotationLevel;
  /** The location of the annotation */
  location: CheckAnnotationRange;
  /** A short description of the feedback for these lines of code. */
  message: Scalars["String"]["input"];
  /** The path of the file to add an annotation to. */
  path: Scalars["String"]["input"];
  /** Details about this annotation. */
  rawDetails?: InputMaybe<Scalars["String"]["input"]>;
  /** The title that represents the annotation. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** An edge in a connection. */
export type CheckAnnotationEdge = {
  __typename?: "CheckAnnotationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CheckAnnotation>;
};

/** Represents an annotation's information level. */
export enum CheckAnnotationLevel {
  /** An annotation indicating an inescapable error. */
  Failure = "FAILURE",
  /** An annotation indicating some information. */
  Notice = "NOTICE",
  /** An annotation indicating an ignorable error. */
  Warning = "WARNING",
}

/** A character position in a check annotation. */
export type CheckAnnotationPosition = {
  __typename?: "CheckAnnotationPosition";
  /** Column number (1 indexed). */
  column?: Maybe<Scalars["Int"]["output"]>;
  /** Line number (1 indexed). */
  line: Scalars["Int"]["output"];
};

/** Information from a check run analysis to specific lines of code. */
export type CheckAnnotationRange = {
  /** The ending column of the range. */
  endColumn?: InputMaybe<Scalars["Int"]["input"]>;
  /** The ending line of the range. */
  endLine: Scalars["Int"]["input"];
  /** The starting column of the range. */
  startColumn?: InputMaybe<Scalars["Int"]["input"]>;
  /** The starting line of the range. */
  startLine: Scalars["Int"]["input"];
};

/** An inclusive pair of positions for a check annotation. */
export type CheckAnnotationSpan = {
  __typename?: "CheckAnnotationSpan";
  /** End position (inclusive). */
  end: CheckAnnotationPosition;
  /** Start position (inclusive). */
  start: CheckAnnotationPosition;
};

/** The possible states for a check suite or run conclusion. */
export enum CheckConclusionState {
  /** The check suite or run requires action. */
  ActionRequired = "ACTION_REQUIRED",
  /** The check suite or run has been cancelled. */
  Cancelled = "CANCELLED",
  /** The check suite or run has failed. */
  Failure = "FAILURE",
  /** The check suite or run was neutral. */
  Neutral = "NEUTRAL",
  /** The check suite or run was skipped. */
  Skipped = "SKIPPED",
  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */
  Stale = "STALE",
  /** The check suite or run has failed at startup. */
  StartupFailure = "STARTUP_FAILURE",
  /** The check suite or run has succeeded. */
  Success = "SUCCESS",
  /** The check suite or run has timed out. */
  TimedOut = "TIMED_OUT",
}

/** A check run. */
export type CheckRun = Node &
  RequirableByPullRequest &
  UniformResourceLocatable & {
    __typename?: "CheckRun";
    /** The check run's annotations */
    annotations?: Maybe<CheckAnnotationConnection>;
    /** The check suite that this run is a part of. */
    checkSuite: CheckSuite;
    /** Identifies the date and time when the check run was completed. */
    completedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The conclusion of the check run. */
    conclusion?: Maybe<CheckConclusionState>;
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The corresponding deployment for this job, if any */
    deployment?: Maybe<Deployment>;
    /** The URL from which to find full details of the check run on the integrator's site. */
    detailsUrl?: Maybe<Scalars["URI"]["output"]>;
    /** A reference for the check run on the integrator's system. */
    externalId?: Maybe<Scalars["String"]["output"]>;
    /** The Node ID of the CheckRun object */
    id: Scalars["ID"]["output"];
    /** Whether this is required to pass before merging for a specific pull request. */
    isRequired: Scalars["Boolean"]["output"];
    /** The name of the check for this check run. */
    name: Scalars["String"]["output"];
    /** Information about a pending deployment, if any, in this check run */
    pendingDeploymentRequest?: Maybe<DeploymentRequest>;
    /** The permalink to the check run summary. */
    permalink: Scalars["URI"]["output"];
    /** The repository associated with this check run. */
    repository: Repository;
    /** The HTTP path for this check run. */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the date and time when the check run was started. */
    startedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The current status of the check run. */
    status: CheckStatusState;
    /** The check run's steps */
    steps?: Maybe<CheckStepConnection>;
    /** A string representing the check run's summary */
    summary?: Maybe<Scalars["String"]["output"]>;
    /** A string representing the check run's text */
    text?: Maybe<Scalars["String"]["output"]>;
    /** A string representing the check run */
    title?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP URL for this check run. */
    url: Scalars["URI"]["output"];
  };

/** A check run. */
export type CheckRunAnnotationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A check run. */
export type CheckRunIsRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars["ID"]["input"]>;
  pullRequestNumber?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A check run. */
export type CheckRunStepsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  number?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Possible further actions the integrator can perform. */
export type CheckRunAction = {
  /** A short explanation of what this action would do. */
  description: Scalars["String"]["input"];
  /** A reference for the action on the integrator's system. */
  identifier: Scalars["String"]["input"];
  /** The text to be displayed on a button in the web UI. */
  label: Scalars["String"]["input"];
};

/** The connection type for CheckRun. */
export type CheckRunConnection = {
  __typename?: "CheckRunConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckRunEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckRun>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CheckRunEdge = {
  __typename?: "CheckRunEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CheckRun>;
};

/** The filters that are available when fetching check runs. */
export type CheckRunFilter = {
  /** Filters the check runs created by this application ID. */
  appId?: InputMaybe<Scalars["Int"]["input"]>;
  /** Filters the check runs by this name. */
  checkName?: InputMaybe<Scalars["String"]["input"]>;
  /** Filters the check runs by this type. */
  checkType?: InputMaybe<CheckRunType>;
  /** Filters the check runs by these conclusions. */
  conclusions?: InputMaybe<Array<CheckConclusionState>>;
  /** Filters the check runs by this status. Superceded by statuses. */
  status?: InputMaybe<CheckStatusState>;
  /** Filters the check runs by this status. Overrides status. */
  statuses?: InputMaybe<Array<CheckStatusState>>;
};

/** Descriptive details about the check run. */
export type CheckRunOutput = {
  /** The annotations that are made as part of the check run. */
  annotations?: InputMaybe<Array<CheckAnnotationData>>;
  /** Images attached to the check run output displayed in the GitHub pull request UI. */
  images?: InputMaybe<Array<CheckRunOutputImage>>;
  /** The summary of the check run (supports Commonmark). */
  summary: Scalars["String"]["input"];
  /** The details of the check run (supports Commonmark). */
  text?: InputMaybe<Scalars["String"]["input"]>;
  /** A title to provide for this check run. */
  title: Scalars["String"]["input"];
};

/** Images attached to the check run output displayed in the GitHub pull request UI. */
export type CheckRunOutputImage = {
  /** The alternative text for the image. */
  alt: Scalars["String"]["input"];
  /** A short image description. */
  caption?: InputMaybe<Scalars["String"]["input"]>;
  /** The full URL of the image. */
  imageUrl: Scalars["URI"]["input"];
};

/** The possible states of a check run in a status rollup. */
export enum CheckRunState {
  /** The check run requires action. */
  ActionRequired = "ACTION_REQUIRED",
  /** The check run has been cancelled. */
  Cancelled = "CANCELLED",
  /** The check run has been completed. */
  Completed = "COMPLETED",
  /** The check run has failed. */
  Failure = "FAILURE",
  /** The check run is in progress. */
  InProgress = "IN_PROGRESS",
  /** The check run was neutral. */
  Neutral = "NEUTRAL",
  /** The check run is in pending state. */
  Pending = "PENDING",
  /** The check run has been queued. */
  Queued = "QUEUED",
  /** The check run was skipped. */
  Skipped = "SKIPPED",
  /** The check run was marked stale by GitHub. Only GitHub can use this conclusion. */
  Stale = "STALE",
  /** The check run has failed at startup. */
  StartupFailure = "STARTUP_FAILURE",
  /** The check run has succeeded. */
  Success = "SUCCESS",
  /** The check run has timed out. */
  TimedOut = "TIMED_OUT",
  /** The check run is in waiting state. */
  Waiting = "WAITING",
}

/** Represents a count of the state of a check run. */
export type CheckRunStateCount = {
  __typename?: "CheckRunStateCount";
  /** The number of check runs with this state. */
  count: Scalars["Int"]["output"];
  /** The state of a check run. */
  state: CheckRunState;
};

/** The possible types of check runs. */
export enum CheckRunType {
  /** Every check run available. */
  All = "ALL",
  /** The latest check run. */
  Latest = "LATEST",
}

/** The possible states for a check suite or run status. */
export enum CheckStatusState {
  /** The check suite or run has been completed. */
  Completed = "COMPLETED",
  /** The check suite or run is in progress. */
  InProgress = "IN_PROGRESS",
  /** The check suite or run is in pending state. */
  Pending = "PENDING",
  /** The check suite or run has been queued. */
  Queued = "QUEUED",
  /** The check suite or run has been requested. */
  Requested = "REQUESTED",
  /** The check suite or run is in waiting state. */
  Waiting = "WAITING",
}

/** A single check step. */
export type CheckStep = {
  __typename?: "CheckStep";
  /** Identifies the date and time when the check step was completed. */
  completedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The conclusion of the check step. */
  conclusion?: Maybe<CheckConclusionState>;
  /** A reference for the check step on the integrator's system. */
  externalId?: Maybe<Scalars["String"]["output"]>;
  /** The step's name. */
  name: Scalars["String"]["output"];
  /** The index of the step in the list of steps of the parent check run. */
  number: Scalars["Int"]["output"];
  /** Number of seconds to completion. */
  secondsToCompletion?: Maybe<Scalars["Int"]["output"]>;
  /** Identifies the date and time when the check step was started. */
  startedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The current status of the check step. */
  status: CheckStatusState;
};

/** The connection type for CheckStep. */
export type CheckStepConnection = {
  __typename?: "CheckStepConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckStepEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckStep>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CheckStepEdge = {
  __typename?: "CheckStepEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CheckStep>;
};

/** A check suite. */
export type CheckSuite = Node & {
  __typename?: "CheckSuite";
  /** The GitHub App which created this check suite. */
  app?: Maybe<App>;
  /** The name of the branch for this check suite. */
  branch?: Maybe<Ref>;
  /** The check runs associated with a check suite. */
  checkRuns?: Maybe<CheckRunConnection>;
  /** The commit for this check suite */
  commit: Commit;
  /** The conclusion of this check suite. */
  conclusion?: Maybe<CheckConclusionState>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The user who triggered the check suite. */
  creator?: Maybe<User>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the CheckSuite object */
  id: Scalars["ID"]["output"];
  /** A list of open pull requests matching the check suite. */
  matchingPullRequests?: Maybe<PullRequestConnection>;
  /** The push that triggered this check suite. */
  push?: Maybe<Push>;
  /** The repository associated with this check suite. */
  repository: Repository;
  /** The HTTP path for this check suite */
  resourcePath: Scalars["URI"]["output"];
  /** The status of this check suite. */
  status: CheckStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** The HTTP URL for this check suite */
  url: Scalars["URI"]["output"];
  /** The workflow run associated with this check suite. */
  workflowRun?: Maybe<WorkflowRun>;
};

/** A check suite. */
export type CheckSuiteCheckRunsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filterBy?: InputMaybe<CheckRunFilter>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A check suite. */
export type CheckSuiteMatchingPullRequestsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  baseRefName?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  headRefName?: InputMaybe<Scalars["String"]["input"]>;
  labels?: InputMaybe<Array<Scalars["String"]["input"]>>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<PullRequestState>>;
};

/** The auto-trigger preferences that are available for check suites. */
export type CheckSuiteAutoTriggerPreference = {
  /** The node ID of the application that owns the check suite. */
  appId: Scalars["ID"]["input"];
  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */
  setting: Scalars["Boolean"]["input"];
};

/** The connection type for CheckSuite. */
export type CheckSuiteConnection = {
  __typename?: "CheckSuiteConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckSuiteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckSuite>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CheckSuiteEdge = {
  __typename?: "CheckSuiteEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CheckSuite>;
};

/** The filters that are available when fetching check suites. */
export type CheckSuiteFilter = {
  /** Filters the check suites created by this application ID. */
  appId?: InputMaybe<Scalars["Int"]["input"]>;
  /** Filters the check suites by this name. */
  checkName?: InputMaybe<Scalars["String"]["input"]>;
};

/** An object which can have its data claimed or claim data from another. */
export type Claimable = Mannequin | User;

/** Autogenerated input type of ClearLabelsFromLabelable */
export type ClearLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The id of the labelable object to clear the labels from. */
  labelableId: Scalars["ID"]["input"];
};

/** Autogenerated return type of ClearLabelsFromLabelable. */
export type ClearLabelsFromLabelablePayload = {
  __typename?: "ClearLabelsFromLabelablePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The item that was unlabeled. */
  labelable?: Maybe<Labelable>;
};

/** Autogenerated input type of ClearProjectV2ItemFieldValue */
export type ClearProjectV2ItemFieldValueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the field to be cleared. */
  fieldId: Scalars["ID"]["input"];
  /** The ID of the item to be cleared. */
  itemId: Scalars["ID"]["input"];
  /** The ID of the Project. */
  projectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of ClearProjectV2ItemFieldValue. */
export type ClearProjectV2ItemFieldValuePayload = {
  __typename?: "ClearProjectV2ItemFieldValuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated item. */
  projectV2Item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of CloneProject */
export type CloneProjectInput = {
  /** The description of the project. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not to clone the source project's workflows. */
  includeWorkflows: Scalars["Boolean"]["input"];
  /** The name of the project. */
  name: Scalars["String"]["input"];
  /** The visibility of the project, defaults to false (private). */
  public?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The source project to clone. */
  sourceId: Scalars["ID"]["input"];
  /** The owner ID to create the project under. */
  targetOwnerId: Scalars["ID"]["input"];
};

/** Autogenerated return type of CloneProject. */
export type CloneProjectPayload = {
  __typename?: "CloneProjectPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The id of the JobStatus for populating cloned fields. */
  jobStatusId?: Maybe<Scalars["String"]["output"]>;
  /** The new cloned project. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of CloneTemplateRepository */
export type CloneTemplateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A short description of the new repository. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * Whether to copy all branches from the template to the new repository. Defaults
   * to copying only the default branch of the template.
   */
  includeAllBranches?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The name of the new repository. */
  name: Scalars["String"]["input"];
  /** The ID of the owner for the new repository. */
  ownerId: Scalars["ID"]["input"];
  /** The Node ID of the template repository. */
  repositoryId: Scalars["ID"]["input"];
  /** Indicates the repository's visibility level. */
  visibility: RepositoryVisibility;
};

/** Autogenerated return type of CloneTemplateRepository. */
export type CloneTemplateRepositoryPayload = {
  __typename?: "CloneTemplateRepositoryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new repository. */
  repository?: Maybe<Repository>;
};

/** An object that can be closed */
export type Closable = {
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars["Boolean"]["output"];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars["Boolean"]["output"];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars["Boolean"]["output"];
};

/** Autogenerated input type of CloseDiscussion */
export type CloseDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the discussion to be closed. */
  discussionId: Scalars["ID"]["input"];
  /** The reason why the discussion is being closed. */
  reason?: InputMaybe<DiscussionCloseReason>;
};

/** Autogenerated return type of CloseDiscussion. */
export type CloseDiscussionPayload = {
  __typename?: "CloseDiscussionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The discussion that was closed. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of CloseIssue */
export type CloseIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the issue to be closed. */
  issueId: Scalars["ID"]["input"];
  /** The reason the issue is to be closed. */
  stateReason?: InputMaybe<IssueClosedStateReason>;
};

/** Autogenerated return type of CloseIssue. */
export type CloseIssuePayload = {
  __typename?: "CloseIssuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The issue that was closed. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of ClosePullRequest */
export type ClosePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the pull request to be closed. */
  pullRequestId: Scalars["ID"]["input"];
};

/** Autogenerated return type of ClosePullRequest. */
export type ClosePullRequestPayload = {
  __typename?: "ClosePullRequestPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The pull request that was closed. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'closed' event on any `Closable`. */
export type ClosedEvent = Node &
  UniformResourceLocatable & {
    __typename?: "ClosedEvent";
    /** Identifies the actor who performed the event. */
    actor?: Maybe<Actor>;
    /** Object that was closed. */
    closable: Closable;
    /** Object which triggered the creation of this event. */
    closer?: Maybe<Closer>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The Node ID of the ClosedEvent object */
    id: Scalars["ID"]["output"];
    /** The HTTP path for this closed event. */
    resourcePath: Scalars["URI"]["output"];
    /** The reason the issue state was changed to closed. */
    stateReason?: Maybe<IssueStateReason>;
    /** The HTTP URL for this closed event. */
    url: Scalars["URI"]["output"];
  };

/** The object which triggered a `ClosedEvent`. */
export type Closer = Commit | ProjectV2 | PullRequest;

/** The Code of Conduct for a repository */
export type CodeOfConduct = Node & {
  __typename?: "CodeOfConduct";
  /** The body of the Code of Conduct */
  body?: Maybe<Scalars["String"]["output"]>;
  /** The Node ID of the CodeOfConduct object */
  id: Scalars["ID"]["output"];
  /** The key for the Code of Conduct */
  key: Scalars["String"]["output"];
  /** The formal name of the Code of Conduct */
  name: Scalars["String"]["output"];
  /** The HTTP path for this Code of Conduct */
  resourcePath?: Maybe<Scalars["URI"]["output"]>;
  /** The HTTP URL for this Code of Conduct */
  url?: Maybe<Scalars["URI"]["output"]>;
};

/**
 * Choose which tools must provide code scanning results before the reference is
 * updated. When configured, code scanning must be enabled and have results for
 * both the commit and the reference being updated.
 */
export type CodeScanningParameters = {
  __typename?: "CodeScanningParameters";
  /** Tools that must provide code scanning results for this rule to pass. */
  codeScanningTools: Array<CodeScanningTool>;
};

/**
 * Choose which tools must provide code scanning results before the reference is
 * updated. When configured, code scanning must be enabled and have results for
 * both the commit and the reference being updated.
 */
export type CodeScanningParametersInput = {
  /** Tools that must provide code scanning results for this rule to pass. */
  codeScanningTools: Array<CodeScanningToolInput>;
};

/** A tool that must provide code scanning results for this rule to pass. */
export type CodeScanningTool = {
  __typename?: "CodeScanningTool";
  /**
   * The severity level at which code scanning results that raise alerts block a
   * reference update. For more information on alert severity levels, see...
   */
  alertsThreshold: Scalars["String"]["output"];
  /**
   * The severity level at which code scanning results that raise security alerts
   * block a reference update. For more information on security severity levels,
   * see...
   */
  securityAlertsThreshold: Scalars["String"]["output"];
  /** The name of a code scanning tool */
  tool: Scalars["String"]["output"];
};

/** A tool that must provide code scanning results for this rule to pass. */
export type CodeScanningToolInput = {
  /**
   * The severity level at which code scanning results that raise alerts block a
   * reference update. For more information on alert severity levels, see...
   */
  alertsThreshold: Scalars["String"]["input"];
  /**
   * The severity level at which code scanning results that raise security alerts
   * block a reference update. For more information on security severity levels,
   * see...
   */
  securityAlertsThreshold: Scalars["String"]["input"];
  /** The name of a code scanning tool */
  tool: Scalars["String"]["input"];
};

/** Collaborators affiliation level with a subject. */
export enum CollaboratorAffiliation {
  /** All collaborators the authenticated user can see. */
  All = "ALL",
  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */
  Direct = "DIRECT",
  /** All outside collaborators of an organization-owned subject. */
  Outside = "OUTSIDE",
}

/** Represents a comment. */
export type Comment = {
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars["String"]["output"];
  /** The body rendered to HTML. */
  bodyHTML: Scalars["HTML"]["output"];
  /** The body rendered to text. */
  bodyText: Scalars["String"]["output"];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars["Boolean"]["output"];
  /** The actor who edited the comment. */
  editor?: Maybe<Actor>;
  /** The Node ID of the Comment object */
  id: Scalars["ID"]["output"];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars["Boolean"]["output"];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars["Boolean"]["output"];
};

/** Represents a comment. */
export type CommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A comment author association with repository. */
export enum CommentAuthorAssociation {
  /** Author has been invited to collaborate on the repository. */
  Collaborator = "COLLABORATOR",
  /** Author has previously committed to the repository. */
  Contributor = "CONTRIBUTOR",
  /** Author has not previously committed to GitHub. */
  FirstTimer = "FIRST_TIMER",
  /** Author has not previously committed to the repository. */
  FirstTimeContributor = "FIRST_TIME_CONTRIBUTOR",
  /** Author is a placeholder for an unclaimed user. */
  Mannequin = "MANNEQUIN",
  /** Author is a member of the organization that owns the repository. */
  Member = "MEMBER",
  /** Author has no association with the repository. */
  None = "NONE",
  /** Author is the owner of the repository. */
  Owner = "OWNER",
}

/** The possible errors that will prevent a user from updating a comment. */
export enum CommentCannotUpdateReason {
  /** Unable to create comment because repository is archived. */
  Archived = "ARCHIVED",
  /** You cannot update this comment */
  Denied = "DENIED",
  /** You must be the author or have write access to this repository to update this comment. */
  InsufficientAccess = "INSUFFICIENT_ACCESS",
  /** Unable to create comment because issue is locked. */
  Locked = "LOCKED",
  /** You must be logged in to update this comment. */
  LoginRequired = "LOGIN_REQUIRED",
  /** Repository is under maintenance. */
  Maintenance = "MAINTENANCE",
  /** At least one email address must be verified to update this comment. */
  VerifiedEmailRequired = "VERIFIED_EMAIL_REQUIRED",
}

/** Represents a 'comment_deleted' event on a given issue or pull request. */
export type CommentDeletedEvent = Node & {
  __typename?: "CommentDeletedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The user who authored the deleted comment. */
  deletedCommentAuthor?: Maybe<Actor>;
  /** The Node ID of the CommentDeletedEvent object */
  id: Scalars["ID"]["output"];
};

/** Represents a Git commit. */
export type Commit = GitObject &
  Node &
  Subscribable &
  UniformResourceLocatable & {
    __typename?: "Commit";
    /** An abbreviated version of the Git object ID */
    abbreviatedOid: Scalars["String"]["output"];
    /** The number of additions in this commit. */
    additions: Scalars["Int"]["output"];
    /**
     * The merged Pull Request that introduced the commit to the repository. If the
     * commit is not present in the default branch, additionally returns open Pull
     * Requests associated with the commit
     */
    associatedPullRequests?: Maybe<PullRequestConnection>;
    /** Authorship details of the commit. */
    author?: Maybe<GitActor>;
    /** Check if the committer and the author match. */
    authoredByCommitter: Scalars["Boolean"]["output"];
    /** The datetime when this commit was authored. */
    authoredDate: Scalars["DateTime"]["output"];
    /**
     * The list of authors for this commit based on the git author and the Co-authored-by
     * message trailer. The git author will always be first.
     */
    authors: GitActorConnection;
    /** Fetches `git blame` information. */
    blame: Blame;
    /**
     * We recommend using the `changedFilesIfAvailable` field instead of
     * `changedFiles`, as `changedFiles` will cause your request to return an error
     * if GitHub is unable to calculate the number of changed files.
     * @deprecated `changedFiles` will be removed. Use `changedFilesIfAvailable` instead. Removal on 2023-01-01 UTC.
     */
    changedFiles: Scalars["Int"]["output"];
    /**
     * The number of changed files in this commit. If GitHub is unable to calculate
     * the number of changed files (for example due to a timeout), this will return
     * `null`. We recommend using this field instead of `changedFiles`.
     */
    changedFilesIfAvailable?: Maybe<Scalars["Int"]["output"]>;
    /** The check suites associated with a commit. */
    checkSuites?: Maybe<CheckSuiteConnection>;
    /** Comments made on the commit. */
    comments: CommitCommentConnection;
    /** The HTTP path for this Git object */
    commitResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for this Git object */
    commitUrl: Scalars["URI"]["output"];
    /** The datetime when this commit was committed. */
    committedDate: Scalars["DateTime"]["output"];
    /** Check if committed via GitHub web UI. */
    committedViaWeb: Scalars["Boolean"]["output"];
    /** Committer details of the commit. */
    committer?: Maybe<GitActor>;
    /** The number of deletions in this commit. */
    deletions: Scalars["Int"]["output"];
    /** The deployments associated with a commit. */
    deployments?: Maybe<DeploymentConnection>;
    /** The tree entry representing the file located at the given path. */
    file?: Maybe<TreeEntry>;
    /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */
    history: CommitHistoryConnection;
    /** The Node ID of the Commit object */
    id: Scalars["ID"]["output"];
    /** The Git commit message */
    message: Scalars["String"]["output"];
    /** The Git commit message body */
    messageBody: Scalars["String"]["output"];
    /** The commit message body rendered to HTML. */
    messageBodyHTML: Scalars["HTML"]["output"];
    /** The Git commit message headline */
    messageHeadline: Scalars["String"]["output"];
    /** The commit message headline rendered to HTML. */
    messageHeadlineHTML: Scalars["HTML"]["output"];
    /** The Git object ID */
    oid: Scalars["GitObjectID"]["output"];
    /** The organization this commit was made on behalf of. */
    onBehalfOf?: Maybe<Organization>;
    /** The parents of a commit. */
    parents: CommitConnection;
    /**
     * The datetime when this commit was pushed.
     * @deprecated `pushedDate` is no longer supported. Removal on 2023-07-01 UTC.
     */
    pushedDate?: Maybe<Scalars["DateTime"]["output"]>;
    /** The Repository this commit belongs to */
    repository: Repository;
    /** The HTTP path for this commit */
    resourcePath: Scalars["URI"]["output"];
    /** Commit signing information, if present. */
    signature?: Maybe<GitSignature>;
    /** Status information for this commit */
    status?: Maybe<Status>;
    /** Check and Status rollup information for this commit. */
    statusCheckRollup?: Maybe<StatusCheckRollup>;
    /** Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file. */
    submodules: SubmoduleConnection;
    /**
     * Returns a URL to download a tarball archive for a repository.
     * Note: For private repositories, these links are temporary and expire after five minutes.
     */
    tarballUrl: Scalars["URI"]["output"];
    /** Commit's root Tree */
    tree: Tree;
    /** The HTTP path for the tree of this commit */
    treeResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for the tree of this commit */
    treeUrl: Scalars["URI"]["output"];
    /** The HTTP URL for this commit */
    url: Scalars["URI"]["output"];
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe: Scalars["Boolean"]["output"];
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: Maybe<SubscriptionState>;
    /**
     * Returns a URL to download a zipball archive for a repository.
     * Note: For private repositories, these links are temporary and expire after five minutes.
     */
    zipballUrl: Scalars["URI"]["output"];
  };

/** Represents a Git commit. */
export type CommitAssociatedPullRequestsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<PullRequestOrder>;
};

/** Represents a Git commit. */
export type CommitAuthorsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a Git commit. */
export type CommitBlameArgs = {
  path: Scalars["String"]["input"];
};

/** Represents a Git commit. */
export type CommitCheckSuitesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filterBy?: InputMaybe<CheckSuiteFilter>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a Git commit. */
export type CommitCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a Git commit. */
export type CommitDeploymentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  environments?: InputMaybe<Array<Scalars["String"]["input"]>>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<DeploymentOrder>;
};

/** Represents a Git commit. */
export type CommitFileArgs = {
  path: Scalars["String"]["input"];
};

/** Represents a Git commit. */
export type CommitHistoryArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  author?: InputMaybe<CommitAuthor>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  path?: InputMaybe<Scalars["String"]["input"]>;
  since?: InputMaybe<Scalars["GitTimestamp"]["input"]>;
  until?: InputMaybe<Scalars["GitTimestamp"]["input"]>;
};

/** Represents a Git commit. */
export type CommitParentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a Git commit. */
export type CommitSubmodulesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Specifies an author for filtering Git commits. */
export type CommitAuthor = {
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  emails?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /**
   * ID of a User to filter by. If non-null, only commits authored by this user
   * will be returned. This field takes precedence over emails.
   */
  id?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Parameters to be used for the commit_author_email_pattern rule */
export type CommitAuthorEmailPatternParameters = {
  __typename?: "CommitAuthorEmailPatternParameters";
  /** How this rule will appear to users. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars["Boolean"]["output"];
  /** The operator to use for matching. */
  operator: Scalars["String"]["output"];
  /** The pattern to match with. */
  pattern: Scalars["String"]["output"];
};

/** Parameters to be used for the commit_author_email_pattern rule */
export type CommitAuthorEmailPatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The operator to use for matching. */
  operator: Scalars["String"]["input"];
  /** The pattern to match with. */
  pattern: Scalars["String"]["input"];
};

/** Represents a comment on a given Commit. */
export type CommitComment = Comment &
  Deletable &
  Minimizable &
  Node &
  Reactable &
  RepositoryNode &
  Updatable &
  UpdatableComment & {
    __typename?: "CommitComment";
    /** The actor who authored the comment. */
    author?: Maybe<Actor>;
    /** Author's association with the subject of the comment. */
    authorAssociation: CommentAuthorAssociation;
    /** Identifies the comment body. */
    body: Scalars["String"]["output"];
    /** The body rendered to HTML. */
    bodyHTML: Scalars["HTML"]["output"];
    /** The body rendered to text. */
    bodyText: Scalars["String"]["output"];
    /** Identifies the commit associated with the comment, if the commit exists. */
    commit?: Maybe<Commit>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail: Scalars["Boolean"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The actor who edited the comment. */
    editor?: Maybe<Actor>;
    /** The Node ID of the CommitComment object */
    id: Scalars["ID"]["output"];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit: Scalars["Boolean"]["output"];
    /** Returns whether or not a comment has been minimized. */
    isMinimized: Scalars["Boolean"]["output"];
    /** The moment the editor made the last edit */
    lastEditedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /**
     * Returns why the comment was minimized. One of `abuse`, `off-topic`,
     * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
     * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
     */
    minimizedReason?: Maybe<Scalars["String"]["output"]>;
    /** Identifies the file path associated with the comment. */
    path?: Maybe<Scalars["String"]["output"]>;
    /** Identifies the line position associated with the comment. */
    position?: Maybe<Scalars["Int"]["output"]>;
    /** Identifies when the comment was published at. */
    publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: Maybe<Array<ReactionGroup>>;
    /** A list of Reactions left on the Issue. */
    reactions: ReactionConnection;
    /** The repository associated with this node. */
    repository: Repository;
    /** The HTTP path permalink for this commit comment. */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL permalink for this commit comment. */
    url: Scalars["URI"]["output"];
    /** A list of edits to this content. */
    userContentEdits?: Maybe<UserContentEditConnection>;
    /** Check if the current viewer can delete this object. */
    viewerCanDelete: Scalars["Boolean"]["output"];
    /** Check if the current viewer can minimize this object. */
    viewerCanMinimize: Scalars["Boolean"]["output"];
    /** Can user react to this subject */
    viewerCanReact: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
    /** Did the viewer author this comment. */
    viewerDidAuthor: Scalars["Boolean"]["output"];
  };

/** Represents a comment on a given Commit. */
export type CommitCommentReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** Represents a comment on a given Commit. */
export type CommitCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for CommitComment. */
export type CommitCommentConnection = {
  __typename?: "CommitCommentConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommitCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CommitComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CommitCommentEdge = {
  __typename?: "CommitCommentEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CommitComment>;
};

/** A thread of comments on a commit. */
export type CommitCommentThread = Node &
  RepositoryNode & {
    __typename?: "CommitCommentThread";
    /** The comments that exist in this thread. */
    comments: CommitCommentConnection;
    /** The commit the comments were made on. */
    commit?: Maybe<Commit>;
    /** The Node ID of the CommitCommentThread object */
    id: Scalars["ID"]["output"];
    /** The file the comments were made on. */
    path?: Maybe<Scalars["String"]["output"]>;
    /** The position in the diff for the commit that the comment was made on. */
    position?: Maybe<Scalars["Int"]["output"]>;
    /** The repository associated with this node. */
    repository: Repository;
  };

/** A thread of comments on a commit. */
export type CommitCommentThreadCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for Commit. */
export type CommitConnection = {
  __typename?: "CommitConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Ordering options for commit contribution connections. */
export type CommitContributionOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field by which to order commit contributions. */
  field: CommitContributionOrderField;
};

/** Properties by which commit contribution connections can be ordered. */
export enum CommitContributionOrderField {
  /** Order commit contributions by how many commits they represent. */
  CommitCount = "COMMIT_COUNT",
  /** Order commit contributions by when they were made. */
  OccurredAt = "OCCURRED_AT",
}

/** This aggregates commits made by a user within one repository. */
export type CommitContributionsByRepository = {
  __typename?: "CommitContributionsByRepository";
  /** The commit contributions, each representing a day. */
  contributions: CreatedCommitContributionConnection;
  /** The repository in which the commits were made. */
  repository: Repository;
  /** The HTTP path for the user's commits to the repository in this time range. */
  resourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for the user's commits to the repository in this time range. */
  url: Scalars["URI"]["output"];
};

/** This aggregates commits made by a user within one repository. */
export type CommitContributionsByRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<CommitContributionOrder>;
};

/** An edge in a connection. */
export type CommitEdge = {
  __typename?: "CommitEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Commit>;
};

/** The connection type for Commit. */
export type CommitHistoryConnection = {
  __typename?: "CommitHistoryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** A message to include with a new commit */
export type CommitMessage = {
  /** The body of the message. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** The headline of the message. */
  headline: Scalars["String"]["input"];
};

/** Parameters to be used for the commit_message_pattern rule */
export type CommitMessagePatternParameters = {
  __typename?: "CommitMessagePatternParameters";
  /** How this rule will appear to users. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars["Boolean"]["output"];
  /** The operator to use for matching. */
  operator: Scalars["String"]["output"];
  /** The pattern to match with. */
  pattern: Scalars["String"]["output"];
};

/** Parameters to be used for the commit_message_pattern rule */
export type CommitMessagePatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The operator to use for matching. */
  operator: Scalars["String"]["input"];
  /** The pattern to match with. */
  pattern: Scalars["String"]["input"];
};

/**
 * A git ref for a commit to be appended to.
 *
 * The ref must be a branch, i.e. its fully qualified name must start
 * with `refs/heads/` (although the input is not required to be fully
 * qualified).
 *
 * The Ref may be specified by its global node ID or by the
 * `repositoryNameWithOwner` and `branchName`.
 *
 * ### Examples
 *
 * Specify a branch using a global node ID:
 *
 *     { "id": "MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=" }
 *
 * Specify a branch using `repositoryNameWithOwner` and `branchName`:
 *
 *     {
 *       "repositoryNameWithOwner": "github/graphql-client",
 *       "branchName": "main"
 *     }
 */
export type CommittableBranch = {
  /** The unqualified name of the branch to append the commit to. */
  branchName?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the Ref to be updated. */
  id?: InputMaybe<Scalars["ID"]["input"]>;
  /** The nameWithOwner of the repository to commit to. */
  repositoryNameWithOwner?: InputMaybe<Scalars["String"]["input"]>;
};

/** Parameters to be used for the committer_email_pattern rule */
export type CommitterEmailPatternParameters = {
  __typename?: "CommitterEmailPatternParameters";
  /** How this rule will appear to users. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars["Boolean"]["output"];
  /** The operator to use for matching. */
  operator: Scalars["String"]["output"];
  /** The pattern to match with. */
  pattern: Scalars["String"]["output"];
};

/** Parameters to be used for the committer_email_pattern rule */
export type CommitterEmailPatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The operator to use for matching. */
  operator: Scalars["String"]["input"];
  /** The pattern to match with. */
  pattern: Scalars["String"]["input"];
};

/** Represents a comparison between two commit revisions. */
export type Comparison = Node & {
  __typename?: "Comparison";
  /** The number of commits ahead of the base branch. */
  aheadBy: Scalars["Int"]["output"];
  /** The base revision of this comparison. */
  baseTarget: GitObject;
  /** The number of commits behind the base branch. */
  behindBy: Scalars["Int"]["output"];
  /** The commits which compose this comparison. */
  commits: ComparisonCommitConnection;
  /** The head revision of this comparison. */
  headTarget: GitObject;
  /** The Node ID of the Comparison object */
  id: Scalars["ID"]["output"];
  /** The status of this comparison. */
  status: ComparisonStatus;
};

/** Represents a comparison between two commit revisions. */
export type ComparisonCommitsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for Commit. */
export type ComparisonCommitConnection = {
  __typename?: "ComparisonCommitConnection";
  /** The total count of authors and co-authors across all commits. */
  authorCount: Scalars["Int"]["output"];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** The status of a git comparison between two refs. */
export enum ComparisonStatus {
  /** The head ref is ahead of the base ref. */
  Ahead = "AHEAD",
  /** The head ref is behind the base ref. */
  Behind = "BEHIND",
  /** The head ref is both ahead and behind of the base ref, indicating git history has diverged. */
  Diverged = "DIVERGED",
  /** The head ref and base ref are identical. */
  Identical = "IDENTICAL",
}

/** Represents a 'connected' event on a given issue or pull request. */
export type ConnectedEvent = Node & {
  __typename?: "ConnectedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the ConnectedEvent object */
  id: Scalars["ID"]["output"];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars["Boolean"]["output"];
  /** Issue or pull request that made the reference. */
  source: ReferencedSubject;
  /** Issue or pull request which was connected. */
  subject: ReferencedSubject;
};

/** The Contributing Guidelines for a repository. */
export type ContributingGuidelines = {
  __typename?: "ContributingGuidelines";
  /** The body of the Contributing Guidelines. */
  body?: Maybe<Scalars["String"]["output"]>;
  /** The HTTP path for the Contributing Guidelines. */
  resourcePath?: Maybe<Scalars["URI"]["output"]>;
  /** The HTTP URL for the Contributing Guidelines. */
  url?: Maybe<Scalars["URI"]["output"]>;
};

/** Represents a contribution a user made on GitHub, such as opening an issue. */
export type Contribution = {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars["Boolean"]["output"];
  /** When this contribution was made. */
  occurredAt: Scalars["DateTime"]["output"];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for this contribution. */
  url: Scalars["URI"]["output"];
  /** The user who made this contribution. */
  user: User;
};

/** A calendar of contributions made on GitHub by a user. */
export type ContributionCalendar = {
  __typename?: "ContributionCalendar";
  /** A list of hex color codes used in this calendar. The darker the color, the more contributions it represents. */
  colors: Array<Scalars["String"]["output"]>;
  /** Determine if the color set was chosen because it's currently Halloween. */
  isHalloween: Scalars["Boolean"]["output"];
  /** A list of the months of contributions in this calendar. */
  months: Array<ContributionCalendarMonth>;
  /** The count of total contributions in the calendar. */
  totalContributions: Scalars["Int"]["output"];
  /** A list of the weeks of contributions in this calendar. */
  weeks: Array<ContributionCalendarWeek>;
};

/** Represents a single day of contributions on GitHub by a user. */
export type ContributionCalendarDay = {
  __typename?: "ContributionCalendarDay";
  /** The hex color code that represents how many contributions were made on this day compared to others in the calendar. */
  color: Scalars["String"]["output"];
  /** How many contributions were made by the user on this day. */
  contributionCount: Scalars["Int"]["output"];
  /**
   * Indication of contributions, relative to other days. Can be used to indicate
   * which color to represent this day on a calendar.
   */
  contributionLevel: ContributionLevel;
  /** The day this square represents. */
  date: Scalars["Date"]["output"];
  /** A number representing which day of the week this square represents, e.g., 1 is Monday. */
  weekday: Scalars["Int"]["output"];
};

/** A month of contributions in a user's contribution graph. */
export type ContributionCalendarMonth = {
  __typename?: "ContributionCalendarMonth";
  /** The date of the first day of this month. */
  firstDay: Scalars["Date"]["output"];
  /** The name of the month. */
  name: Scalars["String"]["output"];
  /** How many weeks started in this month. */
  totalWeeks: Scalars["Int"]["output"];
  /** The year the month occurred in. */
  year: Scalars["Int"]["output"];
};

/** A week of contributions in a user's contribution graph. */
export type ContributionCalendarWeek = {
  __typename?: "ContributionCalendarWeek";
  /** The days of contributions in this week. */
  contributionDays: Array<ContributionCalendarDay>;
  /** The date of the earliest square in this week. */
  firstDay: Scalars["Date"]["output"];
};

/** Varying levels of contributions from none to many. */
export enum ContributionLevel {
  /** Lowest 25% of days of contributions. */
  FirstQuartile = "FIRST_QUARTILE",
  /** Highest 25% of days of contributions. More contributions than the third quartile. */
  FourthQuartile = "FOURTH_QUARTILE",
  /** No contributions occurred. */
  None = "NONE",
  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */
  SecondQuartile = "SECOND_QUARTILE",
  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */
  ThirdQuartile = "THIRD_QUARTILE",
}

/** Ordering options for contribution connections. */
export type ContributionOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollection = {
  __typename?: "ContributionsCollection";
  /** Commit contributions made by the user, grouped by repository. */
  commitContributionsByRepository: Array<CommitContributionsByRepository>;
  /** A calendar of this user's contributions on GitHub. */
  contributionCalendar: ContributionCalendar;
  /** The years the user has been making contributions with the most recent year first. */
  contributionYears: Array<Scalars["Int"]["output"]>;
  /** Determine if this collection's time span ends in the current month. */
  doesEndInCurrentMonth: Scalars["Boolean"]["output"];
  /**
   * The date of the first restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  earliestRestrictedContributionDate?: Maybe<Scalars["Date"]["output"]>;
  /** The ending date and time of this collection. */
  endedAt: Scalars["DateTime"]["output"];
  /**
   * The first issue the user opened on GitHub. This will be null if that issue was
   * opened outside the collection's time range and ignoreTimeRange is false. If
   * the issue is not visible but the user has opted to show private contributions,
   * a RestrictedContribution will be returned.
   */
  firstIssueContribution?: Maybe<CreatedIssueOrRestrictedContribution>;
  /**
   * The first pull request the user opened on GitHub. This will be null if that
   * pull request was opened outside the collection's time range and
   * ignoreTimeRange is not true. If the pull request is not visible but the user
   * has opted to show private contributions, a RestrictedContribution will be returned.
   */
  firstPullRequestContribution?: Maybe<CreatedPullRequestOrRestrictedContribution>;
  /**
   * The first repository the user created on GitHub. This will be null if that
   * first repository was created outside the collection's time range and
   * ignoreTimeRange is false. If the repository is not visible, then a
   * RestrictedContribution is returned.
   */
  firstRepositoryContribution?: Maybe<CreatedRepositoryOrRestrictedContribution>;
  /** Does the user have any more activity in the timeline that occurred prior to the collection's time range? */
  hasActivityInThePast: Scalars["Boolean"]["output"];
  /** Determine if there are any contributions in this collection. */
  hasAnyContributions: Scalars["Boolean"]["output"];
  /**
   * Determine if the user made any contributions in this time frame whose details
   * are not visible because they were made in a private repository. Can only be
   * true if the user enabled private contribution counts.
   */
  hasAnyRestrictedContributions: Scalars["Boolean"]["output"];
  /** Whether or not the collector's time span is all within the same day. */
  isSingleDay: Scalars["Boolean"]["output"];
  /** A list of issues the user opened. */
  issueContributions: CreatedIssueContributionConnection;
  /** Issue contributions made by the user, grouped by repository. */
  issueContributionsByRepository: Array<IssueContributionsByRepository>;
  /**
   * When the user signed up for GitHub. This will be null if that sign up date
   * falls outside the collection's time range and ignoreTimeRange is false.
   */
  joinedGitHubContribution?: Maybe<JoinedGitHubContribution>;
  /**
   * The date of the most recent restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  latestRestrictedContributionDate?: Maybe<Scalars["Date"]["output"]>;
  /**
   * When this collection's time range does not include any activity from the user, use this
   * to get a different collection from an earlier time range that does have activity.
   */
  mostRecentCollectionWithActivity?: Maybe<ContributionsCollection>;
  /**
   * Returns a different contributions collection from an earlier time range than this one
   * that does not have any contributions.
   */
  mostRecentCollectionWithoutActivity?: Maybe<ContributionsCollection>;
  /**
   * The issue the user opened on GitHub that received the most comments in the specified
   * time frame.
   */
  popularIssueContribution?: Maybe<CreatedIssueContribution>;
  /**
   * The pull request the user opened on GitHub that received the most comments in the
   * specified time frame.
   */
  popularPullRequestContribution?: Maybe<CreatedPullRequestContribution>;
  /** Pull request contributions made by the user. */
  pullRequestContributions: CreatedPullRequestContributionConnection;
  /** Pull request contributions made by the user, grouped by repository. */
  pullRequestContributionsByRepository: Array<PullRequestContributionsByRepository>;
  /**
   * Pull request review contributions made by the user. Returns the most recently
   * submitted review for each PR reviewed by the user.
   */
  pullRequestReviewContributions: CreatedPullRequestReviewContributionConnection;
  /** Pull request review contributions made by the user, grouped by repository. */
  pullRequestReviewContributionsByRepository: Array<PullRequestReviewContributionsByRepository>;
  /** A list of repositories owned by the user that the user created in this time range. */
  repositoryContributions: CreatedRepositoryContributionConnection;
  /**
   * A count of contributions made by the user that the viewer cannot access. Only
   * non-zero when the user has chosen to share their private contribution counts.
   */
  restrictedContributionsCount: Scalars["Int"]["output"];
  /** The beginning date and time of this collection. */
  startedAt: Scalars["DateTime"]["output"];
  /** How many commits were made by the user in this time span. */
  totalCommitContributions: Scalars["Int"]["output"];
  /** How many issues the user opened. */
  totalIssueContributions: Scalars["Int"]["output"];
  /** How many pull requests the user opened. */
  totalPullRequestContributions: Scalars["Int"]["output"];
  /** How many pull request reviews the user left. */
  totalPullRequestReviewContributions: Scalars["Int"]["output"];
  /** How many different repositories the user committed to. */
  totalRepositoriesWithContributedCommits: Scalars["Int"]["output"];
  /** How many different repositories the user opened issues in. */
  totalRepositoriesWithContributedIssues: Scalars["Int"]["output"];
  /** How many different repositories the user left pull request reviews in. */
  totalRepositoriesWithContributedPullRequestReviews: Scalars["Int"]["output"];
  /** How many different repositories the user opened pull requests in. */
  totalRepositoriesWithContributedPullRequests: Scalars["Int"]["output"];
  /** How many repositories the user created. */
  totalRepositoryContributions: Scalars["Int"]["output"];
  /** The user who made the contributions in this collection. */
  user: User;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionCommitContributionsByRepositoryArgs = {
  maxRepositories?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionIssueContributionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  excludeFirst?: InputMaybe<Scalars["Boolean"]["input"]>;
  excludePopular?: InputMaybe<Scalars["Boolean"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionIssueContributionsByRepositoryArgs = {
  excludeFirst?: InputMaybe<Scalars["Boolean"]["input"]>;
  excludePopular?: InputMaybe<Scalars["Boolean"]["input"]>;
  maxRepositories?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionPullRequestContributionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  excludeFirst?: InputMaybe<Scalars["Boolean"]["input"]>;
  excludePopular?: InputMaybe<Scalars["Boolean"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionPullRequestContributionsByRepositoryArgs = {
  excludeFirst?: InputMaybe<Scalars["Boolean"]["input"]>;
  excludePopular?: InputMaybe<Scalars["Boolean"]["input"]>;
  maxRepositories?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionPullRequestReviewContributionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionPullRequestReviewContributionsByRepositoryArgs =
  {
    maxRepositories?: InputMaybe<Scalars["Int"]["input"]>;
  };

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  excludeFirst?: InputMaybe<Scalars["Boolean"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionTotalIssueContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars["Boolean"]["input"]>;
  excludePopular?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionTotalPullRequestContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars["Boolean"]["input"]>;
  excludePopular?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionTotalRepositoriesWithContributedIssuesArgs =
  {
    excludeFirst?: InputMaybe<Scalars["Boolean"]["input"]>;
    excludePopular?: InputMaybe<Scalars["Boolean"]["input"]>;
  };

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionTotalRepositoriesWithContributedPullRequestsArgs =
  {
    excludeFirst?: InputMaybe<Scalars["Boolean"]["input"]>;
    excludePopular?: InputMaybe<Scalars["Boolean"]["input"]>;
  };

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionTotalRepositoryContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Autogenerated input type of ConvertProjectCardNoteToIssue */
export type ConvertProjectCardNoteToIssueInput = {
  /** The body of the newly created issue. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ProjectCard ID to convert. */
  projectCardId: Scalars["ID"]["input"];
  /** The ID of the repository to create the issue in. */
  repositoryId: Scalars["ID"]["input"];
  /** The title of the newly created issue. Defaults to the card's note text. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of ConvertProjectCardNoteToIssue. */
export type ConvertProjectCardNoteToIssuePayload = {
  __typename?: "ConvertProjectCardNoteToIssuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated ProjectCard. */
  projectCard?: Maybe<ProjectCard>;
};

/** Autogenerated input type of ConvertProjectV2DraftIssueItemToIssue */
export type ConvertProjectV2DraftIssueItemToIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the draft issue ProjectV2Item to convert. */
  itemId: Scalars["ID"]["input"];
  /** The ID of the repository to create the issue in. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of ConvertProjectV2DraftIssueItemToIssue. */
export type ConvertProjectV2DraftIssueItemToIssuePayload = {
  __typename?: "ConvertProjectV2DraftIssueItemToIssuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated project item. */
  item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of ConvertPullRequestToDraft */
export type ConvertPullRequestToDraftInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the pull request to convert to draft */
  pullRequestId: Scalars["ID"]["input"];
};

/** Autogenerated return type of ConvertPullRequestToDraft. */
export type ConvertPullRequestToDraftPayload = {
  __typename?: "ConvertPullRequestToDraftPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The pull request that is now a draft. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'convert_to_draft' event on a given pull request. */
export type ConvertToDraftEvent = Node &
  UniformResourceLocatable & {
    __typename?: "ConvertToDraftEvent";
    /** Identifies the actor who performed the event. */
    actor?: Maybe<Actor>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The Node ID of the ConvertToDraftEvent object */
    id: Scalars["ID"]["output"];
    /** PullRequest referenced by event. */
    pullRequest: PullRequest;
    /** The HTTP path for this convert to draft event. */
    resourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for this convert to draft event. */
    url: Scalars["URI"]["output"];
  };

/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
export type ConvertedNoteToIssueEvent = Node & {
  __typename?: "ConvertedNoteToIssueEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the ConvertedNoteToIssueEvent object */
  id: Scalars["ID"]["output"];
  /** Project referenced by event. */
  project?: Maybe<Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<ProjectCard>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars["String"]["output"];
};

/** Represents a 'converted_to_discussion' event on a given issue. */
export type ConvertedToDiscussionEvent = Node & {
  __typename?: "ConvertedToDiscussionEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The discussion that the issue was converted into. */
  discussion?: Maybe<Discussion>;
  /** The Node ID of the ConvertedToDiscussionEvent object */
  id: Scalars["ID"]["output"];
};

/** Copilot endpoint information */
export type CopilotEndpoints = {
  __typename?: "CopilotEndpoints";
  /** Copilot API endpoint */
  api: Scalars["String"]["output"];
  /** Copilot origin tracker endpoint */
  originTracker: Scalars["String"]["output"];
  /** Copilot proxy endpoint */
  proxy: Scalars["String"]["output"];
  /** Copilot telemetry endpoint */
  telemetry: Scalars["String"]["output"];
};

/** Autogenerated input type of CopyProjectV2 */
export type CopyProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Include draft issues in the new project */
  includeDraftIssues?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The owner ID of the new project. */
  ownerId: Scalars["ID"]["input"];
  /** The ID of the source Project to copy. */
  projectId: Scalars["ID"]["input"];
  /** The title of the project. */
  title: Scalars["String"]["input"];
};

/** Autogenerated return type of CopyProjectV2. */
export type CopyProjectV2Payload = {
  __typename?: "CopyProjectV2Payload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The copied project. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of CreateAttributionInvitation */
export type CreateAttributionInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the owner scoping the reattributable data. */
  ownerId: Scalars["ID"]["input"];
  /** The Node ID of the account owning the data to reattribute. */
  sourceId: Scalars["ID"]["input"];
  /** The Node ID of the account which may claim the data. */
  targetId: Scalars["ID"]["input"];
};

/** Autogenerated return type of CreateAttributionInvitation. */
export type CreateAttributionInvitationPayload = {
  __typename?: "CreateAttributionInvitationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The owner scoping the reattributable data. */
  owner?: Maybe<Organization>;
  /** The account owning the data to reattribute. */
  source?: Maybe<Claimable>;
  /** The account which may claim the data. */
  target?: Maybe<Claimable>;
};

/** Autogenerated input type of CreateBranchProtectionRule */
export type CreateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Is branch creation a protected operation. */
  blocksCreations?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */
  bypassForcePushActorIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */
  bypassPullRequestActorIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Can admins override branch protection. */
  isAdminEnforced?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The glob-like pattern used to determine matching branches. */
  pattern: Scalars["String"]["input"];
  /** A list of User, Team, or App IDs allowed to push to matching branches. */
  pushActorIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The global relay id of the repository in which a new branch protection rule should be created in. */
  repositoryId: Scalars["ID"]["input"];
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: InputMaybe<Scalars["Int"]["input"]>;
  /** The list of required deployment environments */
  requiredDeploymentEnvironments?: InputMaybe<
    Array<Scalars["String"]["input"]>
  >;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** The list of required status checks */
  requiredStatusChecks?: InputMaybe<Array<RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are successful deployments required before merging. */
  requiresDeployments?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

/** Autogenerated return type of CreateBranchProtectionRule. */
export type CreateBranchProtectionRulePayload = {
  __typename?: "CreateBranchProtectionRulePayload";
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of CreateCheckRun */
export type CreateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: InputMaybe<Array<CheckRunAction>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The time that the check run finished. */
  completedAt?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** The final conclusion of the check. */
  conclusion?: InputMaybe<CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: InputMaybe<Scalars["URI"]["input"]>;
  /** A reference for the run on the integrator's system. */
  externalId?: InputMaybe<Scalars["String"]["input"]>;
  /** The SHA of the head commit. */
  headSha: Scalars["GitObjectID"]["input"];
  /** The name of the check. */
  name: Scalars["String"]["input"];
  /** Descriptive details about the run. */
  output?: InputMaybe<CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars["ID"]["input"];
  /** The time that the check run began. */
  startedAt?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** The current status. */
  status?: InputMaybe<RequestableCheckStatusState>;
};

/** Autogenerated return type of CreateCheckRun. */
export type CreateCheckRunPayload = {
  __typename?: "CreateCheckRunPayload";
  /** The newly created check run. */
  checkRun?: Maybe<CheckRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of CreateCheckSuite */
export type CreateCheckSuiteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The SHA of the head commit. */
  headSha: Scalars["GitObjectID"]["input"];
  /** The Node ID of the repository. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of CreateCheckSuite. */
export type CreateCheckSuitePayload = {
  __typename?: "CreateCheckSuitePayload";
  /** The newly created check suite. */
  checkSuite?: Maybe<CheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of CreateCommitOnBranch */
export type CreateCommitOnBranchInput = {
  /** The Ref to be updated.  Must be a branch. */
  branch: CommittableBranch;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The git commit oid expected at the head of the branch prior to the commit */
  expectedHeadOid: Scalars["GitObjectID"]["input"];
  /** A description of changes to files in this commit. */
  fileChanges?: InputMaybe<FileChanges>;
  /** The commit message the be included with the commit. */
  message: CommitMessage;
};

/** Autogenerated return type of CreateCommitOnBranch. */
export type CreateCommitOnBranchPayload = {
  __typename?: "CreateCommitOnBranchPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new commit. */
  commit?: Maybe<Commit>;
  /** The ref which has been updated to point to the new commit. */
  ref?: Maybe<Ref>;
};

/** Autogenerated input type of CreateDeployment */
export type CreateDeploymentInput = {
  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */
  autoMerge?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Short description of the deployment. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** Name for the target deployment environment. */
  environment?: InputMaybe<Scalars["String"]["input"]>;
  /** JSON payload with extra information about the deployment. */
  payload?: InputMaybe<Scalars["String"]["input"]>;
  /** The node ID of the ref to be deployed. */
  refId: Scalars["ID"]["input"];
  /** The node ID of the repository. */
  repositoryId: Scalars["ID"]["input"];
  /**
   * The status contexts to verify against commit status checks. To bypass required
   * contexts, pass an empty array. Defaults to all unique contexts.
   */
  requiredContexts?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** Specifies a task to execute. */
  task?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of CreateDeployment. */
export type CreateDeploymentPayload = {
  __typename?: "CreateDeploymentPayload";
  /** True if the default branch has been auto-merged into the deployment ref. */
  autoMerged?: Maybe<Scalars["Boolean"]["output"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new deployment. */
  deployment?: Maybe<Deployment>;
};

/** Autogenerated input type of CreateDeploymentStatus */
export type CreateDeploymentStatusInput = {
  /**
   * Adds a new inactive status to all non-transient, non-production environment
   * deployments with the same repository and environment name as the created
   * status's deployment.
   */
  autoInactive?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The node ID of the deployment. */
  deploymentId: Scalars["ID"]["input"];
  /** A short description of the status. Maximum length of 140 characters. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */
  environment?: InputMaybe<Scalars["String"]["input"]>;
  /** Sets the URL for accessing your environment. */
  environmentUrl?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The log URL to associate with this status.       This URL should contain
   * output to keep the user updated while the task is running       or serve as
   * historical information for what happened in the deployment.
   */
  logUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** The state of the deployment. */
  state: DeploymentStatusState;
};

/** Autogenerated return type of CreateDeploymentStatus. */
export type CreateDeploymentStatusPayload = {
  __typename?: "CreateDeploymentStatusPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new deployment status. */
  deploymentStatus?: Maybe<DeploymentStatus>;
};

/** Autogenerated input type of CreateDiscussion */
export type CreateDiscussionInput = {
  /** The body of the discussion. */
  body: Scalars["String"]["input"];
  /** The id of the discussion category to associate with this discussion. */
  categoryId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The id of the repository on which to create the discussion. */
  repositoryId: Scalars["ID"]["input"];
  /** The title of the discussion. */
  title: Scalars["String"]["input"];
};

/** Autogenerated return type of CreateDiscussion. */
export type CreateDiscussionPayload = {
  __typename?: "CreateDiscussionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The discussion that was just created. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of CreateEnterpriseOrganization */
export type CreateEnterpriseOrganizationInput = {
  /** The logins for the administrators of the new organization. */
  adminLogins: Array<Scalars["String"]["input"]>;
  /** The email used for sending billing receipts. */
  billingEmail: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise owning the new organization. */
  enterpriseId: Scalars["ID"]["input"];
  /** The login of the new organization. */
  login: Scalars["String"]["input"];
  /** The profile name of the new organization. */
  profileName: Scalars["String"]["input"];
};

/** Autogenerated return type of CreateEnterpriseOrganization. */
export type CreateEnterpriseOrganizationPayload = {
  __typename?: "CreateEnterpriseOrganizationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise that owns the created organization. */
  enterprise?: Maybe<Enterprise>;
  /** The organization that was created. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of CreateEnvironment */
export type CreateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the environment. */
  name: Scalars["String"]["input"];
  /** The node ID of the repository. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of CreateEnvironment. */
export type CreateEnvironmentPayload = {
  __typename?: "CreateEnvironmentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new or existing environment. */
  environment?: Maybe<Environment>;
};

/** Autogenerated input type of CreateIpAllowListEntry */
export type CreateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars["Boolean"]["input"];
  /** An optional name for the IP allow list entry. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the owner for which to create the new IP allow list entry. */
  ownerId: Scalars["ID"]["input"];
};

/** Autogenerated return type of CreateIpAllowListEntry. */
export type CreateIpAllowListEntryPayload = {
  __typename?: "CreateIpAllowListEntryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The IP allow list entry that was created. */
  ipAllowListEntry?: Maybe<IpAllowListEntry>;
};

/** Autogenerated input type of CreateIssue */
export type CreateIssueInput = {
  /** The Node ID for the user assignee for this issue. */
  assigneeIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The body for the issue description. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */
  issueTemplate?: InputMaybe<Scalars["String"]["input"]>;
  /** An array of Node IDs of labels for this issue. */
  labelIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: InputMaybe<Scalars["ID"]["input"]>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The Node ID of the repository. */
  repositoryId: Scalars["ID"]["input"];
  /** The title for the issue. */
  title: Scalars["String"]["input"];
};

/** Autogenerated return type of CreateIssue. */
export type CreateIssuePayload = {
  __typename?: "CreateIssuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new issue. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of CreateLabel */
export type CreateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A 6 character hex code, without the leading #, identifying the color of the label. */
  color: Scalars["String"]["input"];
  /** A brief description of the label, such as its purpose. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the label. */
  name: Scalars["String"]["input"];
  /** The Node ID of the repository. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of CreateLabel. */
export type CreateLabelPayload = {
  __typename?: "CreateLabelPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new label. */
  label?: Maybe<Label>;
};

/** Autogenerated input type of CreateLinkedBranch */
export type CreateLinkedBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the issue to link to. */
  issueId: Scalars["ID"]["input"];
  /** The name of the new branch. Defaults to issue number and title. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** The commit SHA to base the new branch on. */
  oid: Scalars["GitObjectID"]["input"];
  /** ID of the repository to create the branch in. Defaults to the issue repository. */
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of CreateLinkedBranch. */
export type CreateLinkedBranchPayload = {
  __typename?: "CreateLinkedBranchPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The issue that was linked to. */
  issue?: Maybe<Issue>;
  /** The new branch issue reference. */
  linkedBranch?: Maybe<LinkedBranch>;
};

/** Autogenerated input type of CreateMigrationSource */
export type CreateMigrationSourceInput = {
  /** The migration source access token. */
  accessToken?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The GitHub personal access token of the user importing to the target repository. */
  githubPat?: InputMaybe<Scalars["String"]["input"]>;
  /** The migration source name. */
  name: Scalars["String"]["input"];
  /** The ID of the organization that will own the migration source. */
  ownerId: Scalars["ID"]["input"];
  /** The migration source type. */
  type: MigrationSourceType;
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  url?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of CreateMigrationSource. */
export type CreateMigrationSourcePayload = {
  __typename?: "CreateMigrationSourcePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The created migration source. */
  migrationSource?: Maybe<MigrationSource>;
};

/** Autogenerated input type of CreateProject */
export type CreateProjectInput = {
  /** The description of project. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of project. */
  name: Scalars["String"]["input"];
  /** The owner ID to create the project under. */
  ownerId: Scalars["ID"]["input"];
  /** A list of repository IDs to create as linked repositories for the project */
  repositoryIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The name of the GitHub-provided template. */
  template?: InputMaybe<ProjectTemplate>;
};

/** Autogenerated return type of CreateProject. */
export type CreateProjectPayload = {
  __typename?: "CreateProjectPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new project. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of CreateProjectV2Field */
export type CreateProjectV2FieldInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The data type of the field. */
  dataType: ProjectV2CustomFieldType;
  /** The name of the field. */
  name: Scalars["String"]["input"];
  /** The ID of the Project to create the field in. */
  projectId: Scalars["ID"]["input"];
  /** Options for a single select field. At least one value is required if data_type is SINGLE_SELECT */
  singleSelectOptions?: InputMaybe<
    Array<ProjectV2SingleSelectFieldOptionInput>
  >;
};

/** Autogenerated return type of CreateProjectV2Field. */
export type CreateProjectV2FieldPayload = {
  __typename?: "CreateProjectV2FieldPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new field. */
  projectV2Field?: Maybe<ProjectV2FieldConfiguration>;
};

/** Autogenerated input type of CreateProjectV2 */
export type CreateProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The owner ID to create the project under. */
  ownerId: Scalars["ID"]["input"];
  /** The repository to link the project to. */
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The team to link the project to. The team will be granted read permissions. */
  teamId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The title of the project. */
  title: Scalars["String"]["input"];
};

/** Autogenerated return type of CreateProjectV2. */
export type CreateProjectV2Payload = {
  __typename?: "CreateProjectV2Payload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new project. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of CreateProjectV2StatusUpdate */
export type CreateProjectV2StatusUpdateInput = {
  /** The body of the status update. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Project to create the status update in. */
  projectId: Scalars["ID"]["input"];
  /** The start date of the status update. */
  startDate?: InputMaybe<Scalars["Date"]["input"]>;
  /** The status of the status update. */
  status?: InputMaybe<ProjectV2StatusUpdateStatus>;
  /** The target date of the status update. */
  targetDate?: InputMaybe<Scalars["Date"]["input"]>;
};

/** Autogenerated return type of CreateProjectV2StatusUpdate. */
export type CreateProjectV2StatusUpdatePayload = {
  __typename?: "CreateProjectV2StatusUpdatePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The status update updated in the project. */
  statusUpdate?: Maybe<ProjectV2StatusUpdate>;
};

/** Autogenerated input type of CreatePullRequest */
export type CreatePullRequestInput = {
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository. You cannot update the base branch on a pull request to point
   * to another repository.
   */
  baseRefName: Scalars["String"]["input"];
  /** The contents of the pull request. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Indicates whether this pull request should be a draft. */
  draft?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * The name of the branch where your changes are implemented. For cross-repository pull requests
   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.
   */
  headRefName: Scalars["String"]["input"];
  /** The Node ID of the head repository. */
  headRepositoryId?: InputMaybe<Scalars["ID"]["input"]>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The Node ID of the repository. */
  repositoryId: Scalars["ID"]["input"];
  /** The title of the pull request. */
  title: Scalars["String"]["input"];
};

/** Autogenerated return type of CreatePullRequest. */
export type CreatePullRequestPayload = {
  __typename?: "CreatePullRequestPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new pull request. */
  pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of CreateRef */
export type CreateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */
  name: Scalars["String"]["input"];
  /** The GitObjectID that the new Ref shall target. Must point to a commit. */
  oid: Scalars["GitObjectID"]["input"];
  /** The Node ID of the Repository to create the Ref in. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of CreateRef. */
export type CreateRefPayload = {
  __typename?: "CreateRefPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The newly created ref. */
  ref?: Maybe<Ref>;
};

/** Autogenerated input type of CreateRepository */
export type CreateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A short description of the new repository. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The URL for a web page about this repository. */
  homepageUrl?: InputMaybe<Scalars["URI"]["input"]>;
  /** The name of the new repository. */
  name: Scalars["String"]["input"];
  /** The ID of the owner for the new repository. */
  ownerId?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * When an organization is specified as the owner, this ID identifies the team
   * that should be granted access to the new repository.
   */
  teamId?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Indicates the repository's visibility level. */
  visibility: RepositoryVisibility;
};

/** Autogenerated return type of CreateRepository. */
export type CreateRepositoryPayload = {
  __typename?: "CreateRepositoryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new repository. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of CreateRepositoryRuleset */
export type CreateRepositoryRulesetInput = {
  /** A list of actors that are allowed to bypass rules in this ruleset. */
  bypassActors?: InputMaybe<Array<RepositoryRulesetBypassActorInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The set of conditions for this ruleset */
  conditions: RepositoryRuleConditionsInput;
  /** The enforcement level for this ruleset */
  enforcement: RuleEnforcement;
  /** The name of the ruleset. */
  name: Scalars["String"]["input"];
  /** The list of rules for this ruleset */
  rules?: InputMaybe<Array<RepositoryRuleInput>>;
  /** The global relay id of the source in which a new ruleset should be created in. */
  sourceId: Scalars["ID"]["input"];
  /** The target of the ruleset. */
  target?: InputMaybe<RepositoryRulesetTarget>;
};

/** Autogenerated return type of CreateRepositoryRuleset. */
export type CreateRepositoryRulesetPayload = {
  __typename?: "CreateRepositoryRulesetPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The newly created Ruleset. */
  ruleset?: Maybe<RepositoryRuleset>;
};

/** Autogenerated input type of CreateSponsorsListing */
export type CreateSponsorsListingInput = {
  /**
   * The country or region where the sponsorable's bank account is located.
   * Required if fiscalHostLogin is not specified, ignored when fiscalHostLogin is specified.
   */
  billingCountryOrRegionCode?: InputMaybe<SponsorsCountryOrRegionCode>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The email address we should use to contact you about the GitHub Sponsors
   * profile being created. This will not be shared publicly. Must be a verified
   * email address already on your GitHub account. Only relevant when the
   * sponsorable is yourself. Defaults to your primary email address on file if omitted.
   */
  contactEmail?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The username of the supported fiscal host's GitHub organization, if you want
   * to receive sponsorship payouts through a fiscal host rather than directly to a
   * bank account. For example, 'Open-Source-Collective' for Open Source Collective
   * or 'numfocus' for numFOCUS. Case insensitive. See https://docs.github.com/sponsors/receiving-sponsorships-through-github-sponsors/using-a-fiscal-host-to-receive-github-sponsors-payouts
   * for more information.
   */
  fiscalHostLogin?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The URL for your profile page on the fiscal host's website, e.g.,
   * https://opencollective.com/babel or https://numfocus.org/project/bokeh.
   * Required if fiscalHostLogin is specified.
   */
  fiscallyHostedProjectProfileUrl?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * Provide an introduction to serve as the main focus that appears on your GitHub
   * Sponsors profile. It's a great opportunity to help potential sponsors learn
   * more about you, your work, and why their sponsorship is important to you.
   * GitHub-flavored Markdown is supported.
   */
  fullDescription?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The country or region where the sponsorable resides. This is for tax purposes.
   * Required if the sponsorable is yourself, ignored when sponsorableLogin
   * specifies an organization.
   */
  residenceCountryOrRegionCode?: InputMaybe<SponsorsCountryOrRegionCode>;
  /**
   * The username of the organization to create a GitHub Sponsors profile for, if
   * desired. Defaults to creating a GitHub Sponsors profile for the authenticated
   * user if omitted.
   */
  sponsorableLogin?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of CreateSponsorsListing. */
export type CreateSponsorsListingPayload = {
  __typename?: "CreateSponsorsListingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new GitHub Sponsors profile. */
  sponsorsListing?: Maybe<SponsorsListing>;
};

/** Autogenerated input type of CreateSponsorsTier */
export type CreateSponsorsTierInput = {
  /** The value of the new tier in US dollars. Valid values: 1-12000. */
  amount: Scalars["Int"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A description of what this tier is, what perks sponsors might receive, what a sponsorship at this tier means for you, etc. */
  description: Scalars["String"]["input"];
  /** Whether sponsorships using this tier should happen monthly/yearly or just once. */
  isRecurring?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * Whether to make the tier available immediately for sponsors to choose.
   * Defaults to creating a draft tier that will not be publicly visible.
   */
  publish?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * Optional ID of the private repository that sponsors at this tier should gain
   * read-only access to. Must be owned by an organization.
   */
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * Optional name of the private repository that sponsors at this tier should gain
   * read-only access to. Must be owned by an organization. Necessary if
   * repositoryOwnerLogin is given. Will be ignored if repositoryId is given.
   */
  repositoryName?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * Optional login of the organization owner of the private repository that
   * sponsors at this tier should gain read-only access to. Necessary if
   * repositoryName is given. Will be ignored if repositoryId is given.
   */
  repositoryOwnerLogin?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The ID of the user or organization who owns the GitHub Sponsors profile.
   * Defaults to the current user if omitted and sponsorableLogin is not given.
   */
  sponsorableId?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * The username of the user or organization who owns the GitHub Sponsors profile.
   * Defaults to the current user if omitted and sponsorableId is not given.
   */
  sponsorableLogin?: InputMaybe<Scalars["String"]["input"]>;
  /** Optional message new sponsors at this tier will receive. */
  welcomeMessage?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of CreateSponsorsTier. */
export type CreateSponsorsTierPayload = {
  __typename?: "CreateSponsorsTierPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new tier. */
  sponsorsTier?: Maybe<SponsorsTier>;
};

/** Autogenerated input type of CreateSponsorship */
export type CreateSponsorshipInput = {
  /** The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000. */
  amount?: InputMaybe<Scalars["Int"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified. */
  isRecurring?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: InputMaybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified. */
  tierId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of CreateSponsorship. */
export type CreateSponsorshipPayload = {
  __typename?: "CreateSponsorshipPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The sponsorship that was started. */
  sponsorship?: Maybe<Sponsorship>;
};

/** Autogenerated input type of CreateSponsorships */
export type CreateSponsorshipsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorables. Public visibility still does not reveal the dollar value of
   * the sponsorship.
   */
  privacyLevel?: InputMaybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorables. */
  receiveEmails?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * Whether the sponsorships created should continue each billing cycle for the
   * sponsor (monthly or annually), versus lasting only a single month. Defaults to
   * one-time sponsorships.
   */
  recurring?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The username of the user or organization who is acting as the sponsor, paying for the sponsorships. */
  sponsorLogin: Scalars["String"]["input"];
  /** The list of maintainers to sponsor and for how much apiece. */
  sponsorships: Array<BulkSponsorship>;
};

/** Autogenerated return type of CreateSponsorships. */
export type CreateSponsorshipsPayload = {
  __typename?: "CreateSponsorshipsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The users and organizations who received a sponsorship. */
  sponsorables?: Maybe<Array<Sponsorable>>;
};

/** Autogenerated input type of CreateTeamDiscussionComment */
export type CreateTeamDiscussionCommentInput = {
  /**
   * The content of the comment. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `body` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The ID of the discussion to which the comment belongs. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `discussionId` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  discussionId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of CreateTeamDiscussionComment. */
export type CreateTeamDiscussionCommentPayload = {
  __typename?: "CreateTeamDiscussionCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /**
   * The new comment.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  teamDiscussionComment?: Maybe<TeamDiscussionComment>;
};

/** Autogenerated input type of CreateTeamDiscussion */
export type CreateTeamDiscussionInput = {
  /**
   * The content of the discussion. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `body` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * If true, restricts the visibility of this discussion to team members and
   * organization owners. If false or not specified, allows any organization member
   * to view this discussion.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `private` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  private?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * The ID of the team to which the discussion belongs. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `teamId` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  teamId?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * The title of the discussion. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `title` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of CreateTeamDiscussion. */
export type CreateTeamDiscussionPayload = {
  __typename?: "CreateTeamDiscussionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /**
   * The new discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  teamDiscussion?: Maybe<TeamDiscussion>;
};

/** Autogenerated input type of CreateUserList */
export type CreateUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A description of the list */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not the list is private */
  isPrivate?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The name of the new list */
  name: Scalars["String"]["input"];
};

/** Autogenerated return type of CreateUserList. */
export type CreateUserListPayload = {
  __typename?: "CreateUserListPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The list that was just created */
  list?: Maybe<UserList>;
  /** The user who created the list */
  viewer?: Maybe<User>;
};

/** Represents the contribution a user made by committing to a repository. */
export type CreatedCommitContribution = Contribution & {
  __typename?: "CreatedCommitContribution";
  /** How many commits were made on this day to this repository by the user. */
  commitCount: Scalars["Int"]["output"];
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars["Boolean"]["output"];
  /** When this contribution was made. */
  occurredAt: Scalars["DateTime"]["output"];
  /** The repository the user made a commit in. */
  repository: Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for this contribution. */
  url: Scalars["URI"]["output"];
  /** The user who made this contribution. */
  user: User;
};

/** The connection type for CreatedCommitContribution. */
export type CreatedCommitContributionConnection = {
  __typename?: "CreatedCommitContributionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreatedCommitContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreatedCommitContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of commits across days and repositories in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CreatedCommitContributionEdge = {
  __typename?: "CreatedCommitContributionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CreatedCommitContribution>;
};

/** Represents the contribution a user made on GitHub by opening an issue. */
export type CreatedIssueContribution = Contribution & {
  __typename?: "CreatedIssueContribution";
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars["Boolean"]["output"];
  /** The issue that was opened. */
  issue: Issue;
  /** When this contribution was made. */
  occurredAt: Scalars["DateTime"]["output"];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for this contribution. */
  url: Scalars["URI"]["output"];
  /** The user who made this contribution. */
  user: User;
};

/** The connection type for CreatedIssueContribution. */
export type CreatedIssueContributionConnection = {
  __typename?: "CreatedIssueContributionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreatedIssueContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreatedIssueContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CreatedIssueContributionEdge = {
  __typename?: "CreatedIssueContributionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CreatedIssueContribution>;
};

/** Represents either a issue the viewer can access or a restricted contribution. */
export type CreatedIssueOrRestrictedContribution =
  | CreatedIssueContribution
  | RestrictedContribution;

/** Represents the contribution a user made on GitHub by opening a pull request. */
export type CreatedPullRequestContribution = Contribution & {
  __typename?: "CreatedPullRequestContribution";
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars["Boolean"]["output"];
  /** When this contribution was made. */
  occurredAt: Scalars["DateTime"]["output"];
  /** The pull request that was opened. */
  pullRequest: PullRequest;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for this contribution. */
  url: Scalars["URI"]["output"];
  /** The user who made this contribution. */
  user: User;
};

/** The connection type for CreatedPullRequestContribution. */
export type CreatedPullRequestContributionConnection = {
  __typename?: "CreatedPullRequestContributionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreatedPullRequestContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreatedPullRequestContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CreatedPullRequestContributionEdge = {
  __typename?: "CreatedPullRequestContributionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CreatedPullRequestContribution>;
};

/** Represents either a pull request the viewer can access or a restricted contribution. */
export type CreatedPullRequestOrRestrictedContribution =
  | CreatedPullRequestContribution
  | RestrictedContribution;

/** Represents the contribution a user made by leaving a review on a pull request. */
export type CreatedPullRequestReviewContribution = Contribution & {
  __typename?: "CreatedPullRequestReviewContribution";
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars["Boolean"]["output"];
  /** When this contribution was made. */
  occurredAt: Scalars["DateTime"]["output"];
  /** The pull request the user reviewed. */
  pullRequest: PullRequest;
  /** The review the user left on the pull request. */
  pullRequestReview: PullRequestReview;
  /** The repository containing the pull request that the user reviewed. */
  repository: Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for this contribution. */
  url: Scalars["URI"]["output"];
  /** The user who made this contribution. */
  user: User;
};

/** The connection type for CreatedPullRequestReviewContribution. */
export type CreatedPullRequestReviewContributionConnection = {
  __typename?: "CreatedPullRequestReviewContributionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreatedPullRequestReviewContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreatedPullRequestReviewContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CreatedPullRequestReviewContributionEdge = {
  __typename?: "CreatedPullRequestReviewContributionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CreatedPullRequestReviewContribution>;
};

/** Represents the contribution a user made on GitHub by creating a repository. */
export type CreatedRepositoryContribution = Contribution & {
  __typename?: "CreatedRepositoryContribution";
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars["Boolean"]["output"];
  /** When this contribution was made. */
  occurredAt: Scalars["DateTime"]["output"];
  /** The repository that was created. */
  repository: Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for this contribution. */
  url: Scalars["URI"]["output"];
  /** The user who made this contribution. */
  user: User;
};

/** The connection type for CreatedRepositoryContribution. */
export type CreatedRepositoryContributionConnection = {
  __typename?: "CreatedRepositoryContributionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreatedRepositoryContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreatedRepositoryContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CreatedRepositoryContributionEdge = {
  __typename?: "CreatedRepositoryContributionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CreatedRepositoryContribution>;
};

/** Represents either a repository the viewer can access or a restricted contribution. */
export type CreatedRepositoryOrRestrictedContribution =
  | CreatedRepositoryContribution
  | RestrictedContribution;

/** Represents a mention made by one issue or pull request to another. */
export type CrossReferencedEvent = Node &
  UniformResourceLocatable & {
    __typename?: "CrossReferencedEvent";
    /** Identifies the actor who performed the event. */
    actor?: Maybe<Actor>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The Node ID of the CrossReferencedEvent object */
    id: Scalars["ID"]["output"];
    /** Reference originated in a different repository. */
    isCrossRepository: Scalars["Boolean"]["output"];
    /** Identifies when the reference was made. */
    referencedAt: Scalars["DateTime"]["output"];
    /** The HTTP path for this pull request. */
    resourcePath: Scalars["URI"]["output"];
    /** Issue or pull request that made the reference. */
    source: ReferencedSubject;
    /** Issue or pull request to which the reference was made. */
    target: ReferencedSubject;
    /** The HTTP URL for this pull request. */
    url: Scalars["URI"]["output"];
    /** Checks if the target will be closed when the source is merged. */
    willCloseTarget: Scalars["Boolean"]["output"];
  };

/** Autogenerated input type of DeclineTopicSuggestion */
export type DeclineTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The name of the suggested topic.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `name` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The reason why the suggested topic is declined.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `reason` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  reason?: InputMaybe<TopicSuggestionDeclineReason>;
  /**
   * The Node ID of the repository.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `repositoryId` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of DeclineTopicSuggestion. */
export type DeclineTopicSuggestionPayload = {
  __typename?: "DeclineTopicSuggestionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /**
   * The declined topic.
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  topic?: Maybe<Topic>;
};

/** The possible base permissions for repositories. */
export enum DefaultRepositoryPermissionField {
  /** Can read, write, and administrate repos by default */
  Admin = "ADMIN",
  /** No access */
  None = "NONE",
  /** Can read repos by default */
  Read = "READ",
  /** Can read and write repos by default */
  Write = "WRITE",
}

/** Entities that can be deleted. */
export type Deletable = {
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars["Boolean"]["output"];
};

/** Autogenerated input type of DeleteBranchProtectionRule */
export type DeleteBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be deleted. */
  branchProtectionRuleId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of DeleteBranchProtectionRule. */
export type DeleteBranchProtectionRulePayload = {
  __typename?: "DeleteBranchProtectionRulePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of DeleteDeployment */
export type DeleteDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the deployment to be deleted. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteDeployment. */
export type DeleteDeploymentPayload = {
  __typename?: "DeleteDeploymentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of DeleteDiscussionComment */
export type DeleteDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node id of the discussion comment to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteDiscussionComment. */
export type DeleteDiscussionCommentPayload = {
  __typename?: "DeleteDiscussionCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The discussion comment that was just deleted. */
  comment?: Maybe<DiscussionComment>;
};

/** Autogenerated input type of DeleteDiscussion */
export type DeleteDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The id of the discussion to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteDiscussion. */
export type DeleteDiscussionPayload = {
  __typename?: "DeleteDiscussionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The discussion that was just deleted. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of DeleteEnvironment */
export type DeleteEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the environment to be deleted. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteEnvironment. */
export type DeleteEnvironmentPayload = {
  __typename?: "DeleteEnvironmentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of DeleteIpAllowListEntry */
export type DeleteIpAllowListEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the IP allow list entry to delete. */
  ipAllowListEntryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteIpAllowListEntry. */
export type DeleteIpAllowListEntryPayload = {
  __typename?: "DeleteIpAllowListEntryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The IP allow list entry that was deleted. */
  ipAllowListEntry?: Maybe<IpAllowListEntry>;
};

/** Autogenerated input type of DeleteIssueComment */
export type DeleteIssueCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the comment to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteIssueComment. */
export type DeleteIssueCommentPayload = {
  __typename?: "DeleteIssueCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of DeleteIssue */
export type DeleteIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the issue to delete. */
  issueId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteIssue. */
export type DeleteIssuePayload = {
  __typename?: "DeleteIssuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The repository the issue belonged to */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of DeleteLabel */
export type DeleteLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the label to be deleted. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteLabel. */
export type DeleteLabelPayload = {
  __typename?: "DeleteLabelPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of DeleteLinkedBranch */
export type DeleteLinkedBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the linked branch */
  linkedBranchId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteLinkedBranch. */
export type DeleteLinkedBranchPayload = {
  __typename?: "DeleteLinkedBranchPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The issue the linked branch was unlinked from. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of DeletePackageVersion */
export type DeletePackageVersionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the package version to be deleted. */
  packageVersionId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeletePackageVersion. */
export type DeletePackageVersionPayload = {
  __typename?: "DeletePackageVersionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the operation succeeded. */
  success?: Maybe<Scalars["Boolean"]["output"]>;
};

/** Autogenerated input type of DeleteProjectCard */
export type DeleteProjectCardInput = {
  /** The id of the card to delete. */
  cardId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of DeleteProjectCard. */
export type DeleteProjectCardPayload = {
  __typename?: "DeleteProjectCardPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The column the deleted card was in. */
  column?: Maybe<ProjectColumn>;
  /** The deleted card ID. */
  deletedCardId?: Maybe<Scalars["ID"]["output"]>;
};

/** Autogenerated input type of DeleteProjectColumn */
export type DeleteProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The id of the column to delete. */
  columnId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteProjectColumn. */
export type DeleteProjectColumnPayload = {
  __typename?: "DeleteProjectColumnPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The deleted column ID. */
  deletedColumnId?: Maybe<Scalars["ID"]["output"]>;
  /** The project the deleted column was in. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of DeleteProject */
export type DeleteProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Project ID to update. */
  projectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteProject. */
export type DeleteProjectPayload = {
  __typename?: "DeleteProjectPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The repository or organization the project was removed from. */
  owner?: Maybe<ProjectOwner>;
};

/** Autogenerated input type of DeleteProjectV2Field */
export type DeleteProjectV2FieldInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the field to delete. */
  fieldId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteProjectV2Field. */
export type DeleteProjectV2FieldPayload = {
  __typename?: "DeleteProjectV2FieldPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The deleted field. */
  projectV2Field?: Maybe<ProjectV2FieldConfiguration>;
};

/** Autogenerated input type of DeleteProjectV2 */
export type DeleteProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Project to delete. */
  projectId: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteProjectV2Item */
export type DeleteProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the item to be removed. */
  itemId: Scalars["ID"]["input"];
  /** The ID of the Project from which the item should be removed. */
  projectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteProjectV2Item. */
export type DeleteProjectV2ItemPayload = {
  __typename?: "DeleteProjectV2ItemPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the deleted item. */
  deletedItemId?: Maybe<Scalars["ID"]["output"]>;
};

/** Autogenerated return type of DeleteProjectV2. */
export type DeleteProjectV2Payload = {
  __typename?: "DeleteProjectV2Payload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The deleted Project. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of DeleteProjectV2StatusUpdate */
export type DeleteProjectV2StatusUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the status update to be removed. */
  statusUpdateId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteProjectV2StatusUpdate. */
export type DeleteProjectV2StatusUpdatePayload = {
  __typename?: "DeleteProjectV2StatusUpdatePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the deleted status update. */
  deletedStatusUpdateId?: Maybe<Scalars["ID"]["output"]>;
  /** The project the deleted status update was in. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of DeleteProjectV2Workflow */
export type DeleteProjectV2WorkflowInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the workflow to be removed. */
  workflowId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteProjectV2Workflow. */
export type DeleteProjectV2WorkflowPayload = {
  __typename?: "DeleteProjectV2WorkflowPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the deleted workflow. */
  deletedWorkflowId?: Maybe<Scalars["ID"]["output"]>;
  /** The project the deleted workflow was in. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of DeletePullRequestReviewComment */
export type DeletePullRequestReviewCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the comment to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeletePullRequestReviewComment. */
export type DeletePullRequestReviewCommentPayload = {
  __typename?: "DeletePullRequestReviewCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The pull request review the deleted comment belonged to. */
  pullRequestReview?: Maybe<PullRequestReview>;
  /** The deleted pull request review comment. */
  pullRequestReviewComment?: Maybe<PullRequestReviewComment>;
};

/** Autogenerated input type of DeletePullRequestReview */
export type DeletePullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the pull request review to delete. */
  pullRequestReviewId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeletePullRequestReview. */
export type DeletePullRequestReviewPayload = {
  __typename?: "DeletePullRequestReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The deleted pull request review. */
  pullRequestReview?: Maybe<PullRequestReview>;
};

/** Autogenerated input type of DeleteRef */
export type DeleteRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the Ref to be deleted. */
  refId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteRef. */
export type DeleteRefPayload = {
  __typename?: "DeleteRefPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of DeleteRepositoryRuleset */
export type DeleteRepositoryRulesetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The global relay id of the repository ruleset to be deleted. */
  repositoryRulesetId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteRepositoryRuleset. */
export type DeleteRepositoryRulesetPayload = {
  __typename?: "DeleteRepositoryRulesetPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of DeleteTeamDiscussionComment */
export type DeleteTeamDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the comment to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteTeamDiscussionComment. */
export type DeleteTeamDiscussionCommentPayload = {
  __typename?: "DeleteTeamDiscussionCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of DeleteTeamDiscussion */
export type DeleteTeamDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The discussion ID to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteTeamDiscussion. */
export type DeleteTeamDiscussionPayload = {
  __typename?: "DeleteTeamDiscussionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of DeleteUserList */
export type DeleteUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the list to delete. */
  listId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteUserList. */
export type DeleteUserListPayload = {
  __typename?: "DeleteUserListPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The owner of the list that will be deleted */
  user?: Maybe<User>;
};

/** Autogenerated input type of DeleteVerifiableDomain */
export type DeleteVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the verifiable domain to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeleteVerifiableDomain. */
export type DeleteVerifiableDomainPayload = {
  __typename?: "DeleteVerifiableDomainPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The owning account from which the domain was deleted. */
  owner?: Maybe<VerifiableDomainOwner>;
};

/** Represents a 'demilestoned' event on a given issue or pull request. */
export type DemilestonedEvent = Node & {
  __typename?: "DemilestonedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the DemilestonedEvent object */
  id: Scalars["ID"]["output"];
  /** Identifies the milestone title associated with the 'demilestoned' event. */
  milestoneTitle: Scalars["String"]["output"];
  /** Object referenced by event. */
  subject: MilestoneItem;
};

/** A Dependabot Update for a dependency in a repository */
export type DependabotUpdate = RepositoryNode & {
  __typename?: "DependabotUpdate";
  /** The error from a dependency update */
  error?: Maybe<DependabotUpdateError>;
  /** The associated pull request */
  pullRequest?: Maybe<PullRequest>;
  /** The repository associated with this node. */
  repository: Repository;
};

/** An error produced from a Dependabot Update */
export type DependabotUpdateError = {
  __typename?: "DependabotUpdateError";
  /** The body of the error */
  body: Scalars["String"]["output"];
  /** The error code */
  errorType: Scalars["String"]["output"];
  /** The title of the error */
  title: Scalars["String"]["output"];
};

/** A dependency manifest entry */
export type DependencyGraphDependency = {
  __typename?: "DependencyGraphDependency";
  /** Does the dependency itself have dependencies? */
  hasDependencies: Scalars["Boolean"]["output"];
  /**
   * The original name of the package, as it appears in the manifest.
   * @deprecated `packageLabel` will be removed. Use normalized `packageName` field instead. Removal on 2022-10-01 UTC.
   */
  packageLabel: Scalars["String"]["output"];
  /** The dependency package manager */
  packageManager?: Maybe<Scalars["String"]["output"]>;
  /** The name of the package in the canonical form used by the package manager. */
  packageName: Scalars["String"]["output"];
  /** The repository containing the package */
  repository?: Maybe<Repository>;
  /** The dependency version requirements */
  requirements: Scalars["String"]["output"];
};

/** The connection type for DependencyGraphDependency. */
export type DependencyGraphDependencyConnection = {
  __typename?: "DependencyGraphDependencyConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyGraphDependencyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyGraphDependency>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DependencyGraphDependencyEdge = {
  __typename?: "DependencyGraphDependencyEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyGraphDependency>;
};

/** The possible ecosystems of a dependency graph package. */
export enum DependencyGraphEcosystem {
  /** GitHub Actions */
  Actions = "ACTIONS",
  /** PHP packages hosted at packagist.org */
  Composer = "COMPOSER",
  /** Go modules */
  Go = "GO",
  /** Java artifacts hosted at the Maven central repository */
  Maven = "MAVEN",
  /** JavaScript packages hosted at npmjs.com */
  Npm = "NPM",
  /** .NET packages hosted at the NuGet Gallery */
  Nuget = "NUGET",
  /** Python packages hosted at PyPI.org */
  Pip = "PIP",
  /** Dart packages hosted at pub.dev */
  Pub = "PUB",
  /** Ruby gems hosted at RubyGems.org */
  Rubygems = "RUBYGEMS",
  /** Rust crates */
  Rust = "RUST",
  /** Swift packages */
  Swift = "SWIFT",
}

/** Dependency manifest for a repository */
export type DependencyGraphManifest = Node & {
  __typename?: "DependencyGraphManifest";
  /** Path to view the manifest file blob */
  blobPath: Scalars["String"]["output"];
  /** A list of manifest dependencies */
  dependencies?: Maybe<DependencyGraphDependencyConnection>;
  /** The number of dependencies listed in the manifest */
  dependenciesCount?: Maybe<Scalars["Int"]["output"]>;
  /** Is the manifest too big to parse? */
  exceedsMaxSize: Scalars["Boolean"]["output"];
  /** Fully qualified manifest filename */
  filename: Scalars["String"]["output"];
  /** The Node ID of the DependencyGraphManifest object */
  id: Scalars["ID"]["output"];
  /** Were we able to parse the manifest? */
  parseable: Scalars["Boolean"]["output"];
  /** The repository containing the manifest */
  repository: Repository;
};

/** Dependency manifest for a repository */
export type DependencyGraphManifestDependenciesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for DependencyGraphManifest. */
export type DependencyGraphManifestConnection = {
  __typename?: "DependencyGraphManifestConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyGraphManifestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyGraphManifest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DependencyGraphManifestEdge = {
  __typename?: "DependencyGraphManifestEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyGraphManifest>;
};

/** A repository deploy key. */
export type DeployKey = Node & {
  __typename?: "DeployKey";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the DeployKey object */
  id: Scalars["ID"]["output"];
  /** The deploy key. */
  key: Scalars["String"]["output"];
  /** Whether or not the deploy key is read only. */
  readOnly: Scalars["Boolean"]["output"];
  /** The deploy key title. */
  title: Scalars["String"]["output"];
  /** Whether or not the deploy key has been verified. */
  verified: Scalars["Boolean"]["output"];
};

/** The connection type for DeployKey. */
export type DeployKeyConnection = {
  __typename?: "DeployKeyConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeployKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DeployKey>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DeployKeyEdge = {
  __typename?: "DeployKeyEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DeployKey>;
};

/** Represents a 'deployed' event on a given pull request. */
export type DeployedEvent = Node & {
  __typename?: "DeployedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The deployment associated with the 'deployed' event. */
  deployment: Deployment;
  /** The Node ID of the DeployedEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** The ref associated with the 'deployed' event. */
  ref?: Maybe<Ref>;
};

/** Represents triggered deployment instance. */
export type Deployment = Node & {
  __typename?: "Deployment";
  /** Identifies the commit sha of the deployment. */
  commit?: Maybe<Commit>;
  /** Identifies the oid of the deployment commit, even if the commit has been deleted. */
  commitOid: Scalars["String"]["output"];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the actor who triggered the deployment. */
  creator: Actor;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The deployment description. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The latest environment to which this deployment was made. */
  environment?: Maybe<Scalars["String"]["output"]>;
  /** The Node ID of the Deployment object */
  id: Scalars["ID"]["output"];
  /** The latest environment to which this deployment was made. */
  latestEnvironment?: Maybe<Scalars["String"]["output"]>;
  /** The latest status of this deployment. */
  latestStatus?: Maybe<DeploymentStatus>;
  /** The original environment to which this deployment was made. */
  originalEnvironment?: Maybe<Scalars["String"]["output"]>;
  /** Extra information that a deployment system might need. */
  payload?: Maybe<Scalars["String"]["output"]>;
  /** Identifies the Ref of the deployment, if the deployment was created by ref. */
  ref?: Maybe<Ref>;
  /** Identifies the repository associated with the deployment. */
  repository: Repository;
  /** The current state of the deployment. */
  state?: Maybe<DeploymentState>;
  /** A list of statuses associated with the deployment. */
  statuses?: Maybe<DeploymentStatusConnection>;
  /** The deployment task. */
  task?: Maybe<Scalars["String"]["output"]>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** Represents triggered deployment instance. */
export type DeploymentStatusesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for Deployment. */
export type DeploymentConnection = {
  __typename?: "DeploymentConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Deployment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DeploymentEdge = {
  __typename?: "DeploymentEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Deployment>;
};

/** Represents a 'deployment_environment_changed' event on a given pull request. */
export type DeploymentEnvironmentChangedEvent = Node & {
  __typename?: "DeploymentEnvironmentChangedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The deployment status that updated the deployment environment. */
  deploymentStatus: DeploymentStatus;
  /** The Node ID of the DeploymentEnvironmentChangedEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Ordering options for deployment connections */
export type DeploymentOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order deployments by. */
  field: DeploymentOrderField;
};

/** Properties by which deployment connections can be ordered. */
export enum DeploymentOrderField {
  /** Order collection by creation time */
  CreatedAt = "CREATED_AT",
}

/** A protection rule. */
export type DeploymentProtectionRule = {
  __typename?: "DeploymentProtectionRule";
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** Whether deployments to this environment can be approved by the user who created the deployment. */
  preventSelfReview?: Maybe<Scalars["Boolean"]["output"]>;
  /** The teams or users that can review the deployment */
  reviewers: DeploymentReviewerConnection;
  /** The timeout in minutes for this protection rule. */
  timeout: Scalars["Int"]["output"];
  /** The type of protection rule. */
  type: DeploymentProtectionRuleType;
};

/** A protection rule. */
export type DeploymentProtectionRuleReviewersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for DeploymentProtectionRule. */
export type DeploymentProtectionRuleConnection = {
  __typename?: "DeploymentProtectionRuleConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentProtectionRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DeploymentProtectionRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DeploymentProtectionRuleEdge = {
  __typename?: "DeploymentProtectionRuleEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DeploymentProtectionRule>;
};

/** The possible protection rule types. */
export enum DeploymentProtectionRuleType {
  /** Branch policy */
  BranchPolicy = "BRANCH_POLICY",
  /** Required reviewers */
  RequiredReviewers = "REQUIRED_REVIEWERS",
  /** Wait timer */
  WaitTimer = "WAIT_TIMER",
}

/** A request to deploy a workflow run to an environment. */
export type DeploymentRequest = {
  __typename?: "DeploymentRequest";
  /** Whether or not the current user can approve the deployment */
  currentUserCanApprove: Scalars["Boolean"]["output"];
  /** The target environment of the deployment */
  environment: Environment;
  /** The teams or users that can review the deployment */
  reviewers: DeploymentReviewerConnection;
  /** The wait timer in minutes configured in the environment */
  waitTimer: Scalars["Int"]["output"];
  /** The wait timer in minutes configured in the environment */
  waitTimerStartedAt?: Maybe<Scalars["DateTime"]["output"]>;
};

/** A request to deploy a workflow run to an environment. */
export type DeploymentRequestReviewersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for DeploymentRequest. */
export type DeploymentRequestConnection = {
  __typename?: "DeploymentRequestConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DeploymentRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DeploymentRequestEdge = {
  __typename?: "DeploymentRequestEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DeploymentRequest>;
};

/** A deployment review. */
export type DeploymentReview = Node & {
  __typename?: "DeploymentReview";
  /** The comment the user left. */
  comment: Scalars["String"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The environments approved or rejected */
  environments: EnvironmentConnection;
  /** The Node ID of the DeploymentReview object */
  id: Scalars["ID"]["output"];
  /** The decision of the user. */
  state: DeploymentReviewState;
  /** The user that reviewed the deployment. */
  user: User;
};

/** A deployment review. */
export type DeploymentReviewEnvironmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for DeploymentReview. */
export type DeploymentReviewConnection = {
  __typename?: "DeploymentReviewConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentReviewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DeploymentReview>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DeploymentReviewEdge = {
  __typename?: "DeploymentReviewEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DeploymentReview>;
};

/** The possible states for a deployment review. */
export enum DeploymentReviewState {
  /** The deployment was approved. */
  Approved = "APPROVED",
  /** The deployment was rejected. */
  Rejected = "REJECTED",
}

/** Users and teams. */
export type DeploymentReviewer = Team | User;

/** The connection type for DeploymentReviewer. */
export type DeploymentReviewerConnection = {
  __typename?: "DeploymentReviewerConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentReviewerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DeploymentReviewer>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DeploymentReviewerEdge = {
  __typename?: "DeploymentReviewerEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DeploymentReviewer>;
};

/** The possible states in which a deployment can be. */
export enum DeploymentState {
  /** The pending deployment was not updated after 30 minutes. */
  Abandoned = "ABANDONED",
  /** The deployment is currently active. */
  Active = "ACTIVE",
  /** An inactive transient deployment. */
  Destroyed = "DESTROYED",
  /** The deployment experienced an error. */
  Error = "ERROR",
  /** The deployment has failed. */
  Failure = "FAILURE",
  /** The deployment is inactive. */
  Inactive = "INACTIVE",
  /** The deployment is in progress. */
  InProgress = "IN_PROGRESS",
  /** The deployment is pending. */
  Pending = "PENDING",
  /** The deployment has queued */
  Queued = "QUEUED",
  /** The deployment was successful. */
  Success = "SUCCESS",
  /** The deployment is waiting. */
  Waiting = "WAITING",
}

/** Describes the status of a given deployment attempt. */
export type DeploymentStatus = Node & {
  __typename?: "DeploymentStatus";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the actor who triggered the deployment. */
  creator: Actor;
  /** Identifies the deployment associated with status. */
  deployment: Deployment;
  /** Identifies the description of the deployment. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** Identifies the environment of the deployment at the time of this deployment status */
  environment?: Maybe<Scalars["String"]["output"]>;
  /** Identifies the environment URL of the deployment. */
  environmentUrl?: Maybe<Scalars["URI"]["output"]>;
  /** The Node ID of the DeploymentStatus object */
  id: Scalars["ID"]["output"];
  /** Identifies the log URL of the deployment. */
  logUrl?: Maybe<Scalars["URI"]["output"]>;
  /** Identifies the current state of the deployment. */
  state: DeploymentStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** The connection type for DeploymentStatus. */
export type DeploymentStatusConnection = {
  __typename?: "DeploymentStatusConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DeploymentStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DeploymentStatusEdge = {
  __typename?: "DeploymentStatusEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DeploymentStatus>;
};

/** The possible states for a deployment status. */
export enum DeploymentStatusState {
  /** The deployment experienced an error. */
  Error = "ERROR",
  /** The deployment has failed. */
  Failure = "FAILURE",
  /** The deployment is inactive. */
  Inactive = "INACTIVE",
  /** The deployment is in progress. */
  InProgress = "IN_PROGRESS",
  /** The deployment is pending. */
  Pending = "PENDING",
  /** The deployment is queued */
  Queued = "QUEUED",
  /** The deployment was successful. */
  Success = "SUCCESS",
  /** The deployment is waiting. */
  Waiting = "WAITING",
}

/** Autogenerated input type of DequeuePullRequest */
export type DequeuePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the pull request to be dequeued. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of DequeuePullRequest. */
export type DequeuePullRequestPayload = {
  __typename?: "DequeuePullRequestPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The merge queue entry of the dequeued pull request. */
  mergeQueueEntry?: Maybe<MergeQueueEntry>;
};

/** The possible sides of a diff. */
export enum DiffSide {
  /** The left side of the diff. */
  Left = "LEFT",
  /** The right side of the diff. */
  Right = "RIGHT",
}

/** Autogenerated input type of DisablePullRequestAutoMerge */
export type DisablePullRequestAutoMergeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the pull request to disable auto merge on. */
  pullRequestId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DisablePullRequestAutoMerge. */
export type DisablePullRequestAutoMergePayload = {
  __typename?: "DisablePullRequestAutoMergePayload";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The pull request auto merge was disabled on. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'disconnected' event on a given issue or pull request. */
export type DisconnectedEvent = Node & {
  __typename?: "DisconnectedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the DisconnectedEvent object */
  id: Scalars["ID"]["output"];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars["Boolean"]["output"];
  /** Issue or pull request from which the issue was disconnected. */
  source: ReferencedSubject;
  /** Issue or pull request which was disconnected. */
  subject: ReferencedSubject;
};

/** A discussion in a repository. */
export type Discussion = Closable &
  Comment &
  Deletable &
  Labelable &
  Lockable &
  Node &
  Reactable &
  RepositoryNode &
  Subscribable &
  Updatable &
  Votable & {
    __typename?: "Discussion";
    /** Reason that the conversation was locked. */
    activeLockReason?: Maybe<LockReason>;
    /** The comment chosen as this discussion's answer, if any. */
    answer?: Maybe<DiscussionComment>;
    /** The time when a user chose this discussion's answer, if answered. */
    answerChosenAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The user who chose this discussion's answer, if answered. */
    answerChosenBy?: Maybe<Actor>;
    /** The actor who authored the comment. */
    author?: Maybe<Actor>;
    /** Author's association with the subject of the comment. */
    authorAssociation: CommentAuthorAssociation;
    /** The main text of the discussion post. */
    body: Scalars["String"]["output"];
    /** The body rendered to HTML. */
    bodyHTML: Scalars["HTML"]["output"];
    /** The body rendered to text. */
    bodyText: Scalars["String"]["output"];
    /** The category for this discussion. */
    category: DiscussionCategory;
    /** Indicates if the object is closed (definition of closed may depend on type) */
    closed: Scalars["Boolean"]["output"];
    /** Identifies the date and time when the object was closed. */
    closedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The replies to the discussion. */
    comments: DiscussionCommentConnection;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail: Scalars["Boolean"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The actor who edited the comment. */
    editor?: Maybe<Actor>;
    /** The Node ID of the Discussion object */
    id: Scalars["ID"]["output"];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit: Scalars["Boolean"]["output"];
    /** Only return answered/unanswered discussions */
    isAnswered?: Maybe<Scalars["Boolean"]["output"]>;
    /** A list of labels associated with the object. */
    labels?: Maybe<LabelConnection>;
    /** The moment the editor made the last edit */
    lastEditedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** `true` if the object is locked */
    locked: Scalars["Boolean"]["output"];
    /** The number identifying this discussion within the repository. */
    number: Scalars["Int"]["output"];
    /** The poll associated with this discussion, if one exists. */
    poll?: Maybe<DiscussionPoll>;
    /** Identifies when the comment was published at. */
    publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: Maybe<Array<ReactionGroup>>;
    /** A list of Reactions left on the Issue. */
    reactions: ReactionConnection;
    /** The repository associated with this node. */
    repository: Repository;
    /** The path for this discussion. */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the reason for the discussion's state. */
    stateReason?: Maybe<DiscussionStateReason>;
    /** The title of this discussion. */
    title: Scalars["String"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** Number of upvotes that this subject has received. */
    upvoteCount: Scalars["Int"]["output"];
    /** The URL for this discussion. */
    url: Scalars["URI"]["output"];
    /** A list of edits to this content. */
    userContentEdits?: Maybe<UserContentEditConnection>;
    /** Indicates if the object can be closed by the viewer. */
    viewerCanClose: Scalars["Boolean"]["output"];
    /** Check if the current viewer can delete this object. */
    viewerCanDelete: Scalars["Boolean"]["output"];
    /** Indicates if the viewer can edit labels for this object. */
    viewerCanLabel: Scalars["Boolean"]["output"];
    /** Can user react to this subject */
    viewerCanReact: Scalars["Boolean"]["output"];
    /** Indicates if the object can be reopened by the viewer. */
    viewerCanReopen: Scalars["Boolean"]["output"];
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
    /** Whether or not the current user can add or remove an upvote on this subject. */
    viewerCanUpvote: Scalars["Boolean"]["output"];
    /** Did the viewer author this comment. */
    viewerDidAuthor: Scalars["Boolean"]["output"];
    /** Whether or not the current user has already upvoted this subject. */
    viewerHasUpvoted: Scalars["Boolean"]["output"];
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: Maybe<SubscriptionState>;
  };

/** A discussion in a repository. */
export type DiscussionCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A discussion in a repository. */
export type DiscussionLabelsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<LabelOrder>;
};

/** A discussion in a repository. */
export type DiscussionReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** A discussion in a repository. */
export type DiscussionUserContentEditsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A category for discussions in a repository. */
export type DiscussionCategory = Node &
  RepositoryNode & {
    __typename?: "DiscussionCategory";
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** A description of this category. */
    description?: Maybe<Scalars["String"]["output"]>;
    /** An emoji representing this category. */
    emoji: Scalars["String"]["output"];
    /** This category's emoji rendered as HTML. */
    emojiHTML: Scalars["HTML"]["output"];
    /** The Node ID of the DiscussionCategory object */
    id: Scalars["ID"]["output"];
    /** Whether or not discussions in this category support choosing an answer with the markDiscussionCommentAsAnswer mutation. */
    isAnswerable: Scalars["Boolean"]["output"];
    /** The name of this category. */
    name: Scalars["String"]["output"];
    /** The repository associated with this node. */
    repository: Repository;
    /** The slug of this category. */
    slug: Scalars["String"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
  };

/** The connection type for DiscussionCategory. */
export type DiscussionCategoryConnection = {
  __typename?: "DiscussionCategoryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscussionCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DiscussionCategoryEdge = {
  __typename?: "DiscussionCategoryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DiscussionCategory>;
};

/** The possible reasons for closing a discussion. */
export enum DiscussionCloseReason {
  /** The discussion is a duplicate of another */
  Duplicate = "DUPLICATE",
  /** The discussion is no longer relevant */
  Outdated = "OUTDATED",
  /** The discussion has been resolved */
  Resolved = "RESOLVED",
}

/** A comment on a discussion. */
export type DiscussionComment = Comment &
  Deletable &
  Minimizable &
  Node &
  Reactable &
  Updatable &
  UpdatableComment &
  Votable & {
    __typename?: "DiscussionComment";
    /** The actor who authored the comment. */
    author?: Maybe<Actor>;
    /** Author's association with the subject of the comment. */
    authorAssociation: CommentAuthorAssociation;
    /** The body as Markdown. */
    body: Scalars["String"]["output"];
    /** The body rendered to HTML. */
    bodyHTML: Scalars["HTML"]["output"];
    /** The body rendered to text. */
    bodyText: Scalars["String"]["output"];
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail: Scalars["Boolean"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The time when this replied-to comment was deleted */
    deletedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The discussion this comment was created in */
    discussion?: Maybe<Discussion>;
    /** The actor who edited the comment. */
    editor?: Maybe<Actor>;
    /** The Node ID of the DiscussionComment object */
    id: Scalars["ID"]["output"];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit: Scalars["Boolean"]["output"];
    /** Has this comment been chosen as the answer of its discussion? */
    isAnswer: Scalars["Boolean"]["output"];
    /** Returns whether or not a comment has been minimized. */
    isMinimized: Scalars["Boolean"]["output"];
    /** The moment the editor made the last edit */
    lastEditedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /**
     * Returns why the comment was minimized. One of `abuse`, `off-topic`,
     * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
     * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
     */
    minimizedReason?: Maybe<Scalars["String"]["output"]>;
    /** Identifies when the comment was published at. */
    publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: Maybe<Array<ReactionGroup>>;
    /** A list of Reactions left on the Issue. */
    reactions: ReactionConnection;
    /** The threaded replies to this comment. */
    replies: DiscussionCommentConnection;
    /** The discussion comment this comment is a reply to */
    replyTo?: Maybe<DiscussionComment>;
    /** The path for this discussion comment. */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** Number of upvotes that this subject has received. */
    upvoteCount: Scalars["Int"]["output"];
    /** The URL for this discussion comment. */
    url: Scalars["URI"]["output"];
    /** A list of edits to this content. */
    userContentEdits?: Maybe<UserContentEditConnection>;
    /** Check if the current viewer can delete this object. */
    viewerCanDelete: Scalars["Boolean"]["output"];
    /** Can the current user mark this comment as an answer? */
    viewerCanMarkAsAnswer: Scalars["Boolean"]["output"];
    /** Check if the current viewer can minimize this object. */
    viewerCanMinimize: Scalars["Boolean"]["output"];
    /** Can user react to this subject */
    viewerCanReact: Scalars["Boolean"]["output"];
    /** Can the current user unmark this comment as an answer? */
    viewerCanUnmarkAsAnswer: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
    /** Whether or not the current user can add or remove an upvote on this subject. */
    viewerCanUpvote: Scalars["Boolean"]["output"];
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
    /** Did the viewer author this comment. */
    viewerDidAuthor: Scalars["Boolean"]["output"];
    /** Whether or not the current user has already upvoted this subject. */
    viewerHasUpvoted: Scalars["Boolean"]["output"];
  };

/** A comment on a discussion. */
export type DiscussionCommentReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** A comment on a discussion. */
export type DiscussionCommentRepliesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A comment on a discussion. */
export type DiscussionCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for DiscussionComment. */
export type DiscussionCommentConnection = {
  __typename?: "DiscussionCommentConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscussionComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DiscussionCommentEdge = {
  __typename?: "DiscussionCommentEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DiscussionComment>;
};

/** The connection type for Discussion. */
export type DiscussionConnection = {
  __typename?: "DiscussionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Discussion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DiscussionEdge = {
  __typename?: "DiscussionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Discussion>;
};

/** Ways in which lists of discussions can be ordered upon return. */
export type DiscussionOrder = {
  /** The direction in which to order discussions by the specified field. */
  direction: OrderDirection;
  /** The field by which to order discussions. */
  field: DiscussionOrderField;
};

/** Properties by which discussion connections can be ordered. */
export enum DiscussionOrderField {
  /** Order discussions by creation time. */
  CreatedAt = "CREATED_AT",
  /** Order discussions by most recent modification time. */
  UpdatedAt = "UPDATED_AT",
}

/** A poll for a discussion. */
export type DiscussionPoll = Node & {
  __typename?: "DiscussionPoll";
  /** The discussion that this poll belongs to. */
  discussion?: Maybe<Discussion>;
  /** The Node ID of the DiscussionPoll object */
  id: Scalars["ID"]["output"];
  /** The options for this poll. */
  options?: Maybe<DiscussionPollOptionConnection>;
  /** The question that is being asked by this poll. */
  question: Scalars["String"]["output"];
  /** The total number of votes that have been cast for this poll. */
  totalVoteCount: Scalars["Int"]["output"];
  /** Indicates if the viewer has permission to vote in this poll. */
  viewerCanVote: Scalars["Boolean"]["output"];
  /** Indicates if the viewer has voted for any option in this poll. */
  viewerHasVoted: Scalars["Boolean"]["output"];
};

/** A poll for a discussion. */
export type DiscussionPollOptionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<DiscussionPollOptionOrder>;
};

/** An option for a discussion poll. */
export type DiscussionPollOption = Node & {
  __typename?: "DiscussionPollOption";
  /** The Node ID of the DiscussionPollOption object */
  id: Scalars["ID"]["output"];
  /** The text for this option. */
  option: Scalars["String"]["output"];
  /** The discussion poll that this option belongs to. */
  poll?: Maybe<DiscussionPoll>;
  /** The total number of votes that have been cast for this option. */
  totalVoteCount: Scalars["Int"]["output"];
  /** Indicates if the viewer has voted for this option in the poll. */
  viewerHasVoted: Scalars["Boolean"]["output"];
};

/** The connection type for DiscussionPollOption. */
export type DiscussionPollOptionConnection = {
  __typename?: "DiscussionPollOptionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionPollOptionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscussionPollOption>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DiscussionPollOptionEdge = {
  __typename?: "DiscussionPollOptionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DiscussionPollOption>;
};

/** Ordering options for discussion poll option connections. */
export type DiscussionPollOptionOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order poll options by. */
  field: DiscussionPollOptionOrderField;
};

/** Properties by which discussion poll option connections can be ordered. */
export enum DiscussionPollOptionOrderField {
  /** Order poll options by the order that the poll author specified when creating the poll. */
  AuthoredOrder = "AUTHORED_ORDER",
  /** Order poll options by the number of votes it has. */
  VoteCount = "VOTE_COUNT",
}

/** The possible states of a discussion. */
export enum DiscussionState {
  /** A discussion that has been closed */
  Closed = "CLOSED",
  /** A discussion that is open */
  Open = "OPEN",
}

/** The possible state reasons of a discussion. */
export enum DiscussionStateReason {
  /** The discussion is a duplicate of another */
  Duplicate = "DUPLICATE",
  /** The discussion is no longer relevant */
  Outdated = "OUTDATED",
  /** The discussion was reopened */
  Reopened = "REOPENED",
  /** The discussion has been resolved */
  Resolved = "RESOLVED",
}

/** Autogenerated input type of DismissPullRequestReview */
export type DismissPullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The contents of the pull request review dismissal message. */
  message: Scalars["String"]["input"];
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DismissPullRequestReview. */
export type DismissPullRequestReviewPayload = {
  __typename?: "DismissPullRequestReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The dismissed pull request review. */
  pullRequestReview?: Maybe<PullRequestReview>;
};

/** The possible reasons that a Dependabot alert was dismissed. */
export enum DismissReason {
  /** A fix has already been started */
  FixStarted = "FIX_STARTED",
  /** This alert is inaccurate or incorrect */
  Inaccurate = "INACCURATE",
  /** Vulnerable code is not actually used */
  NotUsed = "NOT_USED",
  /** No bandwidth to fix this */
  NoBandwidth = "NO_BANDWIDTH",
  /** Risk is tolerable to this project */
  TolerableRisk = "TOLERABLE_RISK",
}

/** Autogenerated input type of DismissRepositoryVulnerabilityAlert */
export type DismissRepositoryVulnerabilityAlertInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The reason the Dependabot alert is being dismissed. */
  dismissReason: DismissReason;
  /** The Dependabot alert ID to dismiss. */
  repositoryVulnerabilityAlertId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DismissRepositoryVulnerabilityAlert. */
export type DismissRepositoryVulnerabilityAlertPayload = {
  __typename?: "DismissRepositoryVulnerabilityAlertPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The Dependabot alert that was dismissed */
  repositoryVulnerabilityAlert?: Maybe<RepositoryVulnerabilityAlert>;
};

/** A draft issue within a project. */
export type DraftIssue = Node & {
  __typename?: "DraftIssue";
  /** A list of users to assigned to this draft issue. */
  assignees: UserConnection;
  /** The body of the draft issue. */
  body: Scalars["String"]["output"];
  /** The body of the draft issue rendered to HTML. */
  bodyHTML: Scalars["HTML"]["output"];
  /** The body of the draft issue rendered to text. */
  bodyText: Scalars["String"]["output"];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The actor who created this draft issue. */
  creator?: Maybe<Actor>;
  /** The Node ID of the DraftIssue object */
  id: Scalars["ID"]["output"];
  /** List of items linked with the draft issue (currently draft issue can be linked to only one item). */
  projectV2Items: ProjectV2ItemConnection;
  /** Projects that link to this draft issue (currently draft issue can be linked to only one project). */
  projectsV2: ProjectV2Connection;
  /** The title of the draft issue */
  title: Scalars["String"]["output"];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** A draft issue within a project. */
export type DraftIssueAssigneesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A draft issue within a project. */
export type DraftIssueProjectV2ItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A draft issue within a project. */
export type DraftIssueProjectsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Specifies a review comment to be left with a Pull Request Review. */
export type DraftPullRequestReviewComment = {
  /** Body of the comment to leave. */
  body: Scalars["String"]["input"];
  /** Path to the file being commented on. */
  path: Scalars["String"]["input"];
  /** Position in the file to leave a comment on. */
  position: Scalars["Int"]["input"];
};

/** Specifies a review comment thread to be left with a Pull Request Review. */
export type DraftPullRequestReviewThread = {
  /** Body of the comment to leave. */
  body: Scalars["String"]["input"];
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  line: Scalars["Int"]["input"];
  /** Path to the file being commented on. */
  path: Scalars["String"]["input"];
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: InputMaybe<DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: InputMaybe<Scalars["Int"]["input"]>;
  /** The side of the diff on which the start line resides. */
  startSide?: InputMaybe<DiffSide>;
};

/** Autogenerated input type of EnablePullRequestAutoMerge */
export type EnablePullRequestAutoMergeInput = {
  /** The email address to associate with this merge. */
  authorEmail?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * Commit body to use for the commit when the PR is mergable; if omitted, a
   * default message will be used. NOTE: when merging with a merge queue any input
   * value for commit message is ignored.
   */
  commitBody?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * Commit headline to use for the commit when the PR is mergable; if omitted, a
   * default message will be used. NOTE: when merging with a merge queue any input
   * value for commit headline is ignored.
   */
  commitHeadline?: InputMaybe<Scalars["String"]["input"]>;
  /** The expected head OID of the pull request. */
  expectedHeadOid?: InputMaybe<Scalars["GitObjectID"]["input"]>;
  /**
   * The merge method to use. If omitted, defaults to `MERGE`. NOTE: when merging
   * with a merge queue any input value for merge method is ignored.
   */
  mergeMethod?: InputMaybe<PullRequestMergeMethod>;
  /** ID of the pull request to enable auto-merge on. */
  pullRequestId: Scalars["ID"]["input"];
};

/** Autogenerated return type of EnablePullRequestAutoMerge. */
export type EnablePullRequestAutoMergePayload = {
  __typename?: "EnablePullRequestAutoMergePayload";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The pull request auto-merge was enabled on. */
  pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of EnqueuePullRequest */
export type EnqueuePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The expected head OID of the pull request. */
  expectedHeadOid?: InputMaybe<Scalars["GitObjectID"]["input"]>;
  /** Add the pull request to the front of the queue. */
  jump?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the pull request to enqueue. */
  pullRequestId: Scalars["ID"]["input"];
};

/** Autogenerated return type of EnqueuePullRequest. */
export type EnqueuePullRequestPayload = {
  __typename?: "EnqueuePullRequestPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The merge queue entry for the enqueued pull request. */
  mergeQueueEntry?: Maybe<MergeQueueEntry>;
};

/** An account to manage multiple organizations with consolidated policy and billing. */
export type Enterprise = AnnouncementBanner &
  Node & {
    __typename?: "Enterprise";
    /** The text of the announcement */
    announcement?: Maybe<Scalars["String"]["output"]>;
    /** The date the announcement was created */
    announcementCreatedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The expiration date of the announcement, if any */
    announcementExpiresAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** Whether the announcement can be dismissed by the user */
    announcementUserDismissible?: Maybe<Scalars["Boolean"]["output"]>;
    /** A URL pointing to the enterprise's public avatar. */
    avatarUrl: Scalars["URI"]["output"];
    /** The enterprise's billing email. */
    billingEmail?: Maybe<Scalars["String"]["output"]>;
    /** Enterprise billing information visible to enterprise billing managers. */
    billingInfo?: Maybe<EnterpriseBillingInfo>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The description of the enterprise. */
    description?: Maybe<Scalars["String"]["output"]>;
    /** The description of the enterprise as HTML. */
    descriptionHTML: Scalars["HTML"]["output"];
    /** The Node ID of the Enterprise object */
    id: Scalars["ID"]["output"];
    /** The location of the enterprise. */
    location?: Maybe<Scalars["String"]["output"]>;
    /** A list of users who are members of this enterprise. */
    members: EnterpriseMemberConnection;
    /** The name of the enterprise. */
    name: Scalars["String"]["output"];
    /** A list of organizations that belong to this enterprise. */
    organizations: OrganizationConnection;
    /**
     * Enterprise information visible to enterprise owners or enterprise owners'
     * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
     */
    ownerInfo?: Maybe<EnterpriseOwnerInfo>;
    /** The raw content of the enterprise README. */
    readme?: Maybe<Scalars["String"]["output"]>;
    /** The content of the enterprise README as HTML. */
    readmeHTML: Scalars["HTML"]["output"];
    /** The HTTP path for this enterprise. */
    resourcePath: Scalars["URI"]["output"];
    /** The URL-friendly identifier for the enterprise. */
    slug: Scalars["String"]["output"];
    /** The HTTP URL for this enterprise. */
    url: Scalars["URI"]["output"];
    /** Is the current viewer an admin of this enterprise? */
    viewerIsAdmin: Scalars["Boolean"]["output"];
    /** The URL of the enterprise website. */
    websiteUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** An account to manage multiple organizations with consolidated policy and billing. */
export type EnterpriseAvatarUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An account to manage multiple organizations with consolidated policy and billing. */
export type EnterpriseMembersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  deployment?: InputMaybe<EnterpriseUserDeployment>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  hasTwoFactorEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars["String"]["input"]>>;
  query?: InputMaybe<Scalars["String"]["input"]>;
  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;
};

/** An account to manage multiple organizations with consolidated policy and billing. */
export type EnterpriseOrganizationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<OrganizationOrder>;
  query?: InputMaybe<Scalars["String"]["input"]>;
  viewerOrganizationRole?: InputMaybe<RoleInOrganization>;
};

/** The connection type for User. */
export type EnterpriseAdministratorConnection = {
  __typename?: "EnterpriseAdministratorConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseAdministratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** A User who is an administrator of an enterprise. */
export type EnterpriseAdministratorEdge = {
  __typename?: "EnterpriseAdministratorEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
  /** The role of the administrator. */
  role: EnterpriseAdministratorRole;
};

/** An invitation for a user to become an owner or billing manager of an enterprise. */
export type EnterpriseAdministratorInvitation = Node & {
  __typename?: "EnterpriseAdministratorInvitation";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The email of the person who was invited to the enterprise. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise the invitation is for. */
  enterprise: Enterprise;
  /** The Node ID of the EnterpriseAdministratorInvitation object */
  id: Scalars["ID"]["output"];
  /** The user who was invited to the enterprise. */
  invitee?: Maybe<User>;
  /** The user who created the invitation. */
  inviter?: Maybe<User>;
  /** The invitee's pending role in the enterprise (owner or billing_manager). */
  role: EnterpriseAdministratorRole;
};

/** The connection type for EnterpriseAdministratorInvitation. */
export type EnterpriseAdministratorInvitationConnection = {
  __typename?: "EnterpriseAdministratorInvitationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseAdministratorInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseAdministratorInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type EnterpriseAdministratorInvitationEdge = {
  __typename?: "EnterpriseAdministratorInvitationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseAdministratorInvitation>;
};

/** Ordering options for enterprise administrator invitation connections */
export type EnterpriseAdministratorInvitationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise administrator invitations by. */
  field: EnterpriseAdministratorInvitationOrderField;
};

/** Properties by which enterprise administrator invitation connections can be ordered. */
export enum EnterpriseAdministratorInvitationOrderField {
  /** Order enterprise administrator member invitations by creation time */
  CreatedAt = "CREATED_AT",
}

/** The possible administrator roles in an enterprise account. */
export enum EnterpriseAdministratorRole {
  /** Represents a billing manager of the enterprise account. */
  BillingManager = "BILLING_MANAGER",
  /** Represents an owner of the enterprise account. */
  Owner = "OWNER",
}

/** The possible values for the enterprise allow private repository forking policy value. */
export enum EnterpriseAllowPrivateRepositoryForkingPolicyValue {
  /** Members can fork a repository to an organization within this enterprise. */
  EnterpriseOrganizations = "ENTERPRISE_ORGANIZATIONS",
  /** Members can fork a repository to their enterprise-managed user account or an organization inside this enterprise. */
  EnterpriseOrganizationsUserAccounts = "ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS",
  /** Members can fork a repository to their user account or an organization, either inside or outside of this enterprise. */
  Everywhere = "EVERYWHERE",
  /** Members can fork a repository only within the same organization (intra-org). */
  SameOrganization = "SAME_ORGANIZATION",
  /** Members can fork a repository to their user account or within the same organization. */
  SameOrganizationUserAccounts = "SAME_ORGANIZATION_USER_ACCOUNTS",
  /** Members can fork a repository to their user account. */
  UserAccounts = "USER_ACCOUNTS",
}

/** Metadata for an audit entry containing enterprise account information. */
export type EnterpriseAuditEntryData = {
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars["URI"]["output"]>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars["String"]["output"]>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars["URI"]["output"]>;
};

/** Enterprise billing information visible to enterprise billing managers and owners. */
export type EnterpriseBillingInfo = {
  __typename?: "EnterpriseBillingInfo";
  /** The number of licenseable users/emails across the enterprise. */
  allLicensableUsersCount: Scalars["Int"]["output"];
  /** The number of data packs used by all organizations owned by the enterprise. */
  assetPacks: Scalars["Int"]["output"];
  /** The bandwidth quota in GB for all organizations owned by the enterprise. */
  bandwidthQuota: Scalars["Float"]["output"];
  /** The bandwidth usage in GB for all organizations owned by the enterprise. */
  bandwidthUsage: Scalars["Float"]["output"];
  /** The bandwidth usage as a percentage of the bandwidth quota. */
  bandwidthUsagePercentage: Scalars["Int"]["output"];
  /** The storage quota in GB for all organizations owned by the enterprise. */
  storageQuota: Scalars["Float"]["output"];
  /** The storage usage in GB for all organizations owned by the enterprise. */
  storageUsage: Scalars["Float"]["output"];
  /** The storage usage as a percentage of the storage quota. */
  storageUsagePercentage: Scalars["Int"]["output"];
  /** The number of available licenses across all owned organizations based on the unique number of billable users. */
  totalAvailableLicenses: Scalars["Int"]["output"];
  /** The total number of licenses allocated. */
  totalLicenses: Scalars["Int"]["output"];
};

/** The connection type for Enterprise. */
export type EnterpriseConnection = {
  __typename?: "EnterpriseConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Enterprise>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** The possible values for the enterprise base repository permission setting. */
export enum EnterpriseDefaultRepositoryPermissionSettingValue {
  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */
  Admin = "ADMIN",
  /** Organization members will only be able to clone and pull public repositories. */
  None = "NONE",
  /** Organizations in the enterprise choose base repository permissions for their members. */
  NoPolicy = "NO_POLICY",
  /** Organization members will be able to clone and pull all organization repositories. */
  Read = "READ",
  /** Organization members will be able to clone, pull, and push all organization repositories. */
  Write = "WRITE",
}

/** An edge in a connection. */
export type EnterpriseEdge = {
  __typename?: "EnterpriseEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Enterprise>;
};

/** The possible values for an enabled/disabled enterprise setting. */
export enum EnterpriseEnabledDisabledSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = "DISABLED",
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = "ENABLED",
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = "NO_POLICY",
}

/** The possible values for an enabled/no policy enterprise setting. */
export enum EnterpriseEnabledSettingValue {
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = "ENABLED",
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = "NO_POLICY",
}

/** The connection type for OrganizationInvitation. */
export type EnterpriseFailedInvitationConnection = {
  __typename?: "EnterpriseFailedInvitationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseFailedInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
  /** Identifies the total count of unique users in the connection. */
  totalUniqueUserCount: Scalars["Int"]["output"];
};

/** A failed invitation to be a member in an enterprise organization. */
export type EnterpriseFailedInvitationEdge = {
  __typename?: "EnterpriseFailedInvitationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<OrganizationInvitation>;
};

/**
 * An identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseIdentityProvider = Node & {
  __typename?: "EnterpriseIdentityProvider";
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod?: Maybe<SamlDigestAlgorithm>;
  /** The enterprise this identity provider belongs to. */
  enterprise?: Maybe<Enterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  externalIdentities: ExternalIdentityConnection;
  /** The Node ID of the EnterpriseIdentityProvider object */
  id: Scalars["ID"]["output"];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars["X509Certificate"]["output"]>;
  /** The Issuer Entity ID for the SAML identity provider. */
  issuer?: Maybe<Scalars["String"]["output"]>;
  /** Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable. */
  recoveryCodes?: Maybe<Array<Scalars["String"]["output"]>>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod?: Maybe<SamlSignatureAlgorithm>;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars["URI"]["output"]>;
};

/**
 * An identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseIdentityProviderExternalIdentitiesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  login?: InputMaybe<Scalars["String"]["input"]>;
  membersOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  userName?: InputMaybe<Scalars["String"]["input"]>;
};

/** An object that is a member of an enterprise. */
export type EnterpriseMember = EnterpriseUserAccount | User;

/** The connection type for EnterpriseMember. */
export type EnterpriseMemberConnection = {
  __typename?: "EnterpriseMemberConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** A User who is a member of an enterprise through one or more organizations. */
export type EnterpriseMemberEdge = {
  __typename?: "EnterpriseMemberEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseMember>;
};

/** An invitation for a user to become an unaffiliated member of an enterprise. */
export type EnterpriseMemberInvitation = Node & {
  __typename?: "EnterpriseMemberInvitation";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The email of the person who was invited to the enterprise. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise the invitation is for. */
  enterprise: Enterprise;
  /** The Node ID of the EnterpriseMemberInvitation object */
  id: Scalars["ID"]["output"];
  /** The user who was invited to the enterprise. */
  invitee?: Maybe<User>;
  /** The user who created the invitation. */
  inviter?: Maybe<User>;
};

/** The connection type for EnterpriseMemberInvitation. */
export type EnterpriseMemberInvitationConnection = {
  __typename?: "EnterpriseMemberInvitationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseMemberInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseMemberInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type EnterpriseMemberInvitationEdge = {
  __typename?: "EnterpriseMemberInvitationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseMemberInvitation>;
};

/** Ordering options for enterprise administrator invitation connections */
export type EnterpriseMemberInvitationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise member invitations by. */
  field: EnterpriseMemberInvitationOrderField;
};

/** Properties by which enterprise member invitation connections can be ordered. */
export enum EnterpriseMemberInvitationOrderField {
  /** Order enterprise member invitations by creation time */
  CreatedAt = "CREATED_AT",
}

/** Ordering options for enterprise member connections. */
export type EnterpriseMemberOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise members by. */
  field: EnterpriseMemberOrderField;
};

/** Properties by which enterprise member connections can be ordered. */
export enum EnterpriseMemberOrderField {
  /** Order enterprise members by creation time */
  CreatedAt = "CREATED_AT",
  /** Order enterprise members by login */
  Login = "LOGIN",
}

/** The possible values for the enterprise members can create repositories setting. */
export enum EnterpriseMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = "ALL",
  /** Members will not be able to create public or private repositories. */
  Disabled = "DISABLED",
  /** Organization owners choose whether to allow members to create repositories. */
  NoPolicy = "NO_POLICY",
  /** Members will be able to create only private repositories. */
  Private = "PRIVATE",
  /** Members will be able to create only public repositories. */
  Public = "PUBLIC",
}

/** The possible values for the members can make purchases setting. */
export enum EnterpriseMembersCanMakePurchasesSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = "DISABLED",
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = "ENABLED",
}

/** The possible values we have for filtering Platform::Objects::User#enterprises. */
export enum EnterpriseMembershipType {
  /** Returns all enterprises in which the user is an admin. */
  Admin = "ADMIN",
  /** Returns all enterprises in which the user is a member, admin, or billing manager. */
  All = "ALL",
  /** Returns all enterprises in which the user is a billing manager. */
  BillingManager = "BILLING_MANAGER",
  /** Returns all enterprises in which the user is a member of an org that is owned by the enterprise. */
  OrgMembership = "ORG_MEMBERSHIP",
}

/** Ordering options for enterprises. */
export type EnterpriseOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprises by. */
  field: EnterpriseOrderField;
};

/** Properties by which enterprise connections can be ordered. */
export enum EnterpriseOrderField {
  /** Order enterprises by name */
  Name = "NAME",
}

/** The connection type for Organization. */
export type EnterpriseOrganizationMembershipConnection = {
  __typename?: "EnterpriseOrganizationMembershipConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseOrganizationMembershipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An enterprise organization that a user is a member of. */
export type EnterpriseOrganizationMembershipEdge = {
  __typename?: "EnterpriseOrganizationMembershipEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Organization>;
  /** The role of the user in the enterprise membership. */
  role: EnterpriseUserAccountMembershipRole;
};

/** The connection type for User. */
export type EnterpriseOutsideCollaboratorConnection = {
  __typename?: "EnterpriseOutsideCollaboratorConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseOutsideCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type EnterpriseOutsideCollaboratorEdge = {
  __typename?: "EnterpriseOutsideCollaboratorEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
  /** The enterprise organization repositories this user is a member of. */
  repositories: EnterpriseRepositoryInfoConnection;
};

/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type EnterpriseOutsideCollaboratorEdgeRepositoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RepositoryOrder>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfo = {
  __typename?: "EnterpriseOwnerInfo";
  /** A list of all of the administrators for this enterprise. */
  admins: EnterpriseAdministratorConnection;
  /** A list of users in the enterprise who currently have two-factor authentication disabled. */
  affiliatedUsersWithTwoFactorDisabled: UserConnection;
  /** Whether or not affiliated users with two-factor authentication disabled exist in the enterprise. */
  affiliatedUsersWithTwoFactorDisabledExist: Scalars["Boolean"]["output"];
  /** The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise. */
  allowPrivateRepositoryForkingSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided private repository forking setting value. */
  allowPrivateRepositoryForkingSettingOrganizations: OrganizationConnection;
  /** The value for the allow private repository forking policy on the enterprise. */
  allowPrivateRepositoryForkingSettingPolicyValue?: Maybe<EnterpriseAllowPrivateRepositoryForkingPolicyValue>;
  /** The setting value for base repository permissions for organizations in this enterprise. */
  defaultRepositoryPermissionSetting: EnterpriseDefaultRepositoryPermissionSettingValue;
  /** A list of enterprise organizations configured with the provided base repository permission. */
  defaultRepositoryPermissionSettingOrganizations: OrganizationConnection;
  /**
   * A list of domains owned by the enterprise. Visible to enterprise owners or
   * enterprise owners' personal access tokens (classic) with admin:enterprise scope.
   */
  domains: VerifiableDomainConnection;
  /** Enterprise Server installations owned by the enterprise. */
  enterpriseServerInstallations: EnterpriseServerInstallationConnection;
  /** A list of failed invitations in the enterprise. */
  failedInvitations: EnterpriseFailedInvitationConnection;
  /** The setting value for whether the enterprise has an IP allow list enabled. */
  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;
  /**
   * The IP addresses that are allowed to access resources owned by the enterprise.
   * Visible to enterprise owners or enterprise owners' personal access tokens
   * (classic) with admin:enterprise scope.
   */
  ipAllowListEntries: IpAllowListEntryConnection;
  /** The setting value for whether the enterprise has IP allow list configuration for installed GitHub Apps enabled. */
  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue;
  /** Whether or not the base repository permission is currently being updated. */
  isUpdatingDefaultRepositoryPermission: Scalars["Boolean"]["output"];
  /** Whether the two-factor authentication requirement is currently being enforced. */
  isUpdatingTwoFactorRequirement: Scalars["Boolean"]["output"];
  /**
   * The setting value for whether organization members with admin permissions on a
   * repository can change repository visibility.
   */
  membersCanChangeRepositoryVisibilitySetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided can change repository visibility setting value. */
  membersCanChangeRepositoryVisibilitySettingOrganizations: OrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can create internal repositories. */
  membersCanCreateInternalRepositoriesSetting?: Maybe<
    Scalars["Boolean"]["output"]
  >;
  /** The setting value for whether members of organizations in the enterprise can create private repositories. */
  membersCanCreatePrivateRepositoriesSetting?: Maybe<
    Scalars["Boolean"]["output"]
  >;
  /** The setting value for whether members of organizations in the enterprise can create public repositories. */
  membersCanCreatePublicRepositoriesSetting?: Maybe<
    Scalars["Boolean"]["output"]
  >;
  /** The setting value for whether members of organizations in the enterprise can create repositories. */
  membersCanCreateRepositoriesSetting?: Maybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;
  /** A list of enterprise organizations configured with the provided repository creation setting value. */
  membersCanCreateRepositoriesSettingOrganizations: OrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete issues. */
  membersCanDeleteIssuesSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete issues setting value. */
  membersCanDeleteIssuesSettingOrganizations: OrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete or transfer repositories. */
  membersCanDeleteRepositoriesSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete repositories setting value. */
  membersCanDeleteRepositoriesSettingOrganizations: OrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can invite outside collaborators. */
  membersCanInviteCollaboratorsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can invite collaborators setting value. */
  membersCanInviteCollaboratorsSettingOrganizations: OrganizationConnection;
  /** Indicates whether members of this enterprise's organizations can purchase additional services for those organizations. */
  membersCanMakePurchasesSetting: EnterpriseMembersCanMakePurchasesSettingValue;
  /** The setting value for whether members with admin permissions for repositories can update protected branches. */
  membersCanUpdateProtectedBranchesSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can update protected branches setting value. */
  membersCanUpdateProtectedBranchesSettingOrganizations: OrganizationConnection;
  /** The setting value for whether members can view dependency insights. */
  membersCanViewDependencyInsightsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can view dependency insights setting value. */
  membersCanViewDependencyInsightsSettingOrganizations: OrganizationConnection;
  /** Indicates if email notification delivery for this enterprise is restricted to verified or approved domains. */
  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue;
  /** The OIDC Identity Provider for the enterprise. */
  oidcProvider?: Maybe<OidcProvider>;
  /** The setting value for whether organization projects are enabled for organizations in this enterprise. */
  organizationProjectsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided organization projects setting value. */
  organizationProjectsSettingOrganizations: OrganizationConnection;
  /** A list of outside collaborators across the repositories in the enterprise. */
  outsideCollaborators: EnterpriseOutsideCollaboratorConnection;
  /** A list of pending administrator invitations for the enterprise. */
  pendingAdminInvitations: EnterpriseAdministratorInvitationConnection;
  /** A list of pending collaborator invitations across the repositories in the enterprise. */
  pendingCollaboratorInvitations: RepositoryInvitationConnection;
  /** A list of pending member invitations for organizations in the enterprise. */
  pendingMemberInvitations: EnterprisePendingMemberInvitationConnection;
  /** A list of pending unaffiliated member invitations for the enterprise. */
  pendingUnaffiliatedMemberInvitations: EnterpriseMemberInvitationConnection;
  /** The setting value for whether repository projects are enabled in this enterprise. */
  repositoryProjectsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided repository projects setting value. */
  repositoryProjectsSettingOrganizations: OrganizationConnection;
  /** The SAML Identity Provider for the enterprise. */
  samlIdentityProvider?: Maybe<EnterpriseIdentityProvider>;
  /** A list of enterprise organizations configured with the SAML single sign-on setting value. */
  samlIdentityProviderSettingOrganizations: OrganizationConnection;
  /** A list of members with a support entitlement. */
  supportEntitlements: EnterpriseMemberConnection;
  /** The setting value for whether team discussions are enabled for organizations in this enterprise. */
  teamDiscussionsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided team discussions setting value. */
  teamDiscussionsSettingOrganizations: OrganizationConnection;
  /** The setting value for whether the enterprise requires two-factor authentication for its organizations and users. */
  twoFactorRequiredSetting: EnterpriseEnabledSettingValue;
  /** A list of enterprise organizations configured with the two-factor authentication setting value. */
  twoFactorRequiredSettingOrganizations: OrganizationConnection;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoAdminsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  hasTwoFactorEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars["String"]["input"]>>;
  query?: InputMaybe<Scalars["String"]["input"]>;
  role?: InputMaybe<EnterpriseAdministratorRole>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoAffiliatedUsersWithTwoFactorDisabledArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoAllowPrivateRepositoryForkingSettingOrganizationsArgs =
  {
    after?: InputMaybe<Scalars["String"]["input"]>;
    before?: InputMaybe<Scalars["String"]["input"]>;
    first?: InputMaybe<Scalars["Int"]["input"]>;
    last?: InputMaybe<Scalars["Int"]["input"]>;
    orderBy?: InputMaybe<OrganizationOrder>;
    value: Scalars["Boolean"]["input"];
  };

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoDefaultRepositoryPermissionSettingOrganizationsArgs =
  {
    after?: InputMaybe<Scalars["String"]["input"]>;
    before?: InputMaybe<Scalars["String"]["input"]>;
    first?: InputMaybe<Scalars["Int"]["input"]>;
    last?: InputMaybe<Scalars["Int"]["input"]>;
    orderBy?: InputMaybe<OrganizationOrder>;
    value: DefaultRepositoryPermissionField;
  };

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoDomainsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  isApproved?: InputMaybe<Scalars["Boolean"]["input"]>;
  isVerified?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<VerifiableDomainOrder>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoEnterpriseServerInstallationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  connectedOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<EnterpriseServerInstallationOrder>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoFailedInvitationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoIpAllowListEntriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IpAllowListEntryOrder>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoMembersCanChangeRepositoryVisibilitySettingOrganizationsArgs =
  {
    after?: InputMaybe<Scalars["String"]["input"]>;
    before?: InputMaybe<Scalars["String"]["input"]>;
    first?: InputMaybe<Scalars["Int"]["input"]>;
    last?: InputMaybe<Scalars["Int"]["input"]>;
    orderBy?: InputMaybe<OrganizationOrder>;
    value: Scalars["Boolean"]["input"];
  };

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoMembersCanCreateRepositoriesSettingOrganizationsArgs =
  {
    after?: InputMaybe<Scalars["String"]["input"]>;
    before?: InputMaybe<Scalars["String"]["input"]>;
    first?: InputMaybe<Scalars["Int"]["input"]>;
    last?: InputMaybe<Scalars["Int"]["input"]>;
    orderBy?: InputMaybe<OrganizationOrder>;
    value: OrganizationMembersCanCreateRepositoriesSettingValue;
  };

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoMembersCanDeleteIssuesSettingOrganizationsArgs =
  {
    after?: InputMaybe<Scalars["String"]["input"]>;
    before?: InputMaybe<Scalars["String"]["input"]>;
    first?: InputMaybe<Scalars["Int"]["input"]>;
    last?: InputMaybe<Scalars["Int"]["input"]>;
    orderBy?: InputMaybe<OrganizationOrder>;
    value: Scalars["Boolean"]["input"];
  };

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoMembersCanDeleteRepositoriesSettingOrganizationsArgs =
  {
    after?: InputMaybe<Scalars["String"]["input"]>;
    before?: InputMaybe<Scalars["String"]["input"]>;
    first?: InputMaybe<Scalars["Int"]["input"]>;
    last?: InputMaybe<Scalars["Int"]["input"]>;
    orderBy?: InputMaybe<OrganizationOrder>;
    value: Scalars["Boolean"]["input"];
  };

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoMembersCanInviteCollaboratorsSettingOrganizationsArgs =
  {
    after?: InputMaybe<Scalars["String"]["input"]>;
    before?: InputMaybe<Scalars["String"]["input"]>;
    first?: InputMaybe<Scalars["Int"]["input"]>;
    last?: InputMaybe<Scalars["Int"]["input"]>;
    orderBy?: InputMaybe<OrganizationOrder>;
    value: Scalars["Boolean"]["input"];
  };

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoMembersCanUpdateProtectedBranchesSettingOrganizationsArgs =
  {
    after?: InputMaybe<Scalars["String"]["input"]>;
    before?: InputMaybe<Scalars["String"]["input"]>;
    first?: InputMaybe<Scalars["Int"]["input"]>;
    last?: InputMaybe<Scalars["Int"]["input"]>;
    orderBy?: InputMaybe<OrganizationOrder>;
    value: Scalars["Boolean"]["input"];
  };

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoMembersCanViewDependencyInsightsSettingOrganizationsArgs =
  {
    after?: InputMaybe<Scalars["String"]["input"]>;
    before?: InputMaybe<Scalars["String"]["input"]>;
    first?: InputMaybe<Scalars["Int"]["input"]>;
    last?: InputMaybe<Scalars["Int"]["input"]>;
    orderBy?: InputMaybe<OrganizationOrder>;
    value: Scalars["Boolean"]["input"];
  };

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoOrganizationProjectsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars["Boolean"]["input"];
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoOutsideCollaboratorsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  hasTwoFactorEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  login?: InputMaybe<Scalars["String"]["input"]>;
  orderBy?: InputMaybe<EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars["String"]["input"]>>;
  query?: InputMaybe<Scalars["String"]["input"]>;
  visibility?: InputMaybe<RepositoryVisibility>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoPendingAdminInvitationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<EnterpriseAdministratorInvitationOrder>;
  query?: InputMaybe<Scalars["String"]["input"]>;
  role?: InputMaybe<EnterpriseAdministratorRole>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoPendingCollaboratorInvitationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RepositoryInvitationOrder>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoPendingMemberInvitationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  invitationSource?: InputMaybe<OrganizationInvitationSource>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  organizationLogins?: InputMaybe<Array<Scalars["String"]["input"]>>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoPendingUnaffiliatedMemberInvitationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<EnterpriseMemberInvitationOrder>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoRepositoryProjectsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars["Boolean"]["input"];
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoSamlIdentityProviderSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: IdentityProviderConfigurationState;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoSupportEntitlementsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<EnterpriseMemberOrder>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoTeamDiscussionsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars["Boolean"]["input"];
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoTwoFactorRequiredSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars["Boolean"]["input"];
};

/** The connection type for OrganizationInvitation. */
export type EnterprisePendingMemberInvitationConnection = {
  __typename?: "EnterprisePendingMemberInvitationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterprisePendingMemberInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
  /** Identifies the total count of unique users in the connection. */
  totalUniqueUserCount: Scalars["Int"]["output"];
};

/** An invitation to be a member in an enterprise organization. */
export type EnterprisePendingMemberInvitationEdge = {
  __typename?: "EnterprisePendingMemberInvitationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<OrganizationInvitation>;
};

/** A subset of repository information queryable from an enterprise. */
export type EnterpriseRepositoryInfo = Node & {
  __typename?: "EnterpriseRepositoryInfo";
  /** The Node ID of the EnterpriseRepositoryInfo object */
  id: Scalars["ID"]["output"];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars["Boolean"]["output"];
  /** The repository's name. */
  name: Scalars["String"]["output"];
  /** The repository's name with owner. */
  nameWithOwner: Scalars["String"]["output"];
};

/** The connection type for EnterpriseRepositoryInfo. */
export type EnterpriseRepositoryInfoConnection = {
  __typename?: "EnterpriseRepositoryInfoConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseRepositoryInfoEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseRepositoryInfo>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type EnterpriseRepositoryInfoEdge = {
  __typename?: "EnterpriseRepositoryInfoEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseRepositoryInfo>;
};

/** An Enterprise Server installation. */
export type EnterpriseServerInstallation = Node & {
  __typename?: "EnterpriseServerInstallation";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The customer name to which the Enterprise Server installation belongs. */
  customerName: Scalars["String"]["output"];
  /** The host name of the Enterprise Server installation. */
  hostName: Scalars["String"]["output"];
  /** The Node ID of the EnterpriseServerInstallation object */
  id: Scalars["ID"]["output"];
  /** Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect. */
  isConnected: Scalars["Boolean"]["output"];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** User accounts on this Enterprise Server installation. */
  userAccounts: EnterpriseServerUserAccountConnection;
  /** User accounts uploads for the Enterprise Server installation. */
  userAccountsUploads: EnterpriseServerUserAccountsUploadConnection;
};

/** An Enterprise Server installation. */
export type EnterpriseServerInstallationUserAccountsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<EnterpriseServerUserAccountOrder>;
};

/** An Enterprise Server installation. */
export type EnterpriseServerInstallationUserAccountsUploadsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<EnterpriseServerUserAccountsUploadOrder>;
};

/** The connection type for EnterpriseServerInstallation. */
export type EnterpriseServerInstallationConnection = {
  __typename?: "EnterpriseServerInstallationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseServerInstallationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseServerInstallation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type EnterpriseServerInstallationEdge = {
  __typename?: "EnterpriseServerInstallationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseServerInstallation>;
};

/** The connection type for EnterpriseServerInstallation. */
export type EnterpriseServerInstallationMembershipConnection = {
  __typename?: "EnterpriseServerInstallationMembershipConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseServerInstallationMembershipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseServerInstallation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An Enterprise Server installation that a user is a member of. */
export type EnterpriseServerInstallationMembershipEdge = {
  __typename?: "EnterpriseServerInstallationMembershipEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseServerInstallation>;
  /** The role of the user in the enterprise membership. */
  role: EnterpriseUserAccountMembershipRole;
};

/** Ordering options for Enterprise Server installation connections. */
export type EnterpriseServerInstallationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order Enterprise Server installations by. */
  field: EnterpriseServerInstallationOrderField;
};

/** Properties by which Enterprise Server installation connections can be ordered. */
export enum EnterpriseServerInstallationOrderField {
  /** Order Enterprise Server installations by creation time */
  CreatedAt = "CREATED_AT",
  /** Order Enterprise Server installations by customer name */
  CustomerName = "CUSTOMER_NAME",
  /** Order Enterprise Server installations by host name */
  HostName = "HOST_NAME",
}

/** A user account on an Enterprise Server installation. */
export type EnterpriseServerUserAccount = Node & {
  __typename?: "EnterpriseServerUserAccount";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** User emails belonging to this user account. */
  emails: EnterpriseServerUserAccountEmailConnection;
  /** The Enterprise Server installation on which this user account exists. */
  enterpriseServerInstallation: EnterpriseServerInstallation;
  /** The Node ID of the EnterpriseServerUserAccount object */
  id: Scalars["ID"]["output"];
  /** Whether the user account is a site administrator on the Enterprise Server installation. */
  isSiteAdmin: Scalars["Boolean"]["output"];
  /** The login of the user account on the Enterprise Server installation. */
  login: Scalars["String"]["output"];
  /** The profile name of the user account on the Enterprise Server installation. */
  profileName?: Maybe<Scalars["String"]["output"]>;
  /** The date and time when the user account was created on the Enterprise Server installation. */
  remoteCreatedAt: Scalars["DateTime"]["output"];
  /** The ID of the user account on the Enterprise Server installation. */
  remoteUserId: Scalars["Int"]["output"];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** A user account on an Enterprise Server installation. */
export type EnterpriseServerUserAccountEmailsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<EnterpriseServerUserAccountEmailOrder>;
};

/** The connection type for EnterpriseServerUserAccount. */
export type EnterpriseServerUserAccountConnection = {
  __typename?: "EnterpriseServerUserAccountConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type EnterpriseServerUserAccountEdge = {
  __typename?: "EnterpriseServerUserAccountEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseServerUserAccount>;
};

/** An email belonging to a user account on an Enterprise Server installation. */
export type EnterpriseServerUserAccountEmail = Node & {
  __typename?: "EnterpriseServerUserAccountEmail";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The email address. */
  email: Scalars["String"]["output"];
  /** The Node ID of the EnterpriseServerUserAccountEmail object */
  id: Scalars["ID"]["output"];
  /** Indicates whether this is the primary email of the associated user account. */
  isPrimary: Scalars["Boolean"]["output"];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** The user account to which the email belongs. */
  userAccount: EnterpriseServerUserAccount;
};

/** The connection type for EnterpriseServerUserAccountEmail. */
export type EnterpriseServerUserAccountEmailConnection = {
  __typename?: "EnterpriseServerUserAccountEmailConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountEmailEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccountEmail>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type EnterpriseServerUserAccountEmailEdge = {
  __typename?: "EnterpriseServerUserAccountEmailEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseServerUserAccountEmail>;
};

/** Ordering options for Enterprise Server user account email connections. */
export type EnterpriseServerUserAccountEmailOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order emails by. */
  field: EnterpriseServerUserAccountEmailOrderField;
};

/** Properties by which Enterprise Server user account email connections can be ordered. */
export enum EnterpriseServerUserAccountEmailOrderField {
  /** Order emails by email */
  Email = "EMAIL",
}

/** Ordering options for Enterprise Server user account connections. */
export type EnterpriseServerUserAccountOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order user accounts by. */
  field: EnterpriseServerUserAccountOrderField;
};

/** Properties by which Enterprise Server user account connections can be ordered. */
export enum EnterpriseServerUserAccountOrderField {
  /** Order user accounts by login */
  Login = "LOGIN",
  /** Order user accounts by creation time on the Enterprise Server installation */
  RemoteCreatedAt = "REMOTE_CREATED_AT",
}

/** A user accounts upload from an Enterprise Server installation. */
export type EnterpriseServerUserAccountsUpload = Node & {
  __typename?: "EnterpriseServerUserAccountsUpload";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The enterprise to which this upload belongs. */
  enterprise: Enterprise;
  /** The Enterprise Server installation for which this upload was generated. */
  enterpriseServerInstallation: EnterpriseServerInstallation;
  /** The Node ID of the EnterpriseServerUserAccountsUpload object */
  id: Scalars["ID"]["output"];
  /** The name of the file uploaded. */
  name: Scalars["String"]["output"];
  /** The synchronization state of the upload */
  syncState: EnterpriseServerUserAccountsUploadSyncState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** The connection type for EnterpriseServerUserAccountsUpload. */
export type EnterpriseServerUserAccountsUploadConnection = {
  __typename?: "EnterpriseServerUserAccountsUploadConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountsUploadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccountsUpload>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type EnterpriseServerUserAccountsUploadEdge = {
  __typename?: "EnterpriseServerUserAccountsUploadEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseServerUserAccountsUpload>;
};

/** Ordering options for Enterprise Server user accounts upload connections. */
export type EnterpriseServerUserAccountsUploadOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order user accounts uploads by. */
  field: EnterpriseServerUserAccountsUploadOrderField;
};

/** Properties by which Enterprise Server user accounts upload connections can be ordered. */
export enum EnterpriseServerUserAccountsUploadOrderField {
  /** Order user accounts uploads by creation time */
  CreatedAt = "CREATED_AT",
}

/** Synchronization state of the Enterprise Server user accounts upload */
export enum EnterpriseServerUserAccountsUploadSyncState {
  /** The synchronization of the upload failed. */
  Failure = "FAILURE",
  /** The synchronization of the upload is pending. */
  Pending = "PENDING",
  /** The synchronization of the upload succeeded. */
  Success = "SUCCESS",
}

/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type EnterpriseUserAccount = Actor &
  Node & {
    __typename?: "EnterpriseUserAccount";
    /** A URL pointing to the enterprise user account's public avatar. */
    avatarUrl: Scalars["URI"]["output"];
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The enterprise in which this user account exists. */
    enterprise: Enterprise;
    /** A list of Enterprise Server installations this user is a member of. */
    enterpriseInstallations: EnterpriseServerInstallationMembershipConnection;
    /** The Node ID of the EnterpriseUserAccount object */
    id: Scalars["ID"]["output"];
    /** An identifier for the enterprise user account, a login or email address */
    login: Scalars["String"]["output"];
    /** The name of the enterprise user account */
    name?: Maybe<Scalars["String"]["output"]>;
    /** A list of enterprise organizations this user is a member of. */
    organizations: EnterpriseOrganizationMembershipConnection;
    /** The HTTP path for this user. */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this user. */
    url: Scalars["URI"]["output"];
    /** The user within the enterprise. */
    user?: Maybe<User>;
  };

/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type EnterpriseUserAccountAvatarUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type EnterpriseUserAccountEnterpriseInstallationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<EnterpriseServerInstallationOrder>;
  query?: InputMaybe<Scalars["String"]["input"]>;
  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;
};

/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type EnterpriseUserAccountOrganizationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<OrganizationOrder>;
  query?: InputMaybe<Scalars["String"]["input"]>;
  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;
};

/** The possible roles for enterprise membership. */
export enum EnterpriseUserAccountMembershipRole {
  /** The user is a member of an organization in the enterprise. */
  Member = "MEMBER",
  /** The user is an owner of an organization in the enterprise. */
  Owner = "OWNER",
  /**
   * The user is not an owner of the enterprise, and not a member or owner of any
   * organizations in the enterprise; only for EMU-enabled enterprises.
   */
  Unaffiliated = "UNAFFILIATED",
}

/** The possible GitHub Enterprise deployments where this user can exist. */
export enum EnterpriseUserDeployment {
  /** The user is part of a GitHub Enterprise Cloud deployment. */
  Cloud = "CLOUD",
  /** The user is part of a GitHub Enterprise Server deployment. */
  Server = "SERVER",
}

/** An environment. */
export type Environment = Node & {
  __typename?: "Environment";
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the Environment object */
  id: Scalars["ID"]["output"];
  /** Indicates whether or not this environment is currently pinned to the repository */
  isPinned?: Maybe<Scalars["Boolean"]["output"]>;
  /** The latest completed deployment with status success, failure, or error if it exists */
  latestCompletedDeployment?: Maybe<Deployment>;
  /** The name of the environment */
  name: Scalars["String"]["output"];
  /** The position of the environment if it is pinned, null if it is not pinned */
  pinnedPosition?: Maybe<Scalars["Int"]["output"]>;
  /** The protection rules defined for this environment */
  protectionRules: DeploymentProtectionRuleConnection;
};

/** An environment. */
export type EnvironmentProtectionRulesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for Environment. */
export type EnvironmentConnection = {
  __typename?: "EnvironmentConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Environment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type EnvironmentEdge = {
  __typename?: "EnvironmentEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Environment>;
};

/** Properties by which environments connections can be ordered */
export enum EnvironmentOrderField {
  /** Order environments by name. */
  Name = "NAME",
}

/** Properties by which environments connections can be ordered */
export enum EnvironmentPinnedFilterField {
  /** All environments will be returned. */
  All = "ALL",
  /** Environments exclude pinned will be returned */
  None = "NONE",
  /** Only pinned environment will be returned */
  Only = "ONLY",
}

/** Ordering options for environments */
export type Environments = {
  /** The direction in which to order environments by the specified field. */
  direction: OrderDirection;
  /** The field to order environments by. */
  field: EnvironmentOrderField;
};

/**
 * An external identity provisioned by SAML SSO or SCIM. If SAML is configured on
 * the organization, the external identity is visible to (1) organization owners,
 * (2) organization owners' personal access tokens (classic) with read:org or
 * admin:org scope, (3) GitHub App with an installation token with read or write
 * access to members. If SAML is configured on the enterprise, the external
 * identity is visible to (1) enterprise owners, (2) enterprise owners' personal
 * access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type ExternalIdentity = Node & {
  __typename?: "ExternalIdentity";
  /** The GUID for this identity */
  guid: Scalars["String"]["output"];
  /** The Node ID of the ExternalIdentity object */
  id: Scalars["ID"]["output"];
  /** Organization invitation for this SCIM-provisioned external identity */
  organizationInvitation?: Maybe<OrganizationInvitation>;
  /** SAML Identity attributes */
  samlIdentity?: Maybe<ExternalIdentitySamlAttributes>;
  /** SCIM Identity attributes */
  scimIdentity?: Maybe<ExternalIdentityScimAttributes>;
  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */
  user?: Maybe<User>;
};

/** An attribute for the External Identity attributes collection */
export type ExternalIdentityAttribute = {
  __typename?: "ExternalIdentityAttribute";
  /** The attribute metadata as JSON */
  metadata?: Maybe<Scalars["String"]["output"]>;
  /** The attribute name */
  name: Scalars["String"]["output"];
  /** The attribute value */
  value: Scalars["String"]["output"];
};

/** The connection type for ExternalIdentity. */
export type ExternalIdentityConnection = {
  __typename?: "ExternalIdentityConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExternalIdentityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ExternalIdentity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ExternalIdentityEdge = {
  __typename?: "ExternalIdentityEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ExternalIdentity>;
};

/** SAML attributes for the External Identity */
export type ExternalIdentitySamlAttributes = {
  __typename?: "ExternalIdentitySamlAttributes";
  /** SAML Identity attributes */
  attributes: Array<ExternalIdentityAttribute>;
  /** The emails associated with the SAML identity */
  emails?: Maybe<Array<UserEmailMetadata>>;
  /** Family name of the SAML identity */
  familyName?: Maybe<Scalars["String"]["output"]>;
  /** Given name of the SAML identity */
  givenName?: Maybe<Scalars["String"]["output"]>;
  /** The groups linked to this identity in IDP */
  groups?: Maybe<Array<Scalars["String"]["output"]>>;
  /** The NameID of the SAML identity */
  nameId?: Maybe<Scalars["String"]["output"]>;
  /** The userName of the SAML identity */
  username?: Maybe<Scalars["String"]["output"]>;
};

/** SCIM attributes for the External Identity */
export type ExternalIdentityScimAttributes = {
  __typename?: "ExternalIdentityScimAttributes";
  /** The emails associated with the SCIM identity */
  emails?: Maybe<Array<UserEmailMetadata>>;
  /** Family name of the SCIM identity */
  familyName?: Maybe<Scalars["String"]["output"]>;
  /** Given name of the SCIM identity */
  givenName?: Maybe<Scalars["String"]["output"]>;
  /** The groups linked to this identity in IDP */
  groups?: Maybe<Array<Scalars["String"]["output"]>>;
  /** The userName of the SCIM identity */
  username?: Maybe<Scalars["String"]["output"]>;
};

/**
 * A command to add a file at the given path with the given contents as part of a
 * commit.  Any existing file at that that path will be replaced.
 */
export type FileAddition = {
  /** The base64 encoded contents of the file */
  contents: Scalars["Base64String"]["input"];
  /** The path in the repository where the file will be located */
  path: Scalars["String"]["input"];
};

/**
 * A description of a set of changes to a file tree to be made as part of
 * a git commit, modeled as zero or more file `additions` and zero or more
 * file `deletions`.
 *
 * Both fields are optional; omitting both will produce a commit with no
 * file changes.
 *
 * `deletions` and `additions` describe changes to files identified
 * by their path in the git tree using unix-style path separators, i.e.
 * `/`.  The root of a git tree is an empty string, so paths are not
 * slash-prefixed.
 *
 * `path` values must be unique across all `additions` and `deletions`
 * provided.  Any duplication will result in a validation error.
 *
 * ### Encoding
 *
 * File contents must be provided in full for each `FileAddition`.
 *
 * The `contents` of a `FileAddition` must be encoded using RFC 4648
 * compliant base64, i.e. correct padding is required and no characters
 * outside the standard alphabet may be used.  Invalid base64
 * encoding will be rejected with a validation error.
 *
 * The encoded contents may be binary.
 *
 * For text files, no assumptions are made about the character encoding of
 * the file contents (after base64 decoding).  No charset transcoding or
 * line-ending normalization will be performed; it is the client's
 * responsibility to manage the character encoding of files they provide.
 * However, for maximum compatibility we recommend using UTF-8 encoding
 * and ensuring that all files in a repository use a consistent
 * line-ending convention (`\n` or `\r\n`), and that all files end
 * with a newline.
 *
 * ### Modeling file changes
 *
 * Each of the the five types of conceptual changes that can be made in a
 * git commit can be described using the `FileChanges` type as follows:
 *
 * 1. New file addition: create file `hello world\n` at path `docs/README.txt`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 * 2. Existing file modification: change existing `docs/README.txt` to have new
 *    content `new content here\n`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("new content here\n")
 *            }
 *          ]
 *        }
 *
 * 3. Existing file deletion: remove existing file `docs/README.txt`.
 *    Note that the path is required to exist -- specifying a
 *    path that does not exist on the given branch will abort the
 *    commit and return an error.
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt"
 *            }
 *          ]
 *        }
 *
 *
 * 4. File rename with no changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to the same content at
 *    `newdocs/README.txt`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 *
 * 5. File rename with changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to a file at path
 *    `newdocs/README.txt` with content `new contents\n`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("new contents\n")
 *            }
 *          ]
 *        }
 */
export type FileChanges = {
  /** File to add or change. */
  additions?: InputMaybe<Array<FileAddition>>;
  /** Files to delete. */
  deletions?: InputMaybe<Array<FileDeletion>>;
};

/** A command to delete the file at the given path as part of a commit. */
export type FileDeletion = {
  /** The path to delete */
  path: Scalars["String"]["input"];
};

/**
 * Prevent commits that include files with specified file extensions from being
 * pushed to the commit graph. NOTE: This rule is in beta and subject to change
 */
export type FileExtensionRestrictionParameters = {
  __typename?: "FileExtensionRestrictionParameters";
  /** The file extensions that are restricted from being pushed to the commit graph. */
  restrictedFileExtensions: Array<Scalars["String"]["output"]>;
};

/**
 * Prevent commits that include files with specified file extensions from being
 * pushed to the commit graph. NOTE: This rule is in beta and subject to change
 */
export type FileExtensionRestrictionParametersInput = {
  /** The file extensions that are restricted from being pushed to the commit graph. */
  restrictedFileExtensions: Array<Scalars["String"]["input"]>;
};

/**
 * Prevent commits that include changes in specified file paths from being pushed
 * to the commit graph. NOTE: This rule is in beta and subject to change
 */
export type FilePathRestrictionParameters = {
  __typename?: "FilePathRestrictionParameters";
  /** The file paths that are restricted from being pushed to the commit graph. */
  restrictedFilePaths: Array<Scalars["String"]["output"]>;
};

/**
 * Prevent commits that include changes in specified file paths from being pushed
 * to the commit graph. NOTE: This rule is in beta and subject to change
 */
export type FilePathRestrictionParametersInput = {
  /** The file paths that are restricted from being pushed to the commit graph. */
  restrictedFilePaths: Array<Scalars["String"]["input"]>;
};

/** The possible viewed states of a file . */
export enum FileViewedState {
  /** The file has new changes since last viewed. */
  Dismissed = "DISMISSED",
  /** The file has not been marked as viewed. */
  Unviewed = "UNVIEWED",
  /** The file has been marked as viewed. */
  Viewed = "VIEWED",
}

/** Autogenerated input type of FollowOrganization */
export type FollowOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the organization to follow. */
  organizationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of FollowOrganization. */
export type FollowOrganizationPayload = {
  __typename?: "FollowOrganizationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The organization that was followed. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of FollowUser */
export type FollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the user to follow. */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated return type of FollowUser. */
export type FollowUserPayload = {
  __typename?: "FollowUserPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The user that was followed. */
  user?: Maybe<User>;
};

/** The connection type for User. */
export type FollowerConnection = {
  __typename?: "FollowerConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** The connection type for User. */
export type FollowingConnection = {
  __typename?: "FollowingConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** A funding platform link for a repository. */
export type FundingLink = {
  __typename?: "FundingLink";
  /** The funding platform this link is for. */
  platform: FundingPlatform;
  /** The configured URL for this funding link. */
  url: Scalars["URI"]["output"];
};

/** The possible funding platforms for repository funding links. */
export enum FundingPlatform {
  /** Buy Me a Coffee funding platform. */
  BuyMeACoffee = "BUY_ME_A_COFFEE",
  /** Community Bridge funding platform. */
  CommunityBridge = "COMMUNITY_BRIDGE",
  /** Custom funding platform. */
  Custom = "CUSTOM",
  /** GitHub funding platform. */
  Github = "GITHUB",
  /** IssueHunt funding platform. */
  Issuehunt = "ISSUEHUNT",
  /** Ko-fi funding platform. */
  KoFi = "KO_FI",
  /** LFX Crowdfunding funding platform. */
  LfxCrowdfunding = "LFX_CROWDFUNDING",
  /** Liberapay funding platform. */
  Liberapay = "LIBERAPAY",
  /** Open Collective funding platform. */
  OpenCollective = "OPEN_COLLECTIVE",
  /** Patreon funding platform. */
  Patreon = "PATREON",
  /** Polar funding platform. */
  Polar = "POLAR",
  /** Tidelift funding platform. */
  Tidelift = "TIDELIFT",
}

/** A generic hovercard context with a message and icon */
export type GenericHovercardContext = HovercardContext & {
  __typename?: "GenericHovercardContext";
  /** A string describing this context */
  message: Scalars["String"]["output"];
  /** An octicon to accompany this context */
  octicon: Scalars["String"]["output"];
};

/** A Gist. */
export type Gist = Node &
  Starrable &
  UniformResourceLocatable & {
    __typename?: "Gist";
    /** A list of comments associated with the gist */
    comments: GistCommentConnection;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The gist description. */
    description?: Maybe<Scalars["String"]["output"]>;
    /** The files in this gist. */
    files?: Maybe<Array<Maybe<GistFile>>>;
    /** A list of forks associated with the gist */
    forks: GistConnection;
    /** The Node ID of the Gist object */
    id: Scalars["ID"]["output"];
    /** Identifies if the gist is a fork. */
    isFork: Scalars["Boolean"]["output"];
    /** Whether the gist is public or not. */
    isPublic: Scalars["Boolean"]["output"];
    /** The gist name. */
    name: Scalars["String"]["output"];
    /** The gist owner. */
    owner?: Maybe<RepositoryOwner>;
    /** Identifies when the gist was last pushed to. */
    pushedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The HTML path to this resource. */
    resourcePath: Scalars["URI"]["output"];
    /** Returns a count of how many stargazers there are on this object */
    stargazerCount: Scalars["Int"]["output"];
    /** A list of users who have starred this starrable. */
    stargazers: StargazerConnection;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this Gist. */
    url: Scalars["URI"]["output"];
    /** Returns a boolean indicating whether the viewing user has starred this starrable. */
    viewerHasStarred: Scalars["Boolean"]["output"];
  };

/** A Gist. */
export type GistCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A Gist. */
export type GistFilesArgs = {
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  oid?: InputMaybe<Scalars["GitObjectID"]["input"]>;
};

/** A Gist. */
export type GistForksArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<GistOrder>;
};

/** A Gist. */
export type GistStargazersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<StarOrder>;
};

/** Represents a comment on an Gist. */
export type GistComment = Comment &
  Deletable &
  Minimizable &
  Node &
  Updatable &
  UpdatableComment & {
    __typename?: "GistComment";
    /** The actor who authored the comment. */
    author?: Maybe<Actor>;
    /** Author's association with the gist. */
    authorAssociation: CommentAuthorAssociation;
    /** Identifies the comment body. */
    body: Scalars["String"]["output"];
    /** The body rendered to HTML. */
    bodyHTML: Scalars["HTML"]["output"];
    /** The body rendered to text. */
    bodyText: Scalars["String"]["output"];
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail: Scalars["Boolean"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The actor who edited the comment. */
    editor?: Maybe<Actor>;
    /** The associated gist. */
    gist: Gist;
    /** The Node ID of the GistComment object */
    id: Scalars["ID"]["output"];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit: Scalars["Boolean"]["output"];
    /** Returns whether or not a comment has been minimized. */
    isMinimized: Scalars["Boolean"]["output"];
    /** The moment the editor made the last edit */
    lastEditedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /**
     * Returns why the comment was minimized. One of `abuse`, `off-topic`,
     * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
     * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
     */
    minimizedReason?: Maybe<Scalars["String"]["output"]>;
    /** Identifies when the comment was published at. */
    publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** A list of edits to this content. */
    userContentEdits?: Maybe<UserContentEditConnection>;
    /** Check if the current viewer can delete this object. */
    viewerCanDelete: Scalars["Boolean"]["output"];
    /** Check if the current viewer can minimize this object. */
    viewerCanMinimize: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
    /** Did the viewer author this comment. */
    viewerDidAuthor: Scalars["Boolean"]["output"];
  };

/** Represents a comment on an Gist. */
export type GistCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for GistComment. */
export type GistCommentConnection = {
  __typename?: "GistCommentConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GistCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GistComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type GistCommentEdge = {
  __typename?: "GistCommentEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<GistComment>;
};

/** The connection type for Gist. */
export type GistConnection = {
  __typename?: "GistConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GistEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Gist>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type GistEdge = {
  __typename?: "GistEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Gist>;
};

/** A file in a gist. */
export type GistFile = {
  __typename?: "GistFile";
  /** The file name encoded to remove characters that are invalid in URL paths. */
  encodedName?: Maybe<Scalars["String"]["output"]>;
  /** The gist file encoding. */
  encoding?: Maybe<Scalars["String"]["output"]>;
  /** The file extension from the file name. */
  extension?: Maybe<Scalars["String"]["output"]>;
  /** Indicates if this file is an image. */
  isImage: Scalars["Boolean"]["output"];
  /** Whether the file's contents were truncated. */
  isTruncated: Scalars["Boolean"]["output"];
  /** The programming language this file is written in. */
  language?: Maybe<Language>;
  /** The gist file name. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The gist file size in bytes. */
  size?: Maybe<Scalars["Int"]["output"]>;
  /** UTF8 text data or null if the file is binary */
  text?: Maybe<Scalars["String"]["output"]>;
};

/** A file in a gist. */
export type GistFileTextArgs = {
  truncate?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Ordering options for gist connections */
export type GistOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: GistOrderField;
};

/** Properties by which gist connections can be ordered. */
export enum GistOrderField {
  /** Order gists by creation time */
  CreatedAt = "CREATED_AT",
  /** Order gists by push time */
  PushedAt = "PUSHED_AT",
  /** Order gists by update time */
  UpdatedAt = "UPDATED_AT",
}

/** The privacy of a Gist */
export enum GistPrivacy {
  /** Gists that are public and secret */
  All = "ALL",
  /** Public */
  Public = "PUBLIC",
  /** Secret */
  Secret = "SECRET",
}

/** Represents an actor in a Git commit (ie. an author or committer). */
export type GitActor = {
  __typename?: "GitActor";
  /** A URL pointing to the author's public avatar. */
  avatarUrl: Scalars["URI"]["output"];
  /** The timestamp of the Git action (authoring or committing). */
  date?: Maybe<Scalars["GitTimestamp"]["output"]>;
  /** The email in the Git commit. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The name in the Git commit. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The GitHub user corresponding to the email field. Null if no such user exists. */
  user?: Maybe<User>;
};

/** Represents an actor in a Git commit (ie. an author or committer). */
export type GitActorAvatarUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for GitActor. */
export type GitActorConnection = {
  __typename?: "GitActorConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GitActorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GitActor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type GitActorEdge = {
  __typename?: "GitActorEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<GitActor>;
};

/** Represents information about the GitHub instance. */
export type GitHubMetadata = {
  __typename?: "GitHubMetadata";
  /** Returns a String that's a SHA of `github-services` */
  gitHubServicesSha: Scalars["GitObjectID"]["output"];
  /** IP addresses that users connect to for git operations */
  gitIpAddresses?: Maybe<Array<Scalars["String"]["output"]>>;
  /** IP addresses that GitHub Enterprise Importer uses for outbound connections */
  githubEnterpriseImporterIpAddresses?: Maybe<
    Array<Scalars["String"]["output"]>
  >;
  /** IP addresses that service hooks are sent from */
  hookIpAddresses?: Maybe<Array<Scalars["String"]["output"]>>;
  /** IP addresses that the importer connects from */
  importerIpAddresses?: Maybe<Array<Scalars["String"]["output"]>>;
  /** Whether or not users are verified */
  isPasswordAuthenticationVerifiable: Scalars["Boolean"]["output"];
  /** IP addresses for GitHub Pages' A records */
  pagesIpAddresses?: Maybe<Array<Scalars["String"]["output"]>>;
};

/** Represents a Git object. */
export type GitObject = {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars["String"]["output"];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars["URI"]["output"];
  /** The Node ID of the GitObject object */
  id: Scalars["ID"]["output"];
  /** The Git object ID */
  oid: Scalars["GitObjectID"]["output"];
  /** The Repository the Git object belongs to */
  repository: Repository;
};

/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */
export type GitSignature = {
  /** Email used to sign this object. */
  email: Scalars["String"]["output"];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars["Boolean"]["output"];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars["String"]["output"];
  /** ASCII-armored signature header from object. */
  signature: Scalars["String"]["output"];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars["Boolean"]["output"];
};

/** The state of a Git signature. */
export enum GitSignatureState {
  /** The signing certificate or its chain could not be verified */
  BadCert = "BAD_CERT",
  /** Invalid email used for signing */
  BadEmail = "BAD_EMAIL",
  /** Signing key expired */
  ExpiredKey = "EXPIRED_KEY",
  /** Internal error - the GPG verification service misbehaved */
  GpgverifyError = "GPGVERIFY_ERROR",
  /** Internal error - the GPG verification service is unavailable at the moment */
  GpgverifyUnavailable = "GPGVERIFY_UNAVAILABLE",
  /** Invalid signature */
  Invalid = "INVALID",
  /** Malformed signature */
  MalformedSig = "MALFORMED_SIG",
  /** The usage flags for the key that signed this don't allow signing */
  NotSigningKey = "NOT_SIGNING_KEY",
  /** Email used for signing not known to GitHub */
  NoUser = "NO_USER",
  /** Valid signature, though certificate revocation check failed */
  OcspError = "OCSP_ERROR",
  /** Valid signature, pending certificate revocation checking */
  OcspPending = "OCSP_PENDING",
  /** One or more certificates in chain has been revoked */
  OcspRevoked = "OCSP_REVOKED",
  /** Key used for signing not known to GitHub */
  UnknownKey = "UNKNOWN_KEY",
  /** Unknown signature type */
  UnknownSigType = "UNKNOWN_SIG_TYPE",
  /** Unsigned */
  Unsigned = "UNSIGNED",
  /** Email used for signing unverified on GitHub */
  UnverifiedEmail = "UNVERIFIED_EMAIL",
  /** Valid signature and verified by GitHub */
  Valid = "VALID",
}

/** Represents a GPG signature on a Commit or Tag. */
export type GpgSignature = GitSignature & {
  __typename?: "GpgSignature";
  /** Email used to sign this object. */
  email: Scalars["String"]["output"];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars["Boolean"]["output"];
  /** Hex-encoded ID of the key that signed this object. */
  keyId?: Maybe<Scalars["String"]["output"]>;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars["String"]["output"];
  /** ASCII-armored signature header from object. */
  signature: Scalars["String"]["output"];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars["Boolean"]["output"];
};

/** Autogenerated input type of GrantEnterpriseOrganizationsMigratorRole */
export type GrantEnterpriseOrganizationsMigratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */
  enterpriseId: Scalars["ID"]["input"];
  /** The login of the user to grant the migrator role */
  login: Scalars["String"]["input"];
};

/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole. */
export type GrantEnterpriseOrganizationsMigratorRolePayload = {
  __typename?: "GrantEnterpriseOrganizationsMigratorRolePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The organizations that had the migrator role applied to for the given user. */
  organizations?: Maybe<OrganizationConnection>;
};

/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole. */
export type GrantEnterpriseOrganizationsMigratorRolePayloadOrganizationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Autogenerated input type of GrantMigratorRole */
export type GrantMigratorRoleInput = {
  /** The user login or Team slug to grant the migrator role. */
  actor: Scalars["String"]["input"];
  /** Specifies the type of the actor, can be either USER or TEAM. */
  actorType: ActorType;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the organization that the user/team belongs to. */
  organizationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of GrantMigratorRole. */
export type GrantMigratorRolePayload = {
  __typename?: "GrantMigratorRolePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars["Boolean"]["output"]>;
};

/** Represents a 'head_ref_deleted' event on a given pull request. */
export type HeadRefDeletedEvent = Node & {
  __typename?: "HeadRefDeletedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the Ref associated with the `head_ref_deleted` event. */
  headRef?: Maybe<Ref>;
  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */
  headRefName: Scalars["String"]["output"];
  /** The Node ID of the HeadRefDeletedEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Represents a 'head_ref_force_pushed' event on a given pull request. */
export type HeadRefForcePushedEvent = Node & {
  __typename?: "HeadRefForcePushedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */
  afterCommit?: Maybe<Commit>;
  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */
  beforeCommit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the HeadRefForcePushedEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */
  ref?: Maybe<Ref>;
};

/** Represents a 'head_ref_restored' event on a given pull request. */
export type HeadRefRestoredEvent = Node & {
  __typename?: "HeadRefRestoredEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the HeadRefRestoredEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Detail needed to display a hovercard for a user */
export type Hovercard = {
  __typename?: "Hovercard";
  /** Each of the contexts for this hovercard */
  contexts: Array<HovercardContext>;
};

/** An individual line of a hovercard */
export type HovercardContext = {
  /** A string describing this context */
  message: Scalars["String"]["output"];
  /** An octicon to accompany this context */
  octicon: Scalars["String"]["output"];
};

/** The possible states in which authentication can be configured with an identity provider. */
export enum IdentityProviderConfigurationState {
  /** Authentication with an identity provider is configured but not enforced. */
  Configured = "CONFIGURED",
  /** Authentication with an identity provider is configured and enforced. */
  Enforced = "ENFORCED",
  /** Authentication with an identity provider is not configured. */
  Unconfigured = "UNCONFIGURED",
}

/** Autogenerated input type of ImportProject */
export type ImportProjectInput = {
  /** The description of Project. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A list of columns containing issues and pull requests. */
  columnImports: Array<ProjectColumnImport>;
  /** The name of Project. */
  name: Scalars["String"]["input"];
  /** The name of the Organization or User to create the Project under. */
  ownerName: Scalars["String"]["input"];
  /** Whether the Project is public or not. */
  public?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Autogenerated return type of ImportProject. */
export type ImportProjectPayload = {
  __typename?: "ImportProjectPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new Project! */
  project?: Maybe<Project>;
};

/** Autogenerated input type of InviteEnterpriseAdmin */
export type InviteEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The email of the person to invite as an administrator. */
  email?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise to which you want to invite an administrator. */
  enterpriseId: Scalars["ID"]["input"];
  /** The login of a user to invite as an administrator. */
  invitee?: InputMaybe<Scalars["String"]["input"]>;
  /** The role of the administrator. */
  role?: InputMaybe<EnterpriseAdministratorRole>;
};

/** Autogenerated return type of InviteEnterpriseAdmin. */
export type InviteEnterpriseAdminPayload = {
  __typename?: "InviteEnterpriseAdminPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The created enterprise administrator invitation. */
  invitation?: Maybe<EnterpriseAdministratorInvitation>;
};

/** Autogenerated input type of InviteEnterpriseMember */
export type InviteEnterpriseMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The email of the person to invite as an unaffiliated member. */
  email?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise to which you want to invite an unaffiliated member. */
  enterpriseId: Scalars["ID"]["input"];
  /** The login of a user to invite as an unaffiliated member. */
  invitee?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of InviteEnterpriseMember. */
export type InviteEnterpriseMemberPayload = {
  __typename?: "InviteEnterpriseMemberPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The created enterprise member invitation. */
  invitation?: Maybe<EnterpriseMemberInvitation>;
};

/** The possible values for the IP allow list enabled setting. */
export enum IpAllowListEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = "DISABLED",
  /** The setting is enabled for the owner. */
  Enabled = "ENABLED",
}

/** An IP address or range of addresses that is allowed to access an owner's resources. */
export type IpAllowListEntry = Node & {
  __typename?: "IpAllowListEntry";
  /** A single IP address or range of IP addresses in CIDR notation. */
  allowListValue: Scalars["String"]["output"];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the IpAllowListEntry object */
  id: Scalars["ID"]["output"];
  /** Whether the entry is currently active. */
  isActive: Scalars["Boolean"]["output"];
  /** The name of the IP allow list entry. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The owner of the IP allow list entry. */
  owner: IpAllowListOwner;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** The connection type for IpAllowListEntry. */
export type IpAllowListEntryConnection = {
  __typename?: "IpAllowListEntryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IpAllowListEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IpAllowListEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type IpAllowListEntryEdge = {
  __typename?: "IpAllowListEntryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<IpAllowListEntry>;
};

/** Ordering options for IP allow list entry connections. */
export type IpAllowListEntryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order IP allow list entries by. */
  field: IpAllowListEntryOrderField;
};

/** Properties by which IP allow list entry connections can be ordered. */
export enum IpAllowListEntryOrderField {
  /** Order IP allow list entries by the allow list value. */
  AllowListValue = "ALLOW_LIST_VALUE",
  /** Order IP allow list entries by creation time. */
  CreatedAt = "CREATED_AT",
}

/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */
export enum IpAllowListForInstalledAppsEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = "DISABLED",
  /** The setting is enabled for the owner. */
  Enabled = "ENABLED",
}

/** Types that can own an IP allow list. */
export type IpAllowListOwner = App | Enterprise | Organization;

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Issue = Assignable &
  Closable &
  Comment &
  Deletable &
  Labelable &
  Lockable &
  Node &
  ProjectV2Owner &
  Reactable &
  RepositoryNode &
  Subscribable &
  SubscribableThread &
  UniformResourceLocatable &
  Updatable &
  UpdatableComment & {
    __typename?: "Issue";
    /** Reason that the conversation was locked. */
    activeLockReason?: Maybe<LockReason>;
    /** A list of Users assigned to this object. */
    assignees: UserConnection;
    /** The actor who authored the comment. */
    author?: Maybe<Actor>;
    /** Author's association with the subject of the comment. */
    authorAssociation: CommentAuthorAssociation;
    /** Identifies the body of the issue. */
    body: Scalars["String"]["output"];
    /** The body rendered to HTML. */
    bodyHTML: Scalars["HTML"]["output"];
    /** The http path for this issue body */
    bodyResourcePath: Scalars["URI"]["output"];
    /** Identifies the body of the issue rendered to text. */
    bodyText: Scalars["String"]["output"];
    /** The http URL for this issue body */
    bodyUrl: Scalars["URI"]["output"];
    /** Indicates if the object is closed (definition of closed may depend on type) */
    closed: Scalars["Boolean"]["output"];
    /** Identifies the date and time when the object was closed. */
    closedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** List of open pull requests referenced from this issue */
    closedByPullRequestsReferences?: Maybe<PullRequestConnection>;
    /** A list of comments associated with the Issue. */
    comments: IssueCommentConnection;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail: Scalars["Boolean"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The actor who edited the comment. */
    editor?: Maybe<Actor>;
    /** Identifies the primary key from the database as a BigInt. */
    fullDatabaseId?: Maybe<Scalars["BigInt"]["output"]>;
    /** The hovercard information for this issue */
    hovercard: Hovercard;
    /** The Node ID of the Issue object */
    id: Scalars["ID"]["output"];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit: Scalars["Boolean"]["output"];
    /** Indicates whether or not this issue is currently pinned to the repository issues list */
    isPinned?: Maybe<Scalars["Boolean"]["output"]>;
    /** Is this issue read by the viewer */
    isReadByViewer?: Maybe<Scalars["Boolean"]["output"]>;
    /** A list of labels associated with the object. */
    labels?: Maybe<LabelConnection>;
    /** The moment the editor made the last edit */
    lastEditedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** Branches linked to this issue. */
    linkedBranches: LinkedBranchConnection;
    /** `true` if the object is locked */
    locked: Scalars["Boolean"]["output"];
    /** Identifies the milestone associated with the issue. */
    milestone?: Maybe<Milestone>;
    /** Identifies the issue number. */
    number: Scalars["Int"]["output"];
    /** A list of Users that are participating in the Issue conversation. */
    participants: UserConnection;
    /** List of project cards associated with this issue. */
    projectCards: ProjectCardConnection;
    /** List of project items associated with this issue. */
    projectItems: ProjectV2ItemConnection;
    /** Find a project by number. */
    projectV2?: Maybe<ProjectV2>;
    /** A list of projects under the owner. */
    projectsV2: ProjectV2Connection;
    /** Identifies when the comment was published at. */
    publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: Maybe<Array<ReactionGroup>>;
    /** A list of Reactions left on the Issue. */
    reactions: ReactionConnection;
    /** The repository associated with this node. */
    repository: Repository;
    /** The HTTP path for this issue */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the state of the issue. */
    state: IssueState;
    /** Identifies the reason for the issue state. */
    stateReason?: Maybe<IssueStateReason>;
    /**
     * A list of events, comments, commits, etc. associated with the issue.
     * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.
     */
    timeline: IssueTimelineConnection;
    /** A list of events, comments, commits, etc. associated with the issue. */
    timelineItems: IssueTimelineItemsConnection;
    /** Identifies the issue title. */
    title: Scalars["String"]["output"];
    /** Identifies the issue title rendered to HTML. */
    titleHTML: Scalars["String"]["output"];
    /** A list of issues that track this issue */
    trackedInIssues: IssueConnection;
    /** A list of issues tracked inside the current issue */
    trackedIssues: IssueConnection;
    /** The number of tracked issues for this issue */
    trackedIssuesCount: Scalars["Int"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this issue */
    url: Scalars["URI"]["output"];
    /** A list of edits to this content. */
    userContentEdits?: Maybe<UserContentEditConnection>;
    /** Indicates if the object can be closed by the viewer. */
    viewerCanClose: Scalars["Boolean"]["output"];
    /** Check if the current viewer can delete this object. */
    viewerCanDelete: Scalars["Boolean"]["output"];
    /** Indicates if the viewer can edit labels for this object. */
    viewerCanLabel: Scalars["Boolean"]["output"];
    /** Can user react to this subject */
    viewerCanReact: Scalars["Boolean"]["output"];
    /** Indicates if the object can be reopened by the viewer. */
    viewerCanReopen: Scalars["Boolean"]["output"];
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
    /** Did the viewer author this comment. */
    viewerDidAuthor: Scalars["Boolean"]["output"];
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: Maybe<SubscriptionState>;
    /** Identifies the viewer's thread subscription form action. */
    viewerThreadSubscriptionFormAction?: Maybe<ThreadSubscriptionFormAction>;
    /** Identifies the viewer's thread subscription status. */
    viewerThreadSubscriptionStatus?: Maybe<ThreadSubscriptionState>;
  };

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueAssigneesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueClosedByPullRequestsReferencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includeClosedPrs?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderByState?: InputMaybe<Scalars["Boolean"]["input"]>;
  userLinkedOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueCommentOrder>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueHovercardArgs = {
  includeNotificationContexts?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueLabelsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<LabelOrder>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueLinkedBranchesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueParticipantsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueProjectCardsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueProjectItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includeArchived?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueProjectV2Args = {
  number: Scalars["Int"]["input"];
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueProjectsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  minPermissionLevel?: InputMaybe<ProjectV2PermissionLevel>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueTimelineArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  since?: InputMaybe<Scalars["DateTime"]["input"]>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueTimelineItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  itemTypes?: InputMaybe<Array<IssueTimelineItemsItemType>>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  since?: InputMaybe<Scalars["DateTime"]["input"]>;
  skip?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueTrackedInIssuesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueTrackedIssuesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueTrackedIssuesCountArgs = {
  states?: InputMaybe<Array<InputMaybe<TrackedIssueStates>>>;
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueUserContentEditsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The possible state reasons of a closed issue. */
export enum IssueClosedStateReason {
  /** An issue that has been closed as completed */
  Completed = "COMPLETED",
  /** An issue that has been closed as not planned */
  NotPlanned = "NOT_PLANNED",
}

/** Represents a comment on an Issue. */
export type IssueComment = Comment &
  Deletable &
  Minimizable &
  Node &
  Reactable &
  RepositoryNode &
  Updatable &
  UpdatableComment & {
    __typename?: "IssueComment";
    /** The actor who authored the comment. */
    author?: Maybe<Actor>;
    /** Author's association with the subject of the comment. */
    authorAssociation: CommentAuthorAssociation;
    /** The body as Markdown. */
    body: Scalars["String"]["output"];
    /** The body rendered to HTML. */
    bodyHTML: Scalars["HTML"]["output"];
    /** The body rendered to text. */
    bodyText: Scalars["String"]["output"];
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail: Scalars["Boolean"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The actor who edited the comment. */
    editor?: Maybe<Actor>;
    /** Identifies the primary key from the database as a BigInt. */
    fullDatabaseId?: Maybe<Scalars["BigInt"]["output"]>;
    /** The Node ID of the IssueComment object */
    id: Scalars["ID"]["output"];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit: Scalars["Boolean"]["output"];
    /** Returns whether or not a comment has been minimized. */
    isMinimized: Scalars["Boolean"]["output"];
    /** Identifies the issue associated with the comment. */
    issue: Issue;
    /** The moment the editor made the last edit */
    lastEditedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /**
     * Returns why the comment was minimized. One of `abuse`, `off-topic`,
     * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
     * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
     */
    minimizedReason?: Maybe<Scalars["String"]["output"]>;
    /** Identifies when the comment was published at. */
    publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /**
     * Returns the pull request associated with the comment, if this comment was made on a
     * pull request.
     */
    pullRequest?: Maybe<PullRequest>;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: Maybe<Array<ReactionGroup>>;
    /** A list of Reactions left on the Issue. */
    reactions: ReactionConnection;
    /** The repository associated with this node. */
    repository: Repository;
    /** The HTTP path for this issue comment */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this issue comment */
    url: Scalars["URI"]["output"];
    /** A list of edits to this content. */
    userContentEdits?: Maybe<UserContentEditConnection>;
    /** Check if the current viewer can delete this object. */
    viewerCanDelete: Scalars["Boolean"]["output"];
    /** Check if the current viewer can minimize this object. */
    viewerCanMinimize: Scalars["Boolean"]["output"];
    /** Can user react to this subject */
    viewerCanReact: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
    /** Did the viewer author this comment. */
    viewerDidAuthor: Scalars["Boolean"]["output"];
  };

/** Represents a comment on an Issue. */
export type IssueCommentReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** Represents a comment on an Issue. */
export type IssueCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for IssueComment. */
export type IssueCommentConnection = {
  __typename?: "IssueCommentConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssueCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IssueComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type IssueCommentEdge = {
  __typename?: "IssueCommentEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<IssueComment>;
};

/** Ways in which lists of issue comments can be ordered upon return. */
export type IssueCommentOrder = {
  /** The direction in which to order issue comments by the specified field. */
  direction: OrderDirection;
  /** The field in which to order issue comments by. */
  field: IssueCommentOrderField;
};

/** Properties by which issue comment connections can be ordered. */
export enum IssueCommentOrderField {
  /** Order issue comments by update time */
  UpdatedAt = "UPDATED_AT",
}

/** The connection type for Issue. */
export type IssueConnection = {
  __typename?: "IssueConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Issue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** This aggregates issues opened by a user within one repository. */
export type IssueContributionsByRepository = {
  __typename?: "IssueContributionsByRepository";
  /** The issue contributions. */
  contributions: CreatedIssueContributionConnection;
  /** The repository in which the issues were opened. */
  repository: Repository;
};

/** This aggregates issues opened by a user within one repository. */
export type IssueContributionsByRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** An edge in a connection. */
export type IssueEdge = {
  __typename?: "IssueEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Issue>;
};

/** Ways in which to filter lists of issues. */
export type IssueFilters = {
  /**
   * List issues assigned to given name. Pass in `null` for issues with no assigned
   * user, and `*` for issues assigned to any user.
   */
  assignee?: InputMaybe<Scalars["String"]["input"]>;
  /** List issues created by given name. */
  createdBy?: InputMaybe<Scalars["String"]["input"]>;
  /** List issues where the list of label names exist on the issue. */
  labels?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** List issues where the given name is mentioned in the issue. */
  mentioned?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its database ID. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestone?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its number field. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestoneNumber?: InputMaybe<Scalars["String"]["input"]>;
  /** List issues that have been updated at or after the given date. */
  since?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** List issues filtered by the list of states given. */
  states?: InputMaybe<Array<IssueState>>;
  /** List issues subscribed to by viewer. */
  viewerSubscribed?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Used for return value of Repository.issueOrPullRequest. */
export type IssueOrPullRequest = Issue | PullRequest;

/** Ways in which lists of issues can be ordered upon return. */
export type IssueOrder = {
  /** The direction in which to order issues by the specified field. */
  direction: OrderDirection;
  /** The field in which to order issues by. */
  field: IssueOrderField;
};

/** Properties by which issue connections can be ordered. */
export enum IssueOrderField {
  /** Order issues by comment count */
  Comments = "COMMENTS",
  /** Order issues by creation time */
  CreatedAt = "CREATED_AT",
  /** Order issues by update time */
  UpdatedAt = "UPDATED_AT",
}

/** The possible states of an issue. */
export enum IssueState {
  /** An issue that has been closed */
  Closed = "CLOSED",
  /** An issue that is still open */
  Open = "OPEN",
}

/** The possible state reasons of an issue. */
export enum IssueStateReason {
  /** An issue that has been closed as completed */
  Completed = "COMPLETED",
  /** An issue that has been closed as not planned */
  NotPlanned = "NOT_PLANNED",
  /** An issue that has been reopened */
  Reopened = "REOPENED",
}

/** A repository issue template. */
export type IssueTemplate = {
  __typename?: "IssueTemplate";
  /** The template purpose. */
  about?: Maybe<Scalars["String"]["output"]>;
  /** The suggested assignees. */
  assignees: UserConnection;
  /** The suggested issue body. */
  body?: Maybe<Scalars["String"]["output"]>;
  /** The template filename. */
  filename: Scalars["String"]["output"];
  /** The suggested issue labels */
  labels?: Maybe<LabelConnection>;
  /** The template name. */
  name: Scalars["String"]["output"];
  /** The suggested issue title. */
  title?: Maybe<Scalars["String"]["output"]>;
};

/** A repository issue template. */
export type IssueTemplateAssigneesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository issue template. */
export type IssueTemplateLabelsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<LabelOrder>;
};

/** The connection type for IssueTimelineItem. */
export type IssueTimelineConnection = {
  __typename?: "IssueTimelineConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssueTimelineItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IssueTimelineItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An item in an issue timeline */
export type IssueTimelineItem =
  | AssignedEvent
  | ClosedEvent
  | Commit
  | CrossReferencedEvent
  | DemilestonedEvent
  | IssueComment
  | LabeledEvent
  | LockedEvent
  | MilestonedEvent
  | ReferencedEvent
  | RenamedTitleEvent
  | ReopenedEvent
  | SubscribedEvent
  | TransferredEvent
  | UnassignedEvent
  | UnlabeledEvent
  | UnlockedEvent
  | UnsubscribedEvent
  | UserBlockedEvent;

/** An edge in a connection. */
export type IssueTimelineItemEdge = {
  __typename?: "IssueTimelineItemEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<IssueTimelineItem>;
};

/** An item in an issue timeline */
export type IssueTimelineItems =
  | AddedToProjectEvent
  | AssignedEvent
  | ClosedEvent
  | CommentDeletedEvent
  | ConnectedEvent
  | ConvertedNoteToIssueEvent
  | ConvertedToDiscussionEvent
  | CrossReferencedEvent
  | DemilestonedEvent
  | DisconnectedEvent
  | IssueComment
  | LabeledEvent
  | LockedEvent
  | MarkedAsDuplicateEvent
  | MentionedEvent
  | MilestonedEvent
  | MovedColumnsInProjectEvent
  | PinnedEvent
  | ReferencedEvent
  | RemovedFromProjectEvent
  | RenamedTitleEvent
  | ReopenedEvent
  | SubscribedEvent
  | TransferredEvent
  | UnassignedEvent
  | UnlabeledEvent
  | UnlockedEvent
  | UnmarkedAsDuplicateEvent
  | UnpinnedEvent
  | UnsubscribedEvent
  | UserBlockedEvent;

/** The connection type for IssueTimelineItems. */
export type IssueTimelineItemsConnection = {
  __typename?: "IssueTimelineItemsConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssueTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars["Int"]["output"];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IssueTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars["Int"]["output"];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** An edge in a connection. */
export type IssueTimelineItemsEdge = {
  __typename?: "IssueTimelineItemsEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<IssueTimelineItems>;
};

/** The possible item types found in a timeline. */
export enum IssueTimelineItemsItemType {
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = "ADDED_TO_PROJECT_EVENT",
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = "ASSIGNED_EVENT",
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = "CLOSED_EVENT",
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = "COMMENT_DELETED_EVENT",
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = "CONNECTED_EVENT",
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = "CONVERTED_NOTE_TO_ISSUE_EVENT",
  /** Represents a 'converted_to_discussion' event on a given issue. */
  ConvertedToDiscussionEvent = "CONVERTED_TO_DISCUSSION_EVENT",
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = "CROSS_REFERENCED_EVENT",
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = "DEMILESTONED_EVENT",
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = "DISCONNECTED_EVENT",
  /** Represents a comment on an Issue. */
  IssueComment = "ISSUE_COMMENT",
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = "LABELED_EVENT",
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = "LOCKED_EVENT",
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = "MARKED_AS_DUPLICATE_EVENT",
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = "MENTIONED_EVENT",
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = "MILESTONED_EVENT",
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = "MOVED_COLUMNS_IN_PROJECT_EVENT",
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = "PINNED_EVENT",
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = "REFERENCED_EVENT",
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = "REMOVED_FROM_PROJECT_EVENT",
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = "RENAMED_TITLE_EVENT",
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = "REOPENED_EVENT",
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = "SUBSCRIBED_EVENT",
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = "TRANSFERRED_EVENT",
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = "UNASSIGNED_EVENT",
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = "UNLABELED_EVENT",
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = "UNLOCKED_EVENT",
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = "UNMARKED_AS_DUPLICATE_EVENT",
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = "UNPINNED_EVENT",
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = "UNSUBSCRIBED_EVENT",
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = "USER_BLOCKED_EVENT",
}

/** Represents a user signing up for a GitHub account. */
export type JoinedGitHubContribution = Contribution & {
  __typename?: "JoinedGitHubContribution";
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars["Boolean"]["output"];
  /** When this contribution was made. */
  occurredAt: Scalars["DateTime"]["output"];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for this contribution. */
  url: Scalars["URI"]["output"];
  /** The user who made this contribution. */
  user: User;
};

/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type Label = Node & {
  __typename?: "Label";
  /** Identifies the label color. */
  color: Scalars["String"]["output"];
  /** Identifies the date and time when the label was created. */
  createdAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** A brief description of this label. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The Node ID of the Label object */
  id: Scalars["ID"]["output"];
  /** Indicates whether or not this is a default label. */
  isDefault: Scalars["Boolean"]["output"];
  /** A list of issues associated with this label. */
  issues: IssueConnection;
  /** Identifies the label name. */
  name: Scalars["String"]["output"];
  /** A list of pull requests associated with this label. */
  pullRequests: PullRequestConnection;
  /** The repository associated with this label. */
  repository: Repository;
  /** The HTTP path for this label. */
  resourcePath: Scalars["URI"]["output"];
  /** Identifies the date and time when the label was last updated. */
  updatedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The HTTP URL for this label. */
  url: Scalars["URI"]["output"];
};

/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type LabelIssuesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filterBy?: InputMaybe<IssueFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  labels?: InputMaybe<Array<Scalars["String"]["input"]>>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<IssueState>>;
};

/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type LabelPullRequestsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  baseRefName?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  headRefName?: InputMaybe<Scalars["String"]["input"]>;
  labels?: InputMaybe<Array<Scalars["String"]["input"]>>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<PullRequestState>>;
};

/** The connection type for Label. */
export type LabelConnection = {
  __typename?: "LabelConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LabelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Label>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type LabelEdge = {
  __typename?: "LabelEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Label>;
};

/** Ways in which lists of labels can be ordered upon return. */
export type LabelOrder = {
  /** The direction in which to order labels by the specified field. */
  direction: OrderDirection;
  /** The field in which to order labels by. */
  field: LabelOrderField;
};

/** Properties by which label connections can be ordered. */
export enum LabelOrderField {
  /** Order labels by creation time */
  CreatedAt = "CREATED_AT",
  /** Order labels by name */
  Name = "NAME",
}

/** An object that can have labels assigned to it. */
export type Labelable = {
  /** A list of labels associated with the object. */
  labels?: Maybe<LabelConnection>;
  /** Indicates if the viewer can edit labels for this object. */
  viewerCanLabel: Scalars["Boolean"]["output"];
};

/** An object that can have labels assigned to it. */
export type LabelableLabelsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<LabelOrder>;
};

/** Represents a 'labeled' event on a given issue or pull request. */
export type LabeledEvent = Node & {
  __typename?: "LabeledEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the LabeledEvent object */
  id: Scalars["ID"]["output"];
  /** Identifies the label associated with the 'labeled' event. */
  label: Label;
  /** Identifies the `Labelable` associated with the event. */
  labelable: Labelable;
};

/** Represents a given language found in repositories. */
export type Language = Node & {
  __typename?: "Language";
  /** The color defined for the current language. */
  color?: Maybe<Scalars["String"]["output"]>;
  /** The Node ID of the Language object */
  id: Scalars["ID"]["output"];
  /** The name of the current language. */
  name: Scalars["String"]["output"];
};

/** A list of languages associated with the parent. */
export type LanguageConnection = {
  __typename?: "LanguageConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LanguageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Language>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
  /** The total size in bytes of files written in that language. */
  totalSize: Scalars["Int"]["output"];
};

/** Represents the language of a repository. */
export type LanguageEdge = {
  __typename?: "LanguageEdge";
  cursor: Scalars["String"]["output"];
  node: Language;
  /** The number of bytes of code written in the language. */
  size: Scalars["Int"]["output"];
};

/** Ordering options for language connections. */
export type LanguageOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order languages by. */
  field: LanguageOrderField;
};

/** Properties by which language connections can be ordered. */
export enum LanguageOrderField {
  /** Order languages by the size of all files containing the language */
  Size = "SIZE",
}

/** A repository's open source license */
export type License = Node & {
  __typename?: "License";
  /** The full text of the license */
  body: Scalars["String"]["output"];
  /** The conditions set by the license */
  conditions: Array<Maybe<LicenseRule>>;
  /** A human-readable description of the license */
  description?: Maybe<Scalars["String"]["output"]>;
  /** Whether the license should be featured */
  featured: Scalars["Boolean"]["output"];
  /** Whether the license should be displayed in license pickers */
  hidden: Scalars["Boolean"]["output"];
  /** The Node ID of the License object */
  id: Scalars["ID"]["output"];
  /** Instructions on how to implement the license */
  implementation?: Maybe<Scalars["String"]["output"]>;
  /** The lowercased SPDX ID of the license */
  key: Scalars["String"]["output"];
  /** The limitations set by the license */
  limitations: Array<Maybe<LicenseRule>>;
  /** The license full name specified by <https://spdx.org/licenses> */
  name: Scalars["String"]["output"];
  /** Customary short name if applicable (e.g, GPLv3) */
  nickname?: Maybe<Scalars["String"]["output"]>;
  /** The permissions set by the license */
  permissions: Array<Maybe<LicenseRule>>;
  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */
  pseudoLicense: Scalars["Boolean"]["output"];
  /** Short identifier specified by <https://spdx.org/licenses> */
  spdxId?: Maybe<Scalars["String"]["output"]>;
  /** URL to the license on <https://choosealicense.com> */
  url?: Maybe<Scalars["URI"]["output"]>;
};

/** Describes a License's conditions, permissions, and limitations */
export type LicenseRule = {
  __typename?: "LicenseRule";
  /** A description of the rule */
  description: Scalars["String"]["output"];
  /** The machine-readable rule key */
  key: Scalars["String"]["output"];
  /** The human-readable rule label */
  label: Scalars["String"]["output"];
};

/** Autogenerated input type of LinkProjectV2ToRepository */
export type LinkProjectV2ToRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the project to link to the repository. */
  projectId: Scalars["ID"]["input"];
  /** The ID of the repository to link to the project. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of LinkProjectV2ToRepository. */
export type LinkProjectV2ToRepositoryPayload = {
  __typename?: "LinkProjectV2ToRepositoryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The repository the project is linked to. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of LinkProjectV2ToTeam */
export type LinkProjectV2ToTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the project to link to the team. */
  projectId: Scalars["ID"]["input"];
  /** The ID of the team to link to the project. */
  teamId: Scalars["ID"]["input"];
};

/** Autogenerated return type of LinkProjectV2ToTeam. */
export type LinkProjectV2ToTeamPayload = {
  __typename?: "LinkProjectV2ToTeamPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The team the project is linked to */
  team?: Maybe<Team>;
};

/** Autogenerated input type of LinkRepositoryToProject */
export type LinkRepositoryToProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Project to link to a Repository */
  projectId: Scalars["ID"]["input"];
  /** The ID of the Repository to link to a Project. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of LinkRepositoryToProject. */
export type LinkRepositoryToProjectPayload = {
  __typename?: "LinkRepositoryToProjectPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The linked Project. */
  project?: Maybe<Project>;
  /** The linked Repository. */
  repository?: Maybe<Repository>;
};

/** A branch linked to an issue. */
export type LinkedBranch = Node & {
  __typename?: "LinkedBranch";
  /** The Node ID of the LinkedBranch object */
  id: Scalars["ID"]["output"];
  /** The branch's ref. */
  ref?: Maybe<Ref>;
};

/** A list of branches linked to an issue. */
export type LinkedBranchConnection = {
  __typename?: "LinkedBranchConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LinkedBranchEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LinkedBranch>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type LinkedBranchEdge = {
  __typename?: "LinkedBranchEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<LinkedBranch>;
};

/** Autogenerated input type of LockLockable */
export type LockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A reason for why the item will be locked. */
  lockReason?: InputMaybe<LockReason>;
  /** ID of the item to be locked. */
  lockableId: Scalars["ID"]["input"];
};

/** Autogenerated return type of LockLockable. */
export type LockLockablePayload = {
  __typename?: "LockLockablePayload";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The item that was locked. */
  lockedRecord?: Maybe<Lockable>;
};

/** The possible reasons that an issue or pull request was locked. */
export enum LockReason {
  /** The issue or pull request was locked because the conversation was off-topic. */
  OffTopic = "OFF_TOPIC",
  /** The issue or pull request was locked because the conversation was resolved. */
  Resolved = "RESOLVED",
  /** The issue or pull request was locked because the conversation was spam. */
  Spam = "SPAM",
  /** The issue or pull request was locked because the conversation was too heated. */
  TooHeated = "TOO_HEATED",
}

/** An object that can be locked. */
export type Lockable = {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<LockReason>;
  /** `true` if the object is locked */
  locked: Scalars["Boolean"]["output"];
};

/** Represents a 'locked' event on a given issue or pull request. */
export type LockedEvent = Node & {
  __typename?: "LockedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the LockedEvent object */
  id: Scalars["ID"]["output"];
  /** Reason that the conversation was locked (optional). */
  lockReason?: Maybe<LockReason>;
  /** Object that was locked. */
  lockable: Lockable;
};

/** A placeholder user for attribution of imported data on GitHub. */
export type Mannequin = Actor &
  Node &
  UniformResourceLocatable & {
    __typename?: "Mannequin";
    /** A URL pointing to the GitHub App's public avatar. */
    avatarUrl: Scalars["URI"]["output"];
    /** The user that has claimed the data attributed to this mannequin. */
    claimant?: Maybe<User>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The mannequin's email on the source instance. */
    email?: Maybe<Scalars["String"]["output"]>;
    /** The Node ID of the Mannequin object */
    id: Scalars["ID"]["output"];
    /** The username of the actor. */
    login: Scalars["String"]["output"];
    /** The HTML path to this resource. */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The URL to this resource. */
    url: Scalars["URI"]["output"];
  };

/** A placeholder user for attribution of imported data on GitHub. */
export type MannequinAvatarUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A list of mannequins. */
export type MannequinConnection = {
  __typename?: "MannequinConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MannequinEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Mannequin>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Represents a mannequin. */
export type MannequinEdge = {
  __typename?: "MannequinEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Mannequin>;
};

/** Ordering options for mannequins. */
export type MannequinOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order mannequins by. */
  field: MannequinOrderField;
};

/** Properties by which mannequins can be ordered. */
export enum MannequinOrderField {
  /** Order mannequins why when they were created. */
  CreatedAt = "CREATED_AT",
  /** Order mannequins alphabetically by their source login. */
  Login = "LOGIN",
}

/** Autogenerated input type of MarkDiscussionCommentAsAnswer */
export type MarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the discussion comment to mark as an answer. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of MarkDiscussionCommentAsAnswer. */
export type MarkDiscussionCommentAsAnswerPayload = {
  __typename?: "MarkDiscussionCommentAsAnswerPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The discussion that includes the chosen comment. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of MarkFileAsViewed */
export type MarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The path of the file to mark as viewed */
  path: Scalars["String"]["input"];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars["ID"]["input"];
};

/** Autogenerated return type of MarkFileAsViewed. */
export type MarkFileAsViewedPayload = {
  __typename?: "MarkFileAsViewedPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated pull request. */
  pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of MarkNotificationAsDone */
export type MarkNotificationAsDoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The NotificationThread id. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of MarkNotificationAsDone. */
export type MarkNotificationAsDonePayload = {
  __typename?: "MarkNotificationAsDonePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars["Boolean"]["output"]>;
  /** The user that the notification belongs to. */
  viewer?: Maybe<User>;
};

/** Autogenerated input type of MarkProjectV2AsTemplate */
export type MarkProjectV2AsTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Project to mark as a template. */
  projectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of MarkProjectV2AsTemplate. */
export type MarkProjectV2AsTemplatePayload = {
  __typename?: "MarkProjectV2AsTemplatePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The project. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of MarkPullRequestReadyForReview */
export type MarkPullRequestReadyForReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the pull request to be marked as ready for review. */
  pullRequestId: Scalars["ID"]["input"];
};

/** Autogenerated return type of MarkPullRequestReadyForReview. */
export type MarkPullRequestReadyForReviewPayload = {
  __typename?: "MarkPullRequestReadyForReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The pull request that is ready for review. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
export type MarkedAsDuplicateEvent = Node & {
  __typename?: "MarkedAsDuplicateEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** The authoritative issue or pull request which has been duplicated by another. */
  canonical?: Maybe<IssueOrPullRequest>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The issue or pull request which has been marked as a duplicate of another. */
  duplicate?: Maybe<IssueOrPullRequest>;
  /** The Node ID of the MarkedAsDuplicateEvent object */
  id: Scalars["ID"]["output"];
  /** Canonical and duplicate belong to different repositories. */
  isCrossRepository: Scalars["Boolean"]["output"];
};

/** A public description of a Marketplace category. */
export type MarketplaceCategory = Node & {
  __typename?: "MarketplaceCategory";
  /** The category's description. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The technical description of how apps listed in this category work with GitHub. */
  howItWorks?: Maybe<Scalars["String"]["output"]>;
  /** The Node ID of the MarketplaceCategory object */
  id: Scalars["ID"]["output"];
  /** The category's name. */
  name: Scalars["String"]["output"];
  /** How many Marketplace listings have this as their primary category. */
  primaryListingCount: Scalars["Int"]["output"];
  /** The HTTP path for this Marketplace category. */
  resourcePath: Scalars["URI"]["output"];
  /** How many Marketplace listings have this as their secondary category. */
  secondaryListingCount: Scalars["Int"]["output"];
  /** The short name of the category used in its URL. */
  slug: Scalars["String"]["output"];
  /** The HTTP URL for this Marketplace category. */
  url: Scalars["URI"]["output"];
};

/** A listing in the GitHub integration marketplace. */
export type MarketplaceListing = Node & {
  __typename?: "MarketplaceListing";
  /** The GitHub App this listing represents. */
  app?: Maybe<App>;
  /** URL to the listing owner's company site. */
  companyUrl?: Maybe<Scalars["URI"]["output"]>;
  /** The HTTP path for configuring access to the listing's integration or OAuth app */
  configurationResourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for configuring access to the listing's integration or OAuth app */
  configurationUrl: Scalars["URI"]["output"];
  /** URL to the listing's documentation. */
  documentationUrl?: Maybe<Scalars["URI"]["output"]>;
  /** The listing's detailed description. */
  extendedDescription?: Maybe<Scalars["String"]["output"]>;
  /** The listing's detailed description rendered to HTML. */
  extendedDescriptionHTML: Scalars["HTML"]["output"];
  /** The listing's introductory description. */
  fullDescription: Scalars["String"]["output"];
  /** The listing's introductory description rendered to HTML. */
  fullDescriptionHTML: Scalars["HTML"]["output"];
  /** Does this listing have any plans with a free trial? */
  hasPublishedFreeTrialPlans: Scalars["Boolean"]["output"];
  /** Does this listing have a terms of service link? */
  hasTermsOfService: Scalars["Boolean"]["output"];
  /** Whether the creator of the app is a verified org */
  hasVerifiedOwner: Scalars["Boolean"]["output"];
  /** A technical description of how this app works with GitHub. */
  howItWorks?: Maybe<Scalars["String"]["output"]>;
  /** The listing's technical description rendered to HTML. */
  howItWorksHTML: Scalars["HTML"]["output"];
  /** The Node ID of the MarketplaceListing object */
  id: Scalars["ID"]["output"];
  /** URL to install the product to the viewer's account or organization. */
  installationUrl?: Maybe<Scalars["URI"]["output"]>;
  /** Whether this listing's app has been installed for the current viewer */
  installedForViewer: Scalars["Boolean"]["output"];
  /** Whether this listing has been removed from the Marketplace. */
  isArchived: Scalars["Boolean"]["output"];
  /**
   * Whether this listing is still an editable draft that has not been submitted
   * for review and is not publicly visible in the Marketplace.
   */
  isDraft: Scalars["Boolean"]["output"];
  /** Whether the product this listing represents is available as part of a paid plan. */
  isPaid: Scalars["Boolean"]["output"];
  /** Whether this listing has been approved for display in the Marketplace. */
  isPublic: Scalars["Boolean"]["output"];
  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */
  isRejected: Scalars["Boolean"]["output"];
  /** Whether this listing has been approved for unverified display in the Marketplace. */
  isUnverified: Scalars["Boolean"]["output"];
  /** Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace. */
  isUnverifiedPending: Scalars["Boolean"]["output"];
  /** Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromDraft: Scalars["Boolean"]["output"];
  /** Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromUnverified: Scalars["Boolean"]["output"];
  /** Whether this listing has been approved for verified display in the Marketplace. */
  isVerified: Scalars["Boolean"]["output"];
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars["String"]["output"];
  /** URL for the listing's logo image. */
  logoUrl?: Maybe<Scalars["URI"]["output"]>;
  /** The listing's full name. */
  name: Scalars["String"]["output"];
  /** The listing's very short description without a trailing period or ampersands. */
  normalizedShortDescription: Scalars["String"]["output"];
  /** URL to the listing's detailed pricing. */
  pricingUrl?: Maybe<Scalars["URI"]["output"]>;
  /** The category that best describes the listing. */
  primaryCategory: MarketplaceCategory;
  /** URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL. */
  privacyPolicyUrl: Scalars["URI"]["output"];
  /** The HTTP path for the Marketplace listing. */
  resourcePath: Scalars["URI"]["output"];
  /** The URLs for the listing's screenshots. */
  screenshotUrls: Array<Maybe<Scalars["String"]["output"]>>;
  /** An alternate category that describes the listing. */
  secondaryCategory?: Maybe<MarketplaceCategory>;
  /** The listing's very short description. */
  shortDescription: Scalars["String"]["output"];
  /** The short name of the listing used in its URL. */
  slug: Scalars["String"]["output"];
  /** URL to the listing's status page. */
  statusUrl?: Maybe<Scalars["URI"]["output"]>;
  /** An email address for support for this listing's app. */
  supportEmail?: Maybe<Scalars["String"]["output"]>;
  /**
   * Either a URL or an email address for support for this listing's app, may
   * return an empty string for listings that do not require a support URL.
   */
  supportUrl: Scalars["URI"]["output"];
  /** URL to the listing's terms of service. */
  termsOfServiceUrl?: Maybe<Scalars["URI"]["output"]>;
  /** The HTTP URL for the Marketplace listing. */
  url: Scalars["URI"]["output"];
  /** Can the current viewer add plans for this Marketplace listing. */
  viewerCanAddPlans: Scalars["Boolean"]["output"];
  /** Can the current viewer approve this Marketplace listing. */
  viewerCanApprove: Scalars["Boolean"]["output"];
  /** Can the current viewer delist this Marketplace listing. */
  viewerCanDelist: Scalars["Boolean"]["output"];
  /** Can the current viewer edit this Marketplace listing. */
  viewerCanEdit: Scalars["Boolean"]["output"];
  /**
   * Can the current viewer edit the primary and secondary category of this
   * Marketplace listing.
   */
  viewerCanEditCategories: Scalars["Boolean"]["output"];
  /** Can the current viewer edit the plans for this Marketplace listing. */
  viewerCanEditPlans: Scalars["Boolean"]["output"];
  /**
   * Can the current viewer return this Marketplace listing to draft state
   * so it becomes editable again.
   */
  viewerCanRedraft: Scalars["Boolean"]["output"];
  /**
   * Can the current viewer reject this Marketplace listing by returning it to
   * an editable draft state or rejecting it entirely.
   */
  viewerCanReject: Scalars["Boolean"]["output"];
  /**
   * Can the current viewer request this listing be reviewed for display in
   * the Marketplace as verified.
   */
  viewerCanRequestApproval: Scalars["Boolean"]["output"];
  /** Indicates whether the current user has an active subscription to this Marketplace listing. */
  viewerHasPurchased: Scalars["Boolean"]["output"];
  /**
   * Indicates if the current user has purchased a subscription to this Marketplace listing
   * for all of the organizations the user owns.
   */
  viewerHasPurchasedForAllOrganizations: Scalars["Boolean"]["output"];
  /** Does the current viewer role allow them to administer this Marketplace listing. */
  viewerIsListingAdmin: Scalars["Boolean"]["output"];
};

/** A listing in the GitHub integration marketplace. */
export type MarketplaceListingLogoUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Look up Marketplace Listings */
export type MarketplaceListingConnection = {
  __typename?: "MarketplaceListingConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MarketplaceListingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MarketplaceListing>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type MarketplaceListingEdge = {
  __typename?: "MarketplaceListingEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<MarketplaceListing>;
};

/**
 * Prevent commits that include file paths that exceed a specified character limit
 * from being pushed to the commit graph. NOTE: This rule is in beta and subject to change
 */
export type MaxFilePathLengthParameters = {
  __typename?: "MaxFilePathLengthParameters";
  /** The maximum amount of characters allowed in file paths */
  maxFilePathLength: Scalars["Int"]["output"];
};

/**
 * Prevent commits that include file paths that exceed a specified character limit
 * from being pushed to the commit graph. NOTE: This rule is in beta and subject to change
 */
export type MaxFilePathLengthParametersInput = {
  /** The maximum amount of characters allowed in file paths */
  maxFilePathLength: Scalars["Int"]["input"];
};

/**
 * Prevent commits that exceed a specified file size limit from being pushed to the
 * commit. NOTE: This rule is in beta and subject to change
 */
export type MaxFileSizeParameters = {
  __typename?: "MaxFileSizeParameters";
  /** The maximum file size allowed in megabytes. This limit does not apply to Git Large File Storage (Git LFS). */
  maxFileSize: Scalars["Int"]["output"];
};

/**
 * Prevent commits that exceed a specified file size limit from being pushed to the
 * commit. NOTE: This rule is in beta and subject to change
 */
export type MaxFileSizeParametersInput = {
  /** The maximum file size allowed in megabytes. This limit does not apply to Git Large File Storage (Git LFS). */
  maxFileSize: Scalars["Int"]["input"];
};

/** Represents a member feature request notification */
export type MemberFeatureRequestNotification = Node & {
  __typename?: "MemberFeatureRequestNotification";
  /** Represents member feature request body containing entity name and the number of feature requests */
  body: Scalars["String"]["output"];
  /** The Node ID of the MemberFeatureRequestNotification object */
  id: Scalars["ID"]["output"];
  /** Represents member feature request notification title */
  title: Scalars["String"]["output"];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** Entities that have members who can set status messages. */
export type MemberStatusable = {
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: UserStatusConnection;
};

/** Entities that have members who can set status messages. */
export type MemberStatusableMemberStatusesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<UserStatusOrder>;
};

/** Audit log entry for a members_can_delete_repos.clear event. */
export type MembersCanDeleteReposClearAuditEntry = AuditEntry &
  EnterpriseAuditEntryData &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "MembersCanDeleteReposClearAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The HTTP path for this enterprise. */
    enterpriseResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The slug of the enterprise. */
    enterpriseSlug?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP URL for this enterprise. */
    enterpriseUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The Node ID of the MembersCanDeleteReposClearAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a members_can_delete_repos.disable event. */
export type MembersCanDeleteReposDisableAuditEntry = AuditEntry &
  EnterpriseAuditEntryData &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "MembersCanDeleteReposDisableAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The HTTP path for this enterprise. */
    enterpriseResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The slug of the enterprise. */
    enterpriseSlug?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP URL for this enterprise. */
    enterpriseUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The Node ID of the MembersCanDeleteReposDisableAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a members_can_delete_repos.enable event. */
export type MembersCanDeleteReposEnableAuditEntry = AuditEntry &
  EnterpriseAuditEntryData &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "MembersCanDeleteReposEnableAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The HTTP path for this enterprise. */
    enterpriseResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The slug of the enterprise. */
    enterpriseSlug?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP URL for this enterprise. */
    enterpriseUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The Node ID of the MembersCanDeleteReposEnableAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Represents a 'mentioned' event on a given issue or pull request. */
export type MentionedEvent = Node & {
  __typename?: "MentionedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the MentionedEvent object */
  id: Scalars["ID"]["output"];
};

/** Autogenerated input type of MergeBranch */
export type MergeBranchInput = {
  /** The email address to associate with this commit. */
  authorEmail?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the base branch that the provided head will be merged into. */
  base: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Message to use for the merge commit. If omitted, a default will be used. */
  commitMessage?: InputMaybe<Scalars["String"]["input"]>;
  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */
  head: Scalars["String"]["input"];
  /** The Node ID of the Repository containing the base branch that will be modified. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of MergeBranch. */
export type MergeBranchPayload = {
  __typename?: "MergeBranchPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The resulting merge Commit. */
  mergeCommit?: Maybe<Commit>;
};

/** The possible default commit messages for merges. */
export enum MergeCommitMessage {
  /** Default to a blank commit message. */
  Blank = "BLANK",
  /** Default to the pull request's body. */
  PrBody = "PR_BODY",
  /** Default to the pull request's title. */
  PrTitle = "PR_TITLE",
}

/** The possible default commit titles for merges. */
export enum MergeCommitTitle {
  /** Default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name). */
  MergeMessage = "MERGE_MESSAGE",
  /** Default to the pull request's title. */
  PrTitle = "PR_TITLE",
}

/** Autogenerated input type of MergePullRequest */
export type MergePullRequestInput = {
  /** The email address to associate with this merge. */
  authorEmail?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Commit body to use for the merge commit; if omitted, a default message will be used */
  commitBody?: InputMaybe<Scalars["String"]["input"]>;
  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */
  commitHeadline?: InputMaybe<Scalars["String"]["input"]>;
  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */
  expectedHeadOid?: InputMaybe<Scalars["GitObjectID"]["input"]>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  mergeMethod?: InputMaybe<PullRequestMergeMethod>;
  /** ID of the pull request to be merged. */
  pullRequestId: Scalars["ID"]["input"];
};

/** Autogenerated return type of MergePullRequest. */
export type MergePullRequestPayload = {
  __typename?: "MergePullRequestPayload";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The pull request that was merged. */
  pullRequest?: Maybe<PullRequest>;
};

/** The queue of pull request entries to be merged into a protected branch in a repository. */
export type MergeQueue = Node & {
  __typename?: "MergeQueue";
  /** The configuration for this merge queue */
  configuration?: Maybe<MergeQueueConfiguration>;
  /** The entries in the queue */
  entries?: Maybe<MergeQueueEntryConnection>;
  /** The Node ID of the MergeQueue object */
  id: Scalars["ID"]["output"];
  /** The estimated time in seconds until a newly added entry would be merged */
  nextEntryEstimatedTimeToMerge?: Maybe<Scalars["Int"]["output"]>;
  /** The repository this merge queue belongs to */
  repository?: Maybe<Repository>;
  /** The HTTP path for this merge queue */
  resourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for this merge queue */
  url: Scalars["URI"]["output"];
};

/** The queue of pull request entries to be merged into a protected branch in a repository. */
export type MergeQueueEntriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Configuration for a MergeQueue */
export type MergeQueueConfiguration = {
  __typename?: "MergeQueueConfiguration";
  /** The amount of time in minutes to wait for a check response before considering it a failure. */
  checkResponseTimeout?: Maybe<Scalars["Int"]["output"]>;
  /** The maximum number of entries to build at once. */
  maximumEntriesToBuild?: Maybe<Scalars["Int"]["output"]>;
  /** The maximum number of entries to merge at once. */
  maximumEntriesToMerge?: Maybe<Scalars["Int"]["output"]>;
  /** The merge method to use for this queue. */
  mergeMethod?: Maybe<PullRequestMergeMethod>;
  /** The strategy to use when merging entries. */
  mergingStrategy?: Maybe<MergeQueueMergingStrategy>;
  /** The minimum number of entries required to merge at once. */
  minimumEntriesToMerge?: Maybe<Scalars["Int"]["output"]>;
  /**
   * The amount of time in minutes to wait before ignoring the minumum number of
   * entries in the queue requirement and merging a collection of entries
   */
  minimumEntriesToMergeWaitTime?: Maybe<Scalars["Int"]["output"]>;
};

/** Entries in a MergeQueue */
export type MergeQueueEntry = Node & {
  __typename?: "MergeQueueEntry";
  /** The base commit for this entry */
  baseCommit?: Maybe<Commit>;
  /** The date and time this entry was added to the merge queue */
  enqueuedAt: Scalars["DateTime"]["output"];
  /** The actor that enqueued this entry */
  enqueuer: Actor;
  /** The estimated time in seconds until this entry will be merged */
  estimatedTimeToMerge?: Maybe<Scalars["Int"]["output"]>;
  /** The head commit for this entry */
  headCommit?: Maybe<Commit>;
  /** The Node ID of the MergeQueueEntry object */
  id: Scalars["ID"]["output"];
  /** Whether this pull request should jump the queue */
  jump: Scalars["Boolean"]["output"];
  /** The merge queue that this entry belongs to */
  mergeQueue?: Maybe<MergeQueue>;
  /** The position of this entry in the queue */
  position: Scalars["Int"]["output"];
  /** The pull request that will be added to a merge group */
  pullRequest?: Maybe<PullRequest>;
  /** Does this pull request need to be deployed on its own */
  solo: Scalars["Boolean"]["output"];
  /** The state of this entry in the queue */
  state: MergeQueueEntryState;
};

/** The connection type for MergeQueueEntry. */
export type MergeQueueEntryConnection = {
  __typename?: "MergeQueueEntryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeQueueEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeQueueEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type MergeQueueEntryEdge = {
  __typename?: "MergeQueueEntryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<MergeQueueEntry>;
};

/** The possible states for a merge queue entry. */
export enum MergeQueueEntryState {
  /** The entry is currently waiting for checks to pass. */
  AwaitingChecks = "AWAITING_CHECKS",
  /** The entry is currently locked. */
  Locked = "LOCKED",
  /** The entry is currently mergeable. */
  Mergeable = "MERGEABLE",
  /** The entry is currently queued. */
  Queued = "QUEUED",
  /** The entry is currently unmergeable. */
  Unmergeable = "UNMERGEABLE",
}

/**
 * When set to ALLGREEN, the merge commit created by merge queue for each PR in the
 * group must pass all required checks to merge. When set to HEADGREEN, only the
 * commit at the head of the merge group, i.e. the commit containing changes from
 * all of the PRs in the group, must pass its required checks to merge.
 */
export enum MergeQueueGroupingStrategy {
  /** The merge commit created by merge queue for each PR in the group must pass all required checks to merge */
  Allgreen = "ALLGREEN",
  /** Only the commit at the head of the merge group must pass its required checks to merge. */
  Headgreen = "HEADGREEN",
}

/** Method to use when merging changes from queued pull requests. */
export enum MergeQueueMergeMethod {
  /** Merge commit */
  Merge = "MERGE",
  /** Rebase and merge */
  Rebase = "REBASE",
  /** Squash and merge */
  Squash = "SQUASH",
}

/** The possible merging strategies for a merge queue. */
export enum MergeQueueMergingStrategy {
  /** Entries only allowed to merge if they are passing. */
  Allgreen = "ALLGREEN",
  /** Failing Entires are allowed to merge if they are with a passing entry. */
  Headgreen = "HEADGREEN",
}

/** Merges must be performed via a merge queue. */
export type MergeQueueParameters = {
  __typename?: "MergeQueueParameters";
  /**
   * Maximum time for a required status check to report a conclusion. After this
   * much time has elapsed, checks that have not reported a conclusion will be
   * assumed to have failed
   */
  checkResponseTimeoutMinutes: Scalars["Int"]["output"];
  /**
   * When set to ALLGREEN, the merge commit created by merge queue for each PR in
   * the group must pass all required checks to merge. When set to HEADGREEN, only
   * the commit at the head of the merge group, i.e. the commit containing changes
   * from all of the PRs in the group, must pass its required checks to merge.
   */
  groupingStrategy: MergeQueueGroupingStrategy;
  /** Limit the number of queued pull requests requesting checks and workflow runs at the same time. */
  maxEntriesToBuild: Scalars["Int"]["output"];
  /** The maximum number of PRs that will be merged together in a group. */
  maxEntriesToMerge: Scalars["Int"]["output"];
  /** Method to use when merging changes from queued pull requests. */
  mergeMethod: MergeQueueMergeMethod;
  /** The minimum number of PRs that will be merged together in a group. */
  minEntriesToMerge: Scalars["Int"]["output"];
  /**
   * The time merge queue should wait after the first PR is added to the queue for
   * the minimum group size to be met. After this time has elapsed, the minimum
   * group size will be ignored and a smaller group will be merged.
   */
  minEntriesToMergeWaitMinutes: Scalars["Int"]["output"];
};

/** Merges must be performed via a merge queue. */
export type MergeQueueParametersInput = {
  /**
   * Maximum time for a required status check to report a conclusion. After this
   * much time has elapsed, checks that have not reported a conclusion will be
   * assumed to have failed
   */
  checkResponseTimeoutMinutes: Scalars["Int"]["input"];
  /**
   * When set to ALLGREEN, the merge commit created by merge queue for each PR in
   * the group must pass all required checks to merge. When set to HEADGREEN, only
   * the commit at the head of the merge group, i.e. the commit containing changes
   * from all of the PRs in the group, must pass its required checks to merge.
   */
  groupingStrategy: MergeQueueGroupingStrategy;
  /** Limit the number of queued pull requests requesting checks and workflow runs at the same time. */
  maxEntriesToBuild: Scalars["Int"]["input"];
  /** The maximum number of PRs that will be merged together in a group. */
  maxEntriesToMerge: Scalars["Int"]["input"];
  /** Method to use when merging changes from queued pull requests. */
  mergeMethod: MergeQueueMergeMethod;
  /** The minimum number of PRs that will be merged together in a group. */
  minEntriesToMerge: Scalars["Int"]["input"];
  /**
   * The time merge queue should wait after the first PR is added to the queue for
   * the minimum group size to be met. After this time has elapsed, the minimum
   * group size will be ignored and a smaller group will be merged.
   */
  minEntriesToMergeWaitMinutes: Scalars["Int"]["input"];
};

/** Detailed status information about a pull request merge. */
export enum MergeStateStatus {
  /** The head ref is out of date. */
  Behind = "BEHIND",
  /** The merge is blocked. */
  Blocked = "BLOCKED",
  /** Mergeable and passing commit status. */
  Clean = "CLEAN",
  /** The merge commit cannot be cleanly created. */
  Dirty = "DIRTY",
  /**
   * The merge is blocked due to the pull request being a draft.
   * @deprecated DRAFT state will be removed from this enum and `isDraft` should be used instead Use PullRequest.isDraft instead. Removal on 2021-01-01 UTC.
   */
  Draft = "DRAFT",
  /** Mergeable with passing commit status and pre-receive hooks. */
  HasHooks = "HAS_HOOKS",
  /** The state cannot currently be determined. */
  Unknown = "UNKNOWN",
  /** Mergeable with non-passing commit status. */
  Unstable = "UNSTABLE",
}

/** Whether or not a PullRequest can be merged. */
export enum MergeableState {
  /** The pull request cannot be merged due to merge conflicts. */
  Conflicting = "CONFLICTING",
  /** The pull request can be merged. */
  Mergeable = "MERGEABLE",
  /** The mergeability of the pull request is still being calculated. */
  Unknown = "UNKNOWN",
}

/** Represents a 'merged' event on a given pull request. */
export type MergedEvent = Node &
  UniformResourceLocatable & {
    __typename?: "MergedEvent";
    /** Identifies the actor who performed the event. */
    actor?: Maybe<Actor>;
    /** Identifies the commit associated with the `merge` event. */
    commit?: Maybe<Commit>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The Node ID of the MergedEvent object */
    id: Scalars["ID"]["output"];
    /** Identifies the Ref associated with the `merge` event. */
    mergeRef?: Maybe<Ref>;
    /** Identifies the name of the Ref associated with the `merge` event. */
    mergeRefName: Scalars["String"]["output"];
    /** PullRequest referenced by event. */
    pullRequest: PullRequest;
    /** The HTTP path for this merged event. */
    resourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for this merged event. */
    url: Scalars["URI"]["output"];
  };

/** Represents a GitHub Enterprise Importer (GEI) migration. */
export type Migration = {
  /** The migration flag to continue on error. */
  continueOnError: Scalars["Boolean"]["output"];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["String"]["output"]>;
  /** The reason the migration failed. */
  failureReason?: Maybe<Scalars["String"]["output"]>;
  /** The Node ID of the Migration object */
  id: Scalars["ID"]["output"];
  /** The URL for the migration log (expires 1 day after migration completes). */
  migrationLogUrl?: Maybe<Scalars["URI"]["output"]>;
  /** The migration source. */
  migrationSource: MigrationSource;
  /** The target repository name. */
  repositoryName: Scalars["String"]["output"];
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  sourceUrl: Scalars["URI"]["output"];
  /** The migration state. */
  state: MigrationState;
  /**
   * The number of warnings encountered for this migration. To review the warnings,
   * check the [Migration Log](https://docs.github.com/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).
   */
  warningsCount: Scalars["Int"]["output"];
};

/** A GitHub Enterprise Importer (GEI) migration source. */
export type MigrationSource = Node & {
  __typename?: "MigrationSource";
  /** The Node ID of the MigrationSource object */
  id: Scalars["ID"]["output"];
  /** The migration source name. */
  name: Scalars["String"]["output"];
  /** The migration source type. */
  type: MigrationSourceType;
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  url: Scalars["URI"]["output"];
};

/** Represents the different GitHub Enterprise Importer (GEI) migration sources. */
export enum MigrationSourceType {
  /** An Azure DevOps migration source. */
  AzureDevops = "AZURE_DEVOPS",
  /** A Bitbucket Server migration source. */
  BitbucketServer = "BITBUCKET_SERVER",
  /** A GitHub Migration API source. */
  GithubArchive = "GITHUB_ARCHIVE",
}

/** The GitHub Enterprise Importer (GEI) migration state. */
export enum MigrationState {
  /** The migration has failed. */
  Failed = "FAILED",
  /** The migration has invalid credentials. */
  FailedValidation = "FAILED_VALIDATION",
  /** The migration is in progress. */
  InProgress = "IN_PROGRESS",
  /** The migration has not started. */
  NotStarted = "NOT_STARTED",
  /** The migration needs to have its credentials validated. */
  PendingValidation = "PENDING_VALIDATION",
  /** The migration has been queued. */
  Queued = "QUEUED",
  /** The migration has succeeded. */
  Succeeded = "SUCCEEDED",
}

/** Represents a Milestone object on a given repository. */
export type Milestone = Closable &
  Node &
  UniformResourceLocatable & {
    __typename?: "Milestone";
    /** Indicates if the object is closed (definition of closed may depend on type) */
    closed: Scalars["Boolean"]["output"];
    /** Identifies the date and time when the object was closed. */
    closedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the actor who created the milestone. */
    creator?: Maybe<Actor>;
    /** Identifies the description of the milestone. */
    description?: Maybe<Scalars["String"]["output"]>;
    /** Identifies the due date of the milestone. */
    dueOn?: Maybe<Scalars["DateTime"]["output"]>;
    /** The Node ID of the Milestone object */
    id: Scalars["ID"]["output"];
    /** A list of issues associated with the milestone. */
    issues: IssueConnection;
    /** Identifies the number of the milestone. */
    number: Scalars["Int"]["output"];
    /** Identifies the percentage complete for the milestone */
    progressPercentage: Scalars["Float"]["output"];
    /** A list of pull requests associated with the milestone. */
    pullRequests: PullRequestConnection;
    /** The repository associated with this milestone. */
    repository: Repository;
    /** The HTTP path for this milestone */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the state of the milestone. */
    state: MilestoneState;
    /** Identifies the title of the milestone. */
    title: Scalars["String"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this milestone */
    url: Scalars["URI"]["output"];
    /** Indicates if the object can be closed by the viewer. */
    viewerCanClose: Scalars["Boolean"]["output"];
    /** Indicates if the object can be reopened by the viewer. */
    viewerCanReopen: Scalars["Boolean"]["output"];
  };

/** Represents a Milestone object on a given repository. */
export type MilestoneIssuesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filterBy?: InputMaybe<IssueFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  labels?: InputMaybe<Array<Scalars["String"]["input"]>>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<IssueState>>;
};

/** Represents a Milestone object on a given repository. */
export type MilestonePullRequestsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  baseRefName?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  headRefName?: InputMaybe<Scalars["String"]["input"]>;
  labels?: InputMaybe<Array<Scalars["String"]["input"]>>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<PullRequestState>>;
};

/** The connection type for Milestone. */
export type MilestoneConnection = {
  __typename?: "MilestoneConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MilestoneEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Milestone>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type MilestoneEdge = {
  __typename?: "MilestoneEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Milestone>;
};

/** Types that can be inside a Milestone. */
export type MilestoneItem = Issue | PullRequest;

/** Ordering options for milestone connections. */
export type MilestoneOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order milestones by. */
  field: MilestoneOrderField;
};

/** Properties by which milestone connections can be ordered. */
export enum MilestoneOrderField {
  /** Order milestones by when they were created. */
  CreatedAt = "CREATED_AT",
  /** Order milestones by when they are due. */
  DueDate = "DUE_DATE",
  /** Order milestones by their number. */
  Number = "NUMBER",
  /** Order milestones by when they were last updated. */
  UpdatedAt = "UPDATED_AT",
}

/** The possible states of a milestone. */
export enum MilestoneState {
  /** A milestone that has been closed. */
  Closed = "CLOSED",
  /** A milestone that is still open. */
  Open = "OPEN",
}

/** Represents a 'milestoned' event on a given issue or pull request. */
export type MilestonedEvent = Node & {
  __typename?: "MilestonedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the MilestonedEvent object */
  id: Scalars["ID"]["output"];
  /** Identifies the milestone title associated with the 'milestoned' event. */
  milestoneTitle: Scalars["String"]["output"];
  /** Object referenced by event. */
  subject: MilestoneItem;
};

/** Entities that can be minimized. */
export type Minimizable = {
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars["Boolean"]["output"];
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars["String"]["output"]>;
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars["Boolean"]["output"];
};

/** Autogenerated input type of MinimizeComment */
export type MinimizeCommentInput = {
  /** The classification of comment */
  classifier: ReportedContentClassifiers;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of MinimizeComment. */
export type MinimizeCommentPayload = {
  __typename?: "MinimizeCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The comment that was minimized. */
  minimizedComment?: Maybe<Minimizable>;
};

/** Autogenerated input type of MoveProjectCard */
export type MoveProjectCardInput = {
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  afterCardId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The id of the card to move. */
  cardId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The id of the column to move it into. */
  columnId: Scalars["ID"]["input"];
};

/** Autogenerated return type of MoveProjectCard. */
export type MoveProjectCardPayload = {
  __typename?: "MoveProjectCardPayload";
  /** The new edge of the moved card. */
  cardEdge?: Maybe<ProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of MoveProjectColumn */
export type MoveProjectColumnInput = {
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  afterColumnId?: InputMaybe<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The id of the column to move. */
  columnId: Scalars["ID"]["input"];
};

/** Autogenerated return type of MoveProjectColumn. */
export type MoveProjectColumnPayload = {
  __typename?: "MoveProjectColumnPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new edge of the moved column. */
  columnEdge?: Maybe<ProjectColumnEdge>;
};

/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
export type MovedColumnsInProjectEvent = Node & {
  __typename?: "MovedColumnsInProjectEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the MovedColumnsInProjectEvent object */
  id: Scalars["ID"]["output"];
  /** Column name the issue or pull request was moved from. */
  previousProjectColumnName: Scalars["String"]["output"];
  /** Project referenced by event. */
  project?: Maybe<Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<ProjectCard>;
  /** Column name the issue or pull request was moved to. */
  projectColumnName: Scalars["String"]["output"];
};

/** The root query for implementing GraphQL mutations. */
export type Mutation = {
  __typename?: "Mutation";
  /** Clear all of a customer's queued migrations */
  abortQueuedMigrations?: Maybe<AbortQueuedMigrationsPayload>;
  /** Abort a repository migration queued or in progress. */
  abortRepositoryMigration?: Maybe<AbortRepositoryMigrationPayload>;
  /** Accepts a pending invitation for a user to become an administrator of an enterprise. */
  acceptEnterpriseAdministratorInvitation?: Maybe<AcceptEnterpriseAdministratorInvitationPayload>;
  /** Accepts a pending invitation for a user to become an unaffiliated member of an enterprise. */
  acceptEnterpriseMemberInvitation?: Maybe<AcceptEnterpriseMemberInvitationPayload>;
  /** Applies a suggested topic to the repository. */
  acceptTopicSuggestion?: Maybe<AcceptTopicSuggestionPayload>;
  /** Adds assignees to an assignable object. */
  addAssigneesToAssignable?: Maybe<AddAssigneesToAssignablePayload>;
  /** Adds a comment to an Issue or Pull Request. */
  addComment?: Maybe<AddCommentPayload>;
  /** Adds a comment to a Discussion, possibly as a reply to another comment. */
  addDiscussionComment?: Maybe<AddDiscussionCommentPayload>;
  /** Vote for an option in a discussion poll. */
  addDiscussionPollVote?: Maybe<AddDiscussionPollVotePayload>;
  /** Adds enterprise members to an organization within the enterprise. */
  addEnterpriseOrganizationMember?: Maybe<AddEnterpriseOrganizationMemberPayload>;
  /** Adds a support entitlement to an enterprise member. */
  addEnterpriseSupportEntitlement?: Maybe<AddEnterpriseSupportEntitlementPayload>;
  /** Adds labels to a labelable object. */
  addLabelsToLabelable?: Maybe<AddLabelsToLabelablePayload>;
  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */
  addProjectCard?: Maybe<AddProjectCardPayload>;
  /** Adds a column to a Project. */
  addProjectColumn?: Maybe<AddProjectColumnPayload>;
  /** Creates a new draft issue and add it to a Project. */
  addProjectV2DraftIssue?: Maybe<AddProjectV2DraftIssuePayload>;
  /** Links an existing content instance to a Project. */
  addProjectV2ItemById?: Maybe<AddProjectV2ItemByIdPayload>;
  /** Adds a review to a Pull Request. */
  addPullRequestReview?: Maybe<AddPullRequestReviewPayload>;
  /** Adds a comment to a review. */
  addPullRequestReviewComment?: Maybe<AddPullRequestReviewCommentPayload>;
  /** Adds a new thread to a pending Pull Request Review. */
  addPullRequestReviewThread?: Maybe<AddPullRequestReviewThreadPayload>;
  /** Adds a reply to an existing Pull Request Review Thread. */
  addPullRequestReviewThreadReply?: Maybe<AddPullRequestReviewThreadReplyPayload>;
  /** Adds a reaction to a subject. */
  addReaction?: Maybe<AddReactionPayload>;
  /** Adds a star to a Starrable. */
  addStar?: Maybe<AddStarPayload>;
  /** Add an upvote to a discussion or discussion comment. */
  addUpvote?: Maybe<AddUpvotePayload>;
  /** Adds a verifiable domain to an owning account. */
  addVerifiableDomain?: Maybe<AddVerifiableDomainPayload>;
  /** Approve all pending deployments under one or more environments */
  approveDeployments?: Maybe<ApproveDeploymentsPayload>;
  /** Approve a verifiable domain for notification delivery. */
  approveVerifiableDomain?: Maybe<ApproveVerifiableDomainPayload>;
  /** Archives a ProjectV2Item */
  archiveProjectV2Item?: Maybe<ArchiveProjectV2ItemPayload>;
  /** Marks a repository as archived. */
  archiveRepository?: Maybe<ArchiveRepositoryPayload>;
  /** Cancels a pending invitation for an administrator to join an enterprise. */
  cancelEnterpriseAdminInvitation?: Maybe<CancelEnterpriseAdminInvitationPayload>;
  /** Cancels a pending invitation for an unaffiliated member to join an enterprise. */
  cancelEnterpriseMemberInvitation?: Maybe<CancelEnterpriseMemberInvitationPayload>;
  /** Cancel an active sponsorship. */
  cancelSponsorship?: Maybe<CancelSponsorshipPayload>;
  /** Update your status on GitHub. */
  changeUserStatus?: Maybe<ChangeUserStatusPayload>;
  /** Clears all labels from a labelable object. */
  clearLabelsFromLabelable?: Maybe<ClearLabelsFromLabelablePayload>;
  /**
   * This mutation clears the value of a field for an item in a Project. Currently
   * only text, number, date, assignees, labels, single-select, iteration and
   * milestone fields are supported.
   */
  clearProjectV2ItemFieldValue?: Maybe<ClearProjectV2ItemFieldValuePayload>;
  /** Creates a new project by cloning configuration from an existing project. */
  cloneProject?: Maybe<CloneProjectPayload>;
  /** Create a new repository with the same files and directory structure as a template repository. */
  cloneTemplateRepository?: Maybe<CloneTemplateRepositoryPayload>;
  /** Close a discussion. */
  closeDiscussion?: Maybe<CloseDiscussionPayload>;
  /** Close an issue. */
  closeIssue?: Maybe<CloseIssuePayload>;
  /** Close a pull request. */
  closePullRequest?: Maybe<ClosePullRequestPayload>;
  /** Convert a project note card to one associated with a newly created issue. */
  convertProjectCardNoteToIssue?: Maybe<ConvertProjectCardNoteToIssuePayload>;
  /** Converts a projectV2 draft issue item to an issue. */
  convertProjectV2DraftIssueItemToIssue?: Maybe<ConvertProjectV2DraftIssueItemToIssuePayload>;
  /** Converts a pull request to draft */
  convertPullRequestToDraft?: Maybe<ConvertPullRequestToDraftPayload>;
  /** Copy a project. */
  copyProjectV2?: Maybe<CopyProjectV2Payload>;
  /** Invites a user to claim reattributable data */
  createAttributionInvitation?: Maybe<CreateAttributionInvitationPayload>;
  /** Create a new branch protection rule */
  createBranchProtectionRule?: Maybe<CreateBranchProtectionRulePayload>;
  /** Create a check run. */
  createCheckRun?: Maybe<CreateCheckRunPayload>;
  /** Create a check suite */
  createCheckSuite?: Maybe<CreateCheckSuitePayload>;
  /**
   * Appends a commit to the given branch as the authenticated user.
   *
   * This mutation creates a commit whose parent is the HEAD of the provided
   * branch and also updates that branch to point to the new commit.
   * It can be thought of as similar to `git commit`.
   *
   * ### Locating a Branch
   *
   * Commits are appended to a `branch` of type `Ref`.
   * This must refer to a git branch (i.e.  the fully qualified path must
   * begin with `refs/heads/`, although including this prefix is optional.
   *
   * Callers may specify the `branch` to commit to either by its global node
   * ID or by passing both of `repositoryNameWithOwner` and `refName`.  For
   * more details see the documentation for `CommittableBranch`.
   *
   * ### Describing Changes
   *
   * `fileChanges` are specified as a `FilesChanges` object describing
   * `FileAdditions` and `FileDeletions`.
   *
   * Please see the documentation for `FileChanges` for more information on
   * how to use this argument to describe any set of file changes.
   *
   * ### Authorship
   *
   * Similar to the web commit interface, this mutation does not support
   * specifying the author or committer of the commit and will not add
   * support for this in the future.
   *
   * A commit created by a successful execution of this mutation will be
   * authored by the owner of the credential which authenticates the API
   * request.  The committer will be identical to that of commits authored
   * using the web interface.
   *
   * If you need full control over author and committer information, please
   * use the Git Database REST API instead.
   *
   * ### Commit Signing
   *
   * Commits made using this mutation are automatically signed by GitHub if
   * supported and will be marked as verified in the user interface.
   */
  createCommitOnBranch?: Maybe<CreateCommitOnBranchPayload>;
  /** Creates a new deployment event. */
  createDeployment?: Maybe<CreateDeploymentPayload>;
  /** Create a deployment status. */
  createDeploymentStatus?: Maybe<CreateDeploymentStatusPayload>;
  /** Create a discussion. */
  createDiscussion?: Maybe<CreateDiscussionPayload>;
  /**
   * Creates an organization as part of an enterprise account. A personal access
   * token used to create an organization is implicitly permitted to update the
   * organization it created, if the organization is part of an enterprise that has
   * SAML enabled or uses Enterprise Managed Users. If the organization is not part
   * of such an enterprise, and instead has SAML enabled for it individually, the
   * token will then require SAML authorization to continue working against that organization.
   */
  createEnterpriseOrganization?: Maybe<CreateEnterpriseOrganizationPayload>;
  /** Creates an environment or simply returns it if already exists. */
  createEnvironment?: Maybe<CreateEnvironmentPayload>;
  /** Creates a new IP allow list entry. */
  createIpAllowListEntry?: Maybe<CreateIpAllowListEntryPayload>;
  /** Creates a new issue. */
  createIssue?: Maybe<CreateIssuePayload>;
  /** Creates a new label. */
  createLabel?: Maybe<CreateLabelPayload>;
  /** Create a branch linked to an issue. */
  createLinkedBranch?: Maybe<CreateLinkedBranchPayload>;
  /** Creates a GitHub Enterprise Importer (GEI) migration source. */
  createMigrationSource?: Maybe<CreateMigrationSourcePayload>;
  /** Creates a new project. */
  createProject?: Maybe<CreateProjectPayload>;
  /** Creates a new project. */
  createProjectV2?: Maybe<CreateProjectV2Payload>;
  /** Create a new project field. */
  createProjectV2Field?: Maybe<CreateProjectV2FieldPayload>;
  /** Creates a status update within a Project. */
  createProjectV2StatusUpdate?: Maybe<CreateProjectV2StatusUpdatePayload>;
  /** Create a new pull request */
  createPullRequest?: Maybe<CreatePullRequestPayload>;
  /** Create a new Git Ref. */
  createRef?: Maybe<CreateRefPayload>;
  /** Create a new repository. */
  createRepository?: Maybe<CreateRepositoryPayload>;
  /** Create a repository ruleset */
  createRepositoryRuleset?: Maybe<CreateRepositoryRulesetPayload>;
  /** Create a GitHub Sponsors profile to allow others to sponsor you or your organization. */
  createSponsorsListing?: Maybe<CreateSponsorsListingPayload>;
  /** Create a new payment tier for your GitHub Sponsors profile. */
  createSponsorsTier?: Maybe<CreateSponsorsTierPayload>;
  /** Start a new sponsorship of a maintainer in GitHub Sponsors, or reactivate a past sponsorship. */
  createSponsorship?: Maybe<CreateSponsorshipPayload>;
  /**
   * Make many sponsorships for different sponsorable users or organizations at
   * once. Can only sponsor those who have a public GitHub Sponsors profile.
   */
  createSponsorships?: Maybe<CreateSponsorshipsPayload>;
  /** Creates a new team discussion. */
  createTeamDiscussion?: Maybe<CreateTeamDiscussionPayload>;
  /** Creates a new team discussion comment. */
  createTeamDiscussionComment?: Maybe<CreateTeamDiscussionCommentPayload>;
  /** Creates a new user list. */
  createUserList?: Maybe<CreateUserListPayload>;
  /** Rejects a suggested topic for the repository. */
  declineTopicSuggestion?: Maybe<DeclineTopicSuggestionPayload>;
  /** Delete a branch protection rule */
  deleteBranchProtectionRule?: Maybe<DeleteBranchProtectionRulePayload>;
  /** Deletes a deployment. */
  deleteDeployment?: Maybe<DeleteDeploymentPayload>;
  /** Delete a discussion and all of its replies. */
  deleteDiscussion?: Maybe<DeleteDiscussionPayload>;
  /** Delete a discussion comment. If it has replies, wipe it instead. */
  deleteDiscussionComment?: Maybe<DeleteDiscussionCommentPayload>;
  /** Deletes an environment */
  deleteEnvironment?: Maybe<DeleteEnvironmentPayload>;
  /** Deletes an IP allow list entry. */
  deleteIpAllowListEntry?: Maybe<DeleteIpAllowListEntryPayload>;
  /** Deletes an Issue object. */
  deleteIssue?: Maybe<DeleteIssuePayload>;
  /** Deletes an IssueComment object. */
  deleteIssueComment?: Maybe<DeleteIssueCommentPayload>;
  /** Deletes a label. */
  deleteLabel?: Maybe<DeleteLabelPayload>;
  /** Unlink a branch from an issue. */
  deleteLinkedBranch?: Maybe<DeleteLinkedBranchPayload>;
  /** Delete a package version. */
  deletePackageVersion?: Maybe<DeletePackageVersionPayload>;
  /** Deletes a project. */
  deleteProject?: Maybe<DeleteProjectPayload>;
  /** Deletes a project card. */
  deleteProjectCard?: Maybe<DeleteProjectCardPayload>;
  /** Deletes a project column. */
  deleteProjectColumn?: Maybe<DeleteProjectColumnPayload>;
  /** Delete a project. */
  deleteProjectV2?: Maybe<DeleteProjectV2Payload>;
  /** Delete a project field. */
  deleteProjectV2Field?: Maybe<DeleteProjectV2FieldPayload>;
  /** Deletes an item from a Project. */
  deleteProjectV2Item?: Maybe<DeleteProjectV2ItemPayload>;
  /** Deletes a project status update. */
  deleteProjectV2StatusUpdate?: Maybe<DeleteProjectV2StatusUpdatePayload>;
  /** Deletes a project workflow. */
  deleteProjectV2Workflow?: Maybe<DeleteProjectV2WorkflowPayload>;
  /** Deletes a pull request review. */
  deletePullRequestReview?: Maybe<DeletePullRequestReviewPayload>;
  /** Deletes a pull request review comment. */
  deletePullRequestReviewComment?: Maybe<DeletePullRequestReviewCommentPayload>;
  /** Delete a Git Ref. */
  deleteRef?: Maybe<DeleteRefPayload>;
  /** Delete a repository ruleset */
  deleteRepositoryRuleset?: Maybe<DeleteRepositoryRulesetPayload>;
  /** Deletes a team discussion. */
  deleteTeamDiscussion?: Maybe<DeleteTeamDiscussionPayload>;
  /** Deletes a team discussion comment. */
  deleteTeamDiscussionComment?: Maybe<DeleteTeamDiscussionCommentPayload>;
  /** Deletes a user list. */
  deleteUserList?: Maybe<DeleteUserListPayload>;
  /** Deletes a verifiable domain. */
  deleteVerifiableDomain?: Maybe<DeleteVerifiableDomainPayload>;
  /** Remove a pull request from the merge queue. */
  dequeuePullRequest?: Maybe<DequeuePullRequestPayload>;
  /** Disable auto merge on the given pull request */
  disablePullRequestAutoMerge?: Maybe<DisablePullRequestAutoMergePayload>;
  /** Dismisses an approved or rejected pull request review. */
  dismissPullRequestReview?: Maybe<DismissPullRequestReviewPayload>;
  /** Dismisses the Dependabot alert. */
  dismissRepositoryVulnerabilityAlert?: Maybe<DismissRepositoryVulnerabilityAlertPayload>;
  /** Enable the default auto-merge on a pull request. */
  enablePullRequestAutoMerge?: Maybe<EnablePullRequestAutoMergePayload>;
  /** Add a pull request to the merge queue. */
  enqueuePullRequest?: Maybe<EnqueuePullRequestPayload>;
  /** Follow an organization. */
  followOrganization?: Maybe<FollowOrganizationPayload>;
  /** Follow a user. */
  followUser?: Maybe<FollowUserPayload>;
  /** Grant the migrator role to a user for all organizations under an enterprise account. */
  grantEnterpriseOrganizationsMigratorRole?: Maybe<GrantEnterpriseOrganizationsMigratorRolePayload>;
  /** Grant the migrator role to a user or a team. */
  grantMigratorRole?: Maybe<GrantMigratorRolePayload>;
  /** Creates a new project by importing columns and a list of issues/PRs. */
  importProject?: Maybe<ImportProjectPayload>;
  /** Invite someone to become an administrator of the enterprise. */
  inviteEnterpriseAdmin?: Maybe<InviteEnterpriseAdminPayload>;
  /** Invite someone to become an unaffiliated member of the enterprise. */
  inviteEnterpriseMember?: Maybe<InviteEnterpriseMemberPayload>;
  /** Links a project to a repository. */
  linkProjectV2ToRepository?: Maybe<LinkProjectV2ToRepositoryPayload>;
  /** Links a project to a team. */
  linkProjectV2ToTeam?: Maybe<LinkProjectV2ToTeamPayload>;
  /** Creates a repository link for a project. */
  linkRepositoryToProject?: Maybe<LinkRepositoryToProjectPayload>;
  /** Lock a lockable object */
  lockLockable?: Maybe<LockLockablePayload>;
  /** Mark a discussion comment as the chosen answer for discussions in an answerable category. */
  markDiscussionCommentAsAnswer?: Maybe<MarkDiscussionCommentAsAnswerPayload>;
  /** Mark a pull request file as viewed */
  markFileAsViewed?: Maybe<MarkFileAsViewedPayload>;
  /** Marks a notification as done */
  markNotificationAsDone?: Maybe<MarkNotificationAsDonePayload>;
  /** Mark a project as a template. Note that only projects which are owned by an Organization can be marked as a template. */
  markProjectV2AsTemplate?: Maybe<MarkProjectV2AsTemplatePayload>;
  /** Marks a pull request ready for review. */
  markPullRequestReadyForReview?: Maybe<MarkPullRequestReadyForReviewPayload>;
  /** Merge a head into a branch. */
  mergeBranch?: Maybe<MergeBranchPayload>;
  /** Merge a pull request. */
  mergePullRequest?: Maybe<MergePullRequestPayload>;
  /** Minimizes a comment on an Issue, Commit, Pull Request, or Gist */
  minimizeComment?: Maybe<MinimizeCommentPayload>;
  /** Moves a project card to another place. */
  moveProjectCard?: Maybe<MoveProjectCardPayload>;
  /** Moves a project column to another place. */
  moveProjectColumn?: Maybe<MoveProjectColumnPayload>;
  /** Pin an environment to a repository */
  pinEnvironment?: Maybe<PinEnvironmentPayload>;
  /** Pin an issue to a repository */
  pinIssue?: Maybe<PinIssuePayload>;
  /** Publish an existing sponsorship tier that is currently still a draft to a GitHub Sponsors profile. */
  publishSponsorsTier?: Maybe<PublishSponsorsTierPayload>;
  /** Regenerates the identity provider recovery codes for an enterprise */
  regenerateEnterpriseIdentityProviderRecoveryCodes?: Maybe<RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;
  /** Regenerates a verifiable domain's verification token. */
  regenerateVerifiableDomainToken?: Maybe<RegenerateVerifiableDomainTokenPayload>;
  /** Reject all pending deployments under one or more environments */
  rejectDeployments?: Maybe<RejectDeploymentsPayload>;
  /** Removes assignees from an assignable object. */
  removeAssigneesFromAssignable?: Maybe<RemoveAssigneesFromAssignablePayload>;
  /** Removes an administrator from the enterprise. */
  removeEnterpriseAdmin?: Maybe<RemoveEnterpriseAdminPayload>;
  /**
   * Removes the identity provider from an enterprise. Owners of enterprises both
   * with and without Enterprise Managed Users may use this mutation.
   */
  removeEnterpriseIdentityProvider?: Maybe<RemoveEnterpriseIdentityProviderPayload>;
  /** Removes a user from all organizations within the enterprise */
  removeEnterpriseMember?: Maybe<RemoveEnterpriseMemberPayload>;
  /** Removes an organization from the enterprise */
  removeEnterpriseOrganization?: Maybe<RemoveEnterpriseOrganizationPayload>;
  /** Removes a support entitlement from an enterprise member. */
  removeEnterpriseSupportEntitlement?: Maybe<RemoveEnterpriseSupportEntitlementPayload>;
  /** Removes labels from a Labelable object. */
  removeLabelsFromLabelable?: Maybe<RemoveLabelsFromLabelablePayload>;
  /** Removes outside collaborator from all repositories in an organization. */
  removeOutsideCollaborator?: Maybe<RemoveOutsideCollaboratorPayload>;
  /** Removes a reaction from a subject. */
  removeReaction?: Maybe<RemoveReactionPayload>;
  /** Removes a star from a Starrable. */
  removeStar?: Maybe<RemoveStarPayload>;
  /** Remove an upvote to a discussion or discussion comment. */
  removeUpvote?: Maybe<RemoveUpvotePayload>;
  /** Reopen a discussion. */
  reopenDiscussion?: Maybe<ReopenDiscussionPayload>;
  /** Reopen a issue. */
  reopenIssue?: Maybe<ReopenIssuePayload>;
  /** Reopen a pull request. */
  reopenPullRequest?: Maybe<ReopenPullRequestPayload>;
  /** Reorder a pinned repository environment */
  reorderEnvironment?: Maybe<ReorderEnvironmentPayload>;
  /** Set review requests on a pull request. */
  requestReviews?: Maybe<RequestReviewsPayload>;
  /** Rerequests an existing check suite. */
  rerequestCheckSuite?: Maybe<RerequestCheckSuitePayload>;
  /** Marks a review thread as resolved. */
  resolveReviewThread?: Maybe<ResolveReviewThreadPayload>;
  /** Retire a published payment tier from your GitHub Sponsors profile so it cannot be used to start new sponsorships. */
  retireSponsorsTier?: Maybe<RetireSponsorsTierPayload>;
  /** Create a pull request that reverts the changes from a merged pull request. */
  revertPullRequest?: Maybe<RevertPullRequestPayload>;
  /** Revoke the migrator role to a user for all organizations under an enterprise account. */
  revokeEnterpriseOrganizationsMigratorRole?: Maybe<RevokeEnterpriseOrganizationsMigratorRolePayload>;
  /** Revoke the migrator role from a user or a team. */
  revokeMigratorRole?: Maybe<RevokeMigratorRolePayload>;
  /** Creates or updates the identity provider for an enterprise. */
  setEnterpriseIdentityProvider?: Maybe<SetEnterpriseIdentityProviderPayload>;
  /** Set an organization level interaction limit for an organization's public repositories. */
  setOrganizationInteractionLimit?: Maybe<SetOrganizationInteractionLimitPayload>;
  /** Sets an interaction limit setting for a repository. */
  setRepositoryInteractionLimit?: Maybe<SetRepositoryInteractionLimitPayload>;
  /** Set a user level interaction limit for an user's public repositories. */
  setUserInteractionLimit?: Maybe<SetUserInteractionLimitPayload>;
  /** Starts a GitHub Enterprise Importer organization migration. */
  startOrganizationMigration?: Maybe<StartOrganizationMigrationPayload>;
  /** Starts a GitHub Enterprise Importer (GEI) repository migration. */
  startRepositoryMigration?: Maybe<StartRepositoryMigrationPayload>;
  /** Submits a pending pull request review. */
  submitPullRequestReview?: Maybe<SubmitPullRequestReviewPayload>;
  /** Transfer an organization from one enterprise to another enterprise. */
  transferEnterpriseOrganization?: Maybe<TransferEnterpriseOrganizationPayload>;
  /** Transfer an issue to a different repository */
  transferIssue?: Maybe<TransferIssuePayload>;
  /** Unarchives a ProjectV2Item */
  unarchiveProjectV2Item?: Maybe<UnarchiveProjectV2ItemPayload>;
  /** Unarchives a repository. */
  unarchiveRepository?: Maybe<UnarchiveRepositoryPayload>;
  /** Unfollow an organization. */
  unfollowOrganization?: Maybe<UnfollowOrganizationPayload>;
  /** Unfollow a user. */
  unfollowUser?: Maybe<UnfollowUserPayload>;
  /** Unlinks a project from a repository. */
  unlinkProjectV2FromRepository?: Maybe<UnlinkProjectV2FromRepositoryPayload>;
  /** Unlinks a project to a team. */
  unlinkProjectV2FromTeam?: Maybe<UnlinkProjectV2FromTeamPayload>;
  /** Deletes a repository link from a project. */
  unlinkRepositoryFromProject?: Maybe<UnlinkRepositoryFromProjectPayload>;
  /** Unlock a lockable object */
  unlockLockable?: Maybe<UnlockLockablePayload>;
  /** Unmark a discussion comment as the chosen answer for discussions in an answerable category. */
  unmarkDiscussionCommentAsAnswer?: Maybe<UnmarkDiscussionCommentAsAnswerPayload>;
  /** Unmark a pull request file as viewed */
  unmarkFileAsViewed?: Maybe<UnmarkFileAsViewedPayload>;
  /** Unmark an issue as a duplicate of another issue. */
  unmarkIssueAsDuplicate?: Maybe<UnmarkIssueAsDuplicatePayload>;
  /** Unmark a project as a template. */
  unmarkProjectV2AsTemplate?: Maybe<UnmarkProjectV2AsTemplatePayload>;
  /** Unminimizes a comment on an Issue, Commit, Pull Request, or Gist */
  unminimizeComment?: Maybe<UnminimizeCommentPayload>;
  /** Unpin a pinned issue from a repository */
  unpinIssue?: Maybe<UnpinIssuePayload>;
  /** Marks a review thread as unresolved. */
  unresolveReviewThread?: Maybe<UnresolveReviewThreadPayload>;
  /** Unsubscribes from notifications */
  unsubscribeFromNotifications?: Maybe<UnsubscribeFromNotificationsPayload>;
  /** Update a branch protection rule */
  updateBranchProtectionRule?: Maybe<UpdateBranchProtectionRulePayload>;
  /** Update a check run */
  updateCheckRun?: Maybe<UpdateCheckRunPayload>;
  /** Modifies the settings of an existing check suite */
  updateCheckSuitePreferences?: Maybe<UpdateCheckSuitePreferencesPayload>;
  /** Update a discussion */
  updateDiscussion?: Maybe<UpdateDiscussionPayload>;
  /** Update the contents of a comment on a Discussion */
  updateDiscussionComment?: Maybe<UpdateDiscussionCommentPayload>;
  /** Updates the role of an enterprise administrator. */
  updateEnterpriseAdministratorRole?: Maybe<UpdateEnterpriseAdministratorRolePayload>;
  /** Sets whether private repository forks are enabled for an enterprise. */
  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Maybe<UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;
  /** Sets the base repository permission for organizations in an enterprise. */
  updateEnterpriseDefaultRepositoryPermissionSetting?: Maybe<UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;
  /** Sets whether organization members with admin permissions on a repository can change repository visibility. */
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Maybe<UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;
  /** Sets the members can create repositories setting for an enterprise. */
  updateEnterpriseMembersCanCreateRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;
  /** Sets the members can delete issues setting for an enterprise. */
  updateEnterpriseMembersCanDeleteIssuesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;
  /** Sets the members can delete repositories setting for an enterprise. */
  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;
  /** Sets whether members can invite collaborators are enabled for an enterprise. */
  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Maybe<UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;
  /** Sets whether or not an organization owner can make purchases. */
  updateEnterpriseMembersCanMakePurchasesSetting?: Maybe<UpdateEnterpriseMembersCanMakePurchasesSettingPayload>;
  /** Sets the members can update protected branches setting for an enterprise. */
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Maybe<UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;
  /** Sets the members can view dependency insights for an enterprise. */
  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Maybe<UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;
  /** Sets whether organization projects are enabled for an enterprise. */
  updateEnterpriseOrganizationProjectsSetting?: Maybe<UpdateEnterpriseOrganizationProjectsSettingPayload>;
  /** Updates the role of an enterprise owner with an organization. */
  updateEnterpriseOwnerOrganizationRole?: Maybe<UpdateEnterpriseOwnerOrganizationRolePayload>;
  /** Updates an enterprise's profile. */
  updateEnterpriseProfile?: Maybe<UpdateEnterpriseProfilePayload>;
  /** Sets whether repository projects are enabled for a enterprise. */
  updateEnterpriseRepositoryProjectsSetting?: Maybe<UpdateEnterpriseRepositoryProjectsSettingPayload>;
  /** Sets whether team discussions are enabled for an enterprise. */
  updateEnterpriseTeamDiscussionsSetting?: Maybe<UpdateEnterpriseTeamDiscussionsSettingPayload>;
  /** Sets whether two factor authentication is required for all users in an enterprise. */
  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Maybe<UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;
  /** Updates an environment. */
  updateEnvironment?: Maybe<UpdateEnvironmentPayload>;
  /** Sets whether an IP allow list is enabled on an owner. */
  updateIpAllowListEnabledSetting?: Maybe<UpdateIpAllowListEnabledSettingPayload>;
  /** Updates an IP allow list entry. */
  updateIpAllowListEntry?: Maybe<UpdateIpAllowListEntryPayload>;
  /** Sets whether IP allow list configuration for installed GitHub Apps is enabled on an owner. */
  updateIpAllowListForInstalledAppsEnabledSetting?: Maybe<UpdateIpAllowListForInstalledAppsEnabledSettingPayload>;
  /** Updates an Issue. */
  updateIssue?: Maybe<UpdateIssuePayload>;
  /** Updates an IssueComment object. */
  updateIssueComment?: Maybe<UpdateIssueCommentPayload>;
  /** Updates an existing label. */
  updateLabel?: Maybe<UpdateLabelPayload>;
  /** Update the setting to restrict notifications to only verified or approved domains available to an owner. */
  updateNotificationRestrictionSetting?: Maybe<UpdateNotificationRestrictionSettingPayload>;
  /** Sets whether private repository forks are enabled for an organization. */
  updateOrganizationAllowPrivateRepositoryForkingSetting?: Maybe<UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload>;
  /** Sets whether contributors are required to sign off on web-based commits for repositories in an organization. */
  updateOrganizationWebCommitSignoffSetting?: Maybe<UpdateOrganizationWebCommitSignoffSettingPayload>;
  /**
   * Toggle the setting for your GitHub Sponsors profile that allows other GitHub
   * accounts to sponsor you on GitHub while paying for the sponsorship on Patreon.
   * Only applicable when you have a GitHub Sponsors profile and have connected
   * your GitHub account with Patreon.
   */
  updatePatreonSponsorability?: Maybe<UpdatePatreonSponsorabilityPayload>;
  /** Updates an existing project. */
  updateProject?: Maybe<UpdateProjectPayload>;
  /** Updates an existing project card. */
  updateProjectCard?: Maybe<UpdateProjectCardPayload>;
  /** Updates an existing project column. */
  updateProjectColumn?: Maybe<UpdateProjectColumnPayload>;
  /** Updates an existing project. */
  updateProjectV2?: Maybe<UpdateProjectV2Payload>;
  /** Update the collaborators on a team or a project */
  updateProjectV2Collaborators?: Maybe<UpdateProjectV2CollaboratorsPayload>;
  /** Updates a draft issue within a Project. */
  updateProjectV2DraftIssue?: Maybe<UpdateProjectV2DraftIssuePayload>;
  /**
   * This mutation updates the value of a field for an item in a Project. Currently
   * only single-select, text, number, date, and iteration fields are supported.
   */
  updateProjectV2ItemFieldValue?: Maybe<UpdateProjectV2ItemFieldValuePayload>;
  /** This mutation updates the position of the item in the project, where the position represents the priority of an item. */
  updateProjectV2ItemPosition?: Maybe<UpdateProjectV2ItemPositionPayload>;
  /** Updates a status update within a Project. */
  updateProjectV2StatusUpdate?: Maybe<UpdateProjectV2StatusUpdatePayload>;
  /** Update a pull request */
  updatePullRequest?: Maybe<UpdatePullRequestPayload>;
  /** Merge or Rebase HEAD from upstream branch into pull request branch */
  updatePullRequestBranch?: Maybe<UpdatePullRequestBranchPayload>;
  /** Updates the body of a pull request review. */
  updatePullRequestReview?: Maybe<UpdatePullRequestReviewPayload>;
  /** Updates a pull request review comment. */
  updatePullRequestReviewComment?: Maybe<UpdatePullRequestReviewCommentPayload>;
  /** Update a Git Ref. */
  updateRef?: Maybe<UpdateRefPayload>;
  /**
   * Creates, updates and/or deletes multiple refs in a repository.
   *
   * This mutation takes a list of `RefUpdate`s and performs these updates
   * on the repository. All updates are performed atomically, meaning that
   * if one of them is rejected, no other ref will be modified.
   *
   * `RefUpdate.beforeOid` specifies that the given reference needs to point
   * to the given value before performing any updates. A value of
   * `0000000000000000000000000000000000000000` can be used to verify that
   * the references should not exist.
   *
   * `RefUpdate.afterOid` specifies the value that the given reference
   * will point to after performing all updates. A value of
   * `0000000000000000000000000000000000000000` can be used to delete a
   * reference.
   *
   * If `RefUpdate.force` is set to `true`, a non-fast-forward updates
   * for the given reference will be allowed.
   */
  updateRefs?: Maybe<UpdateRefsPayload>;
  /** Update information about a repository. */
  updateRepository?: Maybe<UpdateRepositoryPayload>;
  /** Update a repository ruleset */
  updateRepositoryRuleset?: Maybe<UpdateRepositoryRulesetPayload>;
  /** Sets whether contributors are required to sign off on web-based commits for a repository. */
  updateRepositoryWebCommitSignoffSetting?: Maybe<UpdateRepositoryWebCommitSignoffSettingPayload>;
  /** Change visibility of your sponsorship and opt in or out of email updates from the maintainer. */
  updateSponsorshipPreferences?: Maybe<UpdateSponsorshipPreferencesPayload>;
  /** Updates the state for subscribable subjects. */
  updateSubscription?: Maybe<UpdateSubscriptionPayload>;
  /** Updates a team discussion. */
  updateTeamDiscussion?: Maybe<UpdateTeamDiscussionPayload>;
  /** Updates a discussion comment. */
  updateTeamDiscussionComment?: Maybe<UpdateTeamDiscussionCommentPayload>;
  /** Updates team review assignment. */
  updateTeamReviewAssignment?: Maybe<UpdateTeamReviewAssignmentPayload>;
  /** Update team repository. */
  updateTeamsRepository?: Maybe<UpdateTeamsRepositoryPayload>;
  /** Replaces the repository's topics with the given topics. */
  updateTopics?: Maybe<UpdateTopicsPayload>;
  /** Updates an existing user list. */
  updateUserList?: Maybe<UpdateUserListPayload>;
  /** Updates which of the viewer's lists an item belongs to */
  updateUserListsForItem?: Maybe<UpdateUserListsForItemPayload>;
  /** Verify that a verifiable domain has the expected DNS record. */
  verifyVerifiableDomain?: Maybe<VerifyVerifiableDomainPayload>;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAbortQueuedMigrationsArgs = {
  input: AbortQueuedMigrationsInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAbortRepositoryMigrationArgs = {
  input: AbortRepositoryMigrationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAcceptEnterpriseAdministratorInvitationArgs = {
  input: AcceptEnterpriseAdministratorInvitationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAcceptEnterpriseMemberInvitationArgs = {
  input: AcceptEnterpriseMemberInvitationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAcceptTopicSuggestionArgs = {
  input: AcceptTopicSuggestionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddAssigneesToAssignableArgs = {
  input: AddAssigneesToAssignableInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddCommentArgs = {
  input: AddCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddDiscussionCommentArgs = {
  input: AddDiscussionCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddDiscussionPollVoteArgs = {
  input: AddDiscussionPollVoteInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddEnterpriseOrganizationMemberArgs = {
  input: AddEnterpriseOrganizationMemberInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddEnterpriseSupportEntitlementArgs = {
  input: AddEnterpriseSupportEntitlementInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddLabelsToLabelableArgs = {
  input: AddLabelsToLabelableInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddProjectCardArgs = {
  input: AddProjectCardInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddProjectColumnArgs = {
  input: AddProjectColumnInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddProjectV2DraftIssueArgs = {
  input: AddProjectV2DraftIssueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddProjectV2ItemByIdArgs = {
  input: AddProjectV2ItemByIdInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddPullRequestReviewArgs = {
  input: AddPullRequestReviewInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddPullRequestReviewCommentArgs = {
  input: AddPullRequestReviewCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddPullRequestReviewThreadArgs = {
  input: AddPullRequestReviewThreadInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddPullRequestReviewThreadReplyArgs = {
  input: AddPullRequestReviewThreadReplyInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddReactionArgs = {
  input: AddReactionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddStarArgs = {
  input: AddStarInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddUpvoteArgs = {
  input: AddUpvoteInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationAddVerifiableDomainArgs = {
  input: AddVerifiableDomainInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationApproveDeploymentsArgs = {
  input: ApproveDeploymentsInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationApproveVerifiableDomainArgs = {
  input: ApproveVerifiableDomainInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationArchiveProjectV2ItemArgs = {
  input: ArchiveProjectV2ItemInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationArchiveRepositoryArgs = {
  input: ArchiveRepositoryInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCancelEnterpriseAdminInvitationArgs = {
  input: CancelEnterpriseAdminInvitationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCancelEnterpriseMemberInvitationArgs = {
  input: CancelEnterpriseMemberInvitationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCancelSponsorshipArgs = {
  input: CancelSponsorshipInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationChangeUserStatusArgs = {
  input: ChangeUserStatusInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationClearLabelsFromLabelableArgs = {
  input: ClearLabelsFromLabelableInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationClearProjectV2ItemFieldValueArgs = {
  input: ClearProjectV2ItemFieldValueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCloneProjectArgs = {
  input: CloneProjectInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCloneTemplateRepositoryArgs = {
  input: CloneTemplateRepositoryInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCloseDiscussionArgs = {
  input: CloseDiscussionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCloseIssueArgs = {
  input: CloseIssueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationClosePullRequestArgs = {
  input: ClosePullRequestInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationConvertProjectCardNoteToIssueArgs = {
  input: ConvertProjectCardNoteToIssueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationConvertProjectV2DraftIssueItemToIssueArgs = {
  input: ConvertProjectV2DraftIssueItemToIssueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationConvertPullRequestToDraftArgs = {
  input: ConvertPullRequestToDraftInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCopyProjectV2Args = {
  input: CopyProjectV2Input;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateAttributionInvitationArgs = {
  input: CreateAttributionInvitationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateBranchProtectionRuleArgs = {
  input: CreateBranchProtectionRuleInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateCheckRunArgs = {
  input: CreateCheckRunInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateCheckSuiteArgs = {
  input: CreateCheckSuiteInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateCommitOnBranchArgs = {
  input: CreateCommitOnBranchInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateDeploymentArgs = {
  input: CreateDeploymentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateDeploymentStatusArgs = {
  input: CreateDeploymentStatusInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateDiscussionArgs = {
  input: CreateDiscussionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateEnterpriseOrganizationArgs = {
  input: CreateEnterpriseOrganizationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateEnvironmentArgs = {
  input: CreateEnvironmentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateIpAllowListEntryArgs = {
  input: CreateIpAllowListEntryInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateIssueArgs = {
  input: CreateIssueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateLabelArgs = {
  input: CreateLabelInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateLinkedBranchArgs = {
  input: CreateLinkedBranchInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateMigrationSourceArgs = {
  input: CreateMigrationSourceInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateProjectArgs = {
  input: CreateProjectInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateProjectV2Args = {
  input: CreateProjectV2Input;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateProjectV2FieldArgs = {
  input: CreateProjectV2FieldInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateProjectV2StatusUpdateArgs = {
  input: CreateProjectV2StatusUpdateInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreatePullRequestArgs = {
  input: CreatePullRequestInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateRefArgs = {
  input: CreateRefInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateRepositoryArgs = {
  input: CreateRepositoryInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateRepositoryRulesetArgs = {
  input: CreateRepositoryRulesetInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateSponsorsListingArgs = {
  input: CreateSponsorsListingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateSponsorsTierArgs = {
  input: CreateSponsorsTierInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateSponsorshipArgs = {
  input: CreateSponsorshipInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateSponsorshipsArgs = {
  input: CreateSponsorshipsInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateTeamDiscussionArgs = {
  input: CreateTeamDiscussionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateTeamDiscussionCommentArgs = {
  input: CreateTeamDiscussionCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationCreateUserListArgs = {
  input: CreateUserListInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeclineTopicSuggestionArgs = {
  input: DeclineTopicSuggestionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteBranchProtectionRuleArgs = {
  input: DeleteBranchProtectionRuleInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteDeploymentArgs = {
  input: DeleteDeploymentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteDiscussionArgs = {
  input: DeleteDiscussionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteDiscussionCommentArgs = {
  input: DeleteDiscussionCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteEnvironmentArgs = {
  input: DeleteEnvironmentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteIpAllowListEntryArgs = {
  input: DeleteIpAllowListEntryInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteIssueArgs = {
  input: DeleteIssueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteIssueCommentArgs = {
  input: DeleteIssueCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteLabelArgs = {
  input: DeleteLabelInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteLinkedBranchArgs = {
  input: DeleteLinkedBranchInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeletePackageVersionArgs = {
  input: DeletePackageVersionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteProjectArgs = {
  input: DeleteProjectInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteProjectCardArgs = {
  input: DeleteProjectCardInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteProjectColumnArgs = {
  input: DeleteProjectColumnInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteProjectV2Args = {
  input: DeleteProjectV2Input;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteProjectV2FieldArgs = {
  input: DeleteProjectV2FieldInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteProjectV2ItemArgs = {
  input: DeleteProjectV2ItemInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteProjectV2StatusUpdateArgs = {
  input: DeleteProjectV2StatusUpdateInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteProjectV2WorkflowArgs = {
  input: DeleteProjectV2WorkflowInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeletePullRequestReviewArgs = {
  input: DeletePullRequestReviewInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeletePullRequestReviewCommentArgs = {
  input: DeletePullRequestReviewCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteRefArgs = {
  input: DeleteRefInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteRepositoryRulesetArgs = {
  input: DeleteRepositoryRulesetInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteTeamDiscussionArgs = {
  input: DeleteTeamDiscussionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteTeamDiscussionCommentArgs = {
  input: DeleteTeamDiscussionCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteUserListArgs = {
  input: DeleteUserListInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDeleteVerifiableDomainArgs = {
  input: DeleteVerifiableDomainInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDequeuePullRequestArgs = {
  input: DequeuePullRequestInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDisablePullRequestAutoMergeArgs = {
  input: DisablePullRequestAutoMergeInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDismissPullRequestReviewArgs = {
  input: DismissPullRequestReviewInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationDismissRepositoryVulnerabilityAlertArgs = {
  input: DismissRepositoryVulnerabilityAlertInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationEnablePullRequestAutoMergeArgs = {
  input: EnablePullRequestAutoMergeInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationEnqueuePullRequestArgs = {
  input: EnqueuePullRequestInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationFollowOrganizationArgs = {
  input: FollowOrganizationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationFollowUserArgs = {
  input: FollowUserInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationGrantEnterpriseOrganizationsMigratorRoleArgs = {
  input: GrantEnterpriseOrganizationsMigratorRoleInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationGrantMigratorRoleArgs = {
  input: GrantMigratorRoleInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationImportProjectArgs = {
  input: ImportProjectInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationInviteEnterpriseAdminArgs = {
  input: InviteEnterpriseAdminInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationInviteEnterpriseMemberArgs = {
  input: InviteEnterpriseMemberInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationLinkProjectV2ToRepositoryArgs = {
  input: LinkProjectV2ToRepositoryInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationLinkProjectV2ToTeamArgs = {
  input: LinkProjectV2ToTeamInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationLinkRepositoryToProjectArgs = {
  input: LinkRepositoryToProjectInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationLockLockableArgs = {
  input: LockLockableInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationMarkDiscussionCommentAsAnswerArgs = {
  input: MarkDiscussionCommentAsAnswerInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationMarkFileAsViewedArgs = {
  input: MarkFileAsViewedInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationMarkNotificationAsDoneArgs = {
  input: MarkNotificationAsDoneInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationMarkProjectV2AsTemplateArgs = {
  input: MarkProjectV2AsTemplateInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationMarkPullRequestReadyForReviewArgs = {
  input: MarkPullRequestReadyForReviewInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationMergeBranchArgs = {
  input: MergeBranchInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationMergePullRequestArgs = {
  input: MergePullRequestInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationMinimizeCommentArgs = {
  input: MinimizeCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationMoveProjectCardArgs = {
  input: MoveProjectCardInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationMoveProjectColumnArgs = {
  input: MoveProjectColumnInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationPinEnvironmentArgs = {
  input: PinEnvironmentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationPinIssueArgs = {
  input: PinIssueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationPublishSponsorsTierArgs = {
  input: PublishSponsorsTierInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRegenerateEnterpriseIdentityProviderRecoveryCodesArgs = {
  input: RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRegenerateVerifiableDomainTokenArgs = {
  input: RegenerateVerifiableDomainTokenInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRejectDeploymentsArgs = {
  input: RejectDeploymentsInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRemoveAssigneesFromAssignableArgs = {
  input: RemoveAssigneesFromAssignableInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRemoveEnterpriseAdminArgs = {
  input: RemoveEnterpriseAdminInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRemoveEnterpriseIdentityProviderArgs = {
  input: RemoveEnterpriseIdentityProviderInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRemoveEnterpriseMemberArgs = {
  input: RemoveEnterpriseMemberInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRemoveEnterpriseOrganizationArgs = {
  input: RemoveEnterpriseOrganizationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRemoveEnterpriseSupportEntitlementArgs = {
  input: RemoveEnterpriseSupportEntitlementInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRemoveLabelsFromLabelableArgs = {
  input: RemoveLabelsFromLabelableInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRemoveOutsideCollaboratorArgs = {
  input: RemoveOutsideCollaboratorInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRemoveReactionArgs = {
  input: RemoveReactionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRemoveStarArgs = {
  input: RemoveStarInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRemoveUpvoteArgs = {
  input: RemoveUpvoteInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationReopenDiscussionArgs = {
  input: ReopenDiscussionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationReopenIssueArgs = {
  input: ReopenIssueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationReopenPullRequestArgs = {
  input: ReopenPullRequestInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationReorderEnvironmentArgs = {
  input: ReorderEnvironmentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRequestReviewsArgs = {
  input: RequestReviewsInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRerequestCheckSuiteArgs = {
  input: RerequestCheckSuiteInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationResolveReviewThreadArgs = {
  input: ResolveReviewThreadInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRetireSponsorsTierArgs = {
  input: RetireSponsorsTierInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRevertPullRequestArgs = {
  input: RevertPullRequestInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRevokeEnterpriseOrganizationsMigratorRoleArgs = {
  input: RevokeEnterpriseOrganizationsMigratorRoleInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationRevokeMigratorRoleArgs = {
  input: RevokeMigratorRoleInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationSetEnterpriseIdentityProviderArgs = {
  input: SetEnterpriseIdentityProviderInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationSetOrganizationInteractionLimitArgs = {
  input: SetOrganizationInteractionLimitInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationSetRepositoryInteractionLimitArgs = {
  input: SetRepositoryInteractionLimitInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationSetUserInteractionLimitArgs = {
  input: SetUserInteractionLimitInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationStartOrganizationMigrationArgs = {
  input: StartOrganizationMigrationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationStartRepositoryMigrationArgs = {
  input: StartRepositoryMigrationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationSubmitPullRequestReviewArgs = {
  input: SubmitPullRequestReviewInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationTransferEnterpriseOrganizationArgs = {
  input: TransferEnterpriseOrganizationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationTransferIssueArgs = {
  input: TransferIssueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnarchiveProjectV2ItemArgs = {
  input: UnarchiveProjectV2ItemInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnarchiveRepositoryArgs = {
  input: UnarchiveRepositoryInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnfollowOrganizationArgs = {
  input: UnfollowOrganizationInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnfollowUserArgs = {
  input: UnfollowUserInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnlinkProjectV2FromRepositoryArgs = {
  input: UnlinkProjectV2FromRepositoryInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnlinkProjectV2FromTeamArgs = {
  input: UnlinkProjectV2FromTeamInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnlinkRepositoryFromProjectArgs = {
  input: UnlinkRepositoryFromProjectInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnlockLockableArgs = {
  input: UnlockLockableInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnmarkDiscussionCommentAsAnswerArgs = {
  input: UnmarkDiscussionCommentAsAnswerInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnmarkFileAsViewedArgs = {
  input: UnmarkFileAsViewedInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnmarkIssueAsDuplicateArgs = {
  input: UnmarkIssueAsDuplicateInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnmarkProjectV2AsTemplateArgs = {
  input: UnmarkProjectV2AsTemplateInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnminimizeCommentArgs = {
  input: UnminimizeCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnpinIssueArgs = {
  input: UnpinIssueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnresolveReviewThreadArgs = {
  input: UnresolveReviewThreadInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUnsubscribeFromNotificationsArgs = {
  input: UnsubscribeFromNotificationsInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateBranchProtectionRuleArgs = {
  input: UpdateBranchProtectionRuleInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateCheckRunArgs = {
  input: UpdateCheckRunInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateCheckSuitePreferencesArgs = {
  input: UpdateCheckSuitePreferencesInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateDiscussionArgs = {
  input: UpdateDiscussionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateDiscussionCommentArgs = {
  input: UpdateDiscussionCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseAdministratorRoleArgs = {
  input: UpdateEnterpriseAdministratorRoleInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseAllowPrivateRepositoryForkingSettingArgs = {
  input: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseDefaultRepositoryPermissionSettingArgs = {
  input: UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs =
  {
    input: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
  };

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseMembersCanCreateRepositoriesSettingArgs = {
  input: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseMembersCanDeleteIssuesSettingArgs = {
  input: UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseMembersCanDeleteRepositoriesSettingArgs = {
  input: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseMembersCanInviteCollaboratorsSettingArgs = {
  input: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseMembersCanMakePurchasesSettingArgs = {
  input: UpdateEnterpriseMembersCanMakePurchasesSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs =
  {
    input: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
  };

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseMembersCanViewDependencyInsightsSettingArgs =
  {
    input: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
  };

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseOrganizationProjectsSettingArgs = {
  input: UpdateEnterpriseOrganizationProjectsSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseOwnerOrganizationRoleArgs = {
  input: UpdateEnterpriseOwnerOrganizationRoleInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseProfileArgs = {
  input: UpdateEnterpriseProfileInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseRepositoryProjectsSettingArgs = {
  input: UpdateEnterpriseRepositoryProjectsSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseTeamDiscussionsSettingArgs = {
  input: UpdateEnterpriseTeamDiscussionsSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs =
  {
    input: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
  };

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateEnvironmentArgs = {
  input: UpdateEnvironmentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateIpAllowListEnabledSettingArgs = {
  input: UpdateIpAllowListEnabledSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateIpAllowListEntryArgs = {
  input: UpdateIpAllowListEntryInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateIpAllowListForInstalledAppsEnabledSettingArgs = {
  input: UpdateIpAllowListForInstalledAppsEnabledSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateIssueArgs = {
  input: UpdateIssueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateIssueCommentArgs = {
  input: UpdateIssueCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateLabelArgs = {
  input: UpdateLabelInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateNotificationRestrictionSettingArgs = {
  input: UpdateNotificationRestrictionSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateOrganizationAllowPrivateRepositoryForkingSettingArgs =
  {
    input: UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
  };

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateOrganizationWebCommitSignoffSettingArgs = {
  input: UpdateOrganizationWebCommitSignoffSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdatePatreonSponsorabilityArgs = {
  input: UpdatePatreonSponsorabilityInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateProjectArgs = {
  input: UpdateProjectInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateProjectCardArgs = {
  input: UpdateProjectCardInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateProjectColumnArgs = {
  input: UpdateProjectColumnInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateProjectV2Args = {
  input: UpdateProjectV2Input;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateProjectV2CollaboratorsArgs = {
  input: UpdateProjectV2CollaboratorsInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateProjectV2DraftIssueArgs = {
  input: UpdateProjectV2DraftIssueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateProjectV2ItemFieldValueArgs = {
  input: UpdateProjectV2ItemFieldValueInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateProjectV2ItemPositionArgs = {
  input: UpdateProjectV2ItemPositionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateProjectV2StatusUpdateArgs = {
  input: UpdateProjectV2StatusUpdateInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdatePullRequestArgs = {
  input: UpdatePullRequestInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdatePullRequestBranchArgs = {
  input: UpdatePullRequestBranchInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdatePullRequestReviewArgs = {
  input: UpdatePullRequestReviewInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdatePullRequestReviewCommentArgs = {
  input: UpdatePullRequestReviewCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateRefArgs = {
  input: UpdateRefInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateRefsArgs = {
  input: UpdateRefsInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateRepositoryArgs = {
  input: UpdateRepositoryInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateRepositoryRulesetArgs = {
  input: UpdateRepositoryRulesetInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateRepositoryWebCommitSignoffSettingArgs = {
  input: UpdateRepositoryWebCommitSignoffSettingInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateSponsorshipPreferencesArgs = {
  input: UpdateSponsorshipPreferencesInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateSubscriptionArgs = {
  input: UpdateSubscriptionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateTeamDiscussionArgs = {
  input: UpdateTeamDiscussionInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateTeamDiscussionCommentArgs = {
  input: UpdateTeamDiscussionCommentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateTeamReviewAssignmentArgs = {
  input: UpdateTeamReviewAssignmentInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateTeamsRepositoryArgs = {
  input: UpdateTeamsRepositoryInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateTopicsArgs = {
  input: UpdateTopicsInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateUserListArgs = {
  input: UpdateUserListInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationUpdateUserListsForItemArgs = {
  input: UpdateUserListsForItemInput;
};

/** The root query for implementing GraphQL mutations. */
export type MutationVerifyVerifiableDomainArgs = {
  input: VerifyVerifiableDomainInput;
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars["ID"]["output"];
};

/** The possible values for the notification restriction setting. */
export enum NotificationRestrictionSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = "DISABLED",
  /** The setting is enabled for the owner. */
  Enabled = "ENABLED",
}

/**
 * An OIDC identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
export type OidcProvider = Node & {
  __typename?: "OIDCProvider";
  /** The enterprise this identity provider belongs to. */
  enterprise?: Maybe<Enterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  externalIdentities: ExternalIdentityConnection;
  /** The Node ID of the OIDCProvider object */
  id: Scalars["ID"]["output"];
  /** The OIDC identity provider type */
  providerType: OidcProviderType;
  /** The id of the tenant this provider is attached to */
  tenantId: Scalars["String"]["output"];
};

/**
 * An OIDC identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
export type OidcProviderExternalIdentitiesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  login?: InputMaybe<Scalars["String"]["input"]>;
  membersOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  userName?: InputMaybe<Scalars["String"]["input"]>;
};

/** The OIDC identity provider type */
export enum OidcProviderType {
  /** Azure Active Directory */
  Aad = "AAD",
}

/** Metadata for an audit entry with action oauth_application.* */
export type OauthApplicationAuditEntryData = {
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars["String"]["output"]>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars["URI"]["output"]>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars["URI"]["output"]>;
};

/** Audit log entry for a oauth_application.create event. */
export type OauthApplicationCreateAuditEntry = AuditEntry &
  Node &
  OauthApplicationAuditEntryData &
  OrganizationAuditEntryData & {
    __typename?: "OauthApplicationCreateAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The application URL of the OAuth application. */
    applicationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The callback URL of the OAuth application. */
    callbackUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OauthApplicationCreateAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The name of the OAuth application. */
    oauthApplicationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the OAuth application */
    oauthApplicationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the OAuth application */
    oauthApplicationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The rate limit of the OAuth application. */
    rateLimit?: Maybe<Scalars["Int"]["output"]>;
    /** The state of the OAuth application. */
    state?: Maybe<OauthApplicationCreateAuditEntryState>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** The state of an OAuth application when it was created. */
export enum OauthApplicationCreateAuditEntryState {
  /** The OAuth application was active and allowed to have OAuth Accesses. */
  Active = "ACTIVE",
  /** The OAuth application was in the process of being deleted. */
  PendingDeletion = "PENDING_DELETION",
  /** The OAuth application was suspended from generating OAuth Accesses due to abuse or security concerns. */
  Suspended = "SUSPENDED",
}

/** The corresponding operation type for the action */
export enum OperationType {
  /** An existing resource was accessed */
  Access = "ACCESS",
  /** A resource performed an authentication event */
  Authentication = "AUTHENTICATION",
  /** A new resource was created */
  Create = "CREATE",
  /** An existing resource was modified */
  Modify = "MODIFY",
  /** An existing resource was removed */
  Remove = "REMOVE",
  /** An existing resource was restored */
  Restore = "RESTORE",
  /** An existing resource was transferred between multiple resources */
  Transfer = "TRANSFER",
}

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = "ASC",
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = "DESC",
}

/** Audit log entry for a org.add_billing_manager */
export type OrgAddBillingManagerAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgAddBillingManagerAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgAddBillingManagerAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The email address used to invite a billing manager for the organization. */
    invitationEmail?: Maybe<Scalars["String"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.add_member */
export type OrgAddMemberAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgAddMemberAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgAddMemberAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The permission level of the member added to the organization. */
    permission?: Maybe<OrgAddMemberAuditEntryPermission>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** The permissions available to members on an Organization. */
export enum OrgAddMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = "ADMIN",
  /** Can read and clone repositories. */
  Read = "READ",
}

/** Audit log entry for a org.block_user */
export type OrgBlockUserAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgBlockUserAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The blocked user. */
    blockedUser?: Maybe<User>;
    /** The username of the blocked user. */
    blockedUserName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the blocked user. */
    blockedUserResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the blocked user. */
    blockedUserUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgBlockUserAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.config.disable_collaborators_only event. */
export type OrgConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgConfigDisableCollaboratorsOnlyAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgConfigDisableCollaboratorsOnlyAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.config.enable_collaborators_only event. */
export type OrgConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgConfigEnableCollaboratorsOnlyAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgConfigEnableCollaboratorsOnlyAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.create event. */
export type OrgCreateAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgCreateAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The billing plan for the Organization. */
    billingPlan?: Maybe<OrgCreateAuditEntryBillingPlan>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgCreateAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** The billing plans available for organizations. */
export enum OrgCreateAuditEntryBillingPlan {
  /** Team Plan */
  Business = "BUSINESS",
  /** Enterprise Cloud Plan */
  BusinessPlus = "BUSINESS_PLUS",
  /** Free Plan */
  Free = "FREE",
  /** Tiered Per Seat Plan */
  TieredPerSeat = "TIERED_PER_SEAT",
  /** Legacy Unlimited Plan */
  Unlimited = "UNLIMITED",
}

/** Audit log entry for a org.disable_oauth_app_restrictions event. */
export type OrgDisableOauthAppRestrictionsAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgDisableOauthAppRestrictionsAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgDisableOauthAppRestrictionsAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.disable_saml event. */
export type OrgDisableSamlAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgDisableSamlAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The SAML provider's digest algorithm URL. */
    digestMethodUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The Node ID of the OrgDisableSamlAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The SAML provider's issuer URL. */
    issuerUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The SAML provider's signature algorithm URL. */
    signatureMethodUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The SAML provider's single sign-on URL. */
    singleSignOnUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.disable_two_factor_requirement event. */
export type OrgDisableTwoFactorRequirementAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgDisableTwoFactorRequirementAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgDisableTwoFactorRequirementAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.enable_oauth_app_restrictions event. */
export type OrgEnableOauthAppRestrictionsAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgEnableOauthAppRestrictionsAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgEnableOauthAppRestrictionsAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.enable_saml event. */
export type OrgEnableSamlAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgEnableSamlAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The SAML provider's digest algorithm URL. */
    digestMethodUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The Node ID of the OrgEnableSamlAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The SAML provider's issuer URL. */
    issuerUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The SAML provider's signature algorithm URL. */
    signatureMethodUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The SAML provider's single sign-on URL. */
    singleSignOnUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.enable_two_factor_requirement event. */
export type OrgEnableTwoFactorRequirementAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgEnableTwoFactorRequirementAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgEnableTwoFactorRequirementAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Ordering options for an organization's enterprise owner connections. */
export type OrgEnterpriseOwnerOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise owners by. */
  field: OrgEnterpriseOwnerOrderField;
};

/** Properties by which enterprise owners can be ordered. */
export enum OrgEnterpriseOwnerOrderField {
  /** Order enterprise owners by login. */
  Login = "LOGIN",
}

/** Audit log entry for a org.invite_member event. */
export type OrgInviteMemberAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgInviteMemberAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The email address of the organization invitation. */
    email?: Maybe<Scalars["String"]["output"]>;
    /** The Node ID of the OrgInviteMemberAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The organization invitation. */
    organizationInvitation?: Maybe<OrganizationInvitation>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.invite_to_business event. */
export type OrgInviteToBusinessAuditEntry = AuditEntry &
  EnterpriseAuditEntryData &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgInviteToBusinessAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The HTTP path for this enterprise. */
    enterpriseResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The slug of the enterprise. */
    enterpriseSlug?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP URL for this enterprise. */
    enterpriseUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The Node ID of the OrgInviteToBusinessAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.oauth_app_access_approved event. */
export type OrgOauthAppAccessApprovedAuditEntry = AuditEntry &
  Node &
  OauthApplicationAuditEntryData &
  OrganizationAuditEntryData & {
    __typename?: "OrgOauthAppAccessApprovedAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgOauthAppAccessApprovedAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The name of the OAuth application. */
    oauthApplicationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the OAuth application */
    oauthApplicationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the OAuth application */
    oauthApplicationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.oauth_app_access_blocked event. */
export type OrgOauthAppAccessBlockedAuditEntry = AuditEntry &
  Node &
  OauthApplicationAuditEntryData &
  OrganizationAuditEntryData & {
    __typename?: "OrgOauthAppAccessBlockedAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgOauthAppAccessBlockedAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The name of the OAuth application. */
    oauthApplicationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the OAuth application */
    oauthApplicationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the OAuth application */
    oauthApplicationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.oauth_app_access_denied event. */
export type OrgOauthAppAccessDeniedAuditEntry = AuditEntry &
  Node &
  OauthApplicationAuditEntryData &
  OrganizationAuditEntryData & {
    __typename?: "OrgOauthAppAccessDeniedAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgOauthAppAccessDeniedAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The name of the OAuth application. */
    oauthApplicationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the OAuth application */
    oauthApplicationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the OAuth application */
    oauthApplicationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.oauth_app_access_requested event. */
export type OrgOauthAppAccessRequestedAuditEntry = AuditEntry &
  Node &
  OauthApplicationAuditEntryData &
  OrganizationAuditEntryData & {
    __typename?: "OrgOauthAppAccessRequestedAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgOauthAppAccessRequestedAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The name of the OAuth application. */
    oauthApplicationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the OAuth application */
    oauthApplicationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the OAuth application */
    oauthApplicationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.oauth_app_access_unblocked event. */
export type OrgOauthAppAccessUnblockedAuditEntry = AuditEntry &
  Node &
  OauthApplicationAuditEntryData &
  OrganizationAuditEntryData & {
    __typename?: "OrgOauthAppAccessUnblockedAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgOauthAppAccessUnblockedAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The name of the OAuth application. */
    oauthApplicationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the OAuth application */
    oauthApplicationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the OAuth application */
    oauthApplicationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.remove_billing_manager event. */
export type OrgRemoveBillingManagerAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgRemoveBillingManagerAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgRemoveBillingManagerAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The reason for the billing manager being removed. */
    reason?: Maybe<OrgRemoveBillingManagerAuditEntryReason>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** The reason a billing manager was removed from an Organization. */
export enum OrgRemoveBillingManagerAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = "SAML_EXTERNAL_IDENTITY_MISSING",
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = "SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY",
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE",
}

/** Audit log entry for a org.remove_member event. */
export type OrgRemoveMemberAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgRemoveMemberAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgRemoveMemberAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The types of membership the member has with the organization. */
    membershipTypes?: Maybe<Array<OrgRemoveMemberAuditEntryMembershipType>>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The reason for the member being removed. */
    reason?: Maybe<OrgRemoveMemberAuditEntryReason>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** The type of membership a user has with an Organization. */
export enum OrgRemoveMemberAuditEntryMembershipType {
  /**
   * Organization owners have full access and can change several settings,
   * including the names of repositories that belong to the Organization and Owners
   * team membership. In addition, organization owners can delete the organization
   * and all of its repositories.
   */
  Admin = "ADMIN",
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = "BILLING_MANAGER",
  /** A direct member is a user that is a member of the Organization. */
  DirectMember = "DIRECT_MEMBER",
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = "OUTSIDE_COLLABORATOR",
  /** A suspended member. */
  Suspended = "SUSPENDED",
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the Organization.
   */
  Unaffiliated = "UNAFFILIATED",
}

/** The reason a member was removed from an Organization. */
export enum OrgRemoveMemberAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = "SAML_EXTERNAL_IDENTITY_MISSING",
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = "SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY",
  /** User was removed from organization during account recovery */
  TwoFactorAccountRecovery = "TWO_FACTOR_ACCOUNT_RECOVERY",
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE",
  /** User account has been deleted */
  UserAccountDeleted = "USER_ACCOUNT_DELETED",
}

/** Audit log entry for a org.remove_outside_collaborator event. */
export type OrgRemoveOutsideCollaboratorAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgRemoveOutsideCollaboratorAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgRemoveOutsideCollaboratorAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The types of membership the outside collaborator has with the organization. */
    membershipTypes?: Maybe<
      Array<OrgRemoveOutsideCollaboratorAuditEntryMembershipType>
    >;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The reason for the outside collaborator being removed from the Organization. */
    reason?: Maybe<OrgRemoveOutsideCollaboratorAuditEntryReason>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** The type of membership a user has with an Organization. */
export enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = "BILLING_MANAGER",
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = "OUTSIDE_COLLABORATOR",
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the organization.
   */
  Unaffiliated = "UNAFFILIATED",
}

/** The reason an outside collaborator was removed from an Organization. */
export enum OrgRemoveOutsideCollaboratorAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = "SAML_EXTERNAL_IDENTITY_MISSING",
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE",
}

/** Audit log entry for a org.restore_member event. */
export type OrgRestoreMemberAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgRestoreMemberAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgRestoreMemberAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The number of custom email routings for the restored member. */
    restoredCustomEmailRoutingsCount?: Maybe<Scalars["Int"]["output"]>;
    /** The number of issue assignments for the restored member. */
    restoredIssueAssignmentsCount?: Maybe<Scalars["Int"]["output"]>;
    /** Restored organization membership objects. */
    restoredMemberships?: Maybe<Array<OrgRestoreMemberAuditEntryMembership>>;
    /** The number of restored memberships. */
    restoredMembershipsCount?: Maybe<Scalars["Int"]["output"]>;
    /** The number of repositories of the restored member. */
    restoredRepositoriesCount?: Maybe<Scalars["Int"]["output"]>;
    /** The number of starred repositories for the restored member. */
    restoredRepositoryStarsCount?: Maybe<Scalars["Int"]["output"]>;
    /** The number of watched repositories for the restored member. */
    restoredRepositoryWatchesCount?: Maybe<Scalars["Int"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Types of memberships that can be restored for an Organization member. */
export type OrgRestoreMemberAuditEntryMembership =
  | OrgRestoreMemberMembershipOrganizationAuditEntryData
  | OrgRestoreMemberMembershipRepositoryAuditEntryData
  | OrgRestoreMemberMembershipTeamAuditEntryData;

/** Metadata for an organization membership for org.restore_member actions */
export type OrgRestoreMemberMembershipOrganizationAuditEntryData =
  OrganizationAuditEntryData & {
    __typename?: "OrgRestoreMemberMembershipOrganizationAuditEntryData";
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Metadata for a repository membership for org.restore_member actions */
export type OrgRestoreMemberMembershipRepositoryAuditEntryData =
  RepositoryAuditEntryData & {
    __typename?: "OrgRestoreMemberMembershipRepositoryAuditEntryData";
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Metadata for a team membership for org.restore_member actions */
export type OrgRestoreMemberMembershipTeamAuditEntryData =
  TeamAuditEntryData & {
    __typename?: "OrgRestoreMemberMembershipTeamAuditEntryData";
    /** The team associated with the action */
    team?: Maybe<Team>;
    /** The name of the team */
    teamName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for this team */
    teamResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for this team */
    teamUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.unblock_user */
export type OrgUnblockUserAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgUnblockUserAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user being unblocked by the organization. */
    blockedUser?: Maybe<User>;
    /** The username of the blocked user. */
    blockedUserName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the blocked user. */
    blockedUserResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the blocked user. */
    blockedUserUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgUnblockUserAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a org.update_default_repository_permission */
export type OrgUpdateDefaultRepositoryPermissionAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgUpdateDefaultRepositoryPermissionAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgUpdateDefaultRepositoryPermissionAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The new base repository permission level for the organization. */
    permission?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
    /** The former base repository permission level for the organization. */
    permissionWas?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** The default permission a repository can have in an Organization. */
export enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = "ADMIN",
  /** No default permission value. */
  None = "NONE",
  /** Can read and clone repositories. */
  Read = "READ",
  /** Can read, clone and push to repositories. */
  Write = "WRITE",
}

/** Audit log entry for a org.update_member event. */
export type OrgUpdateMemberAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgUpdateMemberAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgUpdateMemberAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The new member permission level for the organization. */
    permission?: Maybe<OrgUpdateMemberAuditEntryPermission>;
    /** The former member permission level for the organization. */
    permissionWas?: Maybe<OrgUpdateMemberAuditEntryPermission>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** The permissions available to members on an Organization. */
export enum OrgUpdateMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = "ADMIN",
  /** Can read and clone repositories. */
  Read = "READ",
}

/** Audit log entry for a org.update_member_repository_creation_permission event. */
export type OrgUpdateMemberRepositoryCreationPermissionAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "OrgUpdateMemberRepositoryCreationPermissionAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** Can members create repositories in the organization. */
    canCreateRepositories?: Maybe<Scalars["Boolean"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the OrgUpdateMemberRepositoryCreationPermissionAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The permission for visibility level of repositories for this organization. */
    visibility?: Maybe<OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility>;
  };

/** The permissions available for repository creation on an Organization. */
export enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  /** All organization members are restricted from creating any repositories. */
  All = "ALL",
  /** All organization members are restricted from creating internal repositories. */
  Internal = "INTERNAL",
  /** All organization members are allowed to create any repositories. */
  None = "NONE",
  /** All organization members are restricted from creating private repositories. */
  Private = "PRIVATE",
  /** All organization members are restricted from creating private or internal repositories. */
  PrivateInternal = "PRIVATE_INTERNAL",
  /** All organization members are restricted from creating public repositories. */
  Public = "PUBLIC",
  /** All organization members are restricted from creating public or internal repositories. */
  PublicInternal = "PUBLIC_INTERNAL",
  /** All organization members are restricted from creating public or private repositories. */
  PublicPrivate = "PUBLIC_PRIVATE",
}

/** Audit log entry for a org.update_member_repository_invitation_permission event. */
export type OrgUpdateMemberRepositoryInvitationPermissionAuditEntry =
  AuditEntry &
    Node &
    OrganizationAuditEntryData & {
      __typename?: "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry";
      /** The action name */
      action: Scalars["String"]["output"];
      /** The user who initiated the action */
      actor?: Maybe<AuditEntryActor>;
      /** The IP address of the actor */
      actorIp?: Maybe<Scalars["String"]["output"]>;
      /** A readable representation of the actor's location */
      actorLocation?: Maybe<ActorLocation>;
      /** The username of the user who initiated the action */
      actorLogin?: Maybe<Scalars["String"]["output"]>;
      /** The HTTP path for the actor. */
      actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
      /** The HTTP URL for the actor. */
      actorUrl?: Maybe<Scalars["URI"]["output"]>;
      /** Can outside collaborators be invited to repositories in the organization. */
      canInviteOutsideCollaboratorsToRepositories?: Maybe<
        Scalars["Boolean"]["output"]
      >;
      /** The time the action was initiated */
      createdAt: Scalars["PreciseDateTime"]["output"];
      /** The Node ID of the OrgUpdateMemberRepositoryInvitationPermissionAuditEntry object */
      id: Scalars["ID"]["output"];
      /** The corresponding operation type for the action */
      operationType?: Maybe<OperationType>;
      /** The Organization associated with the Audit Entry. */
      organization?: Maybe<Organization>;
      /** The name of the Organization. */
      organizationName?: Maybe<Scalars["String"]["output"]>;
      /** The HTTP path for the organization */
      organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
      /** The HTTP URL for the organization */
      organizationUrl?: Maybe<Scalars["URI"]["output"]>;
      /** The user affected by the action */
      user?: Maybe<User>;
      /** For actions involving two users, the actor is the initiator and the user is the affected user. */
      userLogin?: Maybe<Scalars["String"]["output"]>;
      /** The HTTP path for the user. */
      userResourcePath?: Maybe<Scalars["URI"]["output"]>;
      /** The HTTP URL for the user. */
      userUrl?: Maybe<Scalars["URI"]["output"]>;
    };

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Organization = Actor &
  AnnouncementBanner &
  MemberStatusable &
  Node &
  PackageOwner &
  ProfileOwner &
  ProjectOwner &
  ProjectV2Owner &
  ProjectV2Recent &
  RepositoryDiscussionAuthor &
  RepositoryDiscussionCommentAuthor &
  RepositoryOwner &
  Sponsorable &
  UniformResourceLocatable & {
    __typename?: "Organization";
    /** The text of the announcement */
    announcement?: Maybe<Scalars["String"]["output"]>;
    /** The date the announcement was created */
    announcementCreatedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The expiration date of the announcement, if any */
    announcementExpiresAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** Whether the announcement can be dismissed by the user */
    announcementUserDismissible?: Maybe<Scalars["Boolean"]["output"]>;
    /** Determine if this repository owner has any items that can be pinned to their profile. */
    anyPinnableItems: Scalars["Boolean"]["output"];
    /** Identifies the date and time when the organization was archived. */
    archivedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** Audit log entries of the organization */
    auditLog: OrganizationAuditEntryConnection;
    /** A URL pointing to the organization's public avatar. */
    avatarUrl: Scalars["URI"]["output"];
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The organization's public profile description. */
    description?: Maybe<Scalars["String"]["output"]>;
    /** The organization's public profile description rendered to HTML. */
    descriptionHTML?: Maybe<Scalars["String"]["output"]>;
    /** A list of domains owned by the organization. */
    domains?: Maybe<VerifiableDomainConnection>;
    /** The organization's public email. */
    email?: Maybe<Scalars["String"]["output"]>;
    /** A list of owners of the organization's enterprise account. */
    enterpriseOwners: OrganizationEnterpriseOwnerConnection;
    /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
    estimatedNextSponsorsPayoutInCents: Scalars["Int"]["output"];
    /** True if this user/organization has a GitHub Sponsors listing. */
    hasSponsorsListing: Scalars["Boolean"]["output"];
    /** The Node ID of the Organization object */
    id: Scalars["ID"]["output"];
    /** The interaction ability settings for this organization. */
    interactionAbility?: Maybe<RepositoryInteractionAbility>;
    /** The setting value for whether the organization has an IP allow list enabled. */
    ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;
    /** The IP addresses that are allowed to access resources owned by the organization. */
    ipAllowListEntries: IpAllowListEntryConnection;
    /** The setting value for whether the organization has IP allow list configuration for installed GitHub Apps enabled. */
    ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue;
    /** Whether the given account is sponsoring this user/organization. */
    isSponsoredBy: Scalars["Boolean"]["output"];
    /** True if the viewer is sponsored by this user/organization. */
    isSponsoringViewer: Scalars["Boolean"]["output"];
    /** Whether the organization has verified its profile email and website. */
    isVerified: Scalars["Boolean"]["output"];
    /**
     * Showcases a selection of repositories and gists that the profile owner has
     * either curated or that have been selected automatically based on popularity.
     */
    itemShowcase: ProfileItemShowcase;
    /**
     * Calculate how much each sponsor has ever paid total to this maintainer via
     * GitHub Sponsors. Does not include sponsorships paid via Patreon.
     */
    lifetimeReceivedSponsorshipValues: SponsorAndLifetimeValueConnection;
    /** The organization's public profile location. */
    location?: Maybe<Scalars["String"]["output"]>;
    /** The organization's login name. */
    login: Scalars["String"]["output"];
    /** A list of all mannequins for this organization. */
    mannequins: MannequinConnection;
    /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
    memberStatuses: UserStatusConnection;
    /** Members can fork private repositories in this organization */
    membersCanForkPrivateRepositories: Scalars["Boolean"]["output"];
    /** A list of users who are members of this organization. */
    membersWithRole: OrganizationMemberConnection;
    /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
    monthlyEstimatedSponsorsIncomeInCents: Scalars["Int"]["output"];
    /** The organization's public profile name. */
    name?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path creating a new team */
    newTeamResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL creating a new team */
    newTeamUrl: Scalars["URI"]["output"];
    /** Indicates if email notification delivery for this organization is restricted to verified or approved domains. */
    notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue;
    /** The billing email for the organization. */
    organizationBillingEmail?: Maybe<Scalars["String"]["output"]>;
    /** A list of packages under the owner. */
    packages: PackageConnection;
    /** A list of users who have been invited to join this organization. */
    pendingMembers: UserConnection;
    /** A list of repositories and gists this profile owner can pin to their profile. */
    pinnableItems: PinnableItemConnection;
    /** A list of repositories and gists this profile owner has pinned to their profile */
    pinnedItems: PinnableItemConnection;
    /** Returns how many more items this profile owner can pin to their profile. */
    pinnedItemsRemaining: Scalars["Int"]["output"];
    /** Find project by number. */
    project?: Maybe<Project>;
    /** Find a project by number. */
    projectV2?: Maybe<ProjectV2>;
    /** A list of projects under the owner. */
    projects: ProjectConnection;
    /** The HTTP path listing organization's projects */
    projectsResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL listing organization's projects */
    projectsUrl: Scalars["URI"]["output"];
    /** A list of projects under the owner. */
    projectsV2: ProjectV2Connection;
    /** Recent projects that this user has modified in the context of the owner. */
    recentProjects: ProjectV2Connection;
    /** A list of repositories that the user owns. */
    repositories: RepositoryConnection;
    /** Find Repository. */
    repository?: Maybe<Repository>;
    /** Discussion comments this user has authored. */
    repositoryDiscussionComments: DiscussionCommentConnection;
    /** Discussions this user has started. */
    repositoryDiscussions: DiscussionConnection;
    /** A list of all repository migrations for this organization. */
    repositoryMigrations: RepositoryMigrationConnection;
    /**
     * When true the organization requires all members, billing managers, and outside
     * collaborators to enable two-factor authentication.
     */
    requiresTwoFactorAuthentication?: Maybe<Scalars["Boolean"]["output"]>;
    /** The HTTP path for this organization. */
    resourcePath: Scalars["URI"]["output"];
    /** Returns a single ruleset from the current organization by ID. */
    ruleset?: Maybe<RepositoryRuleset>;
    /** A list of rulesets for this organization. */
    rulesets?: Maybe<RepositoryRulesetConnection>;
    /**
     * The Organization's SAML identity provider. Visible to (1) organization owners,
     * (2) organization owners' personal access tokens (classic) with read:org or
     * admin:org scope, (3) GitHub App with an installation token with read or write
     * access to members.
     */
    samlIdentityProvider?: Maybe<OrganizationIdentityProvider>;
    /** List of users and organizations this entity is sponsoring. */
    sponsoring: SponsorConnection;
    /** List of sponsors for this user or organization. */
    sponsors: SponsorConnection;
    /** Events involving this sponsorable, such as new sponsorships. */
    sponsorsActivities: SponsorsActivityConnection;
    /** The GitHub Sponsors listing for this user or organization. */
    sponsorsListing?: Maybe<SponsorsListing>;
    /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
    sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;
    /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
    sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;
    /** List of sponsorship updates sent from this sponsorable to sponsors. */
    sponsorshipNewsletters: SponsorshipNewsletterConnection;
    /** The sponsorships where this user or organization is the maintainer receiving the funds. */
    sponsorshipsAsMaintainer: SponsorshipConnection;
    /** The sponsorships where this user or organization is the funder. */
    sponsorshipsAsSponsor: SponsorshipConnection;
    /** Find an organization's team by its slug. */
    team?: Maybe<Team>;
    /** A list of teams in this organization. */
    teams: TeamConnection;
    /** The HTTP path listing organization's teams */
    teamsResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL listing organization's teams */
    teamsUrl: Scalars["URI"]["output"];
    /**
     * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
     * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
     * user themselves or by a user who can manage sponsorships for the requested organization.
     */
    totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars["Int"]["output"]>;
    /** The organization's Twitter username. */
    twitterUsername?: Maybe<Scalars["String"]["output"]>;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this organization. */
    url: Scalars["URI"]["output"];
    /** Organization is adminable by the viewer. */
    viewerCanAdminister: Scalars["Boolean"]["output"];
    /** Can the viewer pin repositories and gists to the profile? */
    viewerCanChangePinnedItems: Scalars["Boolean"]["output"];
    /** Can the current viewer create new projects on this owner. */
    viewerCanCreateProjects: Scalars["Boolean"]["output"];
    /** Viewer can create repositories on this organization */
    viewerCanCreateRepositories: Scalars["Boolean"]["output"];
    /** Viewer can create teams on this organization. */
    viewerCanCreateTeams: Scalars["Boolean"]["output"];
    /** Whether or not the viewer is able to sponsor this user/organization. */
    viewerCanSponsor: Scalars["Boolean"]["output"];
    /** Viewer is an active member of this organization. */
    viewerIsAMember: Scalars["Boolean"]["output"];
    /** Whether or not this Organization is followed by the viewer. */
    viewerIsFollowing: Scalars["Boolean"]["output"];
    /** True if the viewer is sponsoring this user/organization. */
    viewerIsSponsoring: Scalars["Boolean"]["output"];
    /** Whether contributors are required to sign off on web-based commits for repositories in this organization. */
    webCommitSignoffRequired: Scalars["Boolean"]["output"];
    /** The organization's public profile URL. */
    websiteUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationAnyPinnableItemsArgs = {
  type?: InputMaybe<PinnableItemType>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationAuditLogArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<AuditLogOrder>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationAvatarUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationDomainsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  isApproved?: InputMaybe<Scalars["Boolean"]["input"]>;
  isVerified?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<VerifiableDomainOrder>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationEnterpriseOwnersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<OrgEnterpriseOwnerOrder>;
  organizationRole?: InputMaybe<RoleInOrganization>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationIpAllowListEntriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IpAllowListEntryOrder>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationIsSponsoredByArgs = {
  accountLogin: Scalars["String"]["input"];
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationLifetimeReceivedSponsorshipValuesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorAndLifetimeValueOrder>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationMannequinsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  login?: InputMaybe<Scalars["String"]["input"]>;
  orderBy?: InputMaybe<MannequinOrder>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationMemberStatusesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<UserStatusOrder>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationMembersWithRoleArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationPackagesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  names?: InputMaybe<Array<InputMaybe<Scalars["String"]["input"]>>>;
  orderBy?: InputMaybe<PackageOrder>;
  packageType?: InputMaybe<PackageType>;
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationPendingMembersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationPinnableItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  types?: InputMaybe<Array<PinnableItemType>>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationPinnedItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  types?: InputMaybe<Array<PinnableItemType>>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationProjectArgs = {
  number: Scalars["Int"]["input"];
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationProjectV2Args = {
  number: Scalars["Int"]["input"];
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationProjectsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectOrder>;
  search?: InputMaybe<Scalars["String"]["input"]>;
  states?: InputMaybe<Array<ProjectState>>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationProjectsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  minPermissionLevel?: InputMaybe<ProjectV2PermissionLevel>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationRecentProjectsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationRepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  hasIssuesEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  isArchived?: InputMaybe<Scalars["Boolean"]["input"]>;
  isFork?: InputMaybe<Scalars["Boolean"]["input"]>;
  isLocked?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
  visibility?: InputMaybe<RepositoryVisibility>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationRepositoryArgs = {
  followRenames?: InputMaybe<Scalars["Boolean"]["input"]>;
  name: Scalars["String"]["input"];
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationRepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  onlyAnswers?: InputMaybe<Scalars["Boolean"]["input"]>;
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationRepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  answered?: InputMaybe<Scalars["Boolean"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
  states?: InputMaybe<Array<DiscussionState>>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationRepositoryMigrationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RepositoryMigrationOrder>;
  repositoryName?: InputMaybe<Scalars["String"]["input"]>;
  state?: InputMaybe<MigrationState>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationRulesetArgs = {
  databaseId: Scalars["Int"]["input"];
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationRulesetsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includeParents?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationSponsoringArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorOrder>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationSponsorsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorOrder>;
  tierId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationSponsorsActivitiesArgs = {
  actions?: InputMaybe<Array<SponsorsActivityAction>>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includeAsSponsor?: InputMaybe<Scalars["Boolean"]["input"]>;
  includePrivate?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorsActivityOrder>;
  period?: InputMaybe<SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars["DateTime"]["input"]>;
  until?: InputMaybe<Scalars["DateTime"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationSponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationSponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationSponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationSponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includePrivate?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationSponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  maintainerLogins?: InputMaybe<Array<Scalars["String"]["input"]>>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationTeamArgs = {
  slug: Scalars["String"]["input"];
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationTeamsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  ldapMapped?: InputMaybe<Scalars["Boolean"]["input"]>;
  notificationSetting?: InputMaybe<TeamNotificationSetting>;
  orderBy?: InputMaybe<TeamOrder>;
  privacy?: InputMaybe<TeamPrivacy>;
  query?: InputMaybe<Scalars["String"]["input"]>;
  role?: InputMaybe<TeamRole>;
  rootTeamsOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  userLogins?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationTotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars["DateTime"]["input"]>;
  sponsorableLogins?: InputMaybe<Array<Scalars["String"]["input"]>>;
  until?: InputMaybe<Scalars["DateTime"]["input"]>;
};

/** An audit entry in an organization audit log. */
export type OrganizationAuditEntry =
  | MembersCanDeleteReposClearAuditEntry
  | MembersCanDeleteReposDisableAuditEntry
  | MembersCanDeleteReposEnableAuditEntry
  | OauthApplicationCreateAuditEntry
  | OrgAddBillingManagerAuditEntry
  | OrgAddMemberAuditEntry
  | OrgBlockUserAuditEntry
  | OrgConfigDisableCollaboratorsOnlyAuditEntry
  | OrgConfigEnableCollaboratorsOnlyAuditEntry
  | OrgCreateAuditEntry
  | OrgDisableOauthAppRestrictionsAuditEntry
  | OrgDisableSamlAuditEntry
  | OrgDisableTwoFactorRequirementAuditEntry
  | OrgEnableOauthAppRestrictionsAuditEntry
  | OrgEnableSamlAuditEntry
  | OrgEnableTwoFactorRequirementAuditEntry
  | OrgInviteMemberAuditEntry
  | OrgInviteToBusinessAuditEntry
  | OrgOauthAppAccessApprovedAuditEntry
  | OrgOauthAppAccessBlockedAuditEntry
  | OrgOauthAppAccessDeniedAuditEntry
  | OrgOauthAppAccessRequestedAuditEntry
  | OrgOauthAppAccessUnblockedAuditEntry
  | OrgRemoveBillingManagerAuditEntry
  | OrgRemoveMemberAuditEntry
  | OrgRemoveOutsideCollaboratorAuditEntry
  | OrgRestoreMemberAuditEntry
  | OrgUnblockUserAuditEntry
  | OrgUpdateDefaultRepositoryPermissionAuditEntry
  | OrgUpdateMemberAuditEntry
  | OrgUpdateMemberRepositoryCreationPermissionAuditEntry
  | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry
  | PrivateRepositoryForkingDisableAuditEntry
  | PrivateRepositoryForkingEnableAuditEntry
  | RepoAccessAuditEntry
  | RepoAddMemberAuditEntry
  | RepoAddTopicAuditEntry
  | RepoArchivedAuditEntry
  | RepoChangeMergeSettingAuditEntry
  | RepoConfigDisableAnonymousGitAccessAuditEntry
  | RepoConfigDisableCollaboratorsOnlyAuditEntry
  | RepoConfigDisableContributorsOnlyAuditEntry
  | RepoConfigDisableSockpuppetDisallowedAuditEntry
  | RepoConfigEnableAnonymousGitAccessAuditEntry
  | RepoConfigEnableCollaboratorsOnlyAuditEntry
  | RepoConfigEnableContributorsOnlyAuditEntry
  | RepoConfigEnableSockpuppetDisallowedAuditEntry
  | RepoConfigLockAnonymousGitAccessAuditEntry
  | RepoConfigUnlockAnonymousGitAccessAuditEntry
  | RepoCreateAuditEntry
  | RepoDestroyAuditEntry
  | RepoRemoveMemberAuditEntry
  | RepoRemoveTopicAuditEntry
  | RepositoryVisibilityChangeDisableAuditEntry
  | RepositoryVisibilityChangeEnableAuditEntry
  | TeamAddMemberAuditEntry
  | TeamAddRepositoryAuditEntry
  | TeamChangeParentTeamAuditEntry
  | TeamRemoveMemberAuditEntry
  | TeamRemoveRepositoryAuditEntry;

/** The connection type for OrganizationAuditEntry. */
export type OrganizationAuditEntryConnection = {
  __typename?: "OrganizationAuditEntryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationAuditEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OrganizationAuditEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Metadata for an audit entry with action org.* */
export type OrganizationAuditEntryData = {
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars["String"]["output"]>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars["URI"]["output"]>;
};

/** An edge in a connection. */
export type OrganizationAuditEntryEdge = {
  __typename?: "OrganizationAuditEntryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<OrganizationAuditEntry>;
};

/** A list of organizations managed by an enterprise. */
export type OrganizationConnection = {
  __typename?: "OrganizationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type OrganizationEdge = {
  __typename?: "OrganizationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Organization>;
};

/** The connection type for User. */
export type OrganizationEnterpriseOwnerConnection = {
  __typename?: "OrganizationEnterpriseOwnerConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationEnterpriseOwnerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An enterprise owner in the context of an organization that is part of the enterprise. */
export type OrganizationEnterpriseOwnerEdge = {
  __typename?: "OrganizationEnterpriseOwnerEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
  /** The role of the owner with respect to the organization. */
  organizationRole: RoleInOrganization;
};

/**
 * An Identity Provider configured to provision SAML and SCIM identities for
 * Organizations. Visible to (1) organization owners, (2) organization owners'
 * personal access tokens (classic) with read:org or admin:org scope, (3) GitHub
 * App with an installation token with read or write access to members.
 */
export type OrganizationIdentityProvider = Node & {
  __typename?: "OrganizationIdentityProvider";
  /** The digest algorithm used to sign SAML requests for the Identity Provider. */
  digestMethod?: Maybe<Scalars["URI"]["output"]>;
  /** External Identities provisioned by this Identity Provider */
  externalIdentities: ExternalIdentityConnection;
  /** The Node ID of the OrganizationIdentityProvider object */
  id: Scalars["ID"]["output"];
  /** The x509 certificate used by the Identity Provider to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars["X509Certificate"]["output"]>;
  /** The Issuer Entity ID for the SAML Identity Provider */
  issuer?: Maybe<Scalars["String"]["output"]>;
  /** Organization this Identity Provider belongs to */
  organization?: Maybe<Organization>;
  /** The signature algorithm used to sign SAML requests for the Identity Provider. */
  signatureMethod?: Maybe<Scalars["URI"]["output"]>;
  /** The URL endpoint for the Identity Provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars["URI"]["output"]>;
};

/**
 * An Identity Provider configured to provision SAML and SCIM identities for
 * Organizations. Visible to (1) organization owners, (2) organization owners'
 * personal access tokens (classic) with read:org or admin:org scope, (3) GitHub
 * App with an installation token with read or write access to members.
 */
export type OrganizationIdentityProviderExternalIdentitiesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  login?: InputMaybe<Scalars["String"]["input"]>;
  membersOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  userName?: InputMaybe<Scalars["String"]["input"]>;
};

/** An Invitation for a user to an organization. */
export type OrganizationInvitation = Node & {
  __typename?: "OrganizationInvitation";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The email address of the user invited to the organization. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The Node ID of the OrganizationInvitation object */
  id: Scalars["ID"]["output"];
  /** The source of the invitation. */
  invitationSource: OrganizationInvitationSource;
  /** The type of invitation that was sent (e.g. email, user). */
  invitationType: OrganizationInvitationType;
  /** The user who was invited to the organization. */
  invitee?: Maybe<User>;
  /**
   * The user who created the invitation.
   * @deprecated `inviter` will be removed. `inviter` will be replaced by `inviterActor`. Removal on 2024-07-01 UTC.
   */
  inviter: User;
  /** The user who created the invitation. */
  inviterActor?: Maybe<User>;
  /** The organization the invite is for */
  organization: Organization;
  /** The user's pending role in the organization (e.g. member, owner). */
  role: OrganizationInvitationRole;
};

/** The connection type for OrganizationInvitation. */
export type OrganizationInvitationConnection = {
  __typename?: "OrganizationInvitationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type OrganizationInvitationEdge = {
  __typename?: "OrganizationInvitationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<OrganizationInvitation>;
};

/** The possible organization invitation roles. */
export enum OrganizationInvitationRole {
  /** The user is invited to be an admin of the organization. */
  Admin = "ADMIN",
  /** The user is invited to be a billing manager of the organization. */
  BillingManager = "BILLING_MANAGER",
  /** The user is invited to be a direct member of the organization. */
  DirectMember = "DIRECT_MEMBER",
  /** The user's previous role will be reinstated. */
  Reinstate = "REINSTATE",
}

/** The possible organization invitation sources. */
export enum OrganizationInvitationSource {
  /** The invitation was created from the web interface or from API */
  Member = "MEMBER",
  /** The invitation was created from SCIM */
  Scim = "SCIM",
  /** The invitation was sent before this feature was added */
  Unknown = "UNKNOWN",
}

/** The possible organization invitation types. */
export enum OrganizationInvitationType {
  /** The invitation was to an email address. */
  Email = "EMAIL",
  /** The invitation was to an existing user. */
  User = "USER",
}

/** A list of users who belong to the organization. */
export type OrganizationMemberConnection = {
  __typename?: "OrganizationMemberConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Represents a user within an organization. */
export type OrganizationMemberEdge = {
  __typename?: "OrganizationMemberEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer. */
  hasTwoFactorEnabled?: Maybe<Scalars["Boolean"]["output"]>;
  /** The item at the end of the edge. */
  node?: Maybe<User>;
  /** The role this user has in the organization. */
  role?: Maybe<OrganizationMemberRole>;
};

/** The possible roles within an organization for its members. */
export enum OrganizationMemberRole {
  /** The user is an administrator of the organization. */
  Admin = "ADMIN",
  /** The user is a member of the organization. */
  Member = "MEMBER",
}

/** The possible values for the members can create repositories setting on an organization. */
export enum OrganizationMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = "ALL",
  /** Members will not be able to create public or private repositories. */
  Disabled = "DISABLED",
  /** Members will be able to create only internal repositories. */
  Internal = "INTERNAL",
  /** Members will be able to create only private repositories. */
  Private = "PRIVATE",
}

/** A GitHub Enterprise Importer (GEI) organization migration. */
export type OrganizationMigration = Node & {
  __typename?: "OrganizationMigration";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["String"]["output"]>;
  /** The reason the organization migration failed. */
  failureReason?: Maybe<Scalars["String"]["output"]>;
  /** The Node ID of the OrganizationMigration object */
  id: Scalars["ID"]["output"];
  /** The remaining amount of repos to be migrated. */
  remainingRepositoriesCount?: Maybe<Scalars["Int"]["output"]>;
  /** The name of the source organization to be migrated. */
  sourceOrgName: Scalars["String"]["output"];
  /** The URL of the source organization to migrate. */
  sourceOrgUrl: Scalars["URI"]["output"];
  /** The migration state. */
  state: OrganizationMigrationState;
  /** The name of the target organization. */
  targetOrgName: Scalars["String"]["output"];
  /** The total amount of repositories to be migrated. */
  totalRepositoriesCount?: Maybe<Scalars["Int"]["output"]>;
};

/** The Octoshift Organization migration state. */
export enum OrganizationMigrationState {
  /** The Octoshift migration has failed. */
  Failed = "FAILED",
  /** The Octoshift migration has invalid credentials. */
  FailedValidation = "FAILED_VALIDATION",
  /** The Octoshift migration is in progress. */
  InProgress = "IN_PROGRESS",
  /** The Octoshift migration has not started. */
  NotStarted = "NOT_STARTED",
  /** The Octoshift migration needs to have its credentials validated. */
  PendingValidation = "PENDING_VALIDATION",
  /** The Octoshift migration is performing post repository migrations. */
  PostRepoMigration = "POST_REPO_MIGRATION",
  /** The Octoshift migration is performing pre repository migrations. */
  PreRepoMigration = "PRE_REPO_MIGRATION",
  /** The Octoshift migration has been queued. */
  Queued = "QUEUED",
  /** The Octoshift org migration is performing repository migrations. */
  RepoMigration = "REPO_MIGRATION",
  /** The Octoshift migration has succeeded. */
  Succeeded = "SUCCEEDED",
}

/** Used for argument of CreateProjectV2 mutation. */
export type OrganizationOrUser = Organization | User;

/** Ordering options for organization connections. */
export type OrganizationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order organizations by. */
  field: OrganizationOrderField;
};

/** Properties by which organization connections can be ordered. */
export enum OrganizationOrderField {
  /** Order organizations by creation time */
  CreatedAt = "CREATED_AT",
  /** Order organizations by login */
  Login = "LOGIN",
}

/** An organization teams hovercard context */
export type OrganizationTeamsHovercardContext = HovercardContext & {
  __typename?: "OrganizationTeamsHovercardContext";
  /** A string describing this context */
  message: Scalars["String"]["output"];
  /** An octicon to accompany this context */
  octicon: Scalars["String"]["output"];
  /** Teams in this organization the user is a member of that are relevant */
  relevantTeams: TeamConnection;
  /** The path for the full team list for this user */
  teamsResourcePath: Scalars["URI"]["output"];
  /** The URL for the full team list for this user */
  teamsUrl: Scalars["URI"]["output"];
  /** The total number of teams the user is on in the organization */
  totalTeamCount: Scalars["Int"]["output"];
};

/** An organization teams hovercard context */
export type OrganizationTeamsHovercardContextRelevantTeamsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An organization list hovercard context */
export type OrganizationsHovercardContext = HovercardContext & {
  __typename?: "OrganizationsHovercardContext";
  /** A string describing this context */
  message: Scalars["String"]["output"];
  /** An octicon to accompany this context */
  octicon: Scalars["String"]["output"];
  /** Organizations this user is a member of that are relevant */
  relevantOrganizations: OrganizationConnection;
  /** The total number of organizations this user is in */
  totalOrganizationCount: Scalars["Int"]["output"];
};

/** An organization list hovercard context */
export type OrganizationsHovercardContextRelevantOrganizationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<OrganizationOrder>;
};

/** Information for an uploaded package. */
export type Package = Node & {
  __typename?: "Package";
  /** The Node ID of the Package object */
  id: Scalars["ID"]["output"];
  /** Find the latest version for the package. */
  latestVersion?: Maybe<PackageVersion>;
  /** Identifies the name of the package. */
  name: Scalars["String"]["output"];
  /** Identifies the type of the package. */
  packageType: PackageType;
  /** The repository this package belongs to. */
  repository?: Maybe<Repository>;
  /** Statistics about package activity. */
  statistics?: Maybe<PackageStatistics>;
  /** Find package version by version string. */
  version?: Maybe<PackageVersion>;
  /** list of versions for this package */
  versions: PackageVersionConnection;
};

/** Information for an uploaded package. */
export type PackageVersionArgs = {
  version: Scalars["String"]["input"];
};

/** Information for an uploaded package. */
export type PackageVersionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<PackageVersionOrder>;
};

/** The connection type for Package. */
export type PackageConnection = {
  __typename?: "PackageConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Package>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PackageEdge = {
  __typename?: "PackageEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Package>;
};

/** A file in a package version. */
export type PackageFile = Node & {
  __typename?: "PackageFile";
  /** The Node ID of the PackageFile object */
  id: Scalars["ID"]["output"];
  /** MD5 hash of the file. */
  md5?: Maybe<Scalars["String"]["output"]>;
  /** Name of the file. */
  name: Scalars["String"]["output"];
  /** The package version this file belongs to. */
  packageVersion?: Maybe<PackageVersion>;
  /** SHA1 hash of the file. */
  sha1?: Maybe<Scalars["String"]["output"]>;
  /** SHA256 hash of the file. */
  sha256?: Maybe<Scalars["String"]["output"]>;
  /** Size of the file in bytes. */
  size?: Maybe<Scalars["Int"]["output"]>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** URL to download the asset. */
  url?: Maybe<Scalars["URI"]["output"]>;
};

/** The connection type for PackageFile. */
export type PackageFileConnection = {
  __typename?: "PackageFileConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageFile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PackageFileEdge = {
  __typename?: "PackageFileEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PackageFile>;
};

/** Ways in which lists of package files can be ordered upon return. */
export type PackageFileOrder = {
  /** The direction in which to order package files by the specified field. */
  direction?: InputMaybe<OrderDirection>;
  /** The field in which to order package files by. */
  field?: InputMaybe<PackageFileOrderField>;
};

/** Properties by which package file connections can be ordered. */
export enum PackageFileOrderField {
  /** Order package files by creation time */
  CreatedAt = "CREATED_AT",
}

/** Ways in which lists of packages can be ordered upon return. */
export type PackageOrder = {
  /** The direction in which to order packages by the specified field. */
  direction?: InputMaybe<OrderDirection>;
  /** The field in which to order packages by. */
  field?: InputMaybe<PackageOrderField>;
};

/** Properties by which package connections can be ordered. */
export enum PackageOrderField {
  /** Order packages by creation time */
  CreatedAt = "CREATED_AT",
}

/** Represents an owner of a package. */
export type PackageOwner = {
  /** The Node ID of the PackageOwner object */
  id: Scalars["ID"]["output"];
  /** A list of packages under the owner. */
  packages: PackageConnection;
};

/** Represents an owner of a package. */
export type PackageOwnerPackagesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  names?: InputMaybe<Array<InputMaybe<Scalars["String"]["input"]>>>;
  orderBy?: InputMaybe<PackageOrder>;
  packageType?: InputMaybe<PackageType>;
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Represents a object that contains package activity statistics such as downloads. */
export type PackageStatistics = {
  __typename?: "PackageStatistics";
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars["Int"]["output"];
};

/** A version tag contains the mapping between a tag name and a version. */
export type PackageTag = Node & {
  __typename?: "PackageTag";
  /** The Node ID of the PackageTag object */
  id: Scalars["ID"]["output"];
  /** Identifies the tag name of the version. */
  name: Scalars["String"]["output"];
  /** Version that the tag is associated with. */
  version?: Maybe<PackageVersion>;
};

/** The possible types of a package. */
export enum PackageType {
  /** A debian package. */
  Debian = "DEBIAN",
  /**
   * A docker image.
   * @deprecated DOCKER will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2021-06-21 UTC.
   */
  Docker = "DOCKER",
  /**
   * A maven package.
   * @deprecated MAVEN will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2023-02-10 UTC.
   */
  Maven = "MAVEN",
  /**
   * An npm package.
   * @deprecated NPM will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC.
   */
  Npm = "NPM",
  /**
   * A nuget package.
   * @deprecated NUGET will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC.
   */
  Nuget = "NUGET",
  /** A python package. */
  Pypi = "PYPI",
  /**
   * A rubygems package.
   * @deprecated RUBYGEMS will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-12-28 UTC.
   */
  Rubygems = "RUBYGEMS",
}

/** Information about a specific package version. */
export type PackageVersion = Node & {
  __typename?: "PackageVersion";
  /** List of files associated with this package version */
  files: PackageFileConnection;
  /** The Node ID of the PackageVersion object */
  id: Scalars["ID"]["output"];
  /** The package associated with this version. */
  package?: Maybe<Package>;
  /** The platform this version was built for. */
  platform?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not this version is a pre-release. */
  preRelease: Scalars["Boolean"]["output"];
  /** The README of this package version. */
  readme?: Maybe<Scalars["String"]["output"]>;
  /** The release associated with this package version. */
  release?: Maybe<Release>;
  /** Statistics about package activity. */
  statistics?: Maybe<PackageVersionStatistics>;
  /** The package version summary. */
  summary?: Maybe<Scalars["String"]["output"]>;
  /** The version string. */
  version: Scalars["String"]["output"];
};

/** Information about a specific package version. */
export type PackageVersionFilesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<PackageFileOrder>;
};

/** The connection type for PackageVersion. */
export type PackageVersionConnection = {
  __typename?: "PackageVersionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PackageVersionEdge = {
  __typename?: "PackageVersionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PackageVersion>;
};

/** Ways in which lists of package versions can be ordered upon return. */
export type PackageVersionOrder = {
  /** The direction in which to order package versions by the specified field. */
  direction?: InputMaybe<OrderDirection>;
  /** The field in which to order package versions by. */
  field?: InputMaybe<PackageVersionOrderField>;
};

/** Properties by which package version connections can be ordered. */
export enum PackageVersionOrderField {
  /** Order package versions by creation time */
  CreatedAt = "CREATED_AT",
}

/** Represents a object that contains package version activity statistics such as downloads. */
export type PackageVersionStatistics = {
  __typename?: "PackageVersionStatistics";
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars["Int"]["output"];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: "PageInfo";
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars["String"]["output"]>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars["Boolean"]["output"];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars["Boolean"]["output"];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars["String"]["output"]>;
};

/** The possible types of patch statuses. */
export enum PatchStatus {
  /** The file was added. Git status 'A'. */
  Added = "ADDED",
  /** The file's type was changed. Git status 'T'. */
  Changed = "CHANGED",
  /** The file was copied. Git status 'C'. */
  Copied = "COPIED",
  /** The file was deleted. Git status 'D'. */
  Deleted = "DELETED",
  /** The file's contents were changed. Git status 'M'. */
  Modified = "MODIFIED",
  /** The file was renamed. Git status 'R'. */
  Renamed = "RENAMED",
}

/** Types that can grant permissions on a repository to a user */
export type PermissionGranter = Organization | Repository | Team;

/** A level of permission and source for a user's access to a repository. */
export type PermissionSource = {
  __typename?: "PermissionSource";
  /** The organization the repository belongs to. */
  organization: Organization;
  /** The level of access this source has granted to the user. */
  permission: DefaultRepositoryPermissionField;
  /** The name of the role this source has granted to the user. */
  roleName?: Maybe<Scalars["String"]["output"]>;
  /** The source of this permission. */
  source: PermissionGranter;
};

/** Autogenerated input type of PinEnvironment */
export type PinEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the environment to modify */
  environmentId: Scalars["ID"]["input"];
  /** The desired state of the environment. If true, environment will be pinned. If false, it will be unpinned. */
  pinned: Scalars["Boolean"]["input"];
};

/** Autogenerated return type of PinEnvironment. */
export type PinEnvironmentPayload = {
  __typename?: "PinEnvironmentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The environment that was pinned */
  environment?: Maybe<Environment>;
  /** The pinned environment if we pinned */
  pinnedEnvironment?: Maybe<PinnedEnvironment>;
};

/** Autogenerated input type of PinIssue */
export type PinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the issue to be pinned */
  issueId: Scalars["ID"]["input"];
};

/** Autogenerated return type of PinIssue. */
export type PinIssuePayload = {
  __typename?: "PinIssuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The issue that was pinned */
  issue?: Maybe<Issue>;
};

/** Types that can be pinned to a profile page. */
export type PinnableItem = Gist | Repository;

/** The connection type for PinnableItem. */
export type PinnableItemConnection = {
  __typename?: "PinnableItemConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PinnableItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PinnableItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PinnableItemEdge = {
  __typename?: "PinnableItemEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PinnableItem>;
};

/** Represents items that can be pinned to a profile page or dashboard. */
export enum PinnableItemType {
  /** A gist. */
  Gist = "GIST",
  /** An issue. */
  Issue = "ISSUE",
  /** An organization. */
  Organization = "ORGANIZATION",
  /** A project. */
  Project = "PROJECT",
  /** A pull request. */
  PullRequest = "PULL_REQUEST",
  /** A repository. */
  Repository = "REPOSITORY",
  /** A team. */
  Team = "TEAM",
  /** A user. */
  User = "USER",
}

/** A Pinned Discussion is a discussion pinned to a repository's index page. */
export type PinnedDiscussion = Node &
  RepositoryNode & {
    __typename?: "PinnedDiscussion";
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The discussion that was pinned. */
    discussion: Discussion;
    /** Color stops of the chosen gradient */
    gradientStopColors: Array<Scalars["String"]["output"]>;
    /** The Node ID of the PinnedDiscussion object */
    id: Scalars["ID"]["output"];
    /** Background texture pattern */
    pattern: PinnedDiscussionPattern;
    /** The actor that pinned this discussion. */
    pinnedBy: Actor;
    /** Preconfigured background gradient option */
    preconfiguredGradient?: Maybe<PinnedDiscussionGradient>;
    /** The repository associated with this node. */
    repository: Repository;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
  };

/** The connection type for PinnedDiscussion. */
export type PinnedDiscussionConnection = {
  __typename?: "PinnedDiscussionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PinnedDiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PinnedDiscussion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PinnedDiscussionEdge = {
  __typename?: "PinnedDiscussionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PinnedDiscussion>;
};

/** Preconfigured gradients that may be used to style discussions pinned within a repository. */
export enum PinnedDiscussionGradient {
  /** A gradient of blue to mint */
  BlueMint = "BLUE_MINT",
  /** A gradient of blue to purple */
  BluePurple = "BLUE_PURPLE",
  /** A gradient of pink to blue */
  PinkBlue = "PINK_BLUE",
  /** A gradient of purple to coral */
  PurpleCoral = "PURPLE_CORAL",
  /** A gradient of red to orange */
  RedOrange = "RED_ORANGE",
}

/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */
export enum PinnedDiscussionPattern {
  /** An upward-facing chevron pattern */
  ChevronUp = "CHEVRON_UP",
  /** A hollow dot pattern */
  Dot = "DOT",
  /** A solid dot pattern */
  DotFill = "DOT_FILL",
  /** A heart pattern */
  HeartFill = "HEART_FILL",
  /** A plus sign pattern */
  Plus = "PLUS",
  /** A lightning bolt pattern */
  Zap = "ZAP",
}

/** Represents a pinned environment on a given repository */
export type PinnedEnvironment = Node & {
  __typename?: "PinnedEnvironment";
  /** Identifies the date and time when the pinned environment was created */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** Identifies the environment associated. */
  environment: Environment;
  /** The Node ID of the PinnedEnvironment object */
  id: Scalars["ID"]["output"];
  /** Identifies the position of the pinned environment. */
  position: Scalars["Int"]["output"];
  /** The repository that this environment was pinned to. */
  repository: Repository;
};

/** The connection type for PinnedEnvironment. */
export type PinnedEnvironmentConnection = {
  __typename?: "PinnedEnvironmentConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PinnedEnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PinnedEnvironment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PinnedEnvironmentEdge = {
  __typename?: "PinnedEnvironmentEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PinnedEnvironment>;
};

/** Ordering options for pinned environments */
export type PinnedEnvironmentOrder = {
  /** The direction in which to order pinned environments by the specified field. */
  direction: OrderDirection;
  /** The field to order pinned environments by. */
  field: PinnedEnvironmentOrderField;
};

/** Properties by which pinned environments connections can be ordered */
export enum PinnedEnvironmentOrderField {
  /** Order pinned environments by position */
  Position = "POSITION",
}

/** Represents a 'pinned' event on a given issue or pull request. */
export type PinnedEvent = Node & {
  __typename?: "PinnedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the PinnedEvent object */
  id: Scalars["ID"]["output"];
  /** Identifies the issue associated with the event. */
  issue: Issue;
};

/** A Pinned Issue is a issue pinned to a repository's index page. */
export type PinnedIssue = Node & {
  __typename?: "PinnedIssue";
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** Identifies the primary key from the database as a BigInt. */
  fullDatabaseId?: Maybe<Scalars["BigInt"]["output"]>;
  /** The Node ID of the PinnedIssue object */
  id: Scalars["ID"]["output"];
  /** The issue that was pinned. */
  issue: Issue;
  /** The actor that pinned this issue. */
  pinnedBy: Actor;
  /** The repository that this issue was pinned to. */
  repository: Repository;
};

/** The connection type for PinnedIssue. */
export type PinnedIssueConnection = {
  __typename?: "PinnedIssueConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PinnedIssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PinnedIssue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PinnedIssueEdge = {
  __typename?: "PinnedIssueEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PinnedIssue>;
};

/** Audit log entry for a private_repository_forking.disable event. */
export type PrivateRepositoryForkingDisableAuditEntry = AuditEntry &
  EnterpriseAuditEntryData &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "PrivateRepositoryForkingDisableAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The HTTP path for this enterprise. */
    enterpriseResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The slug of the enterprise. */
    enterpriseSlug?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP URL for this enterprise. */
    enterpriseUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The Node ID of the PrivateRepositoryForkingDisableAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a private_repository_forking.enable event. */
export type PrivateRepositoryForkingEnableAuditEntry = AuditEntry &
  EnterpriseAuditEntryData &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "PrivateRepositoryForkingEnableAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The HTTP path for this enterprise. */
    enterpriseResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The slug of the enterprise. */
    enterpriseSlug?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP URL for this enterprise. */
    enterpriseUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The Node ID of the PrivateRepositoryForkingEnableAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
export type ProfileItemShowcase = {
  __typename?: "ProfileItemShowcase";
  /** Whether or not the owner has pinned any repositories or gists. */
  hasPinnedItems: Scalars["Boolean"]["output"];
  /**
   * The repositories and gists in the showcase. If the profile owner has any
   * pinned items, those will be returned. Otherwise, the profile owner's popular
   * repositories will be returned.
   */
  items: PinnableItemConnection;
};

/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
export type ProfileItemShowcaseItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents any entity on GitHub that has a profile page. */
export type ProfileOwner = {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars["Boolean"]["output"];
  /** The public profile email. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The Node ID of the ProfileOwner object */
  id: Scalars["ID"]["output"];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: ProfileItemShowcase;
  /** The public profile location. */
  location?: Maybe<Scalars["String"]["output"]>;
  /** The username used to login. */
  login: Scalars["String"]["output"];
  /** The public profile name. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars["Int"]["output"];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars["Boolean"]["output"];
  /** The public profile website URL. */
  websiteUrl?: Maybe<Scalars["URI"]["output"]>;
};

/** Represents any entity on GitHub that has a profile page. */
export type ProfileOwnerAnyPinnableItemsArgs = {
  type?: InputMaybe<PinnableItemType>;
};

/** Represents any entity on GitHub that has a profile page. */
export type ProfileOwnerPinnableItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  types?: InputMaybe<Array<PinnableItemType>>;
};

/** Represents any entity on GitHub that has a profile page. */
export type ProfileOwnerPinnedItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  types?: InputMaybe<Array<PinnableItemType>>;
};

/** Projects manage issues, pull requests and notes within a project owner. */
export type Project = Closable &
  Node &
  Updatable & {
    __typename?: "Project";
    /** The project's description body. */
    body?: Maybe<Scalars["String"]["output"]>;
    /** The projects description body rendered to HTML. */
    bodyHTML: Scalars["HTML"]["output"];
    /** Indicates if the object is closed (definition of closed may depend on type) */
    closed: Scalars["Boolean"]["output"];
    /** Identifies the date and time when the object was closed. */
    closedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** List of columns in the project */
    columns: ProjectColumnConnection;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The actor who originally created the project. */
    creator?: Maybe<Actor>;
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The Node ID of the Project object */
    id: Scalars["ID"]["output"];
    /** The project's name. */
    name: Scalars["String"]["output"];
    /** The project's number. */
    number: Scalars["Int"]["output"];
    /** The project's owner. Currently limited to repositories, organizations, and users. */
    owner: ProjectOwner;
    /** List of pending cards in this project */
    pendingCards: ProjectCardConnection;
    /** Project progress details. */
    progress: ProjectProgress;
    /** The HTTP path for this project */
    resourcePath: Scalars["URI"]["output"];
    /** Whether the project is open or closed. */
    state: ProjectState;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this project */
    url: Scalars["URI"]["output"];
    /** Indicates if the object can be closed by the viewer. */
    viewerCanClose: Scalars["Boolean"]["output"];
    /** Indicates if the object can be reopened by the viewer. */
    viewerCanReopen: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
  };

/** Projects manage issues, pull requests and notes within a project owner. */
export type ProjectColumnsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Projects manage issues, pull requests and notes within a project owner. */
export type ProjectPendingCardsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A card in a project. */
export type ProjectCard = Node & {
  __typename?: "ProjectCard";
  /**
   * The project column this card is associated under. A card may only belong to one
   * project column at a time. The column field will be null if the card is created
   * in a pending state and has yet to be associated with a column. Once cards are
   * associated with a column, they will not become pending in the future.
   */
  column?: Maybe<ProjectColumn>;
  /** The card content item */
  content?: Maybe<ProjectCardItem>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The actor who created this card */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the ProjectCard object */
  id: Scalars["ID"]["output"];
  /** Whether the card is archived */
  isArchived: Scalars["Boolean"]["output"];
  /** The card note */
  note?: Maybe<Scalars["String"]["output"]>;
  /** The project that contains this card. */
  project: Project;
  /** The HTTP path for this card */
  resourcePath: Scalars["URI"]["output"];
  /** The state of ProjectCard */
  state?: Maybe<ProjectCardState>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** The HTTP URL for this card */
  url: Scalars["URI"]["output"];
};

/** The possible archived states of a project card. */
export enum ProjectCardArchivedState {
  /** A project card that is archived */
  Archived = "ARCHIVED",
  /** A project card that is not archived */
  NotArchived = "NOT_ARCHIVED",
}

/** The connection type for ProjectCard. */
export type ProjectCardConnection = {
  __typename?: "ProjectCardConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectCardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectCard>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProjectCardEdge = {
  __typename?: "ProjectCardEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectCard>;
};

/** An issue or PR and its owning repository to be used in a project card. */
export type ProjectCardImport = {
  /** The issue or pull request number. */
  number: Scalars["Int"]["input"];
  /** Repository name with owner (owner/repository). */
  repository: Scalars["String"]["input"];
};

/** Types that can be inside Project Cards. */
export type ProjectCardItem = Issue | PullRequest;

/** Various content states of a ProjectCard */
export enum ProjectCardState {
  /** The card has content only. */
  ContentOnly = "CONTENT_ONLY",
  /** The card has a note only. */
  NoteOnly = "NOTE_ONLY",
  /** The card is redacted. */
  Redacted = "REDACTED",
}

/** A column inside a project. */
export type ProjectColumn = Node & {
  __typename?: "ProjectColumn";
  /** List of cards in the column */
  cards: ProjectCardConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the ProjectColumn object */
  id: Scalars["ID"]["output"];
  /** The project column's name. */
  name: Scalars["String"]["output"];
  /** The project that contains this column. */
  project: Project;
  /** The semantic purpose of the column */
  purpose?: Maybe<ProjectColumnPurpose>;
  /** The HTTP path for this project column */
  resourcePath: Scalars["URI"]["output"];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** The HTTP URL for this project column */
  url: Scalars["URI"]["output"];
};

/** A column inside a project. */
export type ProjectColumnCardsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for ProjectColumn. */
export type ProjectColumnConnection = {
  __typename?: "ProjectColumnConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectColumnEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectColumn>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProjectColumnEdge = {
  __typename?: "ProjectColumnEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectColumn>;
};

/** A project column and a list of its issues and PRs. */
export type ProjectColumnImport = {
  /** The name of the column. */
  columnName: Scalars["String"]["input"];
  /** A list of issues and pull requests in the column. */
  issues?: InputMaybe<Array<ProjectCardImport>>;
  /** The position of the column, starting from 0. */
  position: Scalars["Int"]["input"];
};

/** The semantic purpose of the column - todo, in progress, or done. */
export enum ProjectColumnPurpose {
  /** The column contains cards which are complete */
  Done = "DONE",
  /** The column contains cards which are currently being worked on */
  InProgress = "IN_PROGRESS",
  /** The column contains cards still to be worked on */
  Todo = "TODO",
}

/** A list of projects associated with the owner. */
export type ProjectConnection = {
  __typename?: "ProjectConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProjectEdge = {
  __typename?: "ProjectEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Project>;
};

/** Ways in which lists of projects can be ordered upon return. */
export type ProjectOrder = {
  /** The direction in which to order projects by the specified field. */
  direction: OrderDirection;
  /** The field in which to order projects by. */
  field: ProjectOrderField;
};

/** Properties by which project connections can be ordered. */
export enum ProjectOrderField {
  /** Order projects by creation time */
  CreatedAt = "CREATED_AT",
  /** Order projects by name */
  Name = "NAME",
  /** Order projects by update time */
  UpdatedAt = "UPDATED_AT",
}

/** Represents an owner of a Project. */
export type ProjectOwner = {
  /** The Node ID of the ProjectOwner object */
  id: Scalars["ID"]["output"];
  /** Find project by number. */
  project?: Maybe<Project>;
  /** A list of projects under the owner. */
  projects: ProjectConnection;
  /** The HTTP path listing owners projects */
  projectsResourcePath: Scalars["URI"]["output"];
  /** The HTTP URL listing owners projects */
  projectsUrl: Scalars["URI"]["output"];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars["Boolean"]["output"];
};

/** Represents an owner of a Project. */
export type ProjectOwnerProjectArgs = {
  number: Scalars["Int"]["input"];
};

/** Represents an owner of a Project. */
export type ProjectOwnerProjectsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectOrder>;
  search?: InputMaybe<Scalars["String"]["input"]>;
  states?: InputMaybe<Array<ProjectState>>;
};

/** Project progress stats. */
export type ProjectProgress = {
  __typename?: "ProjectProgress";
  /** The number of done cards. */
  doneCount: Scalars["Int"]["output"];
  /** The percentage of done cards. */
  donePercentage: Scalars["Float"]["output"];
  /** Whether progress tracking is enabled and cards with purpose exist for this project */
  enabled: Scalars["Boolean"]["output"];
  /** The number of in-progress cards. */
  inProgressCount: Scalars["Int"]["output"];
  /** The percentage of in-progress cards. */
  inProgressPercentage: Scalars["Float"]["output"];
  /** The number of to do cards. */
  todoCount: Scalars["Int"]["output"];
  /** The percentage of to do cards. */
  todoPercentage: Scalars["Float"]["output"];
};

/** State of the project; either 'open' or 'closed' */
export enum ProjectState {
  /** The project is closed. */
  Closed = "CLOSED",
  /** The project is open. */
  Open = "OPEN",
}

/** GitHub-provided templates for Projects */
export enum ProjectTemplate {
  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */
  AutomatedKanbanV2 = "AUTOMATED_KANBAN_V2",
  /** Create a board with triggers to automatically move cards across columns with review automation. */
  AutomatedReviewsKanban = "AUTOMATED_REVIEWS_KANBAN",
  /** Create a board with columns for To do, In progress and Done. */
  BasicKanban = "BASIC_KANBAN",
  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */
  BugTriage = "BUG_TRIAGE",
}

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2 = Closable &
  Node &
  Updatable & {
    __typename?: "ProjectV2";
    /** Returns true if the project is closed. */
    closed: Scalars["Boolean"]["output"];
    /** Identifies the date and time when the object was closed. */
    closedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The actor who originally created the project. */
    creator?: Maybe<Actor>;
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** A field of the project */
    field?: Maybe<ProjectV2FieldConfiguration>;
    /** List of fields and their constraints in the project */
    fields: ProjectV2FieldConfigurationConnection;
    /** The Node ID of the ProjectV2 object */
    id: Scalars["ID"]["output"];
    /** List of items in the project */
    items: ProjectV2ItemConnection;
    /** The project's number. */
    number: Scalars["Int"]["output"];
    /** The project's owner. Currently limited to organizations and users. */
    owner: ProjectV2Owner;
    /** Returns true if the project is public. */
    public: Scalars["Boolean"]["output"];
    /** The project's readme. */
    readme?: Maybe<Scalars["String"]["output"]>;
    /** The repositories the project is linked to. */
    repositories: RepositoryConnection;
    /** The HTTP path for this project */
    resourcePath: Scalars["URI"]["output"];
    /** The project's short description. */
    shortDescription?: Maybe<Scalars["String"]["output"]>;
    /** List of the status updates in the project. */
    statusUpdates: ProjectV2StatusUpdateConnection;
    /** The teams the project is linked to. */
    teams: TeamConnection;
    /** Returns true if this project is a template. */
    template: Scalars["Boolean"]["output"];
    /** The project's name. */
    title: Scalars["String"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this project */
    url: Scalars["URI"]["output"];
    /** A view of the project */
    view?: Maybe<ProjectV2View>;
    /** Indicates if the object can be closed by the viewer. */
    viewerCanClose: Scalars["Boolean"]["output"];
    /** Indicates if the object can be reopened by the viewer. */
    viewerCanReopen: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
    /** List of views in the project */
    views: ProjectV2ViewConnection;
    /** A workflow of the project */
    workflow?: Maybe<ProjectV2Workflow>;
    /** List of the workflows in the project */
    workflows: ProjectV2WorkflowConnection;
  };

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2FieldArgs = {
  name: Scalars["String"]["input"];
};

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2FieldsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2ItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectV2ItemOrder>;
};

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2RepositoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RepositoryOrder>;
};

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2StatusUpdatesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectV2StatusOrder>;
};

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2TeamsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<TeamOrder>;
};

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2ViewArgs = {
  number: Scalars["Int"]["input"];
};

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2ViewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectV2ViewOrder>;
};

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2WorkflowArgs = {
  number: Scalars["Int"]["input"];
};

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2WorkflowsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectV2WorkflowOrder>;
};

/** Possible collaborators for a project. */
export type ProjectV2Actor = Team | User;

/** The connection type for ProjectV2Actor. */
export type ProjectV2ActorConnection = {
  __typename?: "ProjectV2ActorConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2ActorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2Actor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProjectV2ActorEdge = {
  __typename?: "ProjectV2ActorEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2Actor>;
};

/** A collaborator to update on a project. Only one of the userId or teamId should be provided. */
export type ProjectV2Collaborator = {
  /** The role to grant the collaborator */
  role: ProjectV2Roles;
  /** The ID of the team as a collaborator. */
  teamId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the user as a collaborator. */
  userId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** The connection type for ProjectV2. */
export type ProjectV2Connection = {
  __typename?: "ProjectV2Connection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2Edge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** The type of a project field. */
export enum ProjectV2CustomFieldType {
  /** Date */
  Date = "DATE",
  /** Number */
  Number = "NUMBER",
  /** Single Select */
  SingleSelect = "SINGLE_SELECT",
  /** Text */
  Text = "TEXT",
}

/** An edge in a connection. */
export type ProjectV2Edge = {
  __typename?: "ProjectV2Edge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2>;
};

/** A field inside a project. */
export type ProjectV2Field = Node &
  ProjectV2FieldCommon & {
    __typename?: "ProjectV2Field";
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The field's type. */
    dataType: ProjectV2FieldType;
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The Node ID of the ProjectV2Field object */
    id: Scalars["ID"]["output"];
    /** The project field's name. */
    name: Scalars["String"]["output"];
    /** The project that contains this field. */
    project: ProjectV2;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
  };

/** Common fields across different project field types */
export type ProjectV2FieldCommon = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The field's type. */
  dataType: ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the ProjectV2FieldCommon object */
  id: Scalars["ID"]["output"];
  /** The project field's name. */
  name: Scalars["String"]["output"];
  /** The project that contains this field. */
  project: ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** Configurations for project fields. */
export type ProjectV2FieldConfiguration =
  | ProjectV2Field
  | ProjectV2IterationField
  | ProjectV2SingleSelectField;

/** The connection type for ProjectV2FieldConfiguration. */
export type ProjectV2FieldConfigurationConnection = {
  __typename?: "ProjectV2FieldConfigurationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2FieldConfigurationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2FieldConfiguration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProjectV2FieldConfigurationEdge = {
  __typename?: "ProjectV2FieldConfigurationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2FieldConfiguration>;
};

/** The connection type for ProjectV2Field. */
export type ProjectV2FieldConnection = {
  __typename?: "ProjectV2FieldConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2FieldEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2Field>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProjectV2FieldEdge = {
  __typename?: "ProjectV2FieldEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2Field>;
};

/** Ordering options for project v2 field connections */
export type ProjectV2FieldOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 fields by. */
  field: ProjectV2FieldOrderField;
};

/** Properties by which project v2 field connections can be ordered. */
export enum ProjectV2FieldOrderField {
  /** Order project v2 fields by creation time */
  CreatedAt = "CREATED_AT",
  /** Order project v2 fields by name */
  Name = "NAME",
  /** Order project v2 fields by position */
  Position = "POSITION",
}

/** The type of a project field. */
export enum ProjectV2FieldType {
  /** Assignees */
  Assignees = "ASSIGNEES",
  /** Date */
  Date = "DATE",
  /** Iteration */
  Iteration = "ITERATION",
  /** Labels */
  Labels = "LABELS",
  /** Linked Pull Requests */
  LinkedPullRequests = "LINKED_PULL_REQUESTS",
  /** Milestone */
  Milestone = "MILESTONE",
  /** Number */
  Number = "NUMBER",
  /** Repository */
  Repository = "REPOSITORY",
  /** Reviewers */
  Reviewers = "REVIEWERS",
  /** Single Select */
  SingleSelect = "SINGLE_SELECT",
  /** Text */
  Text = "TEXT",
  /** Title */
  Title = "TITLE",
  /** Tracked by */
  TrackedBy = "TRACKED_BY",
  /** Tracks */
  Tracks = "TRACKS",
}

/** The values that can be used to update a field of an item inside a Project. Only 1 value can be updated at a time. */
export type ProjectV2FieldValue = {
  /** The ISO 8601 date to set on the field. */
  date?: InputMaybe<Scalars["Date"]["input"]>;
  /** The id of the iteration to set on the field. */
  iterationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The number to set on the field. */
  number?: InputMaybe<Scalars["Float"]["input"]>;
  /** The id of the single select option to set on the field. */
  singleSelectOptionId?: InputMaybe<Scalars["String"]["input"]>;
  /** The text to set on the field. */
  text?: InputMaybe<Scalars["String"]["input"]>;
};

/** Ways in which to filter lists of projects. */
export type ProjectV2Filters = {
  /** List project v2 filtered by the state given. */
  state?: InputMaybe<ProjectV2State>;
};

/** An item within a Project. */
export type ProjectV2Item = Node & {
  __typename?: "ProjectV2Item";
  /** The content of the referenced draft issue, issue, or pull request */
  content?: Maybe<ProjectV2ItemContent>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The actor who created the item. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The field value of the first project field which matches the 'name' argument that is set on the item. */
  fieldValueByName?: Maybe<ProjectV2ItemFieldValue>;
  /** The field values that are set on the item. */
  fieldValues: ProjectV2ItemFieldValueConnection;
  /** Identifies the primary key from the database as a BigInt. */
  fullDatabaseId?: Maybe<Scalars["BigInt"]["output"]>;
  /** The Node ID of the ProjectV2Item object */
  id: Scalars["ID"]["output"];
  /** Whether the item is archived. */
  isArchived: Scalars["Boolean"]["output"];
  /** The project that contains this item. */
  project: ProjectV2;
  /** The type of the item. */
  type: ProjectV2ItemType;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** An item within a Project. */
export type ProjectV2ItemFieldValueByNameArgs = {
  name: Scalars["String"]["input"];
};

/** An item within a Project. */
export type ProjectV2ItemFieldValuesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectV2ItemFieldValueOrder>;
};

/** The connection type for ProjectV2Item. */
export type ProjectV2ItemConnection = {
  __typename?: "ProjectV2ItemConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2ItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2Item>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Types that can be inside Project Items. */
export type ProjectV2ItemContent = DraftIssue | Issue | PullRequest;

/** An edge in a connection. */
export type ProjectV2ItemEdge = {
  __typename?: "ProjectV2ItemEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2Item>;
};

/** The value of a date field in a Project item. */
export type ProjectV2ItemFieldDateValue = Node &
  ProjectV2ItemFieldValueCommon & {
    __typename?: "ProjectV2ItemFieldDateValue";
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The actor who created the item. */
    creator?: Maybe<Actor>;
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** Date value for the field */
    date?: Maybe<Scalars["Date"]["output"]>;
    /** The project field that contains this value. */
    field: ProjectV2FieldConfiguration;
    /** The Node ID of the ProjectV2ItemFieldDateValue object */
    id: Scalars["ID"]["output"];
    /** The project item that contains this value. */
    item: ProjectV2Item;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
  };

/** The value of an iteration field in a Project item. */
export type ProjectV2ItemFieldIterationValue = Node &
  ProjectV2ItemFieldValueCommon & {
    __typename?: "ProjectV2ItemFieldIterationValue";
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The actor who created the item. */
    creator?: Maybe<Actor>;
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The duration of the iteration in days. */
    duration: Scalars["Int"]["output"];
    /** The project field that contains this value. */
    field: ProjectV2FieldConfiguration;
    /** The Node ID of the ProjectV2ItemFieldIterationValue object */
    id: Scalars["ID"]["output"];
    /** The project item that contains this value. */
    item: ProjectV2Item;
    /** The ID of the iteration. */
    iterationId: Scalars["String"]["output"];
    /** The start date of the iteration. */
    startDate: Scalars["Date"]["output"];
    /** The title of the iteration. */
    title: Scalars["String"]["output"];
    /** The title of the iteration, with HTML. */
    titleHTML: Scalars["String"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
  };

/** The value of the labels field in a Project item. */
export type ProjectV2ItemFieldLabelValue = {
  __typename?: "ProjectV2ItemFieldLabelValue";
  /** The field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** Labels value of a field */
  labels?: Maybe<LabelConnection>;
};

/** The value of the labels field in a Project item. */
export type ProjectV2ItemFieldLabelValueLabelsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The value of a milestone field in a Project item. */
export type ProjectV2ItemFieldMilestoneValue = {
  __typename?: "ProjectV2ItemFieldMilestoneValue";
  /** The field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** Milestone value of a field */
  milestone?: Maybe<Milestone>;
};

/** The value of a number field in a Project item. */
export type ProjectV2ItemFieldNumberValue = Node &
  ProjectV2ItemFieldValueCommon & {
    __typename?: "ProjectV2ItemFieldNumberValue";
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The actor who created the item. */
    creator?: Maybe<Actor>;
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The project field that contains this value. */
    field: ProjectV2FieldConfiguration;
    /** The Node ID of the ProjectV2ItemFieldNumberValue object */
    id: Scalars["ID"]["output"];
    /** The project item that contains this value. */
    item: ProjectV2Item;
    /** Number as a float(8) */
    number?: Maybe<Scalars["Float"]["output"]>;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
  };

/** The value of a pull request field in a Project item. */
export type ProjectV2ItemFieldPullRequestValue = {
  __typename?: "ProjectV2ItemFieldPullRequestValue";
  /** The field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The pull requests for this field */
  pullRequests?: Maybe<PullRequestConnection>;
};

/** The value of a pull request field in a Project item. */
export type ProjectV2ItemFieldPullRequestValuePullRequestsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<PullRequestOrder>;
};

/** The value of a repository field in a Project item. */
export type ProjectV2ItemFieldRepositoryValue = {
  __typename?: "ProjectV2ItemFieldRepositoryValue";
  /** The field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The repository for this field. */
  repository?: Maybe<Repository>;
};

/** The value of a reviewers field in a Project item. */
export type ProjectV2ItemFieldReviewerValue = {
  __typename?: "ProjectV2ItemFieldReviewerValue";
  /** The field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The reviewers for this field. */
  reviewers?: Maybe<RequestedReviewerConnection>;
};

/** The value of a reviewers field in a Project item. */
export type ProjectV2ItemFieldReviewerValueReviewersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The value of a single select field in a Project item. */
export type ProjectV2ItemFieldSingleSelectValue = Node &
  ProjectV2ItemFieldValueCommon & {
    __typename?: "ProjectV2ItemFieldSingleSelectValue";
    /** The color applied to the selected single-select option. */
    color: ProjectV2SingleSelectFieldOptionColor;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The actor who created the item. */
    creator?: Maybe<Actor>;
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** A plain-text description of the selected single-select option, such as what the option means. */
    description?: Maybe<Scalars["String"]["output"]>;
    /** The description of the selected single-select option, including HTML tags. */
    descriptionHTML?: Maybe<Scalars["String"]["output"]>;
    /** The project field that contains this value. */
    field: ProjectV2FieldConfiguration;
    /** The Node ID of the ProjectV2ItemFieldSingleSelectValue object */
    id: Scalars["ID"]["output"];
    /** The project item that contains this value. */
    item: ProjectV2Item;
    /** The name of the selected single select option. */
    name?: Maybe<Scalars["String"]["output"]>;
    /** The html name of the selected single select option. */
    nameHTML?: Maybe<Scalars["String"]["output"]>;
    /** The id of the selected single select option. */
    optionId?: Maybe<Scalars["String"]["output"]>;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
  };

/** The value of a text field in a Project item. */
export type ProjectV2ItemFieldTextValue = Node &
  ProjectV2ItemFieldValueCommon & {
    __typename?: "ProjectV2ItemFieldTextValue";
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The actor who created the item. */
    creator?: Maybe<Actor>;
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The project field that contains this value. */
    field: ProjectV2FieldConfiguration;
    /** The Node ID of the ProjectV2ItemFieldTextValue object */
    id: Scalars["ID"]["output"];
    /** The project item that contains this value. */
    item: ProjectV2Item;
    /** Text value of a field */
    text?: Maybe<Scalars["String"]["output"]>;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
  };

/** The value of a user field in a Project item. */
export type ProjectV2ItemFieldUserValue = {
  __typename?: "ProjectV2ItemFieldUserValue";
  /** The field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The users for this field */
  users?: Maybe<UserConnection>;
};

/** The value of a user field in a Project item. */
export type ProjectV2ItemFieldUserValueUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Project field values */
export type ProjectV2ItemFieldValue =
  | ProjectV2ItemFieldDateValue
  | ProjectV2ItemFieldIterationValue
  | ProjectV2ItemFieldLabelValue
  | ProjectV2ItemFieldMilestoneValue
  | ProjectV2ItemFieldNumberValue
  | ProjectV2ItemFieldPullRequestValue
  | ProjectV2ItemFieldRepositoryValue
  | ProjectV2ItemFieldReviewerValue
  | ProjectV2ItemFieldSingleSelectValue
  | ProjectV2ItemFieldTextValue
  | ProjectV2ItemFieldUserValue;

/** Common fields across different project field value types */
export type ProjectV2ItemFieldValueCommon = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The actor who created the item. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The project field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldValueCommon object */
  id: Scalars["ID"]["output"];
  /** The project item that contains this value. */
  item: ProjectV2Item;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** The connection type for ProjectV2ItemFieldValue. */
export type ProjectV2ItemFieldValueConnection = {
  __typename?: "ProjectV2ItemFieldValueConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2ItemFieldValueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2ItemFieldValue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProjectV2ItemFieldValueEdge = {
  __typename?: "ProjectV2ItemFieldValueEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2ItemFieldValue>;
};

/** Ordering options for project v2 item field value connections */
export type ProjectV2ItemFieldValueOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 item field values by. */
  field: ProjectV2ItemFieldValueOrderField;
};

/** Properties by which project v2 item field value connections can be ordered. */
export enum ProjectV2ItemFieldValueOrderField {
  /** Order project v2 item field values by the their position in the project */
  Position = "POSITION",
}

/** Ordering options for project v2 item connections */
export type ProjectV2ItemOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 items by. */
  field: ProjectV2ItemOrderField;
};

/** Properties by which project v2 item connections can be ordered. */
export enum ProjectV2ItemOrderField {
  /** Order project v2 items by the their position in the project */
  Position = "POSITION",
}

/** The type of a project item. */
export enum ProjectV2ItemType {
  /** Draft Issue */
  DraftIssue = "DRAFT_ISSUE",
  /** Issue */
  Issue = "ISSUE",
  /** Pull Request */
  PullRequest = "PULL_REQUEST",
  /** Redacted Item */
  Redacted = "REDACTED",
}

/** An iteration field inside a project. */
export type ProjectV2IterationField = Node &
  ProjectV2FieldCommon & {
    __typename?: "ProjectV2IterationField";
    /** Iteration configuration settings */
    configuration: ProjectV2IterationFieldConfiguration;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The field's type. */
    dataType: ProjectV2FieldType;
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The Node ID of the ProjectV2IterationField object */
    id: Scalars["ID"]["output"];
    /** The project field's name. */
    name: Scalars["String"]["output"];
    /** The project that contains this field. */
    project: ProjectV2;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
  };

/** Iteration field configuration for a project. */
export type ProjectV2IterationFieldConfiguration = {
  __typename?: "ProjectV2IterationFieldConfiguration";
  /** The iteration's completed iterations */
  completedIterations: Array<ProjectV2IterationFieldIteration>;
  /** The iteration's duration in days */
  duration: Scalars["Int"]["output"];
  /** The iteration's iterations */
  iterations: Array<ProjectV2IterationFieldIteration>;
  /** The iteration's start day of the week */
  startDay: Scalars["Int"]["output"];
};

/** Iteration field iteration settings for a project. */
export type ProjectV2IterationFieldIteration = {
  __typename?: "ProjectV2IterationFieldIteration";
  /** The iteration's duration in days */
  duration: Scalars["Int"]["output"];
  /** The iteration's ID. */
  id: Scalars["String"]["output"];
  /** The iteration's start date */
  startDate: Scalars["Date"]["output"];
  /** The iteration's title. */
  title: Scalars["String"]["output"];
  /** The iteration's html title. */
  titleHTML: Scalars["String"]["output"];
};

/** Ways in which lists of projects can be ordered upon return. */
export type ProjectV2Order = {
  /** The direction in which to order projects by the specified field. */
  direction: OrderDirection;
  /** The field in which to order projects by. */
  field: ProjectV2OrderField;
};

/** Properties by which projects can be ordered. */
export enum ProjectV2OrderField {
  /** The project's date and time of creation */
  CreatedAt = "CREATED_AT",
  /** The project's number */
  Number = "NUMBER",
  /** The project's title */
  Title = "TITLE",
  /** The project's date and time of update */
  UpdatedAt = "UPDATED_AT",
}

/** Represents an owner of a project. */
export type ProjectV2Owner = {
  /** The Node ID of the ProjectV2Owner object */
  id: Scalars["ID"]["output"];
  /** Find a project by number. */
  projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  projectsV2: ProjectV2Connection;
};

/** Represents an owner of a project. */
export type ProjectV2OwnerProjectV2Args = {
  number: Scalars["Int"]["input"];
};

/** Represents an owner of a project. */
export type ProjectV2OwnerProjectsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  minPermissionLevel?: InputMaybe<ProjectV2PermissionLevel>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** The possible roles of a collaborator on a project. */
export enum ProjectV2PermissionLevel {
  /** The collaborator can view, edit, and maange the settings of the project */
  Admin = "ADMIN",
  /** The collaborator can view the project */
  Read = "READ",
  /** The collaborator can view and edit the project */
  Write = "WRITE",
}

/** Recent projects for the owner. */
export type ProjectV2Recent = {
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: ProjectV2Connection;
};

/** Recent projects for the owner. */
export type ProjectV2RecentRecentProjectsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The possible roles of a collaborator on a project. */
export enum ProjectV2Roles {
  /** The collaborator can view, edit, and maange the settings of the project */
  Admin = "ADMIN",
  /** The collaborator has no direct access to the project */
  None = "NONE",
  /** The collaborator can view the project */
  Reader = "READER",
  /** The collaborator can view and edit the project */
  Writer = "WRITER",
}

/** A single select field inside a project. */
export type ProjectV2SingleSelectField = Node &
  ProjectV2FieldCommon & {
    __typename?: "ProjectV2SingleSelectField";
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The field's type. */
    dataType: ProjectV2FieldType;
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The Node ID of the ProjectV2SingleSelectField object */
    id: Scalars["ID"]["output"];
    /** The project field's name. */
    name: Scalars["String"]["output"];
    /** Options for the single select field */
    options: Array<ProjectV2SingleSelectFieldOption>;
    /** The project that contains this field. */
    project: ProjectV2;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
  };

/** A single select field inside a project. */
export type ProjectV2SingleSelectFieldOptionsArgs = {
  names?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** Single select field option for a configuration for a project. */
export type ProjectV2SingleSelectFieldOption = {
  __typename?: "ProjectV2SingleSelectFieldOption";
  /** The option's display color. */
  color: ProjectV2SingleSelectFieldOptionColor;
  /** The option's plain-text description. */
  description: Scalars["String"]["output"];
  /** The option's description, possibly containing HTML. */
  descriptionHTML: Scalars["String"]["output"];
  /** The option's ID. */
  id: Scalars["String"]["output"];
  /** The option's name. */
  name: Scalars["String"]["output"];
  /** The option's html name. */
  nameHTML: Scalars["String"]["output"];
};

/** The display color of a single-select field option. */
export enum ProjectV2SingleSelectFieldOptionColor {
  /** BLUE */
  Blue = "BLUE",
  /** GRAY */
  Gray = "GRAY",
  /** GREEN */
  Green = "GREEN",
  /** ORANGE */
  Orange = "ORANGE",
  /** PINK */
  Pink = "PINK",
  /** PURPLE */
  Purple = "PURPLE",
  /** RED */
  Red = "RED",
  /** YELLOW */
  Yellow = "YELLOW",
}

/** Represents a single select field option */
export type ProjectV2SingleSelectFieldOptionInput = {
  /** The display color of the option */
  color: ProjectV2SingleSelectFieldOptionColor;
  /** The description text of the option */
  description: Scalars["String"]["input"];
  /** The name of the option */
  name: Scalars["String"]["input"];
};

/** Represents a sort by field and direction. */
export type ProjectV2SortBy = {
  __typename?: "ProjectV2SortBy";
  /** The direction of the sorting. Possible values are ASC and DESC. */
  direction: OrderDirection;
  /** The field by which items are sorted. */
  field: ProjectV2Field;
};

/** The connection type for ProjectV2SortBy. */
export type ProjectV2SortByConnection = {
  __typename?: "ProjectV2SortByConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2SortByEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2SortBy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProjectV2SortByEdge = {
  __typename?: "ProjectV2SortByEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2SortBy>;
};

/** Represents a sort by field and direction. */
export type ProjectV2SortByField = {
  __typename?: "ProjectV2SortByField";
  /** The direction of the sorting. Possible values are ASC and DESC. */
  direction: OrderDirection;
  /** The field by which items are sorted. */
  field: ProjectV2FieldConfiguration;
};

/** The connection type for ProjectV2SortByField. */
export type ProjectV2SortByFieldConnection = {
  __typename?: "ProjectV2SortByFieldConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2SortByFieldEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2SortByField>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProjectV2SortByFieldEdge = {
  __typename?: "ProjectV2SortByFieldEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2SortByField>;
};

/** The possible states of a project v2. */
export enum ProjectV2State {
  /** A project v2 that has been closed */
  Closed = "CLOSED",
  /** A project v2 that is still open */
  Open = "OPEN",
}

/** Ways in which project v2 status updates can be ordered. */
export type ProjectV2StatusOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field by which to order nodes. */
  field: ProjectV2StatusUpdateOrderField;
};

/** A status update within a project. */
export type ProjectV2StatusUpdate = Node & {
  __typename?: "ProjectV2StatusUpdate";
  /** The body of the status update. */
  body?: Maybe<Scalars["String"]["output"]>;
  /** The body of the status update rendered to HTML. */
  bodyHTML?: Maybe<Scalars["HTML"]["output"]>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The actor who created the status update. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the ProjectV2StatusUpdate object */
  id: Scalars["ID"]["output"];
  /** The project that contains this status update. */
  project: ProjectV2;
  /** The start date of the status update. */
  startDate?: Maybe<Scalars["Date"]["output"]>;
  /** The status of the status update. */
  status?: Maybe<ProjectV2StatusUpdateStatus>;
  /** The target date of the status update. */
  targetDate?: Maybe<Scalars["Date"]["output"]>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** The connection type for ProjectV2StatusUpdate. */
export type ProjectV2StatusUpdateConnection = {
  __typename?: "ProjectV2StatusUpdateConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2StatusUpdateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2StatusUpdate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProjectV2StatusUpdateEdge = {
  __typename?: "ProjectV2StatusUpdateEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2StatusUpdate>;
};

/** Properties by which project v2 status updates can be ordered. */
export enum ProjectV2StatusUpdateOrderField {
  /** Allows chronological ordering of project v2 status updates. */
  CreatedAt = "CREATED_AT",
}

/** The possible statuses of a project v2. */
export enum ProjectV2StatusUpdateStatus {
  /** A project v2 that is at risk and encountering some challenges. */
  AtRisk = "AT_RISK",
  /** A project v2 that is complete. */
  Complete = "COMPLETE",
  /** A project v2 that is inactive. */
  Inactive = "INACTIVE",
  /** A project v2 that is off track and needs attention. */
  OffTrack = "OFF_TRACK",
  /** A project v2 that is on track with no risks. */
  OnTrack = "ON_TRACK",
}

/** A view within a ProjectV2. */
export type ProjectV2View = Node & {
  __typename?: "ProjectV2View";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The view's visible fields. */
  fields?: Maybe<ProjectV2FieldConfigurationConnection>;
  /** The project view's filter. */
  filter?: Maybe<Scalars["String"]["output"]>;
  /**
   * The view's group-by field.
   * @deprecated The `ProjectV2View#order_by` API is deprecated in favour of the more capable `ProjectV2View#group_by_field` API. Check out the `ProjectV2View#group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  groupBy?: Maybe<ProjectV2FieldConnection>;
  /** The view's group-by field. */
  groupByFields?: Maybe<ProjectV2FieldConfigurationConnection>;
  /** The Node ID of the ProjectV2View object */
  id: Scalars["ID"]["output"];
  /** The project view's layout. */
  layout: ProjectV2ViewLayout;
  /** The project view's name. */
  name: Scalars["String"]["output"];
  /** The project view's number. */
  number: Scalars["Int"]["output"];
  /** The project that contains this view. */
  project: ProjectV2;
  /**
   * The view's sort-by config.
   * @deprecated The `ProjectV2View#sort_by` API is deprecated in favour of the more capable `ProjectV2View#sort_by_fields` API. Check out the `ProjectV2View#sort_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  sortBy?: Maybe<ProjectV2SortByConnection>;
  /** The view's sort-by config. */
  sortByFields?: Maybe<ProjectV2SortByFieldConnection>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /**
   * The view's vertical-group-by field.
   * @deprecated The `ProjectV2View#vertical_group_by` API is deprecated in favour of the more capable `ProjectV2View#vertical_group_by_fields` API. Check out the `ProjectV2View#vertical_group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  verticalGroupBy?: Maybe<ProjectV2FieldConnection>;
  /** The view's vertical-group-by field. */
  verticalGroupByFields?: Maybe<ProjectV2FieldConfigurationConnection>;
  /**
   * The view's visible fields.
   * @deprecated The `ProjectV2View#visibleFields` API is deprecated in favour of the more capable `ProjectV2View#fields` API. Check out the `ProjectV2View#fields` API as an example for the more capable alternative. Removal on 2023-01-01 UTC.
   */
  visibleFields?: Maybe<ProjectV2FieldConnection>;
};

/** A view within a ProjectV2. */
export type ProjectV2ViewFieldsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};

/** A view within a ProjectV2. */
export type ProjectV2ViewGroupByArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};

/** A view within a ProjectV2. */
export type ProjectV2ViewGroupByFieldsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};

/** A view within a ProjectV2. */
export type ProjectV2ViewSortByArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A view within a ProjectV2. */
export type ProjectV2ViewSortByFieldsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A view within a ProjectV2. */
export type ProjectV2ViewVerticalGroupByArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};

/** A view within a ProjectV2. */
export type ProjectV2ViewVerticalGroupByFieldsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};

/** A view within a ProjectV2. */
export type ProjectV2ViewVisibleFieldsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};

/** The connection type for ProjectV2View. */
export type ProjectV2ViewConnection = {
  __typename?: "ProjectV2ViewConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2ViewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2View>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProjectV2ViewEdge = {
  __typename?: "ProjectV2ViewEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2View>;
};

/** The layout of a project v2 view. */
export enum ProjectV2ViewLayout {
  /** Board layout */
  BoardLayout = "BOARD_LAYOUT",
  /** Roadmap layout */
  RoadmapLayout = "ROADMAP_LAYOUT",
  /** Table layout */
  TableLayout = "TABLE_LAYOUT",
}

/** Ordering options for project v2 view connections */
export type ProjectV2ViewOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 views by. */
  field: ProjectV2ViewOrderField;
};

/** Properties by which project v2 view connections can be ordered. */
export enum ProjectV2ViewOrderField {
  /** Order project v2 views by creation time */
  CreatedAt = "CREATED_AT",
  /** Order project v2 views by name */
  Name = "NAME",
  /** Order project v2 views by position */
  Position = "POSITION",
}

/** A workflow inside a project. */
export type ProjectV2Workflow = Node & {
  __typename?: "ProjectV2Workflow";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** Whether the workflow is enabled. */
  enabled: Scalars["Boolean"]["output"];
  /** The Node ID of the ProjectV2Workflow object */
  id: Scalars["ID"]["output"];
  /** The name of the workflow. */
  name: Scalars["String"]["output"];
  /** The number of the workflow. */
  number: Scalars["Int"]["output"];
  /** The project that contains this workflow. */
  project: ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** The connection type for ProjectV2Workflow. */
export type ProjectV2WorkflowConnection = {
  __typename?: "ProjectV2WorkflowConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2WorkflowEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2Workflow>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProjectV2WorkflowEdge = {
  __typename?: "ProjectV2WorkflowEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2Workflow>;
};

/** Ordering options for project v2 workflows connections */
export type ProjectV2WorkflowOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 workflows by. */
  field: ProjectV2WorkflowsOrderField;
};

/** Properties by which project workflows can be ordered. */
export enum ProjectV2WorkflowsOrderField {
  /** The date and time of the workflow creation */
  CreatedAt = "CREATED_AT",
  /** The name of the workflow */
  Name = "NAME",
  /** The number of the workflow */
  Number = "NUMBER",
  /** The date and time of the workflow update */
  UpdatedAt = "UPDATED_AT",
}

/** A property that must match */
export type PropertyTargetDefinition = {
  __typename?: "PropertyTargetDefinition";
  /** The name of the property */
  name: Scalars["String"]["output"];
  /** The values to match for */
  propertyValues: Array<Scalars["String"]["output"]>;
  /** The source of the property. Choose 'custom' or 'system'. Defaults to 'custom' if not specified */
  source?: Maybe<Scalars["String"]["output"]>;
};

/** A property that must match */
export type PropertyTargetDefinitionInput = {
  /** The name of the property */
  name: Scalars["String"]["input"];
  /** The values to match for */
  propertyValues: Array<Scalars["String"]["input"]>;
  /** The source of the property. Choose 'custom' or 'system'. Defaults to 'custom' if not specified */
  source?: InputMaybe<Scalars["String"]["input"]>;
};

/** A user's public key. */
export type PublicKey = Node & {
  __typename?: "PublicKey";
  /** The last time this authorization was used to perform an action. Values will be null for keys not owned by the user. */
  accessedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /**
   * Identifies the date and time when the key was created. Keys created before
   * March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
   */
  createdAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The fingerprint for this PublicKey. */
  fingerprint: Scalars["String"]["output"];
  /** The Node ID of the PublicKey object */
  id: Scalars["ID"]["output"];
  /** Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user. */
  isReadOnly?: Maybe<Scalars["Boolean"]["output"]>;
  /** The public key string. */
  key: Scalars["String"]["output"];
  /**
   * Identifies the date and time when the key was updated. Keys created before
   * March 5th, 2014 may have inaccurate values. Values will be null for keys not
   * owned by the user.
   */
  updatedAt?: Maybe<Scalars["DateTime"]["output"]>;
};

/** The connection type for PublicKey. */
export type PublicKeyConnection = {
  __typename?: "PublicKeyConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicKey>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicKeyEdge = {
  __typename?: "PublicKeyEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicKey>;
};

/** Autogenerated input type of PublishSponsorsTier */
export type PublishSponsorsTierInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the draft tier to publish. */
  tierId: Scalars["ID"]["input"];
};

/** Autogenerated return type of PublishSponsorsTier. */
export type PublishSponsorsTierPayload = {
  __typename?: "PublishSponsorsTierPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The tier that was published. */
  sponsorsTier?: Maybe<SponsorsTier>;
};

/** A repository pull request. */
export type PullRequest = Assignable &
  Closable &
  Comment &
  Labelable &
  Lockable &
  Node &
  ProjectV2Owner &
  Reactable &
  RepositoryNode &
  Subscribable &
  UniformResourceLocatable &
  Updatable &
  UpdatableComment & {
    __typename?: "PullRequest";
    /** Reason that the conversation was locked. */
    activeLockReason?: Maybe<LockReason>;
    /** The number of additions in this pull request. */
    additions: Scalars["Int"]["output"];
    /** A list of Users assigned to this object. */
    assignees: UserConnection;
    /** The actor who authored the comment. */
    author?: Maybe<Actor>;
    /** Author's association with the subject of the comment. */
    authorAssociation: CommentAuthorAssociation;
    /** Returns the auto-merge request object if one exists for this pull request. */
    autoMergeRequest?: Maybe<AutoMergeRequest>;
    /** Identifies the base Ref associated with the pull request. */
    baseRef?: Maybe<Ref>;
    /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */
    baseRefName: Scalars["String"]["output"];
    /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */
    baseRefOid: Scalars["GitObjectID"]["output"];
    /** The repository associated with this pull request's base Ref. */
    baseRepository?: Maybe<Repository>;
    /** The body as Markdown. */
    body: Scalars["String"]["output"];
    /** The body rendered to HTML. */
    bodyHTML: Scalars["HTML"]["output"];
    /** The body rendered to text. */
    bodyText: Scalars["String"]["output"];
    /** Whether or not the pull request is rebaseable. */
    canBeRebased: Scalars["Boolean"]["output"];
    /** The number of changed files in this pull request. */
    changedFiles: Scalars["Int"]["output"];
    /** The HTTP path for the checks of this pull request. */
    checksResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for the checks of this pull request. */
    checksUrl: Scalars["URI"]["output"];
    /** `true` if the pull request is closed */
    closed: Scalars["Boolean"]["output"];
    /** Identifies the date and time when the object was closed. */
    closedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** List of issues that were may be closed by this pull request */
    closingIssuesReferences?: Maybe<IssueConnection>;
    /** A list of comments associated with the pull request. */
    comments: IssueCommentConnection;
    /** A list of commits present in this pull request's head branch not present in the base branch. */
    commits: PullRequestCommitConnection;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail: Scalars["Boolean"]["output"];
    /**
     * Identifies the primary key from the database.
     * @deprecated `databaseId` will be removed because it does not support 64-bit signed integer identifiers. Use `fullDatabaseId` instead. Removal on 2024-07-01 UTC.
     */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The number of deletions in this pull request. */
    deletions: Scalars["Int"]["output"];
    /** The actor who edited this pull request's body. */
    editor?: Maybe<Actor>;
    /** Lists the files changed within this pull request. */
    files?: Maybe<PullRequestChangedFileConnection>;
    /** Identifies the primary key from the database as a BigInt. */
    fullDatabaseId?: Maybe<Scalars["BigInt"]["output"]>;
    /** Identifies the head Ref associated with the pull request. */
    headRef?: Maybe<Ref>;
    /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */
    headRefName: Scalars["String"]["output"];
    /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */
    headRefOid: Scalars["GitObjectID"]["output"];
    /** The repository associated with this pull request's head Ref. */
    headRepository?: Maybe<Repository>;
    /** The owner of the repository associated with this pull request's head Ref. */
    headRepositoryOwner?: Maybe<RepositoryOwner>;
    /** The hovercard information for this issue */
    hovercard: Hovercard;
    /** The Node ID of the PullRequest object */
    id: Scalars["ID"]["output"];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit: Scalars["Boolean"]["output"];
    /** The head and base repositories are different. */
    isCrossRepository: Scalars["Boolean"]["output"];
    /** Identifies if the pull request is a draft. */
    isDraft: Scalars["Boolean"]["output"];
    /** Indicates whether the pull request is in a merge queue */
    isInMergeQueue: Scalars["Boolean"]["output"];
    /** Indicates whether the pull request's base ref has a merge queue enabled. */
    isMergeQueueEnabled: Scalars["Boolean"]["output"];
    /** Is this pull request read by the viewer */
    isReadByViewer?: Maybe<Scalars["Boolean"]["output"]>;
    /** A list of labels associated with the object. */
    labels?: Maybe<LabelConnection>;
    /** The moment the editor made the last edit */
    lastEditedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** A list of latest reviews per user associated with the pull request. */
    latestOpinionatedReviews?: Maybe<PullRequestReviewConnection>;
    /** A list of latest reviews per user associated with the pull request that are not also pending review. */
    latestReviews?: Maybe<PullRequestReviewConnection>;
    /** `true` if the pull request is locked */
    locked: Scalars["Boolean"]["output"];
    /** Indicates whether maintainers can modify the pull request. */
    maintainerCanModify: Scalars["Boolean"]["output"];
    /** The commit that was created when this pull request was merged. */
    mergeCommit?: Maybe<Commit>;
    /** The merge queue for the pull request's base branch */
    mergeQueue?: Maybe<MergeQueue>;
    /** The merge queue entry of the pull request in the base branch's merge queue */
    mergeQueueEntry?: Maybe<MergeQueueEntry>;
    /** Detailed information about the current pull request merge state status. */
    mergeStateStatus: MergeStateStatus;
    /** Whether or not the pull request can be merged based on the existence of merge conflicts. */
    mergeable: MergeableState;
    /** Whether or not the pull request was merged. */
    merged: Scalars["Boolean"]["output"];
    /** The date and time that the pull request was merged. */
    mergedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The actor who merged the pull request. */
    mergedBy?: Maybe<Actor>;
    /** Identifies the milestone associated with the pull request. */
    milestone?: Maybe<Milestone>;
    /** Identifies the pull request number. */
    number: Scalars["Int"]["output"];
    /** A list of Users that are participating in the Pull Request conversation. */
    participants: UserConnection;
    /** The permalink to the pull request. */
    permalink: Scalars["URI"]["output"];
    /**
     * The commit that GitHub automatically generated to test if this pull request
     * could be merged. This field will not return a value if the pull request is
     * merged, or if the test merge commit is still being generated. See the
     * `mergeable` field for more details on the mergeability of the pull request.
     */
    potentialMergeCommit?: Maybe<Commit>;
    /** List of project cards associated with this pull request. */
    projectCards: ProjectCardConnection;
    /** List of project items associated with this pull request. */
    projectItems: ProjectV2ItemConnection;
    /** Find a project by number. */
    projectV2?: Maybe<ProjectV2>;
    /** A list of projects under the owner. */
    projectsV2: ProjectV2Connection;
    /** Identifies when the comment was published at. */
    publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: Maybe<Array<ReactionGroup>>;
    /** A list of Reactions left on the Issue. */
    reactions: ReactionConnection;
    /** The repository associated with this node. */
    repository: Repository;
    /** The HTTP path for this pull request. */
    resourcePath: Scalars["URI"]["output"];
    /** The HTTP path for reverting this pull request. */
    revertResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for reverting this pull request. */
    revertUrl: Scalars["URI"]["output"];
    /** The current status of this pull request with respect to code review. */
    reviewDecision?: Maybe<PullRequestReviewDecision>;
    /** A list of review requests associated with the pull request. */
    reviewRequests?: Maybe<ReviewRequestConnection>;
    /** The list of all review threads for this pull request. */
    reviewThreads: PullRequestReviewThreadConnection;
    /** A list of reviews associated with the pull request. */
    reviews?: Maybe<PullRequestReviewConnection>;
    /** Identifies the state of the pull request. */
    state: PullRequestState;
    /** Check and Status rollup information for the PR's head ref. */
    statusCheckRollup?: Maybe<StatusCheckRollup>;
    /** A list of reviewer suggestions based on commit history and past review comments. */
    suggestedReviewers: Array<Maybe<SuggestedReviewer>>;
    /**
     * A list of events, comments, commits, etc. associated with the pull request.
     * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.
     */
    timeline: PullRequestTimelineConnection;
    /** A list of events, comments, commits, etc. associated with the pull request. */
    timelineItems: PullRequestTimelineItemsConnection;
    /** Identifies the pull request title. */
    title: Scalars["String"]["output"];
    /** Identifies the pull request title rendered to HTML. */
    titleHTML: Scalars["HTML"]["output"];
    /** Returns a count of how many comments this pull request has received. */
    totalCommentsCount?: Maybe<Scalars["Int"]["output"]>;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this pull request. */
    url: Scalars["URI"]["output"];
    /** A list of edits to this content. */
    userContentEdits?: Maybe<UserContentEditConnection>;
    /** Whether or not the viewer can apply suggestion. */
    viewerCanApplySuggestion: Scalars["Boolean"]["output"];
    /** Indicates if the object can be closed by the viewer. */
    viewerCanClose: Scalars["Boolean"]["output"];
    /** Check if the viewer can restore the deleted head ref. */
    viewerCanDeleteHeadRef: Scalars["Boolean"]["output"];
    /** Whether or not the viewer can disable auto-merge */
    viewerCanDisableAutoMerge: Scalars["Boolean"]["output"];
    /** Can the viewer edit files within this pull request. */
    viewerCanEditFiles: Scalars["Boolean"]["output"];
    /** Whether or not the viewer can enable auto-merge */
    viewerCanEnableAutoMerge: Scalars["Boolean"]["output"];
    /** Indicates if the viewer can edit labels for this object. */
    viewerCanLabel: Scalars["Boolean"]["output"];
    /** Indicates whether the viewer can bypass branch protections and merge the pull request immediately */
    viewerCanMergeAsAdmin: Scalars["Boolean"]["output"];
    /** Can user react to this subject */
    viewerCanReact: Scalars["Boolean"]["output"];
    /** Indicates if the object can be reopened by the viewer. */
    viewerCanReopen: Scalars["Boolean"]["output"];
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
    /**
     * Whether or not the viewer can update the head ref of this PR, by merging or rebasing the base ref.
     * If the head ref is up to date or unable to be updated by this user, this will return false.
     */
    viewerCanUpdateBranch: Scalars["Boolean"]["output"];
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
    /** Did the viewer author this comment. */
    viewerDidAuthor: Scalars["Boolean"]["output"];
    /** The latest review given from the viewer. */
    viewerLatestReview?: Maybe<PullRequestReview>;
    /** The person who has requested the viewer for review on this pull request. */
    viewerLatestReviewRequest?: Maybe<ReviewRequest>;
    /** The merge body text for the viewer and method. */
    viewerMergeBodyText: Scalars["String"]["output"];
    /** The merge headline text for the viewer and method. */
    viewerMergeHeadlineText: Scalars["String"]["output"];
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: Maybe<SubscriptionState>;
  };

/** A repository pull request. */
export type PullRequestAssigneesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository pull request. */
export type PullRequestClosingIssuesReferencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueOrder>;
  userLinkedOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** A repository pull request. */
export type PullRequestCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueCommentOrder>;
};

/** A repository pull request. */
export type PullRequestCommitsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository pull request. */
export type PullRequestFilesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository pull request. */
export type PullRequestHovercardArgs = {
  includeNotificationContexts?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** A repository pull request. */
export type PullRequestLabelsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<LabelOrder>;
};

/** A repository pull request. */
export type PullRequestLatestOpinionatedReviewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  writersOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** A repository pull request. */
export type PullRequestLatestReviewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository pull request. */
export type PullRequestParticipantsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository pull request. */
export type PullRequestProjectCardsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository pull request. */
export type PullRequestProjectItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includeArchived?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository pull request. */
export type PullRequestProjectV2Args = {
  number: Scalars["Int"]["input"];
};

/** A repository pull request. */
export type PullRequestProjectsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  minPermissionLevel?: InputMaybe<ProjectV2PermissionLevel>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** A repository pull request. */
export type PullRequestReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** A repository pull request. */
export type PullRequestReviewRequestsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository pull request. */
export type PullRequestReviewThreadsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository pull request. */
export type PullRequestReviewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  author?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  states?: InputMaybe<Array<PullRequestReviewState>>;
};

/** A repository pull request. */
export type PullRequestTimelineArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  since?: InputMaybe<Scalars["DateTime"]["input"]>;
};

/** A repository pull request. */
export type PullRequestTimelineItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  itemTypes?: InputMaybe<Array<PullRequestTimelineItemsItemType>>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  since?: InputMaybe<Scalars["DateTime"]["input"]>;
  skip?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository pull request. */
export type PullRequestUserContentEditsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository pull request. */
export type PullRequestViewerMergeBodyTextArgs = {
  mergeType?: InputMaybe<PullRequestMergeMethod>;
};

/** A repository pull request. */
export type PullRequestViewerMergeHeadlineTextArgs = {
  mergeType?: InputMaybe<PullRequestMergeMethod>;
};

/** The possible methods for updating a pull request's head branch with the base branch. */
export enum PullRequestBranchUpdateMethod {
  /** Update branch via merge */
  Merge = "MERGE",
  /** Update branch via rebase */
  Rebase = "REBASE",
}

/** A file changed in a pull request. */
export type PullRequestChangedFile = {
  __typename?: "PullRequestChangedFile";
  /** The number of additions to the file. */
  additions: Scalars["Int"]["output"];
  /** How the file was changed in this PullRequest */
  changeType: PatchStatus;
  /** The number of deletions to the file. */
  deletions: Scalars["Int"]["output"];
  /** The path of the file. */
  path: Scalars["String"]["output"];
  /** The state of the file for the viewer. */
  viewerViewedState: FileViewedState;
};

/** The connection type for PullRequestChangedFile. */
export type PullRequestChangedFileConnection = {
  __typename?: "PullRequestChangedFileConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestChangedFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestChangedFile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PullRequestChangedFileEdge = {
  __typename?: "PullRequestChangedFileEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestChangedFile>;
};

/** Represents a Git commit part of a pull request. */
export type PullRequestCommit = Node &
  UniformResourceLocatable & {
    __typename?: "PullRequestCommit";
    /** The Git commit object */
    commit: Commit;
    /** The Node ID of the PullRequestCommit object */
    id: Scalars["ID"]["output"];
    /** The pull request this commit belongs to */
    pullRequest: PullRequest;
    /** The HTTP path for this pull request commit */
    resourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for this pull request commit */
    url: Scalars["URI"]["output"];
  };

/** Represents a commit comment thread part of a pull request. */
export type PullRequestCommitCommentThread = Node &
  RepositoryNode & {
    __typename?: "PullRequestCommitCommentThread";
    /** The comments that exist in this thread. */
    comments: CommitCommentConnection;
    /** The commit the comments were made on. */
    commit: Commit;
    /** The Node ID of the PullRequestCommitCommentThread object */
    id: Scalars["ID"]["output"];
    /** The file the comments were made on. */
    path?: Maybe<Scalars["String"]["output"]>;
    /** The position in the diff for the commit that the comment was made on. */
    position?: Maybe<Scalars["Int"]["output"]>;
    /** The pull request this commit comment thread belongs to */
    pullRequest: PullRequest;
    /** The repository associated with this node. */
    repository: Repository;
  };

/** Represents a commit comment thread part of a pull request. */
export type PullRequestCommitCommentThreadCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for PullRequestCommit. */
export type PullRequestCommitConnection = {
  __typename?: "PullRequestCommitConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestCommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestCommit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PullRequestCommitEdge = {
  __typename?: "PullRequestCommitEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestCommit>;
};

/** The connection type for PullRequest. */
export type PullRequestConnection = {
  __typename?: "PullRequestConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** This aggregates pull requests opened by a user within one repository. */
export type PullRequestContributionsByRepository = {
  __typename?: "PullRequestContributionsByRepository";
  /** The pull request contributions. */
  contributions: CreatedPullRequestContributionConnection;
  /** The repository in which the pull requests were opened. */
  repository: Repository;
};

/** This aggregates pull requests opened by a user within one repository. */
export type PullRequestContributionsByRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** An edge in a connection. */
export type PullRequestEdge = {
  __typename?: "PullRequestEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequest>;
};

/** Represents available types of methods to use when merging a pull request. */
export enum PullRequestMergeMethod {
  /** Add all commits from the head branch to the base branch with a merge commit. */
  Merge = "MERGE",
  /** Add all commits from the head branch onto the base branch individually. */
  Rebase = "REBASE",
  /** Combine all commits from the head branch into a single commit in the base branch. */
  Squash = "SQUASH",
}

/** Ways in which lists of issues can be ordered upon return. */
export type PullRequestOrder = {
  /** The direction in which to order pull requests by the specified field. */
  direction: OrderDirection;
  /** The field in which to order pull requests by. */
  field: PullRequestOrderField;
};

/** Properties by which pull_requests connections can be ordered. */
export enum PullRequestOrderField {
  /** Order pull_requests by creation time */
  CreatedAt = "CREATED_AT",
  /** Order pull_requests by update time */
  UpdatedAt = "UPDATED_AT",
}

/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
export type PullRequestParameters = {
  __typename?: "PullRequestParameters";
  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */
  dismissStaleReviewsOnPush: Scalars["Boolean"]["output"];
  /** Require an approving review in pull requests that modify files that have a designated code owner. */
  requireCodeOwnerReview: Scalars["Boolean"]["output"];
  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */
  requireLastPushApproval: Scalars["Boolean"]["output"];
  /** The number of approving reviews that are required before a pull request can be merged. */
  requiredApprovingReviewCount: Scalars["Int"]["output"];
  /** All conversations on code must be resolved before a pull request can be merged. */
  requiredReviewThreadResolution: Scalars["Boolean"]["output"];
};

/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
export type PullRequestParametersInput = {
  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */
  dismissStaleReviewsOnPush: Scalars["Boolean"]["input"];
  /** Require an approving review in pull requests that modify files that have a designated code owner. */
  requireCodeOwnerReview: Scalars["Boolean"]["input"];
  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */
  requireLastPushApproval: Scalars["Boolean"]["input"];
  /** The number of approving reviews that are required before a pull request can be merged. */
  requiredApprovingReviewCount: Scalars["Int"]["input"];
  /** All conversations on code must be resolved before a pull request can be merged. */
  requiredReviewThreadResolution: Scalars["Boolean"]["input"];
};

/** A review object for a given pull request. */
export type PullRequestReview = Comment &
  Deletable &
  Minimizable &
  Node &
  Reactable &
  RepositoryNode &
  Updatable &
  UpdatableComment & {
    __typename?: "PullRequestReview";
    /** The actor who authored the comment. */
    author?: Maybe<Actor>;
    /** Author's association with the subject of the comment. */
    authorAssociation: CommentAuthorAssociation;
    /** Indicates whether the author of this review has push access to the repository. */
    authorCanPushToRepository: Scalars["Boolean"]["output"];
    /** Identifies the pull request review body. */
    body: Scalars["String"]["output"];
    /** The body rendered to HTML. */
    bodyHTML: Scalars["HTML"]["output"];
    /** The body of this review rendered as plain text. */
    bodyText: Scalars["String"]["output"];
    /** A list of review comments for the current pull request review. */
    comments: PullRequestReviewCommentConnection;
    /** Identifies the commit associated with this pull request review. */
    commit?: Maybe<Commit>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail: Scalars["Boolean"]["output"];
    /**
     * Identifies the primary key from the database.
     * @deprecated `databaseId` will be removed because it does not support 64-bit signed integer identifiers. Use `fullDatabaseId` instead. Removal on 2024-07-01 UTC.
     */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The actor who edited the comment. */
    editor?: Maybe<Actor>;
    /** Identifies the primary key from the database as a BigInt. */
    fullDatabaseId?: Maybe<Scalars["BigInt"]["output"]>;
    /** The Node ID of the PullRequestReview object */
    id: Scalars["ID"]["output"];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit: Scalars["Boolean"]["output"];
    /** Returns whether or not a comment has been minimized. */
    isMinimized: Scalars["Boolean"]["output"];
    /** The moment the editor made the last edit */
    lastEditedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /**
     * Returns why the comment was minimized. One of `abuse`, `off-topic`,
     * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
     * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
     */
    minimizedReason?: Maybe<Scalars["String"]["output"]>;
    /** A list of teams that this review was made on behalf of. */
    onBehalfOf: TeamConnection;
    /** Identifies when the comment was published at. */
    publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** Identifies the pull request associated with this pull request review. */
    pullRequest: PullRequest;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: Maybe<Array<ReactionGroup>>;
    /** A list of Reactions left on the Issue. */
    reactions: ReactionConnection;
    /** The repository associated with this node. */
    repository: Repository;
    /** The HTTP path permalink for this PullRequestReview. */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the current state of the pull request review. */
    state: PullRequestReviewState;
    /** Identifies when the Pull Request Review was submitted */
    submittedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL permalink for this PullRequestReview. */
    url: Scalars["URI"]["output"];
    /** A list of edits to this content. */
    userContentEdits?: Maybe<UserContentEditConnection>;
    /** Check if the current viewer can delete this object. */
    viewerCanDelete: Scalars["Boolean"]["output"];
    /** Check if the current viewer can minimize this object. */
    viewerCanMinimize: Scalars["Boolean"]["output"];
    /** Can user react to this subject */
    viewerCanReact: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
    /** Did the viewer author this comment. */
    viewerDidAuthor: Scalars["Boolean"]["output"];
  };

/** A review object for a given pull request. */
export type PullRequestReviewCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A review object for a given pull request. */
export type PullRequestReviewOnBehalfOfArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A review object for a given pull request. */
export type PullRequestReviewReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** A review object for a given pull request. */
export type PullRequestReviewUserContentEditsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A review comment associated with a given repository pull request. */
export type PullRequestReviewComment = Comment &
  Deletable &
  Minimizable &
  Node &
  Reactable &
  RepositoryNode &
  Updatable &
  UpdatableComment & {
    __typename?: "PullRequestReviewComment";
    /** The actor who authored the comment. */
    author?: Maybe<Actor>;
    /** Author's association with the subject of the comment. */
    authorAssociation: CommentAuthorAssociation;
    /** The comment body of this review comment. */
    body: Scalars["String"]["output"];
    /** The body rendered to HTML. */
    bodyHTML: Scalars["HTML"]["output"];
    /** The comment body of this review comment rendered as plain text. */
    bodyText: Scalars["String"]["output"];
    /** Identifies the commit associated with the comment. */
    commit?: Maybe<Commit>;
    /** Identifies when the comment was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail: Scalars["Boolean"]["output"];
    /**
     * Identifies the primary key from the database.
     * @deprecated `databaseId` will be removed because it does not support 64-bit signed integer identifiers. Use `fullDatabaseId` instead. Removal on 2024-07-01 UTC.
     */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The diff hunk to which the comment applies. */
    diffHunk: Scalars["String"]["output"];
    /** Identifies when the comment was created in a draft state. */
    draftedAt: Scalars["DateTime"]["output"];
    /** The actor who edited the comment. */
    editor?: Maybe<Actor>;
    /** Identifies the primary key from the database as a BigInt. */
    fullDatabaseId?: Maybe<Scalars["BigInt"]["output"]>;
    /** The Node ID of the PullRequestReviewComment object */
    id: Scalars["ID"]["output"];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit: Scalars["Boolean"]["output"];
    /** Returns whether or not a comment has been minimized. */
    isMinimized: Scalars["Boolean"]["output"];
    /** The moment the editor made the last edit */
    lastEditedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The end line number on the file to which the comment applies */
    line?: Maybe<Scalars["Int"]["output"]>;
    /**
     * Returns why the comment was minimized. One of `abuse`, `off-topic`,
     * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
     * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
     */
    minimizedReason?: Maybe<Scalars["String"]["output"]>;
    /** Identifies the original commit associated with the comment. */
    originalCommit?: Maybe<Commit>;
    /** The end line number on the file to which the comment applied when it was first created */
    originalLine?: Maybe<Scalars["Int"]["output"]>;
    /**
     * The original line index in the diff to which the comment applies.
     * @deprecated We are phasing out diff-relative positioning for PR comments Removal on 2023-10-01 UTC.
     */
    originalPosition: Scalars["Int"]["output"];
    /** The start line number on the file to which the comment applied when it was first created */
    originalStartLine?: Maybe<Scalars["Int"]["output"]>;
    /** Identifies when the comment body is outdated */
    outdated: Scalars["Boolean"]["output"];
    /** The path to which the comment applies. */
    path: Scalars["String"]["output"];
    /**
     * The line index in the diff to which the comment applies.
     * @deprecated We are phasing out diff-relative positioning for PR comments Use the `line` and `startLine` fields instead, which are file line numbers instead of diff line numbers Removal on 2023-10-01 UTC.
     */
    position?: Maybe<Scalars["Int"]["output"]>;
    /** Identifies when the comment was published at. */
    publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The pull request associated with this review comment. */
    pullRequest: PullRequest;
    /** The pull request review associated with this review comment. */
    pullRequestReview?: Maybe<PullRequestReview>;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: Maybe<Array<ReactionGroup>>;
    /** A list of Reactions left on the Issue. */
    reactions: ReactionConnection;
    /** The comment this is a reply to. */
    replyTo?: Maybe<PullRequestReviewComment>;
    /** The repository associated with this node. */
    repository: Repository;
    /** The HTTP path permalink for this review comment. */
    resourcePath: Scalars["URI"]["output"];
    /** The start line number on the file to which the comment applies */
    startLine?: Maybe<Scalars["Int"]["output"]>;
    /** Identifies the state of the comment. */
    state: PullRequestReviewCommentState;
    /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
    subjectType: PullRequestReviewThreadSubjectType;
    /** Identifies when the comment was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL permalink for this review comment. */
    url: Scalars["URI"]["output"];
    /** A list of edits to this content. */
    userContentEdits?: Maybe<UserContentEditConnection>;
    /** Check if the current viewer can delete this object. */
    viewerCanDelete: Scalars["Boolean"]["output"];
    /** Check if the current viewer can minimize this object. */
    viewerCanMinimize: Scalars["Boolean"]["output"];
    /** Can user react to this subject */
    viewerCanReact: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
    /** Did the viewer author this comment. */
    viewerDidAuthor: Scalars["Boolean"]["output"];
  };

/** A review comment associated with a given repository pull request. */
export type PullRequestReviewCommentReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** A review comment associated with a given repository pull request. */
export type PullRequestReviewCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for PullRequestReviewComment. */
export type PullRequestReviewCommentConnection = {
  __typename?: "PullRequestReviewCommentConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestReviewCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestReviewComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PullRequestReviewCommentEdge = {
  __typename?: "PullRequestReviewCommentEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestReviewComment>;
};

/** The possible states of a pull request review comment. */
export enum PullRequestReviewCommentState {
  /** A comment that is part of a pending review */
  Pending = "PENDING",
  /** A comment that is part of a submitted review */
  Submitted = "SUBMITTED",
}

/** The connection type for PullRequestReview. */
export type PullRequestReviewConnection = {
  __typename?: "PullRequestReviewConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestReviewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestReview>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** This aggregates pull request reviews made by a user within one repository. */
export type PullRequestReviewContributionsByRepository = {
  __typename?: "PullRequestReviewContributionsByRepository";
  /** The pull request review contributions. */
  contributions: CreatedPullRequestReviewContributionConnection;
  /** The repository in which the pull request reviews were made. */
  repository: Repository;
};

/** This aggregates pull request reviews made by a user within one repository. */
export type PullRequestReviewContributionsByRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** The review status of a pull request. */
export enum PullRequestReviewDecision {
  /** The pull request has received an approving review. */
  Approved = "APPROVED",
  /** Changes have been requested on the pull request. */
  ChangesRequested = "CHANGES_REQUESTED",
  /** A review is required before the pull request can be merged. */
  ReviewRequired = "REVIEW_REQUIRED",
}

/** An edge in a connection. */
export type PullRequestReviewEdge = {
  __typename?: "PullRequestReviewEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestReview>;
};

/** The possible events to perform on a pull request review. */
export enum PullRequestReviewEvent {
  /** Submit feedback and approve merging these changes. */
  Approve = "APPROVE",
  /** Submit general feedback without explicit approval. */
  Comment = "COMMENT",
  /** Dismiss review so it now longer effects merging. */
  Dismiss = "DISMISS",
  /** Submit feedback that must be addressed before merging. */
  RequestChanges = "REQUEST_CHANGES",
}

/** The possible states of a pull request review. */
export enum PullRequestReviewState {
  /** A review allowing the pull request to merge. */
  Approved = "APPROVED",
  /** A review blocking the pull request from merging. */
  ChangesRequested = "CHANGES_REQUESTED",
  /** An informational review. */
  Commented = "COMMENTED",
  /** A review that has been dismissed. */
  Dismissed = "DISMISSED",
  /** A review that has not yet been submitted. */
  Pending = "PENDING",
}

/** A threaded list of comments for a given pull request. */
export type PullRequestReviewThread = Node & {
  __typename?: "PullRequestReviewThread";
  /** A list of pull request comments associated with the thread. */
  comments: PullRequestReviewCommentConnection;
  /** The side of the diff on which this thread was placed. */
  diffSide: DiffSide;
  /** The Node ID of the PullRequestReviewThread object */
  id: Scalars["ID"]["output"];
  /** Whether or not the thread has been collapsed (resolved) */
  isCollapsed: Scalars["Boolean"]["output"];
  /** Indicates whether this thread was outdated by newer changes. */
  isOutdated: Scalars["Boolean"]["output"];
  /** Whether this thread has been resolved */
  isResolved: Scalars["Boolean"]["output"];
  /** The line in the file to which this thread refers */
  line?: Maybe<Scalars["Int"]["output"]>;
  /** The original line in the file to which this thread refers. */
  originalLine?: Maybe<Scalars["Int"]["output"]>;
  /** The original start line in the file to which this thread refers (multi-line only). */
  originalStartLine?: Maybe<Scalars["Int"]["output"]>;
  /** Identifies the file path of this thread. */
  path: Scalars["String"]["output"];
  /** Identifies the pull request associated with this thread. */
  pullRequest: PullRequest;
  /** Identifies the repository associated with this thread. */
  repository: Repository;
  /** The user who resolved this thread */
  resolvedBy?: Maybe<User>;
  /** The side of the diff that the first line of the thread starts on (multi-line only) */
  startDiffSide?: Maybe<DiffSide>;
  /** The start line in the file to which this thread refers (multi-line only) */
  startLine?: Maybe<Scalars["Int"]["output"]>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  subjectType: PullRequestReviewThreadSubjectType;
  /** Indicates whether the current viewer can reply to this thread. */
  viewerCanReply: Scalars["Boolean"]["output"];
  /** Whether or not the viewer can resolve this thread */
  viewerCanResolve: Scalars["Boolean"]["output"];
  /** Whether or not the viewer can unresolve this thread */
  viewerCanUnresolve: Scalars["Boolean"]["output"];
};

/** A threaded list of comments for a given pull request. */
export type PullRequestReviewThreadCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  skip?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Review comment threads for a pull request review. */
export type PullRequestReviewThreadConnection = {
  __typename?: "PullRequestReviewThreadConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestReviewThreadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestReviewThread>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PullRequestReviewThreadEdge = {
  __typename?: "PullRequestReviewThreadEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestReviewThread>;
};

/** The possible subject types of a pull request review comment. */
export enum PullRequestReviewThreadSubjectType {
  /** A comment that has been made against the file of a pull request */
  File = "FILE",
  /** A comment that has been made against the line of a pull request */
  Line = "LINE",
}

/** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
export type PullRequestRevisionMarker = {
  __typename?: "PullRequestRevisionMarker";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The last commit the viewer has seen. */
  lastSeenCommit: Commit;
  /** The pull request to which the marker belongs. */
  pullRequest: PullRequest;
};

/** The possible states of a pull request. */
export enum PullRequestState {
  /** A pull request that has been closed without being merged. */
  Closed = "CLOSED",
  /** A pull request that has been closed by being merged. */
  Merged = "MERGED",
  /** A pull request that is still open. */
  Open = "OPEN",
}

/** A repository pull request template. */
export type PullRequestTemplate = {
  __typename?: "PullRequestTemplate";
  /** The body of the template */
  body?: Maybe<Scalars["String"]["output"]>;
  /** The filename of the template */
  filename?: Maybe<Scalars["String"]["output"]>;
  /** The repository the template belongs to */
  repository: Repository;
};

/** A threaded list of comments for a given pull request. */
export type PullRequestThread = Node & {
  __typename?: "PullRequestThread";
  /** A list of pull request comments associated with the thread. */
  comments: PullRequestReviewCommentConnection;
  /** The side of the diff on which this thread was placed. */
  diffSide: DiffSide;
  /** The Node ID of the PullRequestThread object */
  id: Scalars["ID"]["output"];
  /** Whether or not the thread has been collapsed (resolved) */
  isCollapsed: Scalars["Boolean"]["output"];
  /** Indicates whether this thread was outdated by newer changes. */
  isOutdated: Scalars["Boolean"]["output"];
  /** Whether this thread has been resolved */
  isResolved: Scalars["Boolean"]["output"];
  /** The line in the file to which this thread refers */
  line?: Maybe<Scalars["Int"]["output"]>;
  /** Identifies the file path of this thread. */
  path: Scalars["String"]["output"];
  /** Identifies the pull request associated with this thread. */
  pullRequest: PullRequest;
  /** Identifies the repository associated with this thread. */
  repository: Repository;
  /** The user who resolved this thread */
  resolvedBy?: Maybe<User>;
  /** The side of the diff that the first line of the thread starts on (multi-line only) */
  startDiffSide?: Maybe<DiffSide>;
  /** The line of the first file diff in the thread. */
  startLine?: Maybe<Scalars["Int"]["output"]>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  subjectType: PullRequestReviewThreadSubjectType;
  /** Indicates whether the current viewer can reply to this thread. */
  viewerCanReply: Scalars["Boolean"]["output"];
  /** Whether or not the viewer can resolve this thread */
  viewerCanResolve: Scalars["Boolean"]["output"];
  /** Whether or not the viewer can unresolve this thread */
  viewerCanUnresolve: Scalars["Boolean"]["output"];
};

/** A threaded list of comments for a given pull request. */
export type PullRequestThreadCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  skip?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for PullRequestTimelineItem. */
export type PullRequestTimelineConnection = {
  __typename?: "PullRequestTimelineConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestTimelineItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestTimelineItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An item in a pull request timeline */
export type PullRequestTimelineItem =
  | AssignedEvent
  | BaseRefDeletedEvent
  | BaseRefForcePushedEvent
  | ClosedEvent
  | Commit
  | CommitCommentThread
  | CrossReferencedEvent
  | DemilestonedEvent
  | DeployedEvent
  | DeploymentEnvironmentChangedEvent
  | HeadRefDeletedEvent
  | HeadRefForcePushedEvent
  | HeadRefRestoredEvent
  | IssueComment
  | LabeledEvent
  | LockedEvent
  | MergedEvent
  | MilestonedEvent
  | PullRequestReview
  | PullRequestReviewComment
  | PullRequestReviewThread
  | ReferencedEvent
  | RenamedTitleEvent
  | ReopenedEvent
  | ReviewDismissedEvent
  | ReviewRequestRemovedEvent
  | ReviewRequestedEvent
  | SubscribedEvent
  | UnassignedEvent
  | UnlabeledEvent
  | UnlockedEvent
  | UnsubscribedEvent
  | UserBlockedEvent;

/** An edge in a connection. */
export type PullRequestTimelineItemEdge = {
  __typename?: "PullRequestTimelineItemEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestTimelineItem>;
};

/** An item in a pull request timeline */
export type PullRequestTimelineItems =
  | AddedToMergeQueueEvent
  | AddedToProjectEvent
  | AssignedEvent
  | AutoMergeDisabledEvent
  | AutoMergeEnabledEvent
  | AutoRebaseEnabledEvent
  | AutoSquashEnabledEvent
  | AutomaticBaseChangeFailedEvent
  | AutomaticBaseChangeSucceededEvent
  | BaseRefChangedEvent
  | BaseRefDeletedEvent
  | BaseRefForcePushedEvent
  | ClosedEvent
  | CommentDeletedEvent
  | ConnectedEvent
  | ConvertToDraftEvent
  | ConvertedNoteToIssueEvent
  | ConvertedToDiscussionEvent
  | CrossReferencedEvent
  | DemilestonedEvent
  | DeployedEvent
  | DeploymentEnvironmentChangedEvent
  | DisconnectedEvent
  | HeadRefDeletedEvent
  | HeadRefForcePushedEvent
  | HeadRefRestoredEvent
  | IssueComment
  | LabeledEvent
  | LockedEvent
  | MarkedAsDuplicateEvent
  | MentionedEvent
  | MergedEvent
  | MilestonedEvent
  | MovedColumnsInProjectEvent
  | PinnedEvent
  | PullRequestCommit
  | PullRequestCommitCommentThread
  | PullRequestReview
  | PullRequestReviewThread
  | PullRequestRevisionMarker
  | ReadyForReviewEvent
  | ReferencedEvent
  | RemovedFromMergeQueueEvent
  | RemovedFromProjectEvent
  | RenamedTitleEvent
  | ReopenedEvent
  | ReviewDismissedEvent
  | ReviewRequestRemovedEvent
  | ReviewRequestedEvent
  | SubscribedEvent
  | TransferredEvent
  | UnassignedEvent
  | UnlabeledEvent
  | UnlockedEvent
  | UnmarkedAsDuplicateEvent
  | UnpinnedEvent
  | UnsubscribedEvent
  | UserBlockedEvent;

/** The connection type for PullRequestTimelineItems. */
export type PullRequestTimelineItemsConnection = {
  __typename?: "PullRequestTimelineItemsConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars["Int"]["output"];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars["Int"]["output"];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** An edge in a connection. */
export type PullRequestTimelineItemsEdge = {
  __typename?: "PullRequestTimelineItemsEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestTimelineItems>;
};

/** The possible item types found in a timeline. */
export enum PullRequestTimelineItemsItemType {
  /** Represents an 'added_to_merge_queue' event on a given pull request. */
  AddedToMergeQueueEvent = "ADDED_TO_MERGE_QUEUE_EVENT",
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = "ADDED_TO_PROJECT_EVENT",
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = "ASSIGNED_EVENT",
  /** Represents a 'automatic_base_change_failed' event on a given pull request. */
  AutomaticBaseChangeFailedEvent = "AUTOMATIC_BASE_CHANGE_FAILED_EVENT",
  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
  AutomaticBaseChangeSucceededEvent = "AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT",
  /** Represents a 'auto_merge_disabled' event on a given pull request. */
  AutoMergeDisabledEvent = "AUTO_MERGE_DISABLED_EVENT",
  /** Represents a 'auto_merge_enabled' event on a given pull request. */
  AutoMergeEnabledEvent = "AUTO_MERGE_ENABLED_EVENT",
  /** Represents a 'auto_rebase_enabled' event on a given pull request. */
  AutoRebaseEnabledEvent = "AUTO_REBASE_ENABLED_EVENT",
  /** Represents a 'auto_squash_enabled' event on a given pull request. */
  AutoSquashEnabledEvent = "AUTO_SQUASH_ENABLED_EVENT",
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  BaseRefChangedEvent = "BASE_REF_CHANGED_EVENT",
  /** Represents a 'base_ref_deleted' event on a given pull request. */
  BaseRefDeletedEvent = "BASE_REF_DELETED_EVENT",
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  BaseRefForcePushedEvent = "BASE_REF_FORCE_PUSHED_EVENT",
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = "CLOSED_EVENT",
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = "COMMENT_DELETED_EVENT",
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = "CONNECTED_EVENT",
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = "CONVERTED_NOTE_TO_ISSUE_EVENT",
  /** Represents a 'converted_to_discussion' event on a given issue. */
  ConvertedToDiscussionEvent = "CONVERTED_TO_DISCUSSION_EVENT",
  /** Represents a 'convert_to_draft' event on a given pull request. */
  ConvertToDraftEvent = "CONVERT_TO_DRAFT_EVENT",
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = "CROSS_REFERENCED_EVENT",
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = "DEMILESTONED_EVENT",
  /** Represents a 'deployed' event on a given pull request. */
  DeployedEvent = "DEPLOYED_EVENT",
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  DeploymentEnvironmentChangedEvent = "DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT",
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = "DISCONNECTED_EVENT",
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  HeadRefDeletedEvent = "HEAD_REF_DELETED_EVENT",
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  HeadRefForcePushedEvent = "HEAD_REF_FORCE_PUSHED_EVENT",
  /** Represents a 'head_ref_restored' event on a given pull request. */
  HeadRefRestoredEvent = "HEAD_REF_RESTORED_EVENT",
  /** Represents a comment on an Issue. */
  IssueComment = "ISSUE_COMMENT",
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = "LABELED_EVENT",
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = "LOCKED_EVENT",
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = "MARKED_AS_DUPLICATE_EVENT",
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = "MENTIONED_EVENT",
  /** Represents a 'merged' event on a given pull request. */
  MergedEvent = "MERGED_EVENT",
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = "MILESTONED_EVENT",
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = "MOVED_COLUMNS_IN_PROJECT_EVENT",
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = "PINNED_EVENT",
  /** Represents a Git commit part of a pull request. */
  PullRequestCommit = "PULL_REQUEST_COMMIT",
  /** Represents a commit comment thread part of a pull request. */
  PullRequestCommitCommentThread = "PULL_REQUEST_COMMIT_COMMENT_THREAD",
  /** A review object for a given pull request. */
  PullRequestReview = "PULL_REQUEST_REVIEW",
  /** A threaded list of comments for a given pull request. */
  PullRequestReviewThread = "PULL_REQUEST_REVIEW_THREAD",
  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
  PullRequestRevisionMarker = "PULL_REQUEST_REVISION_MARKER",
  /** Represents a 'ready_for_review' event on a given pull request. */
  ReadyForReviewEvent = "READY_FOR_REVIEW_EVENT",
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = "REFERENCED_EVENT",
  /** Represents a 'removed_from_merge_queue' event on a given pull request. */
  RemovedFromMergeQueueEvent = "REMOVED_FROM_MERGE_QUEUE_EVENT",
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = "REMOVED_FROM_PROJECT_EVENT",
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = "RENAMED_TITLE_EVENT",
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = "REOPENED_EVENT",
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  ReviewDismissedEvent = "REVIEW_DISMISSED_EVENT",
  /** Represents an 'review_requested' event on a given pull request. */
  ReviewRequestedEvent = "REVIEW_REQUESTED_EVENT",
  /** Represents an 'review_request_removed' event on a given pull request. */
  ReviewRequestRemovedEvent = "REVIEW_REQUEST_REMOVED_EVENT",
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = "SUBSCRIBED_EVENT",
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = "TRANSFERRED_EVENT",
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = "UNASSIGNED_EVENT",
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = "UNLABELED_EVENT",
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = "UNLOCKED_EVENT",
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = "UNMARKED_AS_DUPLICATE_EVENT",
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = "UNPINNED_EVENT",
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = "UNSUBSCRIBED_EVENT",
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = "USER_BLOCKED_EVENT",
}

/** The possible target states when updating a pull request. */
export enum PullRequestUpdateState {
  /** A pull request that has been closed without being merged. */
  Closed = "CLOSED",
  /** A pull request that is still open. */
  Open = "OPEN",
}

/** A Git push. */
export type Push = Node & {
  __typename?: "Push";
  /** The Node ID of the Push object */
  id: Scalars["ID"]["output"];
  /** The SHA after the push */
  nextSha?: Maybe<Scalars["GitObjectID"]["output"]>;
  /** The permalink for this push. */
  permalink: Scalars["URI"]["output"];
  /** The SHA before the push */
  previousSha?: Maybe<Scalars["GitObjectID"]["output"]>;
  /** The actor who pushed */
  pusher: Actor;
  /** The repository that was pushed to */
  repository: Repository;
};

/** A team, user, or app who has the ability to push to a protected branch. */
export type PushAllowance = Node & {
  __typename?: "PushAllowance";
  /** The actor that can push. */
  actor?: Maybe<PushAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** The Node ID of the PushAllowance object */
  id: Scalars["ID"]["output"];
};

/** Types that can be an actor. */
export type PushAllowanceActor = App | Team | User;

/** The connection type for PushAllowance. */
export type PushAllowanceConnection = {
  __typename?: "PushAllowanceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PushAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PushAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PushAllowanceEdge = {
  __typename?: "PushAllowanceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PushAllowance>;
};

/** The query root of GitHub's GraphQL interface. */
export type Query = {
  __typename?: "Query";
  /** Look up a code of conduct by its key */
  codeOfConduct?: Maybe<CodeOfConduct>;
  /** Look up a code of conduct by its key */
  codesOfConduct?: Maybe<Array<Maybe<CodeOfConduct>>>;
  /** Look up an enterprise by URL slug. */
  enterprise?: Maybe<Enterprise>;
  /** Look up a pending enterprise administrator invitation by invitee, enterprise and role. */
  enterpriseAdministratorInvitation?: Maybe<EnterpriseAdministratorInvitation>;
  /** Look up a pending enterprise administrator invitation by invitation token. */
  enterpriseAdministratorInvitationByToken?: Maybe<EnterpriseAdministratorInvitation>;
  /** Look up a pending enterprise unaffiliated member invitation by invitee and enterprise. */
  enterpriseMemberInvitation?: Maybe<EnterpriseMemberInvitation>;
  /** Look up a pending enterprise unaffiliated member invitation by invitation token. */
  enterpriseMemberInvitationByToken?: Maybe<EnterpriseMemberInvitation>;
  /** Look up an open source license by its key */
  license?: Maybe<License>;
  /** Return a list of known open source licenses */
  licenses: Array<Maybe<License>>;
  /** Get alphabetically sorted list of Marketplace categories */
  marketplaceCategories: Array<MarketplaceCategory>;
  /** Look up a Marketplace category by its slug. */
  marketplaceCategory?: Maybe<MarketplaceCategory>;
  /** Look up a single Marketplace listing */
  marketplaceListing?: Maybe<MarketplaceListing>;
  /** Look up Marketplace listings */
  marketplaceListings: MarketplaceListingConnection;
  /** Return information about the GitHub instance */
  meta: GitHubMetadata;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  /** Lookup a organization by login. */
  organization?: Maybe<Organization>;
  /** The client's rate limit information. */
  rateLimit?: Maybe<RateLimit>;
  /**
   * Workaround for re-exposing the root query object. (Refer to
   * https://github.com/facebook/relay/issues/112 for more information.)
   */
  relay: Query;
  /** Lookup a given repository by the owner and repository name. */
  repository?: Maybe<Repository>;
  /** Lookup a repository owner (ie. either a User or an Organization) by login. */
  repositoryOwner?: Maybe<RepositoryOwner>;
  /** Lookup resource by a URL. */
  resource?: Maybe<UniformResourceLocatable>;
  /** Perform a search across resources, returning a maximum of 1,000 results. */
  search: SearchResultItemConnection;
  /** GitHub Security Advisories */
  securityAdvisories: SecurityAdvisoryConnection;
  /** Fetch a Security Advisory by its GHSA ID */
  securityAdvisory?: Maybe<SecurityAdvisory>;
  /** Software Vulnerabilities documented by GitHub Security Advisories */
  securityVulnerabilities: SecurityVulnerabilityConnection;
  /** Users and organizations who can be sponsored via GitHub Sponsors. */
  sponsorables: SponsorableItemConnection;
  /** Look up a topic by name. */
  topic?: Maybe<Topic>;
  /** Lookup a user by login. */
  user?: Maybe<User>;
  /** The currently authenticated user. */
  viewer: User;
};

/** The query root of GitHub's GraphQL interface. */
export type QueryCodeOfConductArgs = {
  key: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryEnterpriseArgs = {
  invitationToken?: InputMaybe<Scalars["String"]["input"]>;
  slug: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryEnterpriseAdministratorInvitationArgs = {
  enterpriseSlug: Scalars["String"]["input"];
  role: EnterpriseAdministratorRole;
  userLogin: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryEnterpriseAdministratorInvitationByTokenArgs = {
  invitationToken: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryEnterpriseMemberInvitationArgs = {
  enterpriseSlug: Scalars["String"]["input"];
  userLogin: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryEnterpriseMemberInvitationByTokenArgs = {
  invitationToken: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryLicenseArgs = {
  key: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryMarketplaceCategoriesArgs = {
  excludeEmpty?: InputMaybe<Scalars["Boolean"]["input"]>;
  excludeSubcategories?: InputMaybe<Scalars["Boolean"]["input"]>;
  includeCategories?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** The query root of GitHub's GraphQL interface. */
export type QueryMarketplaceCategoryArgs = {
  slug: Scalars["String"]["input"];
  useTopicAliases?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** The query root of GitHub's GraphQL interface. */
export type QueryMarketplaceListingArgs = {
  slug: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryMarketplaceListingsArgs = {
  adminId?: InputMaybe<Scalars["ID"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  allStates?: InputMaybe<Scalars["Boolean"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  categorySlug?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  organizationId?: InputMaybe<Scalars["ID"]["input"]>;
  primaryCategoryOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  slugs?: InputMaybe<Array<InputMaybe<Scalars["String"]["input"]>>>;
  useTopicAliases?: InputMaybe<Scalars["Boolean"]["input"]>;
  viewerCanAdmin?: InputMaybe<Scalars["Boolean"]["input"]>;
  withFreeTrialsOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** The query root of GitHub's GraphQL interface. */
export type QueryNodeArgs = {
  id: Scalars["ID"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryNodesArgs = {
  ids: Array<Scalars["ID"]["input"]>;
};

/** The query root of GitHub's GraphQL interface. */
export type QueryOrganizationArgs = {
  login: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryRateLimitArgs = {
  dryRun?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** The query root of GitHub's GraphQL interface. */
export type QueryRepositoryArgs = {
  followRenames?: InputMaybe<Scalars["Boolean"]["input"]>;
  name: Scalars["String"]["input"];
  owner: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryRepositoryOwnerArgs = {
  login: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryResourceArgs = {
  url: Scalars["URI"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QuerySearchArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  query: Scalars["String"]["input"];
  type: SearchType;
};

/** The query root of GitHub's GraphQL interface. */
export type QuerySecurityAdvisoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  classifications?: InputMaybe<Array<SecurityAdvisoryClassification>>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  identifier?: InputMaybe<SecurityAdvisoryIdentifierFilter>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SecurityAdvisoryOrder>;
  publishedSince?: InputMaybe<Scalars["DateTime"]["input"]>;
  updatedSince?: InputMaybe<Scalars["DateTime"]["input"]>;
};

/** The query root of GitHub's GraphQL interface. */
export type QuerySecurityAdvisoryArgs = {
  ghsaId: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QuerySecurityVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  classifications?: InputMaybe<Array<SecurityAdvisoryClassification>>;
  ecosystem?: InputMaybe<SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SecurityVulnerabilityOrder>;
  package?: InputMaybe<Scalars["String"]["input"]>;
  severities?: InputMaybe<Array<SecurityAdvisorySeverity>>;
};

/** The query root of GitHub's GraphQL interface. */
export type QuerySponsorablesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  dependencyEcosystem?: InputMaybe<SecurityAdvisoryEcosystem>;
  ecosystem?: InputMaybe<DependencyGraphEcosystem>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  onlyDependencies?: InputMaybe<Scalars["Boolean"]["input"]>;
  orderBy?: InputMaybe<SponsorableOrder>;
  orgLoginForDependencies?: InputMaybe<Scalars["String"]["input"]>;
};

/** The query root of GitHub's GraphQL interface. */
export type QueryTopicArgs = {
  name: Scalars["String"]["input"];
};

/** The query root of GitHub's GraphQL interface. */
export type QueryUserArgs = {
  login: Scalars["String"]["input"];
};

/** Represents the client's rate limit. */
export type RateLimit = {
  __typename?: "RateLimit";
  /** The point cost for the current query counting against the rate limit. */
  cost: Scalars["Int"]["output"];
  /** The maximum number of points the client is permitted to consume in a 60 minute window. */
  limit: Scalars["Int"]["output"];
  /** The maximum number of nodes this query may return */
  nodeCount: Scalars["Int"]["output"];
  /** The number of points remaining in the current rate limit window. */
  remaining: Scalars["Int"]["output"];
  /** The time at which the current rate limit window resets in UTC epoch seconds. */
  resetAt: Scalars["DateTime"]["output"];
  /** The number of points used in the current rate limit window. */
  used: Scalars["Int"]["output"];
};

/** Represents a subject that can be reacted on. */
export type Reactable = {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the Reactable object */
  id: Scalars["ID"]["output"];
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** Can user react to this subject */
  viewerCanReact: Scalars["Boolean"]["output"];
};

/** Represents a subject that can be reacted on. */
export type ReactableReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** The connection type for User. */
export type ReactingUserConnection = {
  __typename?: "ReactingUserConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReactingUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Represents a user that's made a reaction. */
export type ReactingUserEdge = {
  __typename?: "ReactingUserEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  node: User;
  /** The moment when the user made the reaction. */
  reactedAt: Scalars["DateTime"]["output"];
};

/** An emoji reaction to a particular piece of content. */
export type Reaction = Node & {
  __typename?: "Reaction";
  /** Identifies the emoji reaction. */
  content: ReactionContent;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the Reaction object */
  id: Scalars["ID"]["output"];
  /** The reactable piece of content */
  reactable: Reactable;
  /** Identifies the user who created this reaction. */
  user?: Maybe<User>;
};

/** A list of reactions that have been left on the subject. */
export type ReactionConnection = {
  __typename?: "ReactionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReactionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Reaction>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars["Boolean"]["output"];
};

/** Emojis that can be attached to Issues, Pull Requests and Comments. */
export enum ReactionContent {
  /** Represents the `:confused:` emoji. */
  Confused = "CONFUSED",
  /** Represents the `:eyes:` emoji. */
  Eyes = "EYES",
  /** Represents the `:heart:` emoji. */
  Heart = "HEART",
  /** Represents the `:hooray:` emoji. */
  Hooray = "HOORAY",
  /** Represents the `:laugh:` emoji. */
  Laugh = "LAUGH",
  /** Represents the `:rocket:` emoji. */
  Rocket = "ROCKET",
  /** Represents the `:-1:` emoji. */
  ThumbsDown = "THUMBS_DOWN",
  /** Represents the `:+1:` emoji. */
  ThumbsUp = "THUMBS_UP",
}

/** An edge in a connection. */
export type ReactionEdge = {
  __typename?: "ReactionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Reaction>;
};

/** A group of emoji reactions to a particular piece of content. */
export type ReactionGroup = {
  __typename?: "ReactionGroup";
  /** Identifies the emoji reaction. */
  content: ReactionContent;
  /** Identifies when the reaction was created. */
  createdAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** Reactors to the reaction subject with the emotion represented by this reaction group. */
  reactors: ReactorConnection;
  /** The subject that was reacted to. */
  subject: Reactable;
  /**
   * Users who have reacted to the reaction subject with the emotion represented by this reaction group
   * @deprecated Reactors can now be mannequins, bots, and organizations. Use the `reactors` field instead. Removal on 2021-10-01 UTC.
   */
  users: ReactingUserConnection;
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars["Boolean"]["output"];
};

/** A group of emoji reactions to a particular piece of content. */
export type ReactionGroupReactorsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A group of emoji reactions to a particular piece of content. */
export type ReactionGroupUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Ways in which lists of reactions can be ordered upon return. */
export type ReactionOrder = {
  /** The direction in which to order reactions by the specified field. */
  direction: OrderDirection;
  /** The field in which to order reactions by. */
  field: ReactionOrderField;
};

/** A list of fields that reactions can be ordered by. */
export enum ReactionOrderField {
  /** Allows ordering a list of reactions by when they were created. */
  CreatedAt = "CREATED_AT",
}

/** Types that can be assigned to reactions. */
export type Reactor = Bot | Mannequin | Organization | User;

/** The connection type for Reactor. */
export type ReactorConnection = {
  __typename?: "ReactorConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReactorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Reactor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Represents an author of a reaction. */
export type ReactorEdge = {
  __typename?: "ReactorEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The author of the reaction. */
  node: Reactor;
  /** The moment when the user made the reaction. */
  reactedAt: Scalars["DateTime"]["output"];
};

/** Represents a 'ready_for_review' event on a given pull request. */
export type ReadyForReviewEvent = Node &
  UniformResourceLocatable & {
    __typename?: "ReadyForReviewEvent";
    /** Identifies the actor who performed the event. */
    actor?: Maybe<Actor>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The Node ID of the ReadyForReviewEvent object */
    id: Scalars["ID"]["output"];
    /** PullRequest referenced by event. */
    pullRequest: PullRequest;
    /** The HTTP path for this ready for review event. */
    resourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for this ready for review event. */
    url: Scalars["URI"]["output"];
  };

/** Represents a Git reference. */
export type Ref = Node & {
  __typename?: "Ref";
  /** A list of pull requests with this ref as the head ref. */
  associatedPullRequests: PullRequestConnection;
  /** Branch protection rules for this ref */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** Compares the current ref as a base ref to another head ref, if the comparison can be made. */
  compare?: Maybe<Comparison>;
  /** The Node ID of the Ref object */
  id: Scalars["ID"]["output"];
  /** The ref name. */
  name: Scalars["String"]["output"];
  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */
  prefix: Scalars["String"]["output"];
  /** Branch protection rules that are viewable by non-admins */
  refUpdateRule?: Maybe<RefUpdateRule>;
  /** The repository the ref belongs to. */
  repository: Repository;
  /** A list of rules from active Repository and Organization rulesets that apply to this ref. */
  rules?: Maybe<RepositoryRuleConnection>;
  /** The object the ref points to. Returns null when object does not exist. */
  target?: Maybe<GitObject>;
};

/** Represents a Git reference. */
export type RefAssociatedPullRequestsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  baseRefName?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  headRefName?: InputMaybe<Scalars["String"]["input"]>;
  labels?: InputMaybe<Array<Scalars["String"]["input"]>>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<PullRequestState>>;
};

/** Represents a Git reference. */
export type RefCompareArgs = {
  headRef: Scalars["String"]["input"];
};

/** Represents a Git reference. */
export type RefRulesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RepositoryRuleOrder>;
};

/** The connection type for Ref. */
export type RefConnection = {
  __typename?: "RefConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RefEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Ref>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type RefEdge = {
  __typename?: "RefEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Ref>;
};

/** Parameters to be used for the ref_name condition */
export type RefNameConditionTarget = {
  __typename?: "RefNameConditionTarget";
  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars["String"]["output"]>;
  /**
   * Array of ref names or patterns to include. One of these patterns must match
   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the
   * default branch or `~ALL` to include all branches.
   */
  include: Array<Scalars["String"]["output"]>;
};

/** Parameters to be used for the ref_name condition */
export type RefNameConditionTargetInput = {
  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars["String"]["input"]>;
  /**
   * Array of ref names or patterns to include. One of these patterns must match
   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the
   * default branch or `~ALL` to include all branches.
   */
  include: Array<Scalars["String"]["input"]>;
};

/** Ways in which lists of git refs can be ordered upon return. */
export type RefOrder = {
  /** The direction in which to order refs by the specified field. */
  direction: OrderDirection;
  /** The field in which to order refs by. */
  field: RefOrderField;
};

/** Properties by which ref connections can be ordered. */
export enum RefOrderField {
  /** Order refs by their alphanumeric name */
  Alphabetical = "ALPHABETICAL",
  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */
  TagCommitDate = "TAG_COMMIT_DATE",
}

/** A ref update */
export type RefUpdate = {
  /** The value this ref should be updated to. */
  afterOid: Scalars["GitObjectID"]["input"];
  /** The value this ref needs to point to before the update. */
  beforeOid?: InputMaybe<Scalars["GitObjectID"]["input"]>;
  /** Force a non fast-forward update. */
  force?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */
  name: Scalars["GitRefname"]["input"];
};

/** Branch protection rules that are enforced on the viewer. */
export type RefUpdateRule = {
  __typename?: "RefUpdateRule";
  /** Can this branch be deleted. */
  allowsDeletions: Scalars["Boolean"]["output"];
  /** Are force pushes allowed on this branch. */
  allowsForcePushes: Scalars["Boolean"]["output"];
  /** Can matching branches be created. */
  blocksCreations: Scalars["Boolean"]["output"];
  /** Identifies the protection rule pattern. */
  pattern: Scalars["String"]["output"];
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars["Int"]["output"]>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<
    Array<Maybe<Scalars["String"]["output"]>>
  >;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews: Scalars["Boolean"]["output"];
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution: Scalars["Boolean"]["output"];
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory: Scalars["Boolean"]["output"];
  /** Are commits required to be signed. */
  requiresSignatures: Scalars["Boolean"]["output"];
  /** Is the viewer allowed to dismiss reviews. */
  viewerAllowedToDismissReviews: Scalars["Boolean"]["output"];
  /** Can the viewer push to the branch */
  viewerCanPush: Scalars["Boolean"]["output"];
};

/** Represents a 'referenced' event on a given `ReferencedSubject`. */
export type ReferencedEvent = Node & {
  __typename?: "ReferencedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the commit associated with the 'referenced' event. */
  commit?: Maybe<Commit>;
  /** Identifies the repository associated with the 'referenced' event. */
  commitRepository: Repository;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the ReferencedEvent object */
  id: Scalars["ID"]["output"];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars["Boolean"]["output"];
  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */
  isDirectReference: Scalars["Boolean"]["output"];
  /** Object referenced by event. */
  subject: ReferencedSubject;
};

/** Any referencable object */
export type ReferencedSubject = Issue | PullRequest;

/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes. */
export type RegenerateEnterpriseIdentityProviderRecoveryCodesPayload = {
  __typename?: "RegenerateEnterpriseIdentityProviderRecoveryCodesPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<EnterpriseIdentityProvider>;
};

/** Autogenerated input type of RegenerateVerifiableDomainToken */
export type RegenerateVerifiableDomainTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the verifiable domain to regenerate the verification token of. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of RegenerateVerifiableDomainToken. */
export type RegenerateVerifiableDomainTokenPayload = {
  __typename?: "RegenerateVerifiableDomainTokenPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The verification token that was generated. */
  verificationToken?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of RejectDeployments */
export type RejectDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Optional comment for rejecting deployments */
  comment?: InputMaybe<Scalars["String"]["input"]>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars["ID"]["input"]>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RejectDeployments. */
export type RejectDeploymentsPayload = {
  __typename?: "RejectDeploymentsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The affected deployments. */
  deployments?: Maybe<Array<Deployment>>;
};

/** A release contains the content for a release. */
export type Release = Node &
  Reactable &
  UniformResourceLocatable & {
    __typename?: "Release";
    /** The author of the release */
    author?: Maybe<User>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The description of the release. */
    description?: Maybe<Scalars["String"]["output"]>;
    /** The description of this release rendered to HTML. */
    descriptionHTML?: Maybe<Scalars["HTML"]["output"]>;
    /** The Node ID of the Release object */
    id: Scalars["ID"]["output"];
    /** Whether or not the release is a draft */
    isDraft: Scalars["Boolean"]["output"];
    /** Whether or not the release is the latest releast */
    isLatest: Scalars["Boolean"]["output"];
    /** Whether or not the release is a prerelease */
    isPrerelease: Scalars["Boolean"]["output"];
    /** A list of users mentioned in the release description */
    mentions?: Maybe<UserConnection>;
    /** The title of the release. */
    name?: Maybe<Scalars["String"]["output"]>;
    /** Identifies the date and time when the release was created. */
    publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: Maybe<Array<ReactionGroup>>;
    /** A list of Reactions left on the Issue. */
    reactions: ReactionConnection;
    /** List of releases assets which are dependent on this release. */
    releaseAssets: ReleaseAssetConnection;
    /** The repository that the release belongs to. */
    repository: Repository;
    /** The HTTP path for this issue */
    resourcePath: Scalars["URI"]["output"];
    /** A description of the release, rendered to HTML without any links in it. */
    shortDescriptionHTML?: Maybe<Scalars["HTML"]["output"]>;
    /** The Git tag the release points to */
    tag?: Maybe<Ref>;
    /** The tag commit for this release. */
    tagCommit?: Maybe<Commit>;
    /** The name of the release's Git tag */
    tagName: Scalars["String"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this issue */
    url: Scalars["URI"]["output"];
    /** Can user react to this subject */
    viewerCanReact: Scalars["Boolean"]["output"];
  };

/** A release contains the content for a release. */
export type ReleaseMentionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A release contains the content for a release. */
export type ReleaseReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** A release contains the content for a release. */
export type ReleaseReleaseAssetsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
};

/** A release contains the content for a release. */
export type ReleaseShortDescriptionHtmlArgs = {
  limit?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A release asset contains the content for a release asset. */
export type ReleaseAsset = Node & {
  __typename?: "ReleaseAsset";
  /** The asset's content-type */
  contentType: Scalars["String"]["output"];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The number of times this asset was downloaded */
  downloadCount: Scalars["Int"]["output"];
  /** Identifies the URL where you can download the release asset via the browser. */
  downloadUrl: Scalars["URI"]["output"];
  /** The Node ID of the ReleaseAsset object */
  id: Scalars["ID"]["output"];
  /** Identifies the title of the release asset. */
  name: Scalars["String"]["output"];
  /** Release that the asset is associated with */
  release?: Maybe<Release>;
  /** The size (in bytes) of the asset */
  size: Scalars["Int"]["output"];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** The user that performed the upload */
  uploadedBy: User;
  /** Identifies the URL of the release asset. */
  url: Scalars["URI"]["output"];
};

/** The connection type for ReleaseAsset. */
export type ReleaseAssetConnection = {
  __typename?: "ReleaseAssetConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseAssetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReleaseAsset>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ReleaseAssetEdge = {
  __typename?: "ReleaseAssetEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ReleaseAsset>;
};

/** The connection type for Release. */
export type ReleaseConnection = {
  __typename?: "ReleaseConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Release>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ReleaseEdge = {
  __typename?: "ReleaseEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Release>;
};

/** Ways in which lists of releases can be ordered upon return. */
export type ReleaseOrder = {
  /** The direction in which to order releases by the specified field. */
  direction: OrderDirection;
  /** The field in which to order releases by. */
  field: ReleaseOrderField;
};

/** Properties by which release connections can be ordered. */
export enum ReleaseOrderField {
  /** Order releases by creation time */
  CreatedAt = "CREATED_AT",
  /** Order releases alphabetically by name */
  Name = "NAME",
}

/** Autogenerated input type of RemoveAssigneesFromAssignable */
export type RemoveAssigneesFromAssignableInput = {
  /** The id of the assignable object to remove assignees from. */
  assignableId: Scalars["ID"]["input"];
  /** The id of users to remove as assignees. */
  assigneeIds: Array<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of RemoveAssigneesFromAssignable. */
export type RemoveAssigneesFromAssignablePayload = {
  __typename?: "RemoveAssigneesFromAssignablePayload";
  /** The item that was unassigned. */
  assignable?: Maybe<Assignable>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of RemoveEnterpriseAdmin */
export type RemoveEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Enterprise ID from which to remove the administrator. */
  enterpriseId: Scalars["ID"]["input"];
  /** The login of the user to remove as an administrator. */
  login: Scalars["String"]["input"];
};

/** Autogenerated return type of RemoveEnterpriseAdmin. */
export type RemoveEnterpriseAdminPayload = {
  __typename?: "RemoveEnterpriseAdminPayload";
  /** The user who was removed as an administrator. */
  admin?: Maybe<User>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated enterprise. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of removing an administrator. */
  message?: Maybe<Scalars["String"]["output"]>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<User>;
};

/** Autogenerated input type of RemoveEnterpriseIdentityProvider */
export type RemoveEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise from which to remove the identity provider. */
  enterpriseId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RemoveEnterpriseIdentityProvider. */
export type RemoveEnterpriseIdentityProviderPayload = {
  __typename?: "RemoveEnterpriseIdentityProviderPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The identity provider that was removed from the enterprise. */
  identityProvider?: Maybe<EnterpriseIdentityProvider>;
};

/** Autogenerated input type of RemoveEnterpriseMember */
export type RemoveEnterpriseMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise from which the user should be removed. */
  enterpriseId: Scalars["ID"]["input"];
  /** The ID of the user to remove from the enterprise. */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RemoveEnterpriseMember. */
export type RemoveEnterpriseMemberPayload = {
  __typename?: "RemoveEnterpriseMemberPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated enterprise. */
  enterprise?: Maybe<Enterprise>;
  /** The user that was removed from the enterprise. */
  user?: Maybe<User>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<User>;
};

/** Autogenerated input type of RemoveEnterpriseOrganization */
export type RemoveEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise from which the organization should be removed. */
  enterpriseId: Scalars["ID"]["input"];
  /** The ID of the organization to remove from the enterprise. */
  organizationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RemoveEnterpriseOrganization. */
export type RemoveEnterpriseOrganizationPayload = {
  __typename?: "RemoveEnterpriseOrganizationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated enterprise. */
  enterprise?: Maybe<Enterprise>;
  /** The organization that was removed from the enterprise. */
  organization?: Maybe<Organization>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<User>;
};

/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */
export type RemoveEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars["ID"]["input"];
  /** The login of a member who will lose the support entitlement. */
  login: Scalars["String"]["input"];
};

/** Autogenerated return type of RemoveEnterpriseSupportEntitlement. */
export type RemoveEnterpriseSupportEntitlementPayload = {
  __typename?: "RemoveEnterpriseSupportEntitlementPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** A message confirming the result of removing the support entitlement. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of RemoveLabelsFromLabelable */
export type RemoveLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ids of labels to remove. */
  labelIds: Array<Scalars["ID"]["input"]>;
  /** The id of the Labelable to remove labels from. */
  labelableId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RemoveLabelsFromLabelable. */
export type RemoveLabelsFromLabelablePayload = {
  __typename?: "RemoveLabelsFromLabelablePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The Labelable the labels were removed from. */
  labelable?: Maybe<Labelable>;
};

/** Autogenerated input type of RemoveOutsideCollaborator */
export type RemoveOutsideCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the organization to remove the outside collaborator from. */
  organizationId: Scalars["ID"]["input"];
  /** The ID of the outside collaborator to remove. */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RemoveOutsideCollaborator. */
export type RemoveOutsideCollaboratorPayload = {
  __typename?: "RemoveOutsideCollaboratorPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The user that was removed as an outside collaborator. */
  removedUser?: Maybe<User>;
};

/** Autogenerated input type of RemoveReaction */
export type RemoveReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the emoji reaction to remove. */
  content: ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RemoveReaction. */
export type RemoveReactionPayload = {
  __typename?: "RemoveReactionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The reaction object. */
  reaction?: Maybe<Reaction>;
  /** The reaction groups for the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** The reactable subject. */
  subject?: Maybe<Reactable>;
};

/** Autogenerated input type of RemoveStar */
export type RemoveStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Starrable ID to unstar. */
  starrableId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RemoveStar. */
export type RemoveStarPayload = {
  __typename?: "RemoveStarPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The starrable. */
  starrable?: Maybe<Starrable>;
};

/** Autogenerated input type of RemoveUpvote */
export type RemoveUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the discussion or comment to remove upvote. */
  subjectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RemoveUpvote. */
export type RemoveUpvotePayload = {
  __typename?: "RemoveUpvotePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The votable subject. */
  subject?: Maybe<Votable>;
};

/** Represents a 'removed_from_merge_queue' event on a given pull request. */
export type RemovedFromMergeQueueEvent = Node & {
  __typename?: "RemovedFromMergeQueueEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the before commit SHA for the 'removed_from_merge_queue' event. */
  beforeCommit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The user who removed this Pull Request from the merge queue */
  enqueuer?: Maybe<User>;
  /** The Node ID of the RemovedFromMergeQueueEvent object */
  id: Scalars["ID"]["output"];
  /** The merge queue where this pull request was removed from. */
  mergeQueue?: Maybe<MergeQueue>;
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<PullRequest>;
  /** The reason this pull request was removed from the queue. */
  reason?: Maybe<Scalars["String"]["output"]>;
};

/** Represents a 'removed_from_project' event on a given issue or pull request. */
export type RemovedFromProjectEvent = Node & {
  __typename?: "RemovedFromProjectEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the RemovedFromProjectEvent object */
  id: Scalars["ID"]["output"];
  /** Project referenced by event. */
  project?: Maybe<Project>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars["String"]["output"];
};

/** Represents a 'renamed' event on a given issue or pull request */
export type RenamedTitleEvent = Node & {
  __typename?: "RenamedTitleEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the current title of the issue or pull request. */
  currentTitle: Scalars["String"]["output"];
  /** The Node ID of the RenamedTitleEvent object */
  id: Scalars["ID"]["output"];
  /** Identifies the previous title of the issue or pull request. */
  previousTitle: Scalars["String"]["output"];
  /** Subject that was renamed. */
  subject: RenamedTitleSubject;
};

/** An object which has a renamable title */
export type RenamedTitleSubject = Issue | PullRequest;

/** Autogenerated input type of ReopenDiscussion */
export type ReopenDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the discussion to be reopened. */
  discussionId: Scalars["ID"]["input"];
};

/** Autogenerated return type of ReopenDiscussion. */
export type ReopenDiscussionPayload = {
  __typename?: "ReopenDiscussionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The discussion that was reopened. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of ReopenIssue */
export type ReopenIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the issue to be opened. */
  issueId: Scalars["ID"]["input"];
};

/** Autogenerated return type of ReopenIssue. */
export type ReopenIssuePayload = {
  __typename?: "ReopenIssuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The issue that was opened. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of ReopenPullRequest */
export type ReopenPullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the pull request to be reopened. */
  pullRequestId: Scalars["ID"]["input"];
};

/** Autogenerated return type of ReopenPullRequest. */
export type ReopenPullRequestPayload = {
  __typename?: "ReopenPullRequestPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The pull request that was reopened. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'reopened' event on any `Closable`. */
export type ReopenedEvent = Node & {
  __typename?: "ReopenedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Object that was reopened. */
  closable: Closable;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the ReopenedEvent object */
  id: Scalars["ID"]["output"];
  /** The reason the issue state was changed to open. */
  stateReason?: Maybe<IssueStateReason>;
};

/** Autogenerated input type of ReorderEnvironment */
export type ReorderEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the environment to modify */
  environmentId: Scalars["ID"]["input"];
  /** The desired position of the environment */
  position: Scalars["Int"]["input"];
};

/** Autogenerated return type of ReorderEnvironment. */
export type ReorderEnvironmentPayload = {
  __typename?: "ReorderEnvironmentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The environment that was reordered */
  environment?: Maybe<Environment>;
};

/** Audit log entry for a repo.access event. */
export type RepoAccessAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoAccessAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoAccessAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The visibility of the repository */
    visibility?: Maybe<RepoAccessAuditEntryVisibility>;
  };

/** The privacy of a repository */
export enum RepoAccessAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** Audit log entry for a repo.add_member event. */
export type RepoAddMemberAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoAddMemberAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoAddMemberAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The visibility of the repository */
    visibility?: Maybe<RepoAddMemberAuditEntryVisibility>;
  };

/** The privacy of a repository */
export enum RepoAddMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** Audit log entry for a repo.add_topic event. */
export type RepoAddTopicAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData &
  TopicAuditEntryData & {
    __typename?: "RepoAddTopicAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoAddTopicAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The name of the topic added to the repository */
    topic?: Maybe<Topic>;
    /** The name of the topic added to the repository */
    topicName?: Maybe<Scalars["String"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a repo.archived event. */
export type RepoArchivedAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoArchivedAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoArchivedAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The visibility of the repository */
    visibility?: Maybe<RepoArchivedAuditEntryVisibility>;
  };

/** The privacy of a repository */
export enum RepoArchivedAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** Audit log entry for a repo.change_merge_setting event. */
export type RepoChangeMergeSettingAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoChangeMergeSettingAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoChangeMergeSettingAuditEntry object */
    id: Scalars["ID"]["output"];
    /** Whether the change was to enable (true) or disable (false) the merge type */
    isEnabled?: Maybe<Scalars["Boolean"]["output"]>;
    /** The merge method affected by the change */
    mergeType?: Maybe<RepoChangeMergeSettingAuditEntryMergeType>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** The merge options available for pull requests to this repository. */
export enum RepoChangeMergeSettingAuditEntryMergeType {
  /** The pull request is added to the base branch in a merge commit. */
  Merge = "MERGE",
  /** Commits from the pull request are added onto the base branch individually without a merge commit. */
  Rebase = "REBASE",
  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */
  Squash = "SQUASH",
}

/** Audit log entry for a repo.config.disable_anonymous_git_access event. */
export type RepoConfigDisableAnonymousGitAccessAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoConfigDisableAnonymousGitAccessAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoConfigDisableAnonymousGitAccessAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a repo.config.disable_collaborators_only event. */
export type RepoConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoConfigDisableCollaboratorsOnlyAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoConfigDisableCollaboratorsOnlyAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a repo.config.disable_contributors_only event. */
export type RepoConfigDisableContributorsOnlyAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoConfigDisableContributorsOnlyAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoConfigDisableContributorsOnlyAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a repo.config.disable_sockpuppet_disallowed event. */
export type RepoConfigDisableSockpuppetDisallowedAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoConfigDisableSockpuppetDisallowedAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoConfigDisableSockpuppetDisallowedAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a repo.config.enable_anonymous_git_access event. */
export type RepoConfigEnableAnonymousGitAccessAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoConfigEnableAnonymousGitAccessAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoConfigEnableAnonymousGitAccessAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a repo.config.enable_collaborators_only event. */
export type RepoConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoConfigEnableCollaboratorsOnlyAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoConfigEnableCollaboratorsOnlyAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a repo.config.enable_contributors_only event. */
export type RepoConfigEnableContributorsOnlyAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoConfigEnableContributorsOnlyAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoConfigEnableContributorsOnlyAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a repo.config.enable_sockpuppet_disallowed event. */
export type RepoConfigEnableSockpuppetDisallowedAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoConfigEnableSockpuppetDisallowedAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoConfigEnableSockpuppetDisallowedAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a repo.config.lock_anonymous_git_access event. */
export type RepoConfigLockAnonymousGitAccessAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoConfigLockAnonymousGitAccessAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoConfigLockAnonymousGitAccessAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a repo.config.unlock_anonymous_git_access event. */
export type RepoConfigUnlockAnonymousGitAccessAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoConfigUnlockAnonymousGitAccessAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoConfigUnlockAnonymousGitAccessAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a repo.create event. */
export type RepoCreateAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoCreateAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The name of the parent repository for this forked repository. */
    forkParentName?: Maybe<Scalars["String"]["output"]>;
    /** The name of the root repository for this network. */
    forkSourceName?: Maybe<Scalars["String"]["output"]>;
    /** The Node ID of the RepoCreateAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The visibility of the repository */
    visibility?: Maybe<RepoCreateAuditEntryVisibility>;
  };

/** The privacy of a repository */
export enum RepoCreateAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** Audit log entry for a repo.destroy event. */
export type RepoDestroyAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoDestroyAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoDestroyAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The visibility of the repository */
    visibility?: Maybe<RepoDestroyAuditEntryVisibility>;
  };

/** The privacy of a repository */
export enum RepoDestroyAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** Audit log entry for a repo.remove_member event. */
export type RepoRemoveMemberAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData & {
    __typename?: "RepoRemoveMemberAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoRemoveMemberAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The visibility of the repository */
    visibility?: Maybe<RepoRemoveMemberAuditEntryVisibility>;
  };

/** The privacy of a repository */
export enum RepoRemoveMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** Audit log entry for a repo.remove_topic event. */
export type RepoRemoveTopicAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData &
  TopicAuditEntryData & {
    __typename?: "RepoRemoveTopicAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the RepoRemoveTopicAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The name of the topic added to the repository */
    topic?: Maybe<Topic>;
    /** The name of the topic added to the repository */
    topicName?: Maybe<Scalars["String"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** The reasons a piece of content can be reported or minimized. */
export enum ReportedContentClassifiers {
  /** An abusive or harassing piece of content */
  Abuse = "ABUSE",
  /** A duplicated piece of content */
  Duplicate = "DUPLICATE",
  /** An irrelevant piece of content */
  OffTopic = "OFF_TOPIC",
  /** An outdated piece of content */
  Outdated = "OUTDATED",
  /** The content has been resolved */
  Resolved = "RESOLVED",
  /** A spammy piece of content */
  Spam = "SPAM",
}

/** A repository contains the content for a project. */
export type Repository = Node &
  PackageOwner &
  ProjectOwner &
  ProjectV2Recent &
  RepositoryInfo &
  Starrable &
  Subscribable &
  UniformResourceLocatable & {
    __typename?: "Repository";
    /**
     * Whether or not a pull request head branch that is behind its base branch can
     * always be updated even if it is not required to be up to date before merging.
     */
    allowUpdateBranch: Scalars["Boolean"]["output"];
    /** Identifies the date and time when the repository was archived. */
    archivedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** A list of users that can be assigned to issues in this repository. */
    assignableUsers: UserConnection;
    /** Whether or not Auto-merge can be enabled on pull requests in this repository. */
    autoMergeAllowed: Scalars["Boolean"]["output"];
    /** A list of branch protection rules for this repository. */
    branchProtectionRules: BranchProtectionRuleConnection;
    /** Returns the code of conduct for this repository */
    codeOfConduct?: Maybe<CodeOfConduct>;
    /** Information extracted from the repository's `CODEOWNERS` file. */
    codeowners?: Maybe<RepositoryCodeowners>;
    /** A list of collaborators associated with the repository. */
    collaborators?: Maybe<RepositoryCollaboratorConnection>;
    /** A list of commit comments associated with the repository. */
    commitComments: CommitCommentConnection;
    /** Returns a list of contact links associated to the repository */
    contactLinks?: Maybe<Array<RepositoryContactLink>>;
    /** Returns the contributing guidelines for this repository. */
    contributingGuidelines?: Maybe<ContributingGuidelines>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The Ref associated with the repository's default branch. */
    defaultBranchRef?: Maybe<Ref>;
    /** Whether or not branches are automatically deleted when merged in this repository. */
    deleteBranchOnMerge: Scalars["Boolean"]["output"];
    /** A list of dependency manifests contained in the repository */
    dependencyGraphManifests?: Maybe<DependencyGraphManifestConnection>;
    /** A list of deploy keys that are on this repository. */
    deployKeys: DeployKeyConnection;
    /** Deployments associated with the repository */
    deployments: DeploymentConnection;
    /** The description of the repository. */
    description?: Maybe<Scalars["String"]["output"]>;
    /** The description of the repository rendered to HTML. */
    descriptionHTML: Scalars["HTML"]["output"];
    /** Returns a single discussion from the current repository by number. */
    discussion?: Maybe<Discussion>;
    /** A list of discussion categories that are available in the repository. */
    discussionCategories: DiscussionCategoryConnection;
    /** A discussion category by slug. */
    discussionCategory?: Maybe<DiscussionCategory>;
    /** A list of discussions that have been opened in the repository. */
    discussions: DiscussionConnection;
    /** The number of kilobytes this repository occupies on disk. */
    diskUsage?: Maybe<Scalars["Int"]["output"]>;
    /** Returns a single active environment from the current repository by name. */
    environment?: Maybe<Environment>;
    /** A list of environments that are in this repository. */
    environments: EnvironmentConnection;
    /** Returns how many forks there are of this repository in the whole network. */
    forkCount: Scalars["Int"]["output"];
    /** Whether this repository allows forks. */
    forkingAllowed: Scalars["Boolean"]["output"];
    /** A list of direct forked repositories. */
    forks: RepositoryConnection;
    /** The funding links for this repository */
    fundingLinks: Array<FundingLink>;
    /** Indicates if the repository has the Discussions feature enabled. */
    hasDiscussionsEnabled: Scalars["Boolean"]["output"];
    /** Indicates if the repository has issues feature enabled. */
    hasIssuesEnabled: Scalars["Boolean"]["output"];
    /** Indicates if the repository has the Projects feature enabled. */
    hasProjectsEnabled: Scalars["Boolean"]["output"];
    /** Indicates if the repository displays a Sponsor button for financial contributions. */
    hasSponsorshipsEnabled: Scalars["Boolean"]["output"];
    /** Whether vulnerability alerts are enabled for the repository. */
    hasVulnerabilityAlertsEnabled: Scalars["Boolean"]["output"];
    /** Indicates if the repository has wiki feature enabled. */
    hasWikiEnabled: Scalars["Boolean"]["output"];
    /** The repository's URL. */
    homepageUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The Node ID of the Repository object */
    id: Scalars["ID"]["output"];
    /** The interaction ability settings for this repository. */
    interactionAbility?: Maybe<RepositoryInteractionAbility>;
    /** Indicates if the repository is unmaintained. */
    isArchived: Scalars["Boolean"]["output"];
    /** Returns true if blank issue creation is allowed */
    isBlankIssuesEnabled: Scalars["Boolean"]["output"];
    /** Returns whether or not this repository disabled. */
    isDisabled: Scalars["Boolean"]["output"];
    /** Returns whether or not this repository is empty. */
    isEmpty: Scalars["Boolean"]["output"];
    /** Identifies if the repository is a fork. */
    isFork: Scalars["Boolean"]["output"];
    /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
    isInOrganization: Scalars["Boolean"]["output"];
    /** Indicates if the repository has been locked or not. */
    isLocked: Scalars["Boolean"]["output"];
    /** Identifies if the repository is a mirror. */
    isMirror: Scalars["Boolean"]["output"];
    /** Identifies if the repository is private or internal. */
    isPrivate: Scalars["Boolean"]["output"];
    /** Returns true if this repository has a security policy */
    isSecurityPolicyEnabled?: Maybe<Scalars["Boolean"]["output"]>;
    /** Identifies if the repository is a template that can be used to generate new repositories. */
    isTemplate: Scalars["Boolean"]["output"];
    /** Is this repository a user configuration repository? */
    isUserConfigurationRepository: Scalars["Boolean"]["output"];
    /** Returns a single issue from the current repository by number. */
    issue?: Maybe<Issue>;
    /** Returns a single issue-like object from the current repository by number. */
    issueOrPullRequest?: Maybe<IssueOrPullRequest>;
    /** Returns a list of issue templates associated to the repository */
    issueTemplates?: Maybe<Array<IssueTemplate>>;
    /** A list of issues that have been opened in the repository. */
    issues: IssueConnection;
    /** Returns a single label by name */
    label?: Maybe<Label>;
    /** A list of labels associated with the repository. */
    labels?: Maybe<LabelConnection>;
    /** A list containing a breakdown of the language composition of the repository. */
    languages?: Maybe<LanguageConnection>;
    /** Get the latest release for the repository if one exists. */
    latestRelease?: Maybe<Release>;
    /** The license associated with the repository */
    licenseInfo?: Maybe<License>;
    /** The reason the repository has been locked. */
    lockReason?: Maybe<RepositoryLockReason>;
    /** A list of Users that can be mentioned in the context of the repository. */
    mentionableUsers: UserConnection;
    /** Whether or not PRs are merged with a merge commit on this repository. */
    mergeCommitAllowed: Scalars["Boolean"]["output"];
    /** How the default commit message will be generated when merging a pull request. */
    mergeCommitMessage: MergeCommitMessage;
    /** How the default commit title will be generated when merging a pull request. */
    mergeCommitTitle: MergeCommitTitle;
    /** The merge queue for a specified branch, otherwise the default branch if not provided. */
    mergeQueue?: Maybe<MergeQueue>;
    /** Returns a single milestone from the current repository by number. */
    milestone?: Maybe<Milestone>;
    /** A list of milestones associated with the repository. */
    milestones?: Maybe<MilestoneConnection>;
    /** The repository's original mirror URL. */
    mirrorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The name of the repository. */
    name: Scalars["String"]["output"];
    /** The repository's name with owner. */
    nameWithOwner: Scalars["String"]["output"];
    /** A Git object in the repository */
    object?: Maybe<GitObject>;
    /** The image used to represent this repository in Open Graph data. */
    openGraphImageUrl: Scalars["URI"]["output"];
    /** The User owner of the repository. */
    owner: RepositoryOwner;
    /** A list of packages under the owner. */
    packages: PackageConnection;
    /** The repository parent, if this is a fork. */
    parent?: Maybe<Repository>;
    /** A list of discussions that have been pinned in this repository. */
    pinnedDiscussions: PinnedDiscussionConnection;
    /** A list of pinned environments for this repository. */
    pinnedEnvironments?: Maybe<PinnedEnvironmentConnection>;
    /** A list of pinned issues for this repository. */
    pinnedIssues?: Maybe<PinnedIssueConnection>;
    /** Returns information about the availability of certain features and limits based on the repository's billing plan. */
    planFeatures: RepositoryPlanFeatures;
    /** The primary language of the repository's code. */
    primaryLanguage?: Maybe<Language>;
    /** Find project by number. */
    project?: Maybe<Project>;
    /** Finds and returns the Project according to the provided Project number. */
    projectV2?: Maybe<ProjectV2>;
    /** A list of projects under the owner. */
    projects: ProjectConnection;
    /** The HTTP path listing the repository's projects */
    projectsResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL listing the repository's projects */
    projectsUrl: Scalars["URI"]["output"];
    /** List of projects linked to this repository. */
    projectsV2: ProjectV2Connection;
    /** Returns a single pull request from the current repository by number. */
    pullRequest?: Maybe<PullRequest>;
    /** Returns a list of pull request templates associated to the repository */
    pullRequestTemplates?: Maybe<Array<PullRequestTemplate>>;
    /** A list of pull requests that have been opened in the repository. */
    pullRequests: PullRequestConnection;
    /** Identifies the date and time when the repository was last pushed to. */
    pushedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** Whether or not rebase-merging is enabled on this repository. */
    rebaseMergeAllowed: Scalars["Boolean"]["output"];
    /** Recent projects that this user has modified in the context of the owner. */
    recentProjects: ProjectV2Connection;
    /** Fetch a given ref from the repository */
    ref?: Maybe<Ref>;
    /** Fetch a list of refs from the repository */
    refs?: Maybe<RefConnection>;
    /** Lookup a single release given various criteria. */
    release?: Maybe<Release>;
    /** List of releases which are dependent on this repository. */
    releases: ReleaseConnection;
    /** A list of applied repository-topic associations for this repository. */
    repositoryTopics: RepositoryTopicConnection;
    /** The HTTP path for this repository */
    resourcePath: Scalars["URI"]["output"];
    /** Returns a single ruleset from the current repository by ID. */
    ruleset?: Maybe<RepositoryRuleset>;
    /** A list of rulesets for this repository. */
    rulesets?: Maybe<RepositoryRulesetConnection>;
    /** The security policy URL. */
    securityPolicyUrl?: Maybe<Scalars["URI"]["output"]>;
    /** A description of the repository, rendered to HTML without any links in it. */
    shortDescriptionHTML: Scalars["HTML"]["output"];
    /** Whether or not squash-merging is enabled on this repository. */
    squashMergeAllowed: Scalars["Boolean"]["output"];
    /** How the default commit message will be generated when squash merging a pull request. */
    squashMergeCommitMessage: SquashMergeCommitMessage;
    /** How the default commit title will be generated when squash merging a pull request. */
    squashMergeCommitTitle: SquashMergeCommitTitle;
    /**
     * Whether a squash merge commit can use the pull request title as default.
     * @deprecated `squashPrTitleUsedAsDefault` will be removed. Use `Repository.squashMergeCommitTitle` instead. Removal on 2023-04-01 UTC.
     */
    squashPrTitleUsedAsDefault: Scalars["Boolean"]["output"];
    /** The SSH URL to clone this repository */
    sshUrl: Scalars["GitSSHRemote"]["output"];
    /** Returns a count of how many stargazers there are on this object */
    stargazerCount: Scalars["Int"]["output"];
    /** A list of users who have starred this starrable. */
    stargazers: StargazerConnection;
    /**
     * Returns a list of all submodules in this repository parsed from the
     * .gitmodules file as of the default branch's HEAD commit.
     */
    submodules: SubmoduleConnection;
    /** Temporary authentication token for cloning this repository. */
    tempCloneToken?: Maybe<Scalars["String"]["output"]>;
    /** The repository from which this repository was generated, if any. */
    templateRepository?: Maybe<Repository>;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this repository */
    url: Scalars["URI"]["output"];
    /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
    usesCustomOpenGraphImage: Scalars["Boolean"]["output"];
    /** Indicates whether the viewer has admin permissions on this repository. */
    viewerCanAdminister: Scalars["Boolean"]["output"];
    /** Can the current viewer create new projects on this owner. */
    viewerCanCreateProjects: Scalars["Boolean"]["output"];
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe: Scalars["Boolean"]["output"];
    /** Indicates whether the viewer can update the topics of this repository. */
    viewerCanUpdateTopics: Scalars["Boolean"]["output"];
    /** The last commit email for the viewer. */
    viewerDefaultCommitEmail?: Maybe<Scalars["String"]["output"]>;
    /** The last used merge method by the viewer or the default for the repository. */
    viewerDefaultMergeMethod: PullRequestMergeMethod;
    /** Returns a boolean indicating whether the viewing user has starred this starrable. */
    viewerHasStarred: Scalars["Boolean"]["output"];
    /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */
    viewerPermission?: Maybe<RepositoryPermission>;
    /** A list of emails this viewer can commit with. */
    viewerPossibleCommitEmails?: Maybe<Array<Scalars["String"]["output"]>>;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: Maybe<SubscriptionState>;
    /** Indicates the repository's visibility level. */
    visibility: RepositoryVisibility;
    /** Returns a single vulnerability alert from the current repository by number. */
    vulnerabilityAlert?: Maybe<RepositoryVulnerabilityAlert>;
    /** A list of vulnerability alerts that are on this repository. */
    vulnerabilityAlerts?: Maybe<RepositoryVulnerabilityAlertConnection>;
    /** A list of users watching the repository. */
    watchers: UserConnection;
    /** Whether contributors are required to sign off on web-based commits in this repository. */
    webCommitSignoffRequired: Scalars["Boolean"]["output"];
  };

/** A repository contains the content for a project. */
export type RepositoryAssignableUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryBranchProtectionRulesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryCodeownersArgs = {
  refName?: InputMaybe<Scalars["String"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryCollaboratorsArgs = {
  affiliation?: InputMaybe<CollaboratorAffiliation>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  login?: InputMaybe<Scalars["String"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryCommitCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryDependencyGraphManifestsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  dependenciesAfter?: InputMaybe<Scalars["String"]["input"]>;
  dependenciesFirst?: InputMaybe<Scalars["Int"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  withDependencies?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryDeployKeysArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryDeploymentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  environments?: InputMaybe<Array<Scalars["String"]["input"]>>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<DeploymentOrder>;
};

/** A repository contains the content for a project. */
export type RepositoryDiscussionArgs = {
  number: Scalars["Int"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryDiscussionCategoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filterByAssignable?: InputMaybe<Scalars["Boolean"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryDiscussionCategoryArgs = {
  slug: Scalars["String"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  answered?: InputMaybe<Scalars["Boolean"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  categoryId?: InputMaybe<Scalars["ID"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<DiscussionOrder>;
  states?: InputMaybe<Array<DiscussionState>>;
};

/** A repository contains the content for a project. */
export type RepositoryEnvironmentArgs = {
  name: Scalars["String"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryEnvironmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  names?: InputMaybe<Array<Scalars["String"]["input"]>>;
  orderBy?: InputMaybe<Environments>;
  pinnedEnvironmentFilter?: InputMaybe<EnvironmentPinnedFilterField>;
};

/** A repository contains the content for a project. */
export type RepositoryForksArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  hasIssuesEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  isLocked?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
  visibility?: InputMaybe<RepositoryVisibility>;
};

/** A repository contains the content for a project. */
export type RepositoryIssueArgs = {
  number: Scalars["Int"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryIssueOrPullRequestArgs = {
  number: Scalars["Int"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryIssuesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filterBy?: InputMaybe<IssueFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  labels?: InputMaybe<Array<Scalars["String"]["input"]>>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<IssueState>>;
};

/** A repository contains the content for a project. */
export type RepositoryLabelArgs = {
  name: Scalars["String"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryLabelsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<LabelOrder>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryLanguagesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<LanguageOrder>;
};

/** A repository contains the content for a project. */
export type RepositoryMentionableUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryMergeQueueArgs = {
  branch?: InputMaybe<Scalars["String"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryMilestoneArgs = {
  number: Scalars["Int"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryMilestonesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<MilestoneOrder>;
  query?: InputMaybe<Scalars["String"]["input"]>;
  states?: InputMaybe<Array<MilestoneState>>;
};

/** A repository contains the content for a project. */
export type RepositoryObjectArgs = {
  expression?: InputMaybe<Scalars["String"]["input"]>;
  oid?: InputMaybe<Scalars["GitObjectID"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryPackagesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  names?: InputMaybe<Array<InputMaybe<Scalars["String"]["input"]>>>;
  orderBy?: InputMaybe<PackageOrder>;
  packageType?: InputMaybe<PackageType>;
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryPinnedDiscussionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryPinnedEnvironmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<PinnedEnvironmentOrder>;
};

/** A repository contains the content for a project. */
export type RepositoryPinnedIssuesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryProjectArgs = {
  number: Scalars["Int"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryProjectV2Args = {
  number: Scalars["Int"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryProjectsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectOrder>;
  search?: InputMaybe<Scalars["String"]["input"]>;
  states?: InputMaybe<Array<ProjectState>>;
};

/** A repository contains the content for a project. */
export type RepositoryProjectsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  minPermissionLevel?: InputMaybe<ProjectV2PermissionLevel>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryPullRequestArgs = {
  number: Scalars["Int"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryPullRequestsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  baseRefName?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  headRefName?: InputMaybe<Scalars["String"]["input"]>;
  labels?: InputMaybe<Array<Scalars["String"]["input"]>>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<PullRequestState>>;
};

/** A repository contains the content for a project. */
export type RepositoryRecentProjectsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryRefArgs = {
  qualifiedName: Scalars["String"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryRefsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  direction?: InputMaybe<OrderDirection>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RefOrder>;
  query?: InputMaybe<Scalars["String"]["input"]>;
  refPrefix: Scalars["String"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryReleaseArgs = {
  tagName: Scalars["String"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryReleasesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReleaseOrder>;
};

/** A repository contains the content for a project. */
export type RepositoryRepositoryTopicsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryRulesetArgs = {
  databaseId: Scalars["Int"]["input"];
  includeParents?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryRulesetsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includeParents?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryShortDescriptionHtmlArgs = {
  limit?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryStargazersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<StarOrder>;
};

/** A repository contains the content for a project. */
export type RepositorySubmodulesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository contains the content for a project. */
export type RepositoryVulnerabilityAlertArgs = {
  number: Scalars["Int"]["input"];
};

/** A repository contains the content for a project. */
export type RepositoryVulnerabilityAlertsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  dependencyScopes?: InputMaybe<
    Array<RepositoryVulnerabilityAlertDependencyScope>
  >;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  states?: InputMaybe<Array<RepositoryVulnerabilityAlertState>>;
};

/** A repository contains the content for a project. */
export type RepositoryWatchersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The affiliation of a user to a repository */
export enum RepositoryAffiliation {
  /** Repositories that the user has been added to as a collaborator. */
  Collaborator = "COLLABORATOR",
  /**
   * Repositories that the user has access to through being a member of an
   * organization. This includes every repository on every team that the user is on.
   */
  OrganizationMember = "ORGANIZATION_MEMBER",
  /** Repositories that are owned by the authenticated user. */
  Owner = "OWNER",
}

/** Metadata for an audit entry with action repo.* */
export type RepositoryAuditEntryData = {
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars["String"]["output"]>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
};

/** Information extracted from a repository's `CODEOWNERS` file. */
export type RepositoryCodeowners = {
  __typename?: "RepositoryCodeowners";
  /** Any problems that were encountered while parsing the `CODEOWNERS` file. */
  errors: Array<RepositoryCodeownersError>;
};

/** An error in a `CODEOWNERS` file. */
export type RepositoryCodeownersError = {
  __typename?: "RepositoryCodeownersError";
  /** The column number where the error occurs. */
  column: Scalars["Int"]["output"];
  /** A short string describing the type of error. */
  kind: Scalars["String"]["output"];
  /** The line number where the error occurs. */
  line: Scalars["Int"]["output"];
  /** A complete description of the error, combining information from other fields. */
  message: Scalars["String"]["output"];
  /** The path to the file when the error occurs. */
  path: Scalars["String"]["output"];
  /** The content of the line where the error occurs. */
  source: Scalars["String"]["output"];
  /** A suggestion of how to fix the error. */
  suggestion?: Maybe<Scalars["String"]["output"]>;
};

/** The connection type for User. */
export type RepositoryCollaboratorConnection = {
  __typename?: "RepositoryCollaboratorConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Represents a user who is a collaborator of a repository. */
export type RepositoryCollaboratorEdge = {
  __typename?: "RepositoryCollaboratorEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  node: User;
  /** The permission the user has on the repository. */
  permission: RepositoryPermission;
  /** A list of sources for the user's access to the repository. */
  permissionSources?: Maybe<Array<PermissionSource>>;
};

/** A list of repositories owned by the subject. */
export type RepositoryConnection = {
  __typename?: "RepositoryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
  /**
   * The total size in kilobytes of all repositories in the connection. Value will
   * never be larger than max 32-bit signed integer.
   */
  totalDiskUsage: Scalars["Int"]["output"];
};

/** A repository contact link. */
export type RepositoryContactLink = {
  __typename?: "RepositoryContactLink";
  /** The contact link purpose. */
  about: Scalars["String"]["output"];
  /** The contact link name. */
  name: Scalars["String"]["output"];
  /** The contact link URL. */
  url: Scalars["URI"]["output"];
};

/** The reason a repository is listed as 'contributed'. */
export enum RepositoryContributionType {
  /** Created a commit */
  Commit = "COMMIT",
  /** Created an issue */
  Issue = "ISSUE",
  /** Created a pull request */
  PullRequest = "PULL_REQUEST",
  /** Reviewed a pull request */
  PullRequestReview = "PULL_REQUEST_REVIEW",
  /** Created the repository */
  Repository = "REPOSITORY",
}

/** Represents an author of discussions in repositories. */
export type RepositoryDiscussionAuthor = {
  /** Discussions this user has started. */
  repositoryDiscussions: DiscussionConnection;
};

/** Represents an author of discussions in repositories. */
export type RepositoryDiscussionAuthorRepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  answered?: InputMaybe<Scalars["Boolean"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
  states?: InputMaybe<Array<DiscussionState>>;
};

/** Represents an author of discussion comments in repositories. */
export type RepositoryDiscussionCommentAuthor = {
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: DiscussionCommentConnection;
};

/** Represents an author of discussion comments in repositories. */
export type RepositoryDiscussionCommentAuthorRepositoryDiscussionCommentsArgs =
  {
    after?: InputMaybe<Scalars["String"]["input"]>;
    before?: InputMaybe<Scalars["String"]["input"]>;
    first?: InputMaybe<Scalars["Int"]["input"]>;
    last?: InputMaybe<Scalars["Int"]["input"]>;
    onlyAnswers?: InputMaybe<Scalars["Boolean"]["input"]>;
    repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
  };

/** An edge in a connection. */
export type RepositoryEdge = {
  __typename?: "RepositoryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Repository>;
};

/** Parameters to be used for the repository_id condition */
export type RepositoryIdConditionTarget = {
  __typename?: "RepositoryIdConditionTarget";
  /** One of these repo IDs must match the repo. */
  repositoryIds: Array<Scalars["ID"]["output"]>;
};

/** Parameters to be used for the repository_id condition */
export type RepositoryIdConditionTargetInput = {
  /** One of these repo IDs must match the repo. */
  repositoryIds: Array<Scalars["ID"]["input"]>;
};

/** A subset of repository info. */
export type RepositoryInfo = {
  /** Identifies the date and time when the repository was archived. */
  archivedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The description of the repository. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars["HTML"]["output"];
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars["Int"]["output"];
  /** Indicates if the repository has the Discussions feature enabled. */
  hasDiscussionsEnabled: Scalars["Boolean"]["output"];
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars["Boolean"]["output"];
  /** Indicates if the repository has the Projects feature enabled. */
  hasProjectsEnabled: Scalars["Boolean"]["output"];
  /** Indicates if the repository displays a Sponsor button for financial contributions. */
  hasSponsorshipsEnabled: Scalars["Boolean"]["output"];
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars["Boolean"]["output"];
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars["URI"]["output"]>;
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars["Boolean"]["output"];
  /** Identifies if the repository is a fork. */
  isFork: Scalars["Boolean"]["output"];
  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
  isInOrganization: Scalars["Boolean"]["output"];
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars["Boolean"]["output"];
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars["Boolean"]["output"];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars["Boolean"]["output"];
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars["Boolean"]["output"];
  /** The license associated with the repository */
  licenseInfo?: Maybe<License>;
  /** The reason the repository has been locked. */
  lockReason?: Maybe<RepositoryLockReason>;
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars["URI"]["output"]>;
  /** The name of the repository. */
  name: Scalars["String"]["output"];
  /** The repository's name with owner. */
  nameWithOwner: Scalars["String"]["output"];
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars["URI"]["output"];
  /** The User owner of the repository. */
  owner: RepositoryOwner;
  /** Identifies the date and time when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The HTTP path for this repository */
  resourcePath: Scalars["URI"]["output"];
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars["HTML"]["output"];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** The HTTP URL for this repository */
  url: Scalars["URI"]["output"];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars["Boolean"]["output"];
  /** Indicates the repository's visibility level. */
  visibility: RepositoryVisibility;
};

/** A subset of repository info. */
export type RepositoryInfoShortDescriptionHtmlArgs = {
  limit?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Repository interaction limit that applies to this object. */
export type RepositoryInteractionAbility = {
  __typename?: "RepositoryInteractionAbility";
  /** The time the currently active limit expires. */
  expiresAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The current limit that is enabled on this object. */
  limit: RepositoryInteractionLimit;
  /** The origin of the currently active interaction limit. */
  origin: RepositoryInteractionLimitOrigin;
};

/** A repository interaction limit. */
export enum RepositoryInteractionLimit {
  /** Users that are not collaborators will not be able to interact with the repository. */
  CollaboratorsOnly = "COLLABORATORS_ONLY",
  /** Users that have not previously committed to a repository’s default branch will be unable to interact with the repository. */
  ContributorsOnly = "CONTRIBUTORS_ONLY",
  /** Users that have recently created their account will be unable to interact with the repository. */
  ExistingUsers = "EXISTING_USERS",
  /** No interaction limits are enabled. */
  NoLimit = "NO_LIMIT",
}

/** The length for a repository interaction limit to be enabled for. */
export enum RepositoryInteractionLimitExpiry {
  /** The interaction limit will expire after 1 day. */
  OneDay = "ONE_DAY",
  /** The interaction limit will expire after 1 month. */
  OneMonth = "ONE_MONTH",
  /** The interaction limit will expire after 1 week. */
  OneWeek = "ONE_WEEK",
  /** The interaction limit will expire after 6 months. */
  SixMonths = "SIX_MONTHS",
  /** The interaction limit will expire after 3 days. */
  ThreeDays = "THREE_DAYS",
}

/** Indicates where an interaction limit is configured. */
export enum RepositoryInteractionLimitOrigin {
  /** A limit that is configured at the organization level. */
  Organization = "ORGANIZATION",
  /** A limit that is configured at the repository level. */
  Repository = "REPOSITORY",
  /** A limit that is configured at the user-wide level. */
  User = "USER",
}

/** An invitation for a user to be added to a repository. */
export type RepositoryInvitation = Node & {
  __typename?: "RepositoryInvitation";
  /** The email address that received the invitation. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The Node ID of the RepositoryInvitation object */
  id: Scalars["ID"]["output"];
  /** The user who received the invitation. */
  invitee?: Maybe<User>;
  /** The user who created the invitation. */
  inviter: User;
  /** The permalink for this repository invitation. */
  permalink: Scalars["URI"]["output"];
  /** The permission granted on this repository by this invitation. */
  permission: RepositoryPermission;
  /** The Repository the user is invited to. */
  repository?: Maybe<RepositoryInfo>;
};

/** A list of repository invitations. */
export type RepositoryInvitationConnection = {
  __typename?: "RepositoryInvitationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type RepositoryInvitationEdge = {
  __typename?: "RepositoryInvitationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryInvitation>;
};

/** Ordering options for repository invitation connections. */
export type RepositoryInvitationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repository invitations by. */
  field: RepositoryInvitationOrderField;
};

/** Properties by which repository invitation connections can be ordered. */
export enum RepositoryInvitationOrderField {
  /** Order repository invitations by creation time */
  CreatedAt = "CREATED_AT",
}

/** The possible reasons a given repository could be in a locked state. */
export enum RepositoryLockReason {
  /** The repository is locked due to a billing related reason. */
  Billing = "BILLING",
  /** The repository is locked due to a migration. */
  Migrating = "MIGRATING",
  /** The repository is locked due to a move. */
  Moving = "MOVING",
  /** The repository is locked due to a rename. */
  Rename = "RENAME",
  /** The repository is locked due to a trade controls related reason. */
  TradeRestriction = "TRADE_RESTRICTION",
  /** The repository is locked due to an ownership transfer. */
  TransferringOwnership = "TRANSFERRING_OWNERSHIP",
}

/** A GitHub Enterprise Importer (GEI) repository migration. */
export type RepositoryMigration = Migration &
  Node & {
    __typename?: "RepositoryMigration";
    /** The migration flag to continue on error. */
    continueOnError: Scalars["Boolean"]["output"];
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["String"]["output"]>;
    /** The reason the migration failed. */
    failureReason?: Maybe<Scalars["String"]["output"]>;
    /** The Node ID of the RepositoryMigration object */
    id: Scalars["ID"]["output"];
    /** The URL for the migration log (expires 1 day after migration completes). */
    migrationLogUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The migration source. */
    migrationSource: MigrationSource;
    /** The target repository name. */
    repositoryName: Scalars["String"]["output"];
    /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
    sourceUrl: Scalars["URI"]["output"];
    /** The migration state. */
    state: MigrationState;
    /**
     * The number of warnings encountered for this migration. To review the warnings,
     * check the [Migration Log](https://docs.github.com/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).
     */
    warningsCount: Scalars["Int"]["output"];
  };

/** A list of migrations. */
export type RepositoryMigrationConnection = {
  __typename?: "RepositoryMigrationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryMigrationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryMigration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Represents a repository migration. */
export type RepositoryMigrationEdge = {
  __typename?: "RepositoryMigrationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryMigration>;
};

/** Ordering options for repository migrations. */
export type RepositoryMigrationOrder = {
  /** The ordering direction. */
  direction: RepositoryMigrationOrderDirection;
  /** The field to order repository migrations by. */
  field: RepositoryMigrationOrderField;
};

/** Possible directions in which to order a list of repository migrations when provided an `orderBy` argument. */
export enum RepositoryMigrationOrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = "ASC",
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = "DESC",
}

/** Properties by which repository migrations can be ordered. */
export enum RepositoryMigrationOrderField {
  /** Order mannequins why when they were created. */
  CreatedAt = "CREATED_AT",
}

/** Parameters to be used for the repository_name condition */
export type RepositoryNameConditionTarget = {
  __typename?: "RepositoryNameConditionTarget";
  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars["String"]["output"]>;
  /**
   * Array of repository names or patterns to include. One of these patterns must
   * match for the condition to pass. Also accepts `~ALL` to include all repositories.
   */
  include: Array<Scalars["String"]["output"]>;
  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */
  protected: Scalars["Boolean"]["output"];
};

/** Parameters to be used for the repository_name condition */
export type RepositoryNameConditionTargetInput = {
  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars["String"]["input"]>;
  /**
   * Array of repository names or patterns to include. One of these patterns must
   * match for the condition to pass. Also accepts `~ALL` to include all repositories.
   */
  include: Array<Scalars["String"]["input"]>;
  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */
  protected?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Represents a object that belongs to a repository. */
export type RepositoryNode = {
  /** The repository associated with this node. */
  repository: Repository;
};

/** Ordering options for repository connections */
export type RepositoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: RepositoryOrderField;
};

/** Properties by which repository connections can be ordered. */
export enum RepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = "CREATED_AT",
  /** Order repositories by name */
  Name = "NAME",
  /** Order repositories by push time */
  PushedAt = "PUSHED_AT",
  /** Order repositories by number of stargazers */
  Stargazers = "STARGAZERS",
  /** Order repositories by update time */
  UpdatedAt = "UPDATED_AT",
}

/** Represents an owner of a Repository. */
export type RepositoryOwner = {
  /** A URL pointing to the owner's public avatar. */
  avatarUrl: Scalars["URI"]["output"];
  /** The Node ID of the RepositoryOwner object */
  id: Scalars["ID"]["output"];
  /** The username used to login. */
  login: Scalars["String"]["output"];
  /** A list of repositories that the user owns. */
  repositories: RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<Repository>;
  /** The HTTP URL for the owner. */
  resourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for the owner. */
  url: Scalars["URI"]["output"];
};

/** Represents an owner of a Repository. */
export type RepositoryOwnerAvatarUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents an owner of a Repository. */
export type RepositoryOwnerRepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  hasIssuesEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  isArchived?: InputMaybe<Scalars["Boolean"]["input"]>;
  isFork?: InputMaybe<Scalars["Boolean"]["input"]>;
  isLocked?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
  visibility?: InputMaybe<RepositoryVisibility>;
};

/** Represents an owner of a Repository. */
export type RepositoryOwnerRepositoryArgs = {
  followRenames?: InputMaybe<Scalars["Boolean"]["input"]>;
  name: Scalars["String"]["input"];
};

/** The access level to a repository */
export enum RepositoryPermission {
  /**
   * Can read, clone, and push to this repository. Can also manage issues, pull
   * requests, and repository settings, including adding collaborators
   */
  Admin = "ADMIN",
  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */
  Maintain = "MAINTAIN",
  /** Can read and clone this repository. Can also open and comment on issues and pull requests */
  Read = "READ",
  /** Can read and clone this repository. Can also manage issues and pull requests */
  Triage = "TRIAGE",
  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */
  Write = "WRITE",
}

/** Information about the availability of features and limits for a repository based on its billing plan. */
export type RepositoryPlanFeatures = {
  __typename?: "RepositoryPlanFeatures";
  /** Whether reviews can be automatically requested and enforced with a CODEOWNERS file */
  codeowners: Scalars["Boolean"]["output"];
  /** Whether pull requests can be created as or converted to draft */
  draftPullRequests: Scalars["Boolean"]["output"];
  /** Maximum number of users that can be assigned to an issue or pull request */
  maximumAssignees: Scalars["Int"]["output"];
  /** Maximum number of manually-requested reviews on a pull request */
  maximumManualReviewRequests: Scalars["Int"]["output"];
  /** Whether teams can be requested to review pull requests */
  teamReviewRequests: Scalars["Boolean"]["output"];
};

/** The privacy of a repository */
export enum RepositoryPrivacy {
  /** Private */
  Private = "PRIVATE",
  /** Public */
  Public = "PUBLIC",
}

/** Parameters to be used for the repository_property condition */
export type RepositoryPropertyConditionTarget = {
  __typename?: "RepositoryPropertyConditionTarget";
  /** Array of repository properties that must not match. */
  exclude: Array<PropertyTargetDefinition>;
  /** Array of repository properties that must match */
  include: Array<PropertyTargetDefinition>;
};

/** Parameters to be used for the repository_property condition */
export type RepositoryPropertyConditionTargetInput = {
  /** Array of repository properties that must not match. */
  exclude: Array<PropertyTargetDefinitionInput>;
  /** Array of repository properties that must match */
  include: Array<PropertyTargetDefinitionInput>;
};

/** A repository rule. */
export type RepositoryRule = Node & {
  __typename?: "RepositoryRule";
  /** The Node ID of the RepositoryRule object */
  id: Scalars["ID"]["output"];
  /** The parameters for this rule. */
  parameters?: Maybe<RuleParameters>;
  /** The repository ruleset associated with this rule configuration */
  repositoryRuleset?: Maybe<RepositoryRuleset>;
  /** The type of rule. */
  type: RepositoryRuleType;
};

/** Set of conditions that determine if a ruleset will evaluate */
export type RepositoryRuleConditions = {
  __typename?: "RepositoryRuleConditions";
  /** Configuration for the ref_name condition */
  refName?: Maybe<RefNameConditionTarget>;
  /** Configuration for the repository_id condition */
  repositoryId?: Maybe<RepositoryIdConditionTarget>;
  /** Configuration for the repository_name condition */
  repositoryName?: Maybe<RepositoryNameConditionTarget>;
  /** Configuration for the repository_property condition */
  repositoryProperty?: Maybe<RepositoryPropertyConditionTarget>;
};

/** Specifies the conditions required for a ruleset to evaluate */
export type RepositoryRuleConditionsInput = {
  /** Configuration for the ref_name condition */
  refName?: InputMaybe<RefNameConditionTargetInput>;
  /** Configuration for the repository_id condition */
  repositoryId?: InputMaybe<RepositoryIdConditionTargetInput>;
  /** Configuration for the repository_name condition */
  repositoryName?: InputMaybe<RepositoryNameConditionTargetInput>;
  /** Configuration for the repository_property condition */
  repositoryProperty?: InputMaybe<RepositoryPropertyConditionTargetInput>;
};

/** The connection type for RepositoryRule. */
export type RepositoryRuleConnection = {
  __typename?: "RepositoryRuleConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type RepositoryRuleEdge = {
  __typename?: "RepositoryRuleEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryRule>;
};

/** Specifies the attributes for a new or updated rule. */
export type RepositoryRuleInput = {
  /** Optional ID of this rule when updating */
  id?: InputMaybe<Scalars["ID"]["input"]>;
  /** The parameters for the rule. */
  parameters?: InputMaybe<RuleParametersInput>;
  /** The type of rule to create. */
  type: RepositoryRuleType;
};

/** Ordering options for repository rules. */
export type RepositoryRuleOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repository rules by. */
  field: RepositoryRuleOrderField;
};

/** Properties by which repository rule connections can be ordered. */
export enum RepositoryRuleOrderField {
  /** Order repository rules by created time */
  CreatedAt = "CREATED_AT",
  /** Order repository rules by type */
  Type = "TYPE",
  /** Order repository rules by updated time */
  UpdatedAt = "UPDATED_AT",
}

/** The rule types supported in rulesets */
export enum RepositoryRuleType {
  /** Authorization */
  Authorization = "AUTHORIZATION",
  /** Branch name pattern */
  BranchNamePattern = "BRANCH_NAME_PATTERN",
  /**
   * Choose which tools must provide code scanning results before the reference is
   * updated. When configured, code scanning must be enabled and have results for
   * both the commit and the reference being updated.
   */
  CodeScanning = "CODE_SCANNING",
  /** Committer email pattern */
  CommitterEmailPattern = "COMMITTER_EMAIL_PATTERN",
  /** Commit author email pattern */
  CommitAuthorEmailPattern = "COMMIT_AUTHOR_EMAIL_PATTERN",
  /** Commit message pattern */
  CommitMessagePattern = "COMMIT_MESSAGE_PATTERN",
  /** Only allow users with bypass permission to create matching refs. */
  Creation = "CREATION",
  /** Only allow users with bypass permissions to delete matching refs. */
  Deletion = "DELETION",
  /**
   * Prevent commits that include files with specified file extensions from being
   * pushed to the commit graph. NOTE: This rule is in beta and subject to change
   */
  FileExtensionRestriction = "FILE_EXTENSION_RESTRICTION",
  /**
   * Prevent commits that include changes in specified file paths from being pushed
   * to the commit graph. NOTE: This rule is in beta and subject to change
   */
  FilePathRestriction = "FILE_PATH_RESTRICTION",
  /** Branch is read-only. Users cannot push to the branch. */
  LockBranch = "LOCK_BRANCH",
  /**
   * Prevent commits that include file paths that exceed a specified character
   * limit from being pushed to the commit graph. NOTE: This rule is in beta and
   * subject to change
   */
  MaxFilePathLength = "MAX_FILE_PATH_LENGTH",
  /**
   * Prevent commits that exceed a specified file size limit from being pushed to
   * the commit. NOTE: This rule is in beta and subject to change
   */
  MaxFileSize = "MAX_FILE_SIZE",
  /** Max ref updates */
  MaxRefUpdates = "MAX_REF_UPDATES",
  /** Merges must be performed via a merge queue. */
  MergeQueue = "MERGE_QUEUE",
  /** Merge queue locked ref */
  MergeQueueLockedRef = "MERGE_QUEUE_LOCKED_REF",
  /** Prevent users with push access from force pushing to refs. */
  NonFastForward = "NON_FAST_FORWARD",
  /** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
  PullRequest = "PULL_REQUEST",
  /** Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule. */
  RequiredDeployments = "REQUIRED_DEPLOYMENTS",
  /** Prevent merge commits from being pushed to matching refs. */
  RequiredLinearHistory = "REQUIRED_LINEAR_HISTORY",
  /**
   * When enabled, all conversations on code must be resolved before a pull request
   * can be merged into a branch that matches this rule.
   */
  RequiredReviewThreadResolution = "REQUIRED_REVIEW_THREAD_RESOLUTION",
  /** Commits pushed to matching refs must have verified signatures. */
  RequiredSignatures = "REQUIRED_SIGNATURES",
  /**
   * Choose which status checks must pass before the ref is updated. When enabled,
   * commits must first be pushed to another ref where the checks pass.
   */
  RequiredStatusChecks = "REQUIRED_STATUS_CHECKS",
  /**
   * Require all commits be made to a non-target branch and submitted via a pull
   * request and required workflow checks to pass before they can be merged.
   */
  RequiredWorkflowStatusChecks = "REQUIRED_WORKFLOW_STATUS_CHECKS",
  /** Secret scanning */
  SecretScanning = "SECRET_SCANNING",
  /** Tag */
  Tag = "TAG",
  /** Tag name pattern */
  TagNamePattern = "TAG_NAME_PATTERN",
  /** Only allow users with bypass permission to update matching refs. */
  Update = "UPDATE",
  /** Require all changes made to a targeted branch to pass the specified workflows before they can be merged. */
  Workflows = "WORKFLOWS",
  /** Workflow files cannot be modified. */
  WorkflowUpdates = "WORKFLOW_UPDATES",
}

/** A repository ruleset. */
export type RepositoryRuleset = Node & {
  __typename?: "RepositoryRuleset";
  /** The actors that can bypass this ruleset */
  bypassActors?: Maybe<RepositoryRulesetBypassActorConnection>;
  /** The set of conditions that must evaluate to true for this ruleset to apply */
  conditions: RepositoryRuleConditions;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The enforcement level of this ruleset */
  enforcement: RuleEnforcement;
  /** The Node ID of the RepositoryRuleset object */
  id: Scalars["ID"]["output"];
  /** Name of the ruleset. */
  name: Scalars["String"]["output"];
  /** List of rules. */
  rules?: Maybe<RepositoryRuleConnection>;
  /** Source of ruleset. */
  source: RuleSource;
  /** Target of the ruleset. */
  target?: Maybe<RepositoryRulesetTarget>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** A repository ruleset. */
export type RepositoryRulesetBypassActorsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A repository ruleset. */
export type RepositoryRulesetRulesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  type?: InputMaybe<RepositoryRuleType>;
};

/** A team or app that has the ability to bypass a rules defined on a ruleset */
export type RepositoryRulesetBypassActor = Node & {
  __typename?: "RepositoryRulesetBypassActor";
  /** The actor that can bypass rules. */
  actor?: Maybe<BypassActor>;
  /** The mode for the bypass actor */
  bypassMode?: Maybe<RepositoryRulesetBypassActorBypassMode>;
  /** This actor represents the ability for a deploy key to bypass */
  deployKey: Scalars["Boolean"]["output"];
  /** The Node ID of the RepositoryRulesetBypassActor object */
  id: Scalars["ID"]["output"];
  /** This actor represents the ability for an organization owner to bypass */
  organizationAdmin: Scalars["Boolean"]["output"];
  /** If the actor is a repository role, the repository role's ID that can bypass */
  repositoryRoleDatabaseId?: Maybe<Scalars["Int"]["output"]>;
  /** If the actor is a repository role, the repository role's name that can bypass */
  repositoryRoleName?: Maybe<Scalars["String"]["output"]>;
  /** Identifies the ruleset associated with the allowed actor */
  repositoryRuleset?: Maybe<RepositoryRuleset>;
};

/** The bypass mode for a specific actor on a ruleset. */
export enum RepositoryRulesetBypassActorBypassMode {
  /** The actor can always bypass rules */
  Always = "ALWAYS",
  /** The actor can only bypass rules via a pull request */
  PullRequest = "PULL_REQUEST",
}

/** The connection type for RepositoryRulesetBypassActor. */
export type RepositoryRulesetBypassActorConnection = {
  __typename?: "RepositoryRulesetBypassActorConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryRulesetBypassActorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryRulesetBypassActor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type RepositoryRulesetBypassActorEdge = {
  __typename?: "RepositoryRulesetBypassActorEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryRulesetBypassActor>;
};

/**
 * Specifies the attributes for a new or updated ruleset bypass actor. Only one of
 * `actor_id`, `repository_role_database_id`, `organization_admin`, or `deploy_key`
 * should be specified.
 */
export type RepositoryRulesetBypassActorInput = {
  /** For Team and Integration bypasses, the Team or Integration ID */
  actorId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The bypass mode for this actor. */
  bypassMode: RepositoryRulesetBypassActorBypassMode;
  /** For deploy key bypasses, true. Can only use ALWAYS as the bypass mode */
  deployKey?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** For organization owner bypasses, true */
  organizationAdmin?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** For role bypasses, the role database ID */
  repositoryRoleDatabaseId?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for RepositoryRuleset. */
export type RepositoryRulesetConnection = {
  __typename?: "RepositoryRulesetConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryRulesetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryRuleset>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type RepositoryRulesetEdge = {
  __typename?: "RepositoryRulesetEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryRuleset>;
};

/** The targets supported for rulesets. NOTE: The push target is in beta and subject to change. */
export enum RepositoryRulesetTarget {
  /** Branch */
  Branch = "BRANCH",
  /** Push */
  Push = "PUSH",
  /** Tag */
  Tag = "TAG",
}

/** A repository-topic connects a repository to a topic. */
export type RepositoryTopic = Node &
  UniformResourceLocatable & {
    __typename?: "RepositoryTopic";
    /** The Node ID of the RepositoryTopic object */
    id: Scalars["ID"]["output"];
    /** The HTTP path for this repository-topic. */
    resourcePath: Scalars["URI"]["output"];
    /** The topic. */
    topic: Topic;
    /** The HTTP URL for this repository-topic. */
    url: Scalars["URI"]["output"];
  };

/** The connection type for RepositoryTopic. */
export type RepositoryTopicConnection = {
  __typename?: "RepositoryTopicConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryTopicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryTopic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type RepositoryTopicEdge = {
  __typename?: "RepositoryTopicEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryTopic>;
};

/** The repository's visibility level. */
export enum RepositoryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = "INTERNAL",
  /** The repository is visible only to those with explicit access. */
  Private = "PRIVATE",
  /** The repository is visible to everyone. */
  Public = "PUBLIC",
}

/** Audit log entry for a repository_visibility_change.disable event. */
export type RepositoryVisibilityChangeDisableAuditEntry = AuditEntry &
  EnterpriseAuditEntryData &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "RepositoryVisibilityChangeDisableAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The HTTP path for this enterprise. */
    enterpriseResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The slug of the enterprise. */
    enterpriseSlug?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP URL for this enterprise. */
    enterpriseUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The Node ID of the RepositoryVisibilityChangeDisableAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a repository_visibility_change.enable event. */
export type RepositoryVisibilityChangeEnableAuditEntry = AuditEntry &
  EnterpriseAuditEntryData &
  Node &
  OrganizationAuditEntryData & {
    __typename?: "RepositoryVisibilityChangeEnableAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The HTTP path for this enterprise. */
    enterpriseResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The slug of the enterprise. */
    enterpriseSlug?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP URL for this enterprise. */
    enterpriseUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The Node ID of the RepositoryVisibilityChangeEnableAuditEntry object */
    id: Scalars["ID"]["output"];
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** A Dependabot alert for a repository with a dependency affected by a security vulnerability. */
export type RepositoryVulnerabilityAlert = Node &
  RepositoryNode & {
    __typename?: "RepositoryVulnerabilityAlert";
    /** When was the alert auto-dismissed? */
    autoDismissedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** When was the alert created? */
    createdAt: Scalars["DateTime"]["output"];
    /** The associated Dependabot update */
    dependabotUpdate?: Maybe<DependabotUpdate>;
    /** The scope of an alert's dependency */
    dependencyScope?: Maybe<RepositoryVulnerabilityAlertDependencyScope>;
    /** Comment explaining the reason the alert was dismissed */
    dismissComment?: Maybe<Scalars["String"]["output"]>;
    /** The reason the alert was dismissed */
    dismissReason?: Maybe<Scalars["String"]["output"]>;
    /** When was the alert dismissed? */
    dismissedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The user who dismissed the alert */
    dismisser?: Maybe<User>;
    /** When was the alert fixed? */
    fixedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** The Node ID of the RepositoryVulnerabilityAlert object */
    id: Scalars["ID"]["output"];
    /** Identifies the alert number. */
    number: Scalars["Int"]["output"];
    /** The associated repository */
    repository: Repository;
    /** The associated security advisory */
    securityAdvisory?: Maybe<SecurityAdvisory>;
    /** The associated security vulnerability */
    securityVulnerability?: Maybe<SecurityVulnerability>;
    /** Identifies the state of the alert. */
    state: RepositoryVulnerabilityAlertState;
    /** The vulnerable manifest filename */
    vulnerableManifestFilename: Scalars["String"]["output"];
    /** The vulnerable manifest path */
    vulnerableManifestPath: Scalars["String"]["output"];
    /** The vulnerable requirements */
    vulnerableRequirements?: Maybe<Scalars["String"]["output"]>;
  };

/** The connection type for RepositoryVulnerabilityAlert. */
export type RepositoryVulnerabilityAlertConnection = {
  __typename?: "RepositoryVulnerabilityAlertConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryVulnerabilityAlertEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryVulnerabilityAlert>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** The possible scopes of an alert's dependency. */
export enum RepositoryVulnerabilityAlertDependencyScope {
  /** A dependency that is only used in development */
  Development = "DEVELOPMENT",
  /** A dependency that is leveraged during application runtime */
  Runtime = "RUNTIME",
}

/** An edge in a connection. */
export type RepositoryVulnerabilityAlertEdge = {
  __typename?: "RepositoryVulnerabilityAlertEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryVulnerabilityAlert>;
};

/** The possible states of an alert */
export enum RepositoryVulnerabilityAlertState {
  /** An alert that has been automatically closed by Dependabot. */
  AutoDismissed = "AUTO_DISMISSED",
  /** An alert that has been manually closed by a user. */
  Dismissed = "DISMISSED",
  /** An alert that has been resolved by a code change. */
  Fixed = "FIXED",
  /** An alert that is still open. */
  Open = "OPEN",
}

/** Autogenerated input type of RequestReviews */
export type RequestReviewsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars["ID"]["input"];
  /** The Node IDs of the team to request. */
  teamIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** Add users to the set rather than replace. */
  union?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The Node IDs of the user to request. */
  userIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

/** Autogenerated return type of RequestReviews. */
export type RequestReviewsPayload = {
  __typename?: "RequestReviewsPayload";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The pull request that is getting requests. */
  pullRequest?: Maybe<PullRequest>;
  /** The edge from the pull request to the requested reviewers. */
  requestedReviewersEdge?: Maybe<UserEdge>;
};

/** The possible states that can be requested when creating a check run. */
export enum RequestableCheckStatusState {
  /** The check suite or run has been completed. */
  Completed = "COMPLETED",
  /** The check suite or run is in progress. */
  InProgress = "IN_PROGRESS",
  /** The check suite or run is in pending state. */
  Pending = "PENDING",
  /** The check suite or run has been queued. */
  Queued = "QUEUED",
  /** The check suite or run is in waiting state. */
  Waiting = "WAITING",
}

/** Types that can be requested reviewers. */
export type RequestedReviewer = Bot | Mannequin | Team | User;

/** The connection type for RequestedReviewer. */
export type RequestedReviewerConnection = {
  __typename?: "RequestedReviewerConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RequestedReviewerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RequestedReviewer>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type RequestedReviewerEdge = {
  __typename?: "RequestedReviewerEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<RequestedReviewer>;
};

/** Represents a type that can be required by a pull request for merging. */
export type RequirableByPullRequest = {
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars["Boolean"]["output"];
};

/** Represents a type that can be required by a pull request for merging. */
export type RequirableByPullRequestIsRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars["ID"]["input"]>;
  pullRequestNumber?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule. */
export type RequiredDeploymentsParameters = {
  __typename?: "RequiredDeploymentsParameters";
  /** The environments that must be successfully deployed to before branches can be merged. */
  requiredDeploymentEnvironments: Array<Scalars["String"]["output"]>;
};

/** Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule. */
export type RequiredDeploymentsParametersInput = {
  /** The environments that must be successfully deployed to before branches can be merged. */
  requiredDeploymentEnvironments: Array<Scalars["String"]["input"]>;
};

/** Represents a required status check for a protected branch, but not any specific run of that check. */
export type RequiredStatusCheckDescription = {
  __typename?: "RequiredStatusCheckDescription";
  /** The App that must provide this status in order for it to be accepted. */
  app?: Maybe<App>;
  /** The name of this status. */
  context: Scalars["String"]["output"];
};

/** Specifies the attributes for a new or updated required status check. */
export type RequiredStatusCheckInput = {
  /**
   * The ID of the App that must set the status in order for it to be accepted.
   * Omit this value to use whichever app has recently been setting this status, or
   * use "any" to allow any app to set the status.
   */
  appId?: InputMaybe<Scalars["ID"]["input"]>;
  /** Status check context that must pass for commits to be accepted to the matching branch. */
  context: Scalars["String"]["input"];
};

/**
 * Choose which status checks must pass before the ref is updated. When enabled,
 * commits must first be pushed to another ref where the checks pass.
 */
export type RequiredStatusChecksParameters = {
  __typename?: "RequiredStatusChecksParameters";
  /** Allow repositories and branches to be created if a check would otherwise prohibit it. */
  doNotEnforceOnCreate: Scalars["Boolean"]["output"];
  /** Status checks that are required. */
  requiredStatusChecks: Array<StatusCheckConfiguration>;
  /**
   * Whether pull requests targeting a matching branch must be tested with the
   * latest code. This setting will not take effect unless at least one status
   * check is enabled.
   */
  strictRequiredStatusChecksPolicy: Scalars["Boolean"]["output"];
};

/**
 * Choose which status checks must pass before the ref is updated. When enabled,
 * commits must first be pushed to another ref where the checks pass.
 */
export type RequiredStatusChecksParametersInput = {
  /** Allow repositories and branches to be created if a check would otherwise prohibit it. */
  doNotEnforceOnCreate?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Status checks that are required. */
  requiredStatusChecks: Array<StatusCheckConfigurationInput>;
  /**
   * Whether pull requests targeting a matching branch must be tested with the
   * latest code. This setting will not take effect unless at least one status
   * check is enabled.
   */
  strictRequiredStatusChecksPolicy: Scalars["Boolean"]["input"];
};

/** Autogenerated input type of RerequestCheckSuite */
export type RerequestCheckSuiteInput = {
  /** The Node ID of the check suite. */
  checkSuiteId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the repository. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RerequestCheckSuite. */
export type RerequestCheckSuitePayload = {
  __typename?: "RerequestCheckSuitePayload";
  /** The requested check suite. */
  checkSuite?: Maybe<CheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of ResolveReviewThread */
export type ResolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the thread to resolve */
  threadId: Scalars["ID"]["input"];
};

/** Autogenerated return type of ResolveReviewThread. */
export type ResolveReviewThreadPayload = {
  __typename?: "ResolveReviewThreadPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The thread to resolve. */
  thread?: Maybe<PullRequestReviewThread>;
};

/** Represents a private contribution a user made on GitHub. */
export type RestrictedContribution = Contribution & {
  __typename?: "RestrictedContribution";
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars["Boolean"]["output"];
  /** When this contribution was made. */
  occurredAt: Scalars["DateTime"]["output"];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for this contribution. */
  url: Scalars["URI"]["output"];
  /** The user who made this contribution. */
  user: User;
};

/** Autogenerated input type of RetireSponsorsTier */
export type RetireSponsorsTierInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the published tier to retire. */
  tierId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RetireSponsorsTier. */
export type RetireSponsorsTierPayload = {
  __typename?: "RetireSponsorsTierPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The tier that was retired. */
  sponsorsTier?: Maybe<SponsorsTier>;
};

/** Autogenerated input type of RevertPullRequest */
export type RevertPullRequestInput = {
  /** The description of the revert pull request. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Indicates whether the revert pull request should be a draft. */
  draft?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the pull request to revert. */
  pullRequestId: Scalars["ID"]["input"];
  /** The title of the revert pull request. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of RevertPullRequest. */
export type RevertPullRequestPayload = {
  __typename?: "RevertPullRequestPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The pull request that was reverted. */
  pullRequest?: Maybe<PullRequest>;
  /** The new pull request that reverts the input pull request. */
  revertPullRequest?: Maybe<PullRequest>;
};

/** A user, team, or app who has the ability to dismiss a review on a protected branch. */
export type ReviewDismissalAllowance = Node & {
  __typename?: "ReviewDismissalAllowance";
  /** The actor that can dismiss. */
  actor?: Maybe<ReviewDismissalAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** The Node ID of the ReviewDismissalAllowance object */
  id: Scalars["ID"]["output"];
};

/** Types that can be an actor. */
export type ReviewDismissalAllowanceActor = App | Team | User;

/** The connection type for ReviewDismissalAllowance. */
export type ReviewDismissalAllowanceConnection = {
  __typename?: "ReviewDismissalAllowanceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReviewDismissalAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReviewDismissalAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ReviewDismissalAllowanceEdge = {
  __typename?: "ReviewDismissalAllowanceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ReviewDismissalAllowance>;
};

/** Represents a 'review_dismissed' event on a given issue or pull request. */
export type ReviewDismissedEvent = Node &
  UniformResourceLocatable & {
    __typename?: "ReviewDismissedEvent";
    /** Identifies the actor who performed the event. */
    actor?: Maybe<Actor>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** Identifies the optional message associated with the 'review_dismissed' event. */
    dismissalMessage?: Maybe<Scalars["String"]["output"]>;
    /** Identifies the optional message associated with the event, rendered to HTML. */
    dismissalMessageHTML?: Maybe<Scalars["String"]["output"]>;
    /** The Node ID of the ReviewDismissedEvent object */
    id: Scalars["ID"]["output"];
    /** Identifies the previous state of the review with the 'review_dismissed' event. */
    previousReviewState: PullRequestReviewState;
    /** PullRequest referenced by event. */
    pullRequest: PullRequest;
    /** Identifies the commit which caused the review to become stale. */
    pullRequestCommit?: Maybe<PullRequestCommit>;
    /** The HTTP path for this review dismissed event. */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the review associated with the 'review_dismissed' event. */
    review?: Maybe<PullRequestReview>;
    /** The HTTP URL for this review dismissed event. */
    url: Scalars["URI"]["output"];
  };

/** A request for a user to review a pull request. */
export type ReviewRequest = Node & {
  __typename?: "ReviewRequest";
  /** Whether this request was created for a code owner */
  asCodeOwner: Scalars["Boolean"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the ReviewRequest object */
  id: Scalars["ID"]["output"];
  /** Identifies the pull request associated with this review request. */
  pullRequest: PullRequest;
  /** The reviewer that is requested. */
  requestedReviewer?: Maybe<RequestedReviewer>;
};

/** The connection type for ReviewRequest. */
export type ReviewRequestConnection = {
  __typename?: "ReviewRequestConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReviewRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReviewRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ReviewRequestEdge = {
  __typename?: "ReviewRequestEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ReviewRequest>;
};

/** Represents an 'review_request_removed' event on a given pull request. */
export type ReviewRequestRemovedEvent = Node & {
  __typename?: "ReviewRequestRemovedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the ReviewRequestRemovedEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the reviewer whose review request was removed. */
  requestedReviewer?: Maybe<RequestedReviewer>;
};

/** Represents an 'review_requested' event on a given pull request. */
export type ReviewRequestedEvent = Node & {
  __typename?: "ReviewRequestedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the ReviewRequestedEvent object */
  id: Scalars["ID"]["output"];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the reviewer whose review was requested. */
  requestedReviewer?: Maybe<RequestedReviewer>;
};

/**
 * A hovercard context with a message describing the current code review state of the pull
 * request.
 */
export type ReviewStatusHovercardContext = HovercardContext & {
  __typename?: "ReviewStatusHovercardContext";
  /** A string describing this context */
  message: Scalars["String"]["output"];
  /** An octicon to accompany this context */
  octicon: Scalars["String"]["output"];
  /** The current status of the pull request with respect to code review. */
  reviewDecision?: Maybe<PullRequestReviewDecision>;
};

/** Autogenerated input type of RevokeEnterpriseOrganizationsMigratorRole */
export type RevokeEnterpriseOrganizationsMigratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */
  enterpriseId: Scalars["ID"]["input"];
  /** The login of the user to revoke the migrator role */
  login: Scalars["String"]["input"];
};

/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole. */
export type RevokeEnterpriseOrganizationsMigratorRolePayload = {
  __typename?: "RevokeEnterpriseOrganizationsMigratorRolePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The organizations that had the migrator role revoked for the given user. */
  organizations?: Maybe<OrganizationConnection>;
};

/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole. */
export type RevokeEnterpriseOrganizationsMigratorRolePayloadOrganizationsArgs =
  {
    after?: InputMaybe<Scalars["String"]["input"]>;
    before?: InputMaybe<Scalars["String"]["input"]>;
    first?: InputMaybe<Scalars["Int"]["input"]>;
    last?: InputMaybe<Scalars["Int"]["input"]>;
  };

/** Autogenerated input type of RevokeMigratorRole */
export type RevokeMigratorRoleInput = {
  /** The user login or Team slug to revoke the migrator role from. */
  actor: Scalars["String"]["input"];
  /** Specifies the type of the actor, can be either USER or TEAM. */
  actorType: ActorType;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the organization that the user/team belongs to. */
  organizationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RevokeMigratorRole. */
export type RevokeMigratorRolePayload = {
  __typename?: "RevokeMigratorRolePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars["Boolean"]["output"]>;
};

/** Possible roles a user may have in relation to an organization. */
export enum RoleInOrganization {
  /** A user who is a direct member of the organization. */
  DirectMember = "DIRECT_MEMBER",
  /** A user with full administrative access to the organization. */
  Owner = "OWNER",
  /** A user who is unaffiliated with the organization. */
  Unaffiliated = "UNAFFILIATED",
}

/** The level of enforcement for a rule or ruleset. */
export enum RuleEnforcement {
  /** Rules will be enforced */
  Active = "ACTIVE",
  /** Do not evaluate or enforce rules */
  Disabled = "DISABLED",
  /**
   * Allow admins to test rules before enforcing them. Admins can view insights on
   * the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
   */
  Evaluate = "EVALUATE",
}

/** Types which can be parameters for `RepositoryRule` objects. */
export type RuleParameters =
  | BranchNamePatternParameters
  | CodeScanningParameters
  | CommitAuthorEmailPatternParameters
  | CommitMessagePatternParameters
  | CommitterEmailPatternParameters
  | FileExtensionRestrictionParameters
  | FilePathRestrictionParameters
  | MaxFilePathLengthParameters
  | MaxFileSizeParameters
  | MergeQueueParameters
  | PullRequestParameters
  | RequiredDeploymentsParameters
  | RequiredStatusChecksParameters
  | TagNamePatternParameters
  | UpdateParameters
  | WorkflowsParameters;

/** Specifies the parameters for a `RepositoryRule` object. Only one of the fields should be specified. */
export type RuleParametersInput = {
  /** Parameters used for the `branch_name_pattern` rule type */
  branchNamePattern?: InputMaybe<BranchNamePatternParametersInput>;
  /** Parameters used for the `code_scanning` rule type */
  codeScanning?: InputMaybe<CodeScanningParametersInput>;
  /** Parameters used for the `commit_author_email_pattern` rule type */
  commitAuthorEmailPattern?: InputMaybe<CommitAuthorEmailPatternParametersInput>;
  /** Parameters used for the `commit_message_pattern` rule type */
  commitMessagePattern?: InputMaybe<CommitMessagePatternParametersInput>;
  /** Parameters used for the `committer_email_pattern` rule type */
  committerEmailPattern?: InputMaybe<CommitterEmailPatternParametersInput>;
  /** Parameters used for the `file_extension_restriction` rule type */
  fileExtensionRestriction?: InputMaybe<FileExtensionRestrictionParametersInput>;
  /** Parameters used for the `file_path_restriction` rule type */
  filePathRestriction?: InputMaybe<FilePathRestrictionParametersInput>;
  /** Parameters used for the `max_file_path_length` rule type */
  maxFilePathLength?: InputMaybe<MaxFilePathLengthParametersInput>;
  /** Parameters used for the `max_file_size` rule type */
  maxFileSize?: InputMaybe<MaxFileSizeParametersInput>;
  /** Parameters used for the `merge_queue` rule type */
  mergeQueue?: InputMaybe<MergeQueueParametersInput>;
  /** Parameters used for the `pull_request` rule type */
  pullRequest?: InputMaybe<PullRequestParametersInput>;
  /** Parameters used for the `required_deployments` rule type */
  requiredDeployments?: InputMaybe<RequiredDeploymentsParametersInput>;
  /** Parameters used for the `required_status_checks` rule type */
  requiredStatusChecks?: InputMaybe<RequiredStatusChecksParametersInput>;
  /** Parameters used for the `tag_name_pattern` rule type */
  tagNamePattern?: InputMaybe<TagNamePatternParametersInput>;
  /** Parameters used for the `update` rule type */
  update?: InputMaybe<UpdateParametersInput>;
  /** Parameters used for the `workflows` rule type */
  workflows?: InputMaybe<WorkflowsParametersInput>;
};

/** Types which can have `RepositoryRule` objects. */
export type RuleSource = Organization | Repository;

/** The possible digest algorithms used to sign SAML requests for an identity provider. */
export enum SamlDigestAlgorithm {
  /** SHA1 */
  Sha1 = "SHA1",
  /** SHA256 */
  Sha256 = "SHA256",
  /** SHA384 */
  Sha384 = "SHA384",
  /** SHA512 */
  Sha512 = "SHA512",
}

/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */
export enum SamlSignatureAlgorithm {
  /** RSA-SHA1 */
  RsaSha1 = "RSA_SHA1",
  /** RSA-SHA256 */
  RsaSha256 = "RSA_SHA256",
  /** RSA-SHA384 */
  RsaSha384 = "RSA_SHA384",
  /** RSA-SHA512 */
  RsaSha512 = "RSA_SHA512",
}

/** A Saved Reply is text a user can use to reply quickly. */
export type SavedReply = Node & {
  __typename?: "SavedReply";
  /** The body of the saved reply. */
  body: Scalars["String"]["output"];
  /** The saved reply body rendered to HTML. */
  bodyHTML: Scalars["HTML"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The Node ID of the SavedReply object */
  id: Scalars["ID"]["output"];
  /** The title of the saved reply. */
  title: Scalars["String"]["output"];
  /** The user that saved this reply. */
  user?: Maybe<Actor>;
};

/** The connection type for SavedReply. */
export type SavedReplyConnection = {
  __typename?: "SavedReplyConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SavedReplyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SavedReply>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type SavedReplyEdge = {
  __typename?: "SavedReplyEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<SavedReply>;
};

/** Ordering options for saved reply connections. */
export type SavedReplyOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order saved replies by. */
  field: SavedReplyOrderField;
};

/** Properties by which saved reply connections can be ordered. */
export enum SavedReplyOrderField {
  /** Order saved reply by when they were updated. */
  UpdatedAt = "UPDATED_AT",
}

/** The results of a search. */
export type SearchResultItem =
  | App
  | Discussion
  | Issue
  | MarketplaceListing
  | Organization
  | PullRequest
  | Repository
  | User;

/**
 * A list of results that matched against a search query. Regardless of the number
 * of matches, a maximum of 1,000 results will be available across all types,
 * potentially split across many pages.
 */
export type SearchResultItemConnection = {
  __typename?: "SearchResultItemConnection";
  /**
   * The total number of pieces of code that matched the search query. Regardless
   * of the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  codeCount: Scalars["Int"]["output"];
  /**
   * The total number of discussions that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  discussionCount: Scalars["Int"]["output"];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SearchResultItemEdge>>>;
  /**
   * The total number of issues that matched the search query. Regardless of the
   * total number of matches, a maximum of 1,000 results will be available across all types.
   */
  issueCount: Scalars["Int"]["output"];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SearchResultItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /**
   * The total number of repositories that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  repositoryCount: Scalars["Int"]["output"];
  /**
   * The total number of users that matched the search query. Regardless of the
   * total number of matches, a maximum of 1,000 results will be available across all types.
   */
  userCount: Scalars["Int"]["output"];
  /**
   * The total number of wiki pages that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  wikiCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type SearchResultItemEdge = {
  __typename?: "SearchResultItemEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<SearchResultItem>;
  /** Text matches on the result found. */
  textMatches?: Maybe<Array<Maybe<TextMatch>>>;
};

/** Represents the individual results of a search. */
export enum SearchType {
  /** Returns matching discussions in repositories. */
  Discussion = "DISCUSSION",
  /** Returns results matching issues in repositories. */
  Issue = "ISSUE",
  /** Returns results matching repositories. */
  Repository = "REPOSITORY",
  /** Returns results matching users and organizations on GitHub. */
  User = "USER",
}

/** A GitHub Security Advisory */
export type SecurityAdvisory = Node & {
  __typename?: "SecurityAdvisory";
  /** The classification of the advisory */
  classification: SecurityAdvisoryClassification;
  /** The CVSS associated with this advisory */
  cvss: Cvss;
  /** CWEs associated with this Advisory */
  cwes: CweConnection;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** This is a long plaintext description of the advisory */
  description: Scalars["String"]["output"];
  /** The GitHub Security Advisory ID */
  ghsaId: Scalars["String"]["output"];
  /** The Node ID of the SecurityAdvisory object */
  id: Scalars["ID"]["output"];
  /** A list of identifiers for this advisory */
  identifiers: Array<SecurityAdvisoryIdentifier>;
  /** The permalink for the advisory's dependabot alerts page */
  notificationsPermalink?: Maybe<Scalars["URI"]["output"]>;
  /** The organization that originated the advisory */
  origin: Scalars["String"]["output"];
  /** The permalink for the advisory */
  permalink?: Maybe<Scalars["URI"]["output"]>;
  /** When the advisory was published */
  publishedAt: Scalars["DateTime"]["output"];
  /** A list of references for this advisory */
  references: Array<SecurityAdvisoryReference>;
  /** The severity of the advisory */
  severity: SecurityAdvisorySeverity;
  /** A short plaintext summary of the advisory */
  summary: Scalars["String"]["output"];
  /** When the advisory was last updated */
  updatedAt: Scalars["DateTime"]["output"];
  /** Vulnerabilities associated with this Advisory */
  vulnerabilities: SecurityVulnerabilityConnection;
  /** When the advisory was withdrawn, if it has been withdrawn */
  withdrawnAt?: Maybe<Scalars["DateTime"]["output"]>;
};

/** A GitHub Security Advisory */
export type SecurityAdvisoryCwesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A GitHub Security Advisory */
export type SecurityAdvisoryVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  classifications?: InputMaybe<Array<SecurityAdvisoryClassification>>;
  ecosystem?: InputMaybe<SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SecurityVulnerabilityOrder>;
  package?: InputMaybe<Scalars["String"]["input"]>;
  severities?: InputMaybe<Array<SecurityAdvisorySeverity>>;
};

/** Classification of the advisory. */
export enum SecurityAdvisoryClassification {
  /** Classification of general advisories. */
  General = "GENERAL",
  /** Classification of malware advisories. */
  Malware = "MALWARE",
}

/** The connection type for SecurityAdvisory. */
export type SecurityAdvisoryConnection = {
  __typename?: "SecurityAdvisoryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SecurityAdvisoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SecurityAdvisory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** The possible ecosystems of a security vulnerability's package. */
export enum SecurityAdvisoryEcosystem {
  /** GitHub Actions */
  Actions = "ACTIONS",
  /** PHP packages hosted at packagist.org */
  Composer = "COMPOSER",
  /** Erlang/Elixir packages hosted at hex.pm */
  Erlang = "ERLANG",
  /** Go modules */
  Go = "GO",
  /** Java artifacts hosted at the Maven central repository */
  Maven = "MAVEN",
  /** JavaScript packages hosted at npmjs.com */
  Npm = "NPM",
  /** .NET packages hosted at the NuGet Gallery */
  Nuget = "NUGET",
  /** Python packages hosted at PyPI.org */
  Pip = "PIP",
  /** Dart packages hosted at pub.dev */
  Pub = "PUB",
  /** Ruby gems hosted at RubyGems.org */
  Rubygems = "RUBYGEMS",
  /** Rust crates */
  Rust = "RUST",
  /** Swift packages */
  Swift = "SWIFT",
}

/** An edge in a connection. */
export type SecurityAdvisoryEdge = {
  __typename?: "SecurityAdvisoryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<SecurityAdvisory>;
};

/** A GitHub Security Advisory Identifier */
export type SecurityAdvisoryIdentifier = {
  __typename?: "SecurityAdvisoryIdentifier";
  /** The identifier type, e.g. GHSA, CVE */
  type: Scalars["String"]["output"];
  /** The identifier */
  value: Scalars["String"]["output"];
};

/** An advisory identifier to filter results on. */
export type SecurityAdvisoryIdentifierFilter = {
  /** The identifier type. */
  type: SecurityAdvisoryIdentifierType;
  /** The identifier string. Supports exact or partial matching. */
  value: Scalars["String"]["input"];
};

/** Identifier formats available for advisories. */
export enum SecurityAdvisoryIdentifierType {
  /** Common Vulnerabilities and Exposures Identifier. */
  Cve = "CVE",
  /** GitHub Security Advisory ID. */
  Ghsa = "GHSA",
}

/** Ordering options for security advisory connections */
export type SecurityAdvisoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order security advisories by. */
  field: SecurityAdvisoryOrderField;
};

/** Properties by which security advisory connections can be ordered. */
export enum SecurityAdvisoryOrderField {
  /** Order advisories by publication time */
  PublishedAt = "PUBLISHED_AT",
  /** Order advisories by update time */
  UpdatedAt = "UPDATED_AT",
}

/** An individual package */
export type SecurityAdvisoryPackage = {
  __typename?: "SecurityAdvisoryPackage";
  /** The ecosystem the package belongs to, e.g. RUBYGEMS, NPM */
  ecosystem: SecurityAdvisoryEcosystem;
  /** The package name */
  name: Scalars["String"]["output"];
};

/** An individual package version */
export type SecurityAdvisoryPackageVersion = {
  __typename?: "SecurityAdvisoryPackageVersion";
  /** The package name or version */
  identifier: Scalars["String"]["output"];
};

/** A GitHub Security Advisory Reference */
export type SecurityAdvisoryReference = {
  __typename?: "SecurityAdvisoryReference";
  /** A publicly accessible reference */
  url: Scalars["URI"]["output"];
};

/** Severity of the vulnerability. */
export enum SecurityAdvisorySeverity {
  /** Critical. */
  Critical = "CRITICAL",
  /** High. */
  High = "HIGH",
  /** Low. */
  Low = "LOW",
  /** Moderate. */
  Moderate = "MODERATE",
}

/** An individual vulnerability within an Advisory */
export type SecurityVulnerability = {
  __typename?: "SecurityVulnerability";
  /** The Advisory associated with this Vulnerability */
  advisory: SecurityAdvisory;
  /** The first version containing a fix for the vulnerability */
  firstPatchedVersion?: Maybe<SecurityAdvisoryPackageVersion>;
  /** A description of the vulnerable package */
  package: SecurityAdvisoryPackage;
  /** The severity of the vulnerability within this package */
  severity: SecurityAdvisorySeverity;
  /** When the vulnerability was last updated */
  updatedAt: Scalars["DateTime"]["output"];
  /**
   * A string that describes the vulnerable package versions.
   * This string follows a basic syntax with a few forms.
   * + `= 0.2.0` denotes a single vulnerable version.
   * + `<= 1.0.8` denotes a version range up to and including the specified version
   * + `< 0.1.11` denotes a version range up to, but excluding, the specified version
   * + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
   * + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
   */
  vulnerableVersionRange: Scalars["String"]["output"];
};

/** The connection type for SecurityVulnerability. */
export type SecurityVulnerabilityConnection = {
  __typename?: "SecurityVulnerabilityConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SecurityVulnerabilityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SecurityVulnerability>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type SecurityVulnerabilityEdge = {
  __typename?: "SecurityVulnerabilityEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<SecurityVulnerability>;
};

/** Ordering options for security vulnerability connections */
export type SecurityVulnerabilityOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order security vulnerabilities by. */
  field: SecurityVulnerabilityOrderField;
};

/** Properties by which security vulnerability connections can be ordered. */
export enum SecurityVulnerabilityOrderField {
  /** Order vulnerability by update time */
  UpdatedAt = "UPDATED_AT",
}

/** Autogenerated input type of SetEnterpriseIdentityProvider */
export type SetEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod: SamlDigestAlgorithm;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars["ID"]["input"];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate: Scalars["String"]["input"];
  /** The Issuer Entity ID for the SAML identity provider */
  issuer?: InputMaybe<Scalars["String"]["input"]>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod: SamlSignatureAlgorithm;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl: Scalars["URI"]["input"];
};

/** Autogenerated return type of SetEnterpriseIdentityProvider. */
export type SetEnterpriseIdentityProviderPayload = {
  __typename?: "SetEnterpriseIdentityProviderPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<EnterpriseIdentityProvider>;
};

/** Autogenerated input type of SetOrganizationInteractionLimit */
export type SetOrganizationInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** When this limit should expire. */
  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: RepositoryInteractionLimit;
  /** The ID of the organization to set a limit for. */
  organizationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of SetOrganizationInteractionLimit. */
export type SetOrganizationInteractionLimitPayload = {
  __typename?: "SetOrganizationInteractionLimitPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The organization that the interaction limit was set for. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of SetRepositoryInteractionLimit */
export type SetRepositoryInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** When this limit should expire. */
  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: RepositoryInteractionLimit;
  /** The ID of the repository to set a limit for. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of SetRepositoryInteractionLimit. */
export type SetRepositoryInteractionLimitPayload = {
  __typename?: "SetRepositoryInteractionLimitPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The repository that the interaction limit was set for. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of SetUserInteractionLimit */
export type SetUserInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** When this limit should expire. */
  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: RepositoryInteractionLimit;
  /** The ID of the user to set a limit for. */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated return type of SetUserInteractionLimit. */
export type SetUserInteractionLimitPayload = {
  __typename?: "SetUserInteractionLimitPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The user that the interaction limit was set for. */
  user?: Maybe<User>;
};

/** Represents an S/MIME signature on a Commit or Tag. */
export type SmimeSignature = GitSignature & {
  __typename?: "SmimeSignature";
  /** Email used to sign this object. */
  email: Scalars["String"]["output"];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars["Boolean"]["output"];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars["String"]["output"];
  /** ASCII-armored signature header from object. */
  signature: Scalars["String"]["output"];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars["Boolean"]["output"];
};

/** Social media profile associated with a user. */
export type SocialAccount = {
  __typename?: "SocialAccount";
  /** Name of the social media account as it appears on the profile. */
  displayName: Scalars["String"]["output"];
  /** Software or company that hosts the social media account. */
  provider: SocialAccountProvider;
  /** URL of the social media account. */
  url: Scalars["URI"]["output"];
};

/** The connection type for SocialAccount. */
export type SocialAccountConnection = {
  __typename?: "SocialAccountConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SocialAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SocialAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type SocialAccountEdge = {
  __typename?: "SocialAccountEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<SocialAccount>;
};

/** Software or company that hosts social media accounts. */
export enum SocialAccountProvider {
  /** Social media and networking website. */
  Facebook = "FACEBOOK",
  /** Catch-all for social media providers that do not yet have specific handling. */
  Generic = "GENERIC",
  /** Fork of Mastodon with a greater focus on local posting. */
  Hometown = "HOMETOWN",
  /** Social media website with a focus on photo and video sharing. */
  Instagram = "INSTAGRAM",
  /** Professional networking website. */
  Linkedin = "LINKEDIN",
  /** Open-source federated microblogging service. */
  Mastodon = "MASTODON",
  /** JavaScript package registry. */
  Npm = "NPM",
  /** Social news aggregation and discussion website. */
  Reddit = "REDDIT",
  /** Live-streaming service. */
  Twitch = "TWITCH",
  /** Microblogging website. */
  Twitter = "TWITTER",
  /** Online video platform. */
  Youtube = "YOUTUBE",
}

/** Entities that can sponsor others via GitHub Sponsors */
export type Sponsor = Organization | User;

/**
 * A GitHub account and the total amount in USD they've paid for sponsorships to a
 * particular maintainer. Does not include payments made via Patreon.
 */
export type SponsorAndLifetimeValue = {
  __typename?: "SponsorAndLifetimeValue";
  /** The amount in cents. */
  amountInCents: Scalars["Int"]["output"];
  /** The amount in USD, formatted as a string. */
  formattedAmount: Scalars["String"]["output"];
  /** The sponsor's GitHub account. */
  sponsor: Sponsorable;
  /** The maintainer's GitHub account. */
  sponsorable: Sponsorable;
};

/** The connection type for SponsorAndLifetimeValue. */
export type SponsorAndLifetimeValueConnection = {
  __typename?: "SponsorAndLifetimeValueConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorAndLifetimeValueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SponsorAndLifetimeValue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type SponsorAndLifetimeValueEdge = {
  __typename?: "SponsorAndLifetimeValueEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<SponsorAndLifetimeValue>;
};

/** Ordering options for connections to get sponsor entities and associated USD amounts for GitHub Sponsors. */
export type SponsorAndLifetimeValueOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order results by. */
  field: SponsorAndLifetimeValueOrderField;
};

/** Properties by which sponsor and lifetime value connections can be ordered. */
export enum SponsorAndLifetimeValueOrderField {
  /** Order results by how much money the sponsor has paid in total. */
  LifetimeValue = "LIFETIME_VALUE",
  /** Order results by the sponsor's login (username). */
  SponsorLogin = "SPONSOR_LOGIN",
  /** Order results by the sponsor's relevance to the viewer. */
  SponsorRelevance = "SPONSOR_RELEVANCE",
}

/** A list of users and organizations sponsoring someone via GitHub Sponsors. */
export type SponsorConnection = {
  __typename?: "SponsorConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Sponsor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Represents a user or organization who is sponsoring someone in GitHub Sponsors. */
export type SponsorEdge = {
  __typename?: "SponsorEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Sponsor>;
};

/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */
export type SponsorOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsor entities by. */
  field: SponsorOrderField;
};

/** Properties by which sponsor connections can be ordered. */
export enum SponsorOrderField {
  /** Order sponsorable entities by login (username). */
  Login = "LOGIN",
  /** Order sponsors by their relevance to the viewer. */
  Relevance = "RELEVANCE",
}

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Sponsorable = {
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars["Int"]["output"];
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars["Boolean"]["output"];
  /** Whether the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars["Boolean"]["output"];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars["Boolean"]["output"];
  /**
   * Calculate how much each sponsor has ever paid total to this maintainer via
   * GitHub Sponsors. Does not include sponsorships paid via Patreon.
   */
  lifetimeReceivedSponsorshipValues: SponsorAndLifetimeValueConnection;
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars["Int"]["output"];
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  sponsorshipsAsMaintainer: SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  sponsorshipsAsSponsor: SponsorshipConnection;
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars["Int"]["output"]>;
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars["Boolean"]["output"];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars["Boolean"]["output"];
};

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorableIsSponsoredByArgs = {
  accountLogin: Scalars["String"]["input"];
};

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorableLifetimeReceivedSponsorshipValuesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorAndLifetimeValueOrder>;
};

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorableSponsoringArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorOrder>;
};

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorableSponsorsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorOrder>;
  tierId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorableSponsorsActivitiesArgs = {
  actions?: InputMaybe<Array<SponsorsActivityAction>>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includeAsSponsor?: InputMaybe<Scalars["Boolean"]["input"]>;
  includePrivate?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorsActivityOrder>;
  period?: InputMaybe<SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars["DateTime"]["input"]>;
  until?: InputMaybe<Scalars["DateTime"]["input"]>;
};

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorableSponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorableSponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorableSponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;
};

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorableSponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includePrivate?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorableSponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  maintainerLogins?: InputMaybe<Array<Scalars["String"]["input"]>>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorableTotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars["DateTime"]["input"]>;
  sponsorableLogins?: InputMaybe<Array<Scalars["String"]["input"]>>;
  until?: InputMaybe<Scalars["DateTime"]["input"]>;
};

/** Entities that can be sponsored via GitHub Sponsors */
export type SponsorableItem = Organization | User;

/** The connection type for SponsorableItem. */
export type SponsorableItemConnection = {
  __typename?: "SponsorableItemConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorableItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SponsorableItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type SponsorableItemEdge = {
  __typename?: "SponsorableItemEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<SponsorableItem>;
};

/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */
export type SponsorableOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsorable entities by. */
  field: SponsorableOrderField;
};

/** Properties by which sponsorable connections can be ordered. */
export enum SponsorableOrderField {
  /** Order sponsorable entities by login (username). */
  Login = "LOGIN",
}

/** An event related to sponsorship activity. */
export type SponsorsActivity = Node & {
  __typename?: "SponsorsActivity";
  /** What action this activity indicates took place. */
  action: SponsorsActivityAction;
  /** The sponsor's current privacy level. */
  currentPrivacyLevel?: Maybe<SponsorshipPrivacy>;
  /** The Node ID of the SponsorsActivity object */
  id: Scalars["ID"]["output"];
  /** The platform that was used to pay for the sponsorship. */
  paymentSource?: Maybe<SponsorshipPaymentSource>;
  /** The tier that the sponsorship used to use, for tier change events. */
  previousSponsorsTier?: Maybe<SponsorsTier>;
  /** The user or organization who triggered this activity and was/is sponsoring the sponsorable. */
  sponsor?: Maybe<Sponsor>;
  /** The user or organization that is being sponsored, the maintainer. */
  sponsorable: Sponsorable;
  /** The associated sponsorship tier. */
  sponsorsTier?: Maybe<SponsorsTier>;
  /** The timestamp of this event. */
  timestamp?: Maybe<Scalars["DateTime"]["output"]>;
  /** Was this sponsorship made alongside other sponsorships at the same time from the same sponsor? */
  viaBulkSponsorship: Scalars["Boolean"]["output"];
};

/** The possible actions that GitHub Sponsors activities can represent. */
export enum SponsorsActivityAction {
  /** The activity was cancelling a sponsorship. */
  CancelledSponsorship = "CANCELLED_SPONSORSHIP",
  /** The activity was starting a sponsorship. */
  NewSponsorship = "NEW_SPONSORSHIP",
  /** The activity was scheduling a downgrade or cancellation. */
  PendingChange = "PENDING_CHANGE",
  /** The activity was funds being refunded to the sponsor or GitHub. */
  Refund = "REFUND",
  /** The activity was disabling matching for a previously matched sponsorship. */
  SponsorMatchDisabled = "SPONSOR_MATCH_DISABLED",
  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */
  TierChange = "TIER_CHANGE",
}

/** The connection type for SponsorsActivity. */
export type SponsorsActivityConnection = {
  __typename?: "SponsorsActivityConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorsActivityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SponsorsActivity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type SponsorsActivityEdge = {
  __typename?: "SponsorsActivityEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<SponsorsActivity>;
};

/** Ordering options for GitHub Sponsors activity connections. */
export type SponsorsActivityOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order activity by. */
  field: SponsorsActivityOrderField;
};

/** Properties by which GitHub Sponsors activity connections can be ordered. */
export enum SponsorsActivityOrderField {
  /** Order activities by when they happened. */
  Timestamp = "TIMESTAMP",
}

/** The possible time periods for which Sponsors activities can be requested. */
export enum SponsorsActivityPeriod {
  /** Don't restrict the activity to any date range, include all activity. */
  All = "ALL",
  /** The previous calendar day. */
  Day = "DAY",
  /** The previous thirty days. */
  Month = "MONTH",
  /** The previous seven days. */
  Week = "WEEK",
}

/** Represents countries or regions for billing and residence for a GitHub Sponsors profile. */
export enum SponsorsCountryOrRegionCode {
  /** Andorra */
  Ad = "AD",
  /** United Arab Emirates */
  Ae = "AE",
  /** Afghanistan */
  Af = "AF",
  /** Antigua and Barbuda */
  Ag = "AG",
  /** Anguilla */
  Ai = "AI",
  /** Albania */
  Al = "AL",
  /** Armenia */
  Am = "AM",
  /** Angola */
  Ao = "AO",
  /** Antarctica */
  Aq = "AQ",
  /** Argentina */
  Ar = "AR",
  /** American Samoa */
  As = "AS",
  /** Austria */
  At = "AT",
  /** Australia */
  Au = "AU",
  /** Aruba */
  Aw = "AW",
  /** Åland */
  Ax = "AX",
  /** Azerbaijan */
  Az = "AZ",
  /** Bosnia and Herzegovina */
  Ba = "BA",
  /** Barbados */
  Bb = "BB",
  /** Bangladesh */
  Bd = "BD",
  /** Belgium */
  Be = "BE",
  /** Burkina Faso */
  Bf = "BF",
  /** Bulgaria */
  Bg = "BG",
  /** Bahrain */
  Bh = "BH",
  /** Burundi */
  Bi = "BI",
  /** Benin */
  Bj = "BJ",
  /** Saint Barthélemy */
  Bl = "BL",
  /** Bermuda */
  Bm = "BM",
  /** Brunei Darussalam */
  Bn = "BN",
  /** Bolivia */
  Bo = "BO",
  /** Bonaire, Sint Eustatius and Saba */
  Bq = "BQ",
  /** Brazil */
  Br = "BR",
  /** Bahamas */
  Bs = "BS",
  /** Bhutan */
  Bt = "BT",
  /** Bouvet Island */
  Bv = "BV",
  /** Botswana */
  Bw = "BW",
  /** Belarus */
  By = "BY",
  /** Belize */
  Bz = "BZ",
  /** Canada */
  Ca = "CA",
  /** Cocos (Keeling) Islands */
  Cc = "CC",
  /** Congo (Kinshasa) */
  Cd = "CD",
  /** Central African Republic */
  Cf = "CF",
  /** Congo (Brazzaville) */
  Cg = "CG",
  /** Switzerland */
  Ch = "CH",
  /** Côte d'Ivoire */
  Ci = "CI",
  /** Cook Islands */
  Ck = "CK",
  /** Chile */
  Cl = "CL",
  /** Cameroon */
  Cm = "CM",
  /** China */
  Cn = "CN",
  /** Colombia */
  Co = "CO",
  /** Costa Rica */
  Cr = "CR",
  /** Cape Verde */
  Cv = "CV",
  /** Curaçao */
  Cw = "CW",
  /** Christmas Island */
  Cx = "CX",
  /** Cyprus */
  Cy = "CY",
  /** Czech Republic */
  Cz = "CZ",
  /** Germany */
  De = "DE",
  /** Djibouti */
  Dj = "DJ",
  /** Denmark */
  Dk = "DK",
  /** Dominica */
  Dm = "DM",
  /** Dominican Republic */
  Do = "DO",
  /** Algeria */
  Dz = "DZ",
  /** Ecuador */
  Ec = "EC",
  /** Estonia */
  Ee = "EE",
  /** Egypt */
  Eg = "EG",
  /** Western Sahara */
  Eh = "EH",
  /** Eritrea */
  Er = "ER",
  /** Spain */
  Es = "ES",
  /** Ethiopia */
  Et = "ET",
  /** Finland */
  Fi = "FI",
  /** Fiji */
  Fj = "FJ",
  /** Falkland Islands */
  Fk = "FK",
  /** Micronesia */
  Fm = "FM",
  /** Faroe Islands */
  Fo = "FO",
  /** France */
  Fr = "FR",
  /** Gabon */
  Ga = "GA",
  /** United Kingdom */
  Gb = "GB",
  /** Grenada */
  Gd = "GD",
  /** Georgia */
  Ge = "GE",
  /** French Guiana */
  Gf = "GF",
  /** Guernsey */
  Gg = "GG",
  /** Ghana */
  Gh = "GH",
  /** Gibraltar */
  Gi = "GI",
  /** Greenland */
  Gl = "GL",
  /** Gambia */
  Gm = "GM",
  /** Guinea */
  Gn = "GN",
  /** Guadeloupe */
  Gp = "GP",
  /** Equatorial Guinea */
  Gq = "GQ",
  /** Greece */
  Gr = "GR",
  /** South Georgia and South Sandwich Islands */
  Gs = "GS",
  /** Guatemala */
  Gt = "GT",
  /** Guam */
  Gu = "GU",
  /** Guinea-Bissau */
  Gw = "GW",
  /** Guyana */
  Gy = "GY",
  /** Hong Kong */
  Hk = "HK",
  /** Heard and McDonald Islands */
  Hm = "HM",
  /** Honduras */
  Hn = "HN",
  /** Croatia */
  Hr = "HR",
  /** Haiti */
  Ht = "HT",
  /** Hungary */
  Hu = "HU",
  /** Indonesia */
  Id = "ID",
  /** Ireland */
  Ie = "IE",
  /** Israel */
  Il = "IL",
  /** Isle of Man */
  Im = "IM",
  /** India */
  In = "IN",
  /** British Indian Ocean Territory */
  Io = "IO",
  /** Iraq */
  Iq = "IQ",
  /** Iran */
  Ir = "IR",
  /** Iceland */
  Is = "IS",
  /** Italy */
  It = "IT",
  /** Jersey */
  Je = "JE",
  /** Jamaica */
  Jm = "JM",
  /** Jordan */
  Jo = "JO",
  /** Japan */
  Jp = "JP",
  /** Kenya */
  Ke = "KE",
  /** Kyrgyzstan */
  Kg = "KG",
  /** Cambodia */
  Kh = "KH",
  /** Kiribati */
  Ki = "KI",
  /** Comoros */
  Km = "KM",
  /** Saint Kitts and Nevis */
  Kn = "KN",
  /** Korea, South */
  Kr = "KR",
  /** Kuwait */
  Kw = "KW",
  /** Cayman Islands */
  Ky = "KY",
  /** Kazakhstan */
  Kz = "KZ",
  /** Laos */
  La = "LA",
  /** Lebanon */
  Lb = "LB",
  /** Saint Lucia */
  Lc = "LC",
  /** Liechtenstein */
  Li = "LI",
  /** Sri Lanka */
  Lk = "LK",
  /** Liberia */
  Lr = "LR",
  /** Lesotho */
  Ls = "LS",
  /** Lithuania */
  Lt = "LT",
  /** Luxembourg */
  Lu = "LU",
  /** Latvia */
  Lv = "LV",
  /** Libya */
  Ly = "LY",
  /** Morocco */
  Ma = "MA",
  /** Monaco */
  Mc = "MC",
  /** Moldova */
  Md = "MD",
  /** Montenegro */
  Me = "ME",
  /** Saint Martin (French part) */
  Mf = "MF",
  /** Madagascar */
  Mg = "MG",
  /** Marshall Islands */
  Mh = "MH",
  /** Macedonia */
  Mk = "MK",
  /** Mali */
  Ml = "ML",
  /** Myanmar */
  Mm = "MM",
  /** Mongolia */
  Mn = "MN",
  /** Macau */
  Mo = "MO",
  /** Northern Mariana Islands */
  Mp = "MP",
  /** Martinique */
  Mq = "MQ",
  /** Mauritania */
  Mr = "MR",
  /** Montserrat */
  Ms = "MS",
  /** Malta */
  Mt = "MT",
  /** Mauritius */
  Mu = "MU",
  /** Maldives */
  Mv = "MV",
  /** Malawi */
  Mw = "MW",
  /** Mexico */
  Mx = "MX",
  /** Malaysia */
  My = "MY",
  /** Mozambique */
  Mz = "MZ",
  /** Namibia */
  Na = "NA",
  /** New Caledonia */
  Nc = "NC",
  /** Niger */
  Ne = "NE",
  /** Norfolk Island */
  Nf = "NF",
  /** Nigeria */
  Ng = "NG",
  /** Nicaragua */
  Ni = "NI",
  /** Netherlands */
  Nl = "NL",
  /** Norway */
  No = "NO",
  /** Nepal */
  Np = "NP",
  /** Nauru */
  Nr = "NR",
  /** Niue */
  Nu = "NU",
  /** New Zealand */
  Nz = "NZ",
  /** Oman */
  Om = "OM",
  /** Panama */
  Pa = "PA",
  /** Peru */
  Pe = "PE",
  /** French Polynesia */
  Pf = "PF",
  /** Papua New Guinea */
  Pg = "PG",
  /** Philippines */
  Ph = "PH",
  /** Pakistan */
  Pk = "PK",
  /** Poland */
  Pl = "PL",
  /** Saint Pierre and Miquelon */
  Pm = "PM",
  /** Pitcairn */
  Pn = "PN",
  /** Puerto Rico */
  Pr = "PR",
  /** Palestine */
  Ps = "PS",
  /** Portugal */
  Pt = "PT",
  /** Palau */
  Pw = "PW",
  /** Paraguay */
  Py = "PY",
  /** Qatar */
  Qa = "QA",
  /** Reunion */
  Re = "RE",
  /** Romania */
  Ro = "RO",
  /** Serbia */
  Rs = "RS",
  /** Russian Federation */
  Ru = "RU",
  /** Rwanda */
  Rw = "RW",
  /** Saudi Arabia */
  Sa = "SA",
  /** Solomon Islands */
  Sb = "SB",
  /** Seychelles */
  Sc = "SC",
  /** Sudan */
  Sd = "SD",
  /** Sweden */
  Se = "SE",
  /** Singapore */
  Sg = "SG",
  /** Saint Helena */
  Sh = "SH",
  /** Slovenia */
  Si = "SI",
  /** Svalbard and Jan Mayen Islands */
  Sj = "SJ",
  /** Slovakia */
  Sk = "SK",
  /** Sierra Leone */
  Sl = "SL",
  /** San Marino */
  Sm = "SM",
  /** Senegal */
  Sn = "SN",
  /** Somalia */
  So = "SO",
  /** Suriname */
  Sr = "SR",
  /** South Sudan */
  Ss = "SS",
  /** Sao Tome and Principe */
  St = "ST",
  /** El Salvador */
  Sv = "SV",
  /** Sint Maarten (Dutch part) */
  Sx = "SX",
  /** Swaziland */
  Sz = "SZ",
  /** Turks and Caicos Islands */
  Tc = "TC",
  /** Chad */
  Td = "TD",
  /** French Southern Lands */
  Tf = "TF",
  /** Togo */
  Tg = "TG",
  /** Thailand */
  Th = "TH",
  /** Tajikistan */
  Tj = "TJ",
  /** Tokelau */
  Tk = "TK",
  /** Timor-Leste */
  Tl = "TL",
  /** Turkmenistan */
  Tm = "TM",
  /** Tunisia */
  Tn = "TN",
  /** Tonga */
  To = "TO",
  /** Türkiye */
  Tr = "TR",
  /** Trinidad and Tobago */
  Tt = "TT",
  /** Tuvalu */
  Tv = "TV",
  /** Taiwan */
  Tw = "TW",
  /** Tanzania */
  Tz = "TZ",
  /** Ukraine */
  Ua = "UA",
  /** Uganda */
  Ug = "UG",
  /** United States Minor Outlying Islands */
  Um = "UM",
  /** United States of America */
  Us = "US",
  /** Uruguay */
  Uy = "UY",
  /** Uzbekistan */
  Uz = "UZ",
  /** Vatican City */
  Va = "VA",
  /** Saint Vincent and the Grenadines */
  Vc = "VC",
  /** Venezuela */
  Ve = "VE",
  /** Virgin Islands, British */
  Vg = "VG",
  /** Virgin Islands, U.S. */
  Vi = "VI",
  /** Vietnam */
  Vn = "VN",
  /** Vanuatu */
  Vu = "VU",
  /** Wallis and Futuna Islands */
  Wf = "WF",
  /** Samoa */
  Ws = "WS",
  /** Yemen */
  Ye = "YE",
  /** Mayotte */
  Yt = "YT",
  /** South Africa */
  Za = "ZA",
  /** Zambia */
  Zm = "ZM",
  /** Zimbabwe */
  Zw = "ZW",
}

/** A goal associated with a GitHub Sponsors listing, representing a target the sponsored maintainer would like to attain. */
export type SponsorsGoal = {
  __typename?: "SponsorsGoal";
  /** A description of the goal from the maintainer. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** What the objective of this goal is. */
  kind: SponsorsGoalKind;
  /** The percentage representing how complete this goal is, between 0-100. */
  percentComplete: Scalars["Int"]["output"];
  /**
   * What the goal amount is. Represents an amount in USD for monthly sponsorship
   * amount goals. Represents a count of unique sponsors for total sponsors count goals.
   */
  targetValue: Scalars["Int"]["output"];
  /** A brief summary of the kind and target value of this goal. */
  title: Scalars["String"]["output"];
};

/** The different kinds of goals a GitHub Sponsors member can have. */
export enum SponsorsGoalKind {
  /** The goal is about getting a certain amount in USD from sponsorships each month. */
  MonthlySponsorshipAmount = "MONTHLY_SPONSORSHIP_AMOUNT",
  /** The goal is about reaching a certain number of sponsors. */
  TotalSponsorsCount = "TOTAL_SPONSORS_COUNT",
}

/** A GitHub Sponsors listing. */
export type SponsorsListing = Node & {
  __typename?: "SponsorsListing";
  /** The current goal the maintainer is trying to reach with GitHub Sponsors, if any. */
  activeGoal?: Maybe<SponsorsGoal>;
  /**
   * The Stripe Connect account currently in use for payouts for this Sponsors
   * listing, if any. Will only return a value when queried by the maintainer
   * themselves, or by an admin of the sponsorable organization.
   */
  activeStripeConnectAccount?: Maybe<StripeConnectAccount>;
  /**
   * The name of the country or region with the maintainer's bank account or fiscal
   * host. Will only return a value when queried by the maintainer themselves, or
   * by an admin of the sponsorable organization.
   */
  billingCountryOrRegion?: Maybe<Scalars["String"]["output"]>;
  /**
   * The email address used by GitHub to contact the sponsorable about their GitHub
   * Sponsors profile. Will only return a value when queried by the maintainer
   * themselves, or by an admin of the sponsorable organization.
   */
  contactEmailAddress?: Maybe<Scalars["String"]["output"]>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The HTTP path for the Sponsors dashboard for this Sponsors listing. */
  dashboardResourcePath: Scalars["URI"]["output"];
  /** The HTTP URL for the Sponsors dashboard for this Sponsors listing. */
  dashboardUrl: Scalars["URI"]["output"];
  /** The records featured on the GitHub Sponsors profile. */
  featuredItems: Array<SponsorsListingFeaturedItem>;
  /**
   * The fiscal host used for payments, if any. Will only return a value when
   * queried by the maintainer themselves, or by an admin of the sponsorable organization.
   */
  fiscalHost?: Maybe<Organization>;
  /** The full description of the listing. */
  fullDescription: Scalars["String"]["output"];
  /** The full description of the listing rendered to HTML. */
  fullDescriptionHTML: Scalars["HTML"]["output"];
  /** The Node ID of the SponsorsListing object */
  id: Scalars["ID"]["output"];
  /** Whether this listing is publicly visible. */
  isPublic: Scalars["Boolean"]["output"];
  /** The listing's full name. */
  name: Scalars["String"]["output"];
  /** A future date on which this listing is eligible to receive a payout. */
  nextPayoutDate?: Maybe<Scalars["Date"]["output"]>;
  /**
   * The name of the country or region where the maintainer resides. Will only
   * return a value when queried by the maintainer themselves, or by an admin of
   * the sponsorable organization.
   */
  residenceCountryOrRegion?: Maybe<Scalars["String"]["output"]>;
  /** The HTTP path for this Sponsors listing. */
  resourcePath: Scalars["URI"]["output"];
  /** The short description of the listing. */
  shortDescription: Scalars["String"]["output"];
  /** The short name of the listing. */
  slug: Scalars["String"]["output"];
  /** The entity this listing represents who can be sponsored on GitHub Sponsors. */
  sponsorable: Sponsorable;
  /** The tiers for this GitHub Sponsors profile. */
  tiers?: Maybe<SponsorsTierConnection>;
  /** The HTTP URL for this Sponsors listing. */
  url: Scalars["URI"]["output"];
};

/** A GitHub Sponsors listing. */
export type SponsorsListingFeaturedItemsArgs = {
  featureableTypes?: InputMaybe<
    Array<SponsorsListingFeaturedItemFeatureableType>
  >;
};

/** A GitHub Sponsors listing. */
export type SponsorsListingTiersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includeUnpublished?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorsTierOrder>;
};

/** A record that can be featured on a GitHub Sponsors profile. */
export type SponsorsListingFeatureableItem = Repository | User;

/** A record that is promoted on a GitHub Sponsors profile. */
export type SponsorsListingFeaturedItem = Node & {
  __typename?: "SponsorsListingFeaturedItem";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /**
   * Will either be a description from the sponsorable maintainer about why they
   * featured this item, or the item's description itself, such as a user's bio
   * from their GitHub profile page.
   */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The record that is featured on the GitHub Sponsors profile. */
  featureable: SponsorsListingFeatureableItem;
  /** The Node ID of the SponsorsListingFeaturedItem object */
  id: Scalars["ID"]["output"];
  /**
   * The position of this featured item on the GitHub Sponsors profile with a lower
   * position indicating higher precedence. Starts at 1.
   */
  position: Scalars["Int"]["output"];
  /** The GitHub Sponsors profile that features this record. */
  sponsorsListing: SponsorsListing;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** The different kinds of records that can be featured on a GitHub Sponsors profile page. */
export enum SponsorsListingFeaturedItemFeatureableType {
  /** A repository owned by the user or organization with the GitHub Sponsors profile. */
  Repository = "REPOSITORY",
  /** A user who belongs to the organization with the GitHub Sponsors profile. */
  User = "USER",
}

/** A GitHub Sponsors tier associated with a GitHub Sponsors listing. */
export type SponsorsTier = Node & {
  __typename?: "SponsorsTier";
  /** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
  adminInfo?: Maybe<SponsorsTierAdminInfo>;
  /**
   * Get a different tier for this tier's maintainer that is at the same frequency
   * as this tier but with an equal or lesser cost. Returns the published tier with
   * the monthly price closest to this tier's without going over.
   */
  closestLesserValueTier?: Maybe<SponsorsTier>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The description of the tier. */
  description: Scalars["String"]["output"];
  /** The tier description rendered to HTML */
  descriptionHTML: Scalars["HTML"]["output"];
  /** The Node ID of the SponsorsTier object */
  id: Scalars["ID"]["output"];
  /**
   * Whether this tier was chosen at checkout time by the sponsor rather than
   * defined ahead of time by the maintainer who manages the Sponsors listing.
   */
  isCustomAmount: Scalars["Boolean"]["output"];
  /** Whether this tier is only for use with one-time sponsorships. */
  isOneTime: Scalars["Boolean"]["output"];
  /** How much this tier costs per month in cents. */
  monthlyPriceInCents: Scalars["Int"]["output"];
  /** How much this tier costs per month in USD. */
  monthlyPriceInDollars: Scalars["Int"]["output"];
  /** The name of the tier. */
  name: Scalars["String"]["output"];
  /** The sponsors listing that this tier belongs to. */
  sponsorsListing: SponsorsListing;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type SponsorsTierAdminInfo = {
  __typename?: "SponsorsTierAdminInfo";
  /**
   * Indicates whether this tier is still a work in progress by the sponsorable and
   * not yet published to the associated GitHub Sponsors profile. Draft tiers
   * cannot be used for new sponsorships and will not be in use on existing
   * sponsorships. Draft tiers cannot be seen by anyone but the admins of the
   * GitHub Sponsors profile.
   */
  isDraft: Scalars["Boolean"]["output"];
  /**
   * Indicates whether this tier is published to the associated GitHub Sponsors
   * profile. Published tiers are visible to anyone who can see the GitHub Sponsors
   * profile, and are available for use in sponsorships if the GitHub Sponsors
   * profile is publicly visible.
   */
  isPublished: Scalars["Boolean"]["output"];
  /**
   * Indicates whether this tier has been retired from the associated GitHub
   * Sponsors profile. Retired tiers are no longer shown on the GitHub Sponsors
   * profile and cannot be chosen for new sponsorships. Existing sponsorships may
   * still use retired tiers if the sponsor selected the tier before it was retired.
   */
  isRetired: Scalars["Boolean"]["output"];
  /** The sponsorships using this tier. */
  sponsorships: SponsorshipConnection;
};

/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type SponsorsTierAdminInfoSponsorshipsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includePrivate?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};

/** The connection type for SponsorsTier. */
export type SponsorsTierConnection = {
  __typename?: "SponsorsTierConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorsTierEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SponsorsTier>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type SponsorsTierEdge = {
  __typename?: "SponsorsTierEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<SponsorsTier>;
};

/** Ordering options for Sponsors tiers connections. */
export type SponsorsTierOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order tiers by. */
  field: SponsorsTierOrderField;
};

/** Properties by which Sponsors tiers connections can be ordered. */
export enum SponsorsTierOrderField {
  /** Order tiers by creation time. */
  CreatedAt = "CREATED_AT",
  /** Order tiers by their monthly price in cents */
  MonthlyPriceInCents = "MONTHLY_PRICE_IN_CENTS",
}

/** A sponsorship relationship between a sponsor and a maintainer */
export type Sponsorship = Node & {
  __typename?: "Sponsorship";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the Sponsorship object */
  id: Scalars["ID"]["output"];
  /**
   * Whether the sponsorship is active. False implies the sponsor is a past sponsor
   * of the maintainer, while true implies they are a current sponsor.
   */
  isActive: Scalars["Boolean"]["output"];
  /** Whether this sponsorship represents a one-time payment versus a recurring sponsorship. */
  isOneTimePayment: Scalars["Boolean"]["output"];
  /**
   * Whether the sponsor has chosen to receive sponsorship update emails sent from
   * the sponsorable. Only returns a non-null value when the viewer has permission to know this.
   */
  isSponsorOptedIntoEmail?: Maybe<Scalars["Boolean"]["output"]>;
  /**
   * The entity that is being sponsored
   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.
   */
  maintainer: User;
  /** The platform that was most recently used to pay for the sponsorship. */
  paymentSource?: Maybe<SponsorshipPaymentSource>;
  /** The privacy level for this sponsorship. */
  privacyLevel: SponsorshipPrivacy;
  /**
   * The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.
   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.
   */
  sponsor?: Maybe<User>;
  /** The user or organization that is sponsoring, if you have permission to view them. */
  sponsorEntity?: Maybe<Sponsor>;
  /** The entity that is being sponsored */
  sponsorable: Sponsorable;
  /** The associated sponsorship tier */
  tier?: Maybe<SponsorsTier>;
  /** Identifies the date and time when the current tier was chosen for this sponsorship. */
  tierSelectedAt?: Maybe<Scalars["DateTime"]["output"]>;
};

/** A list of sponsorships either from the subject or received by the subject. */
export type SponsorshipConnection = {
  __typename?: "SponsorshipConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorshipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Sponsorship>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
  /**
   * The total amount in cents of all recurring sponsorships in the connection
   * whose amount you can view. Does not include one-time sponsorships.
   */
  totalRecurringMonthlyPriceInCents: Scalars["Int"]["output"];
  /**
   * The total amount in USD of all recurring sponsorships in the connection whose
   * amount you can view. Does not include one-time sponsorships.
   */
  totalRecurringMonthlyPriceInDollars: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type SponsorshipEdge = {
  __typename?: "SponsorshipEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Sponsorship>;
};

/** An update sent to sponsors of a user or organization on GitHub Sponsors. */
export type SponsorshipNewsletter = Node & {
  __typename?: "SponsorshipNewsletter";
  /** The author of the newsletter. */
  author?: Maybe<User>;
  /** The contents of the newsletter, the message the sponsorable wanted to give. */
  body: Scalars["String"]["output"];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the SponsorshipNewsletter object */
  id: Scalars["ID"]["output"];
  /** Indicates if the newsletter has been made available to sponsors. */
  isPublished: Scalars["Boolean"]["output"];
  /** The user or organization this newsletter is from. */
  sponsorable: Sponsorable;
  /** The subject of the newsletter, what it's about. */
  subject: Scalars["String"]["output"];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** The connection type for SponsorshipNewsletter. */
export type SponsorshipNewsletterConnection = {
  __typename?: "SponsorshipNewsletterConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorshipNewsletterEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SponsorshipNewsletter>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type SponsorshipNewsletterEdge = {
  __typename?: "SponsorshipNewsletterEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<SponsorshipNewsletter>;
};

/** Ordering options for sponsorship newsletter connections. */
export type SponsorshipNewsletterOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsorship newsletters by. */
  field: SponsorshipNewsletterOrderField;
};

/** Properties by which sponsorship update connections can be ordered. */
export enum SponsorshipNewsletterOrderField {
  /** Order sponsorship newsletters by when they were created. */
  CreatedAt = "CREATED_AT",
}

/** Ordering options for sponsorship connections. */
export type SponsorshipOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsorship by. */
  field: SponsorshipOrderField;
};

/** Properties by which sponsorship connections can be ordered. */
export enum SponsorshipOrderField {
  /** Order sponsorship by creation time. */
  CreatedAt = "CREATED_AT",
}

/** How payment was made for funding a GitHub Sponsors sponsorship. */
export enum SponsorshipPaymentSource {
  /** Payment was made through GitHub. */
  Github = "GITHUB",
  /** Payment was made through Patreon. */
  Patreon = "PATREON",
}

/** The privacy of a sponsorship */
export enum SponsorshipPrivacy {
  /** Private */
  Private = "PRIVATE",
  /** Public */
  Public = "PUBLIC",
}

/** The possible default commit messages for squash merges. */
export enum SquashMergeCommitMessage {
  /** Default to a blank commit message. */
  Blank = "BLANK",
  /** Default to the branch's commit messages. */
  CommitMessages = "COMMIT_MESSAGES",
  /** Default to the pull request's body. */
  PrBody = "PR_BODY",
}

/** The possible default commit titles for squash merges. */
export enum SquashMergeCommitTitle {
  /** Default to the commit's title (if only one commit) or the pull request's title (when more than one commit). */
  CommitOrPrTitle = "COMMIT_OR_PR_TITLE",
  /** Default to the pull request's title. */
  PrTitle = "PR_TITLE",
}

/** Represents an SSH signature on a Commit or Tag. */
export type SshSignature = GitSignature & {
  __typename?: "SshSignature";
  /** Email used to sign this object. */
  email: Scalars["String"]["output"];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars["Boolean"]["output"];
  /** Hex-encoded fingerprint of the key that signed this object. */
  keyFingerprint?: Maybe<Scalars["String"]["output"]>;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars["String"]["output"];
  /** ASCII-armored signature header from object. */
  signature: Scalars["String"]["output"];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars["Boolean"]["output"];
};

/** Ways in which star connections can be ordered. */
export type StarOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field in which to order nodes by. */
  field: StarOrderField;
};

/** Properties by which star connections can be ordered. */
export enum StarOrderField {
  /** Allows ordering a list of stars by when they were created. */
  StarredAt = "STARRED_AT",
}

/** The connection type for User. */
export type StargazerConnection = {
  __typename?: "StargazerConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<StargazerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Represents a user that's starred a repository. */
export type StargazerEdge = {
  __typename?: "StargazerEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  node: User;
  /** Identifies when the item was starred. */
  starredAt: Scalars["DateTime"]["output"];
};

/** Things that can be starred. */
export type Starrable = {
  /** The Node ID of the Starrable object */
  id: Scalars["ID"]["output"];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars["Int"]["output"];
  /** A list of users who have starred this starrable. */
  stargazers: StargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars["Boolean"]["output"];
};

/** Things that can be starred. */
export type StarrableStargazersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<StarOrder>;
};

/** The connection type for Repository. */
export type StarredRepositoryConnection = {
  __typename?: "StarredRepositoryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<StarredRepositoryEdge>>>;
  /** Is the list of stars for this user truncated? This is true for users that have many stars. */
  isOverLimit: Scalars["Boolean"]["output"];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Represents a starred repository. */
export type StarredRepositoryEdge = {
  __typename?: "StarredRepositoryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  node: Repository;
  /** Identifies when the item was starred. */
  starredAt: Scalars["DateTime"]["output"];
};

/** Autogenerated input type of StartOrganizationMigration */
export type StartOrganizationMigrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The migration source access token. */
  sourceAccessToken: Scalars["String"]["input"];
  /** The URL of the organization to migrate. */
  sourceOrgUrl: Scalars["URI"]["input"];
  /** The ID of the enterprise the target organization belongs to. */
  targetEnterpriseId: Scalars["ID"]["input"];
  /** The name of the target organization. */
  targetOrgName: Scalars["String"]["input"];
};

/** Autogenerated return type of StartOrganizationMigration. */
export type StartOrganizationMigrationPayload = {
  __typename?: "StartOrganizationMigrationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new organization migration. */
  orgMigration?: Maybe<OrganizationMigration>;
};

/** Autogenerated input type of StartRepositoryMigration */
export type StartRepositoryMigrationInput = {
  /** The migration source access token. */
  accessToken?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether to continue the migration on error. Defaults to `true`. */
  continueOnError?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The signed URL to access the user-uploaded git archive. */
  gitArchiveUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** The GitHub personal access token of the user importing to the target repository. */
  githubPat?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether to lock the source repository. */
  lockSource?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The signed URL to access the user-uploaded metadata archive. */
  metadataArchiveUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the organization that will own the imported repository. */
  ownerId: Scalars["ID"]["input"];
  /** The name of the imported repository. */
  repositoryName: Scalars["String"]["input"];
  /** Whether to skip migrating releases for the repository. */
  skipReleases?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the migration source. */
  sourceId: Scalars["ID"]["input"];
  /** The URL of the source repository. */
  sourceRepositoryUrl: Scalars["URI"]["input"];
  /** The visibility of the imported repository. */
  targetRepoVisibility?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of StartRepositoryMigration. */
export type StartRepositoryMigrationPayload = {
  __typename?: "StartRepositoryMigrationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The new repository migration. */
  repositoryMigration?: Maybe<RepositoryMigration>;
};

/** Represents a commit status. */
export type Status = Node & {
  __typename?: "Status";
  /** A list of status contexts and check runs for this commit. */
  combinedContexts: StatusCheckRollupContextConnection;
  /** The commit this status is attached to. */
  commit?: Maybe<Commit>;
  /** Looks up an individual status context by context name. */
  context?: Maybe<StatusContext>;
  /** The individual status contexts for this commit. */
  contexts: Array<StatusContext>;
  /** The Node ID of the Status object */
  id: Scalars["ID"]["output"];
  /** The combined commit status. */
  state: StatusState;
};

/** Represents a commit status. */
export type StatusCombinedContextsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a commit status. */
export type StatusContextArgs = {
  name: Scalars["String"]["input"];
};

/** Required status check */
export type StatusCheckConfiguration = {
  __typename?: "StatusCheckConfiguration";
  /** The status check context name that must be present on the commit. */
  context: Scalars["String"]["output"];
  /** The optional integration ID that this status check must originate from. */
  integrationId?: Maybe<Scalars["Int"]["output"]>;
};

/** Required status check */
export type StatusCheckConfigurationInput = {
  /** The status check context name that must be present on the commit. */
  context: Scalars["String"]["input"];
  /** The optional integration ID that this status check must originate from. */
  integrationId?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents the rollup for both the check runs and status for a commit. */
export type StatusCheckRollup = Node & {
  __typename?: "StatusCheckRollup";
  /** The commit the status and check runs are attached to. */
  commit?: Maybe<Commit>;
  /** A list of status contexts and check runs for this commit. */
  contexts: StatusCheckRollupContextConnection;
  /** The Node ID of the StatusCheckRollup object */
  id: Scalars["ID"]["output"];
  /** The combined status for the commit. */
  state: StatusState;
};

/** Represents the rollup for both the check runs and status for a commit. */
export type StatusCheckRollupContextsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Types that can be inside a StatusCheckRollup context. */
export type StatusCheckRollupContext = CheckRun | StatusContext;

/** The connection type for StatusCheckRollupContext. */
export type StatusCheckRollupContextConnection = {
  __typename?: "StatusCheckRollupContextConnection";
  /** The number of check runs in this rollup. */
  checkRunCount: Scalars["Int"]["output"];
  /** Counts of check runs by state. */
  checkRunCountsByState?: Maybe<Array<CheckRunStateCount>>;
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<StatusCheckRollupContextEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<StatusCheckRollupContext>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The number of status contexts in this rollup. */
  statusContextCount: Scalars["Int"]["output"];
  /** Counts of status contexts by state. */
  statusContextCountsByState?: Maybe<Array<StatusContextStateCount>>;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type StatusCheckRollupContextEdge = {
  __typename?: "StatusCheckRollupContextEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<StatusCheckRollupContext>;
};

/** Represents an individual commit status context */
export type StatusContext = Node &
  RequirableByPullRequest & {
    __typename?: "StatusContext";
    /** The avatar of the OAuth application or the user that created the status */
    avatarUrl?: Maybe<Scalars["URI"]["output"]>;
    /** This commit this status context is attached to. */
    commit?: Maybe<Commit>;
    /** The name of this status context. */
    context: Scalars["String"]["output"];
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** The actor who created this status context. */
    creator?: Maybe<Actor>;
    /** The description for this status context. */
    description?: Maybe<Scalars["String"]["output"]>;
    /** The Node ID of the StatusContext object */
    id: Scalars["ID"]["output"];
    /** Whether this is required to pass before merging for a specific pull request. */
    isRequired: Scalars["Boolean"]["output"];
    /** The state of this status context. */
    state: StatusState;
    /** The URL for this status context. */
    targetUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Represents an individual commit status context */
export type StatusContextAvatarUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents an individual commit status context */
export type StatusContextIsRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars["ID"]["input"]>;
  pullRequestNumber?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a count of the state of a status context. */
export type StatusContextStateCount = {
  __typename?: "StatusContextStateCount";
  /** The number of statuses with this state. */
  count: Scalars["Int"]["output"];
  /** The state of a status context. */
  state: StatusState;
};

/** The possible commit status states. */
export enum StatusState {
  /** Status is errored. */
  Error = "ERROR",
  /** Status is expected. */
  Expected = "EXPECTED",
  /** Status is failing. */
  Failure = "FAILURE",
  /** Status is pending. */
  Pending = "PENDING",
  /** Status is successful. */
  Success = "SUCCESS",
}

/** A Stripe Connect account for receiving sponsorship funds from GitHub Sponsors. */
export type StripeConnectAccount = {
  __typename?: "StripeConnectAccount";
  /** The account number used to identify this Stripe Connect account. */
  accountId: Scalars["String"]["output"];
  /**
   * The name of the country or region of an external account, such as a bank
   * account, tied to the Stripe Connect account. Will only return a value when
   * queried by the maintainer of the associated GitHub Sponsors profile
   * themselves, or by an admin of the sponsorable organization.
   */
  billingCountryOrRegion?: Maybe<Scalars["String"]["output"]>;
  /**
   * The name of the country or region of the Stripe Connect account. Will only
   * return a value when queried by the maintainer of the associated GitHub
   * Sponsors profile themselves, or by an admin of the sponsorable organization.
   */
  countryOrRegion?: Maybe<Scalars["String"]["output"]>;
  /** Whether this Stripe Connect account is currently in use for the associated GitHub Sponsors profile. */
  isActive: Scalars["Boolean"]["output"];
  /** The GitHub Sponsors profile associated with this Stripe Connect account. */
  sponsorsListing: SponsorsListing;
  /** The URL to access this Stripe Connect account on Stripe's website. */
  stripeDashboardUrl: Scalars["URI"]["output"];
};

/** Autogenerated input type of SubmitPullRequestReview */
export type SubmitPullRequestReviewInput = {
  /** The text field to set on the Pull Request Review. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The event to send to the Pull Request Review. */
  event: PullRequestReviewEvent;
  /** The Pull Request ID to submit any pending reviews. */
  pullRequestId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The Pull Request Review ID to submit. */
  pullRequestReviewId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of SubmitPullRequestReview. */
export type SubmitPullRequestReviewPayload = {
  __typename?: "SubmitPullRequestReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The submitted pull request review. */
  pullRequestReview?: Maybe<PullRequestReview>;
};

/** A pointer to a repository at a specific revision embedded inside another repository. */
export type Submodule = {
  __typename?: "Submodule";
  /** The branch of the upstream submodule for tracking updates */
  branch?: Maybe<Scalars["String"]["output"]>;
  /** The git URL of the submodule repository */
  gitUrl: Scalars["URI"]["output"];
  /** The name of the submodule in .gitmodules */
  name: Scalars["String"]["output"];
  /** The name of the submodule in .gitmodules (Base64-encoded) */
  nameRaw: Scalars["Base64String"]["output"];
  /** The path in the superproject that this submodule is located in */
  path: Scalars["String"]["output"];
  /** The path in the superproject that this submodule is located in (Base64-encoded) */
  pathRaw: Scalars["Base64String"]["output"];
  /** The commit revision of the subproject repository being tracked by the submodule */
  subprojectCommitOid?: Maybe<Scalars["GitObjectID"]["output"]>;
};

/** The connection type for Submodule. */
export type SubmoduleConnection = {
  __typename?: "SubmoduleConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SubmoduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Submodule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type SubmoduleEdge = {
  __typename?: "SubmoduleEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Submodule>;
};

/** Entities that can be subscribed to for web and email notifications. */
export type Subscribable = {
  /** The Node ID of the Subscribable object */
  id: Scalars["ID"]["output"];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars["Boolean"]["output"];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<SubscriptionState>;
};

/** Entities that can be subscribed to for web and email notifications. */
export type SubscribableThread = {
  /** The Node ID of the SubscribableThread object */
  id: Scalars["ID"]["output"];
  /** Identifies the viewer's thread subscription form action. */
  viewerThreadSubscriptionFormAction?: Maybe<ThreadSubscriptionFormAction>;
  /** Identifies the viewer's thread subscription status. */
  viewerThreadSubscriptionStatus?: Maybe<ThreadSubscriptionState>;
};

/** Represents a 'subscribed' event on a given `Subscribable`. */
export type SubscribedEvent = Node & {
  __typename?: "SubscribedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the SubscribedEvent object */
  id: Scalars["ID"]["output"];
  /** Object referenced by event. */
  subscribable: Subscribable;
};

/** The possible states of a subscription. */
export enum SubscriptionState {
  /** The User is never notified. */
  Ignored = "IGNORED",
  /** The User is notified of all conversations. */
  Subscribed = "SUBSCRIBED",
  /** The User is only notified when participating or @mentioned. */
  Unsubscribed = "UNSUBSCRIBED",
}

/** A suggestion to review a pull request based on a user's commit history and review comments. */
export type SuggestedReviewer = {
  __typename?: "SuggestedReviewer";
  /** Is this suggestion based on past commits? */
  isAuthor: Scalars["Boolean"]["output"];
  /** Is this suggestion based on past review comments? */
  isCommenter: Scalars["Boolean"]["output"];
  /** Identifies the user suggested to review the pull request. */
  reviewer: User;
};

/** Represents a Git tag. */
export type Tag = GitObject &
  Node & {
    __typename?: "Tag";
    /** An abbreviated version of the Git object ID */
    abbreviatedOid: Scalars["String"]["output"];
    /** The HTTP path for this Git object */
    commitResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for this Git object */
    commitUrl: Scalars["URI"]["output"];
    /** The Node ID of the Tag object */
    id: Scalars["ID"]["output"];
    /** The Git tag message. */
    message?: Maybe<Scalars["String"]["output"]>;
    /** The Git tag name. */
    name: Scalars["String"]["output"];
    /** The Git object ID */
    oid: Scalars["GitObjectID"]["output"];
    /** The Repository the Git object belongs to */
    repository: Repository;
    /** Details about the tag author. */
    tagger?: Maybe<GitActor>;
    /** The Git object the tag points to. */
    target: GitObject;
  };

/** Parameters to be used for the tag_name_pattern rule */
export type TagNamePatternParameters = {
  __typename?: "TagNamePatternParameters";
  /** How this rule will appear to users. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars["Boolean"]["output"];
  /** The operator to use for matching. */
  operator: Scalars["String"]["output"];
  /** The pattern to match with. */
  pattern: Scalars["String"]["output"];
};

/** Parameters to be used for the tag_name_pattern rule */
export type TagNamePatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The operator to use for matching. */
  operator: Scalars["String"]["input"];
  /** The pattern to match with. */
  pattern: Scalars["String"]["input"];
};

/** A team of users in an organization. */
export type Team = MemberStatusable &
  Node &
  Subscribable & {
    __typename?: "Team";
    /** A list of teams that are ancestors of this team. */
    ancestors: TeamConnection;
    /** A URL pointing to the team's avatar. */
    avatarUrl?: Maybe<Scalars["URI"]["output"]>;
    /** List of child teams belonging to this team */
    childTeams: TeamConnection;
    /** The slug corresponding to the organization and team. */
    combinedSlug: Scalars["String"]["output"];
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The description of the team. */
    description?: Maybe<Scalars["String"]["output"]>;
    /** Find a team discussion by its number. */
    discussion?: Maybe<TeamDiscussion>;
    /** A list of team discussions. */
    discussions: TeamDiscussionConnection;
    /** The HTTP path for team discussions */
    discussionsResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for team discussions */
    discussionsUrl: Scalars["URI"]["output"];
    /** The HTTP path for editing this team */
    editTeamResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for editing this team */
    editTeamUrl: Scalars["URI"]["output"];
    /** The Node ID of the Team object */
    id: Scalars["ID"]["output"];
    /** A list of pending invitations for users to this team */
    invitations?: Maybe<OrganizationInvitationConnection>;
    /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
    memberStatuses: UserStatusConnection;
    /** A list of users who are members of this team. */
    members: TeamMemberConnection;
    /** The HTTP path for the team' members */
    membersResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for the team' members */
    membersUrl: Scalars["URI"]["output"];
    /** The name of the team. */
    name: Scalars["String"]["output"];
    /** The HTTP path creating a new team */
    newTeamResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL creating a new team */
    newTeamUrl: Scalars["URI"]["output"];
    /** The notification setting that the team has set. */
    notificationSetting: TeamNotificationSetting;
    /** The organization that owns this team. */
    organization: Organization;
    /** The parent team of the team. */
    parentTeam?: Maybe<Team>;
    /** The level of privacy the team has. */
    privacy: TeamPrivacy;
    /** Finds and returns the project according to the provided project number. */
    projectV2?: Maybe<ProjectV2>;
    /** List of projects this team has collaborator access to. */
    projectsV2: ProjectV2Connection;
    /** A list of repositories this team has access to. */
    repositories: TeamRepositoryConnection;
    /** The HTTP path for this team's repositories */
    repositoriesResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for this team's repositories */
    repositoriesUrl: Scalars["URI"]["output"];
    /** The HTTP path for this team */
    resourcePath: Scalars["URI"]["output"];
    /** What algorithm is used for review assignment for this team */
    reviewRequestDelegationAlgorithm?: Maybe<TeamReviewAssignmentAlgorithm>;
    /** True if review assignment is enabled for this team */
    reviewRequestDelegationEnabled: Scalars["Boolean"]["output"];
    /** How many team members are required for review assignment for this team */
    reviewRequestDelegationMemberCount?: Maybe<Scalars["Int"]["output"]>;
    /** When assigning team members via delegation, whether the entire team should be notified as well. */
    reviewRequestDelegationNotifyTeam: Scalars["Boolean"]["output"];
    /** The slug corresponding to the team. */
    slug: Scalars["String"]["output"];
    /** The HTTP path for this team's teams */
    teamsResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for this team's teams */
    teamsUrl: Scalars["URI"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this team */
    url: Scalars["URI"]["output"];
    /** Team is adminable by the viewer. */
    viewerCanAdminister: Scalars["Boolean"]["output"];
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe: Scalars["Boolean"]["output"];
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: Maybe<SubscriptionState>;
  };

/** A team of users in an organization. */
export type TeamAncestorsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A team of users in an organization. */
export type TeamAvatarUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A team of users in an organization. */
export type TeamChildTeamsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  immediateOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<TeamOrder>;
  userLogins?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** A team of users in an organization. */
export type TeamDiscussionArgs = {
  number: Scalars["Int"]["input"];
};

/** A team of users in an organization. */
export type TeamDiscussionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  isPinned?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<TeamDiscussionOrder>;
};

/** A team of users in an organization. */
export type TeamInvitationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A team of users in an organization. */
export type TeamMemberStatusesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<UserStatusOrder>;
};

/** A team of users in an organization. */
export type TeamMembersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  membership?: InputMaybe<TeamMembershipType>;
  orderBy?: InputMaybe<TeamMemberOrder>;
  query?: InputMaybe<Scalars["String"]["input"]>;
  role?: InputMaybe<TeamMemberRole>;
};

/** A team of users in an organization. */
export type TeamProjectV2Args = {
  number: Scalars["Int"]["input"];
};

/** A team of users in an organization. */
export type TeamProjectsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filterBy?: InputMaybe<ProjectV2Filters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  minPermissionLevel?: InputMaybe<ProjectV2PermissionLevel>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** A team of users in an organization. */
export type TeamRepositoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<TeamRepositoryOrder>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** Audit log entry for a team.add_member event. */
export type TeamAddMemberAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  TeamAuditEntryData & {
    __typename?: "TeamAddMemberAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the TeamAddMemberAuditEntry object */
    id: Scalars["ID"]["output"];
    /** Whether the team was mapped to an LDAP Group. */
    isLdapMapped?: Maybe<Scalars["Boolean"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The team associated with the action */
    team?: Maybe<Team>;
    /** The name of the team */
    teamName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for this team */
    teamResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for this team */
    teamUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a team.add_repository event. */
export type TeamAddRepositoryAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData &
  TeamAuditEntryData & {
    __typename?: "TeamAddRepositoryAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the TeamAddRepositoryAuditEntry object */
    id: Scalars["ID"]["output"];
    /** Whether the team was mapped to an LDAP Group. */
    isLdapMapped?: Maybe<Scalars["Boolean"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The team associated with the action */
    team?: Maybe<Team>;
    /** The name of the team */
    teamName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for this team */
    teamResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for this team */
    teamUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Metadata for an audit entry with action team.* */
export type TeamAuditEntryData = {
  /** The team associated with the action */
  team?: Maybe<Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars["String"]["output"]>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars["URI"]["output"]>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars["URI"]["output"]>;
};

/** Audit log entry for a team.change_parent_team event. */
export type TeamChangeParentTeamAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  TeamAuditEntryData & {
    __typename?: "TeamChangeParentTeamAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the TeamChangeParentTeamAuditEntry object */
    id: Scalars["ID"]["output"];
    /** Whether the team was mapped to an LDAP Group. */
    isLdapMapped?: Maybe<Scalars["Boolean"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The new parent team. */
    parentTeam?: Maybe<Team>;
    /** The name of the new parent team */
    parentTeamName?: Maybe<Scalars["String"]["output"]>;
    /** The name of the former parent team */
    parentTeamNameWas?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the parent team */
    parentTeamResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the parent team */
    parentTeamUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The former parent team. */
    parentTeamWas?: Maybe<Team>;
    /** The HTTP path for the previous parent team */
    parentTeamWasResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the previous parent team */
    parentTeamWasUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The team associated with the action */
    team?: Maybe<Team>;
    /** The name of the team */
    teamName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for this team */
    teamResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for this team */
    teamUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** The connection type for Team. */
export type TeamConnection = {
  __typename?: "TeamConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TeamEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Team>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** A team discussion. */
export type TeamDiscussion = Comment &
  Deletable &
  Node &
  Reactable &
  Subscribable &
  UniformResourceLocatable &
  Updatable &
  UpdatableComment & {
    __typename?: "TeamDiscussion";
    /** The actor who authored the comment. */
    author?: Maybe<Actor>;
    /**
     * Author's association with the discussion's team.
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    authorAssociation: CommentAuthorAssociation;
    /** The body as Markdown. */
    body: Scalars["String"]["output"];
    /** The body rendered to HTML. */
    bodyHTML: Scalars["HTML"]["output"];
    /** The body rendered to text. */
    bodyText: Scalars["String"]["output"];
    /**
     * Identifies the discussion body hash.
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    bodyVersion: Scalars["String"]["output"];
    /**
     * A list of comments on this discussion.
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    comments: TeamDiscussionCommentConnection;
    /**
     * The HTTP path for discussion comments
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    commentsResourcePath: Scalars["URI"]["output"];
    /**
     * The HTTP URL for discussion comments
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    commentsUrl: Scalars["URI"]["output"];
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail: Scalars["Boolean"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The actor who edited the comment. */
    editor?: Maybe<Actor>;
    /** The Node ID of the TeamDiscussion object */
    id: Scalars["ID"]["output"];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit: Scalars["Boolean"]["output"];
    /**
     * Whether or not the discussion is pinned.
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    isPinned: Scalars["Boolean"]["output"];
    /**
     * Whether or not the discussion is only visible to team members and organization owners.
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    isPrivate: Scalars["Boolean"]["output"];
    /** The moment the editor made the last edit */
    lastEditedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /**
     * Identifies the discussion within its team.
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    number: Scalars["Int"]["output"];
    /** Identifies when the comment was published at. */
    publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: Maybe<Array<ReactionGroup>>;
    /** A list of Reactions left on the Issue. */
    reactions: ReactionConnection;
    /**
     * The HTTP path for this discussion
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    resourcePath: Scalars["URI"]["output"];
    /**
     * The team that defines the context of this discussion.
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    team: Team;
    /**
     * The title of the discussion
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    title: Scalars["String"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /**
     * The HTTP URL for this discussion
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    url: Scalars["URI"]["output"];
    /** A list of edits to this content. */
    userContentEdits?: Maybe<UserContentEditConnection>;
    /** Check if the current viewer can delete this object. */
    viewerCanDelete: Scalars["Boolean"]["output"];
    /**
     * Whether or not the current viewer can pin this discussion.
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    viewerCanPin: Scalars["Boolean"]["output"];
    /** Can user react to this subject */
    viewerCanReact: Scalars["Boolean"]["output"];
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
    /** Did the viewer author this comment. */
    viewerDidAuthor: Scalars["Boolean"]["output"];
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: Maybe<SubscriptionState>;
  };

/** A team discussion. */
export type TeamDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  fromComment?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<TeamDiscussionCommentOrder>;
};

/** A team discussion. */
export type TeamDiscussionReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** A team discussion. */
export type TeamDiscussionUserContentEditsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A comment on a team discussion. */
export type TeamDiscussionComment = Comment &
  Deletable &
  Node &
  Reactable &
  UniformResourceLocatable &
  Updatable &
  UpdatableComment & {
    __typename?: "TeamDiscussionComment";
    /** The actor who authored the comment. */
    author?: Maybe<Actor>;
    /**
     * Author's association with the comment's team.
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    authorAssociation: CommentAuthorAssociation;
    /** The body as Markdown. */
    body: Scalars["String"]["output"];
    /** The body rendered to HTML. */
    bodyHTML: Scalars["HTML"]["output"];
    /** The body rendered to text. */
    bodyText: Scalars["String"]["output"];
    /**
     * The current version of the body content.
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    bodyVersion: Scalars["String"]["output"];
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail: Scalars["Boolean"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /**
     * The discussion this comment is about.
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    discussion: TeamDiscussion;
    /** The actor who edited the comment. */
    editor?: Maybe<Actor>;
    /** The Node ID of the TeamDiscussionComment object */
    id: Scalars["ID"]["output"];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit: Scalars["Boolean"]["output"];
    /** The moment the editor made the last edit */
    lastEditedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /**
     * Identifies the comment number.
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    number: Scalars["Int"]["output"];
    /** Identifies when the comment was published at. */
    publishedAt?: Maybe<Scalars["DateTime"]["output"]>;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: Maybe<Array<ReactionGroup>>;
    /** A list of Reactions left on the Issue. */
    reactions: ReactionConnection;
    /**
     * The HTTP path for this comment
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    resourcePath: Scalars["URI"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /**
     * The HTTP URL for this comment
     * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
     */
    url: Scalars["URI"]["output"];
    /** A list of edits to this content. */
    userContentEdits?: Maybe<UserContentEditConnection>;
    /** Check if the current viewer can delete this object. */
    viewerCanDelete: Scalars["Boolean"]["output"];
    /** Can user react to this subject */
    viewerCanReact: Scalars["Boolean"]["output"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: Scalars["Boolean"]["output"];
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
    /** Did the viewer author this comment. */
    viewerDidAuthor: Scalars["Boolean"]["output"];
  };

/** A comment on a team discussion. */
export type TeamDiscussionCommentReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** A comment on a team discussion. */
export type TeamDiscussionCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for TeamDiscussionComment. */
export type TeamDiscussionCommentConnection = {
  __typename?: "TeamDiscussionCommentConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TeamDiscussionCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TeamDiscussionComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type TeamDiscussionCommentEdge = {
  __typename?: "TeamDiscussionCommentEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<TeamDiscussionComment>;
};

/** Ways in which team discussion comment connections can be ordered. */
export type TeamDiscussionCommentOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field by which to order nodes. */
  field: TeamDiscussionCommentOrderField;
};

/** Properties by which team discussion comment connections can be ordered. */
export enum TeamDiscussionCommentOrderField {
  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */
  Number = "NUMBER",
}

/** The connection type for TeamDiscussion. */
export type TeamDiscussionConnection = {
  __typename?: "TeamDiscussionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TeamDiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TeamDiscussion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type TeamDiscussionEdge = {
  __typename?: "TeamDiscussionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<TeamDiscussion>;
};

/** Ways in which team discussion connections can be ordered. */
export type TeamDiscussionOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field by which to order nodes. */
  field: TeamDiscussionOrderField;
};

/** Properties by which team discussion connections can be ordered. */
export enum TeamDiscussionOrderField {
  /** Allows chronological ordering of team discussions. */
  CreatedAt = "CREATED_AT",
}

/** An edge in a connection. */
export type TeamEdge = {
  __typename?: "TeamEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Team>;
};

/** The connection type for User. */
export type TeamMemberConnection = {
  __typename?: "TeamMemberConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TeamMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Represents a user who is a member of a team. */
export type TeamMemberEdge = {
  __typename?: "TeamMemberEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The HTTP path to the organization's member access page. */
  memberAccessResourcePath: Scalars["URI"]["output"];
  /** The HTTP URL to the organization's member access page. */
  memberAccessUrl: Scalars["URI"]["output"];
  node: User;
  /** The role the member has on the team. */
  role: TeamMemberRole;
};

/** Ordering options for team member connections */
export type TeamMemberOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order team members by. */
  field: TeamMemberOrderField;
};

/** Properties by which team member connections can be ordered. */
export enum TeamMemberOrderField {
  /** Order team members by creation time */
  CreatedAt = "CREATED_AT",
  /** Order team members by login */
  Login = "LOGIN",
}

/** The possible team member roles; either 'maintainer' or 'member'. */
export enum TeamMemberRole {
  /** A team maintainer has permission to add and remove team members. */
  Maintainer = "MAINTAINER",
  /** A team member has no administrative permissions on the team. */
  Member = "MEMBER",
}

/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
export enum TeamMembershipType {
  /** Includes immediate and child team members for the team. */
  All = "ALL",
  /** Includes only child team members for the team. */
  ChildTeam = "CHILD_TEAM",
  /** Includes only immediate members of the team. */
  Immediate = "IMMEDIATE",
}

/** The possible team notification values. */
export enum TeamNotificationSetting {
  /** No one will receive notifications. */
  NotificationsDisabled = "NOTIFICATIONS_DISABLED",
  /** Everyone will receive notifications when the team is @mentioned. */
  NotificationsEnabled = "NOTIFICATIONS_ENABLED",
}

/** Ways in which team connections can be ordered. */
export type TeamOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field in which to order nodes by. */
  field: TeamOrderField;
};

/** Properties by which team connections can be ordered. */
export enum TeamOrderField {
  /** Allows ordering a list of teams by name. */
  Name = "NAME",
}

/** The possible team privacy values. */
export enum TeamPrivacy {
  /** A secret team can only be seen by its members. */
  Secret = "SECRET",
  /** A visible team can be seen and @mentioned by every member of the organization. */
  Visible = "VISIBLE",
}

/** Audit log entry for a team.remove_member event. */
export type TeamRemoveMemberAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  TeamAuditEntryData & {
    __typename?: "TeamRemoveMemberAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the TeamRemoveMemberAuditEntry object */
    id: Scalars["ID"]["output"];
    /** Whether the team was mapped to an LDAP Group. */
    isLdapMapped?: Maybe<Scalars["Boolean"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The team associated with the action */
    team?: Maybe<Team>;
    /** The name of the team */
    teamName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for this team */
    teamResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for this team */
    teamUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** Audit log entry for a team.remove_repository event. */
export type TeamRemoveRepositoryAuditEntry = AuditEntry &
  Node &
  OrganizationAuditEntryData &
  RepositoryAuditEntryData &
  TeamAuditEntryData & {
    __typename?: "TeamRemoveRepositoryAuditEntry";
    /** The action name */
    action: Scalars["String"]["output"];
    /** The user who initiated the action */
    actor?: Maybe<AuditEntryActor>;
    /** The IP address of the actor */
    actorIp?: Maybe<Scalars["String"]["output"]>;
    /** A readable representation of the actor's location */
    actorLocation?: Maybe<ActorLocation>;
    /** The username of the user who initiated the action */
    actorLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the actor. */
    actorResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the actor. */
    actorUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The time the action was initiated */
    createdAt: Scalars["PreciseDateTime"]["output"];
    /** The Node ID of the TeamRemoveRepositoryAuditEntry object */
    id: Scalars["ID"]["output"];
    /** Whether the team was mapped to an LDAP Group. */
    isLdapMapped?: Maybe<Scalars["Boolean"]["output"]>;
    /** The corresponding operation type for the action */
    operationType?: Maybe<OperationType>;
    /** The Organization associated with the Audit Entry. */
    organization?: Maybe<Organization>;
    /** The name of the Organization. */
    organizationName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the organization */
    organizationResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the organization */
    organizationUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The repository associated with the action */
    repository?: Maybe<Repository>;
    /** The name of the repository */
    repositoryName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the repository */
    repositoryResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the repository */
    repositoryUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The team associated with the action */
    team?: Maybe<Team>;
    /** The name of the team */
    teamName?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for this team */
    teamResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for this team */
    teamUrl?: Maybe<Scalars["URI"]["output"]>;
    /** The user affected by the action */
    user?: Maybe<User>;
    /** For actions involving two users, the actor is the initiator and the user is the affected user. */
    userLogin?: Maybe<Scalars["String"]["output"]>;
    /** The HTTP path for the user. */
    userResourcePath?: Maybe<Scalars["URI"]["output"]>;
    /** The HTTP URL for the user. */
    userUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** The connection type for Repository. */
export type TeamRepositoryConnection = {
  __typename?: "TeamRepositoryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TeamRepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Represents a team repository. */
export type TeamRepositoryEdge = {
  __typename?: "TeamRepositoryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  node: Repository;
  /** The permission level the team has on the repository */
  permission: RepositoryPermission;
};

/** Ordering options for team repository connections */
export type TeamRepositoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: TeamRepositoryOrderField;
};

/** Properties by which team repository connections can be ordered. */
export enum TeamRepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = "CREATED_AT",
  /** Order repositories by name */
  Name = "NAME",
  /** Order repositories by permission */
  Permission = "PERMISSION",
  /** Order repositories by push time */
  PushedAt = "PUSHED_AT",
  /** Order repositories by number of stargazers */
  Stargazers = "STARGAZERS",
  /** Order repositories by update time */
  UpdatedAt = "UPDATED_AT",
}

/** The possible team review assignment algorithms */
export enum TeamReviewAssignmentAlgorithm {
  /** Balance review load across the entire team */
  LoadBalance = "LOAD_BALANCE",
  /** Alternate reviews between each team member */
  RoundRobin = "ROUND_ROBIN",
}

/** The role of a user on a team. */
export enum TeamRole {
  /** User has admin rights on the team. */
  Admin = "ADMIN",
  /** User is a member of the team. */
  Member = "MEMBER",
}

/** A text match within a search result. */
export type TextMatch = {
  __typename?: "TextMatch";
  /** The specific text fragment within the property matched on. */
  fragment: Scalars["String"]["output"];
  /** Highlights within the matched fragment. */
  highlights: Array<TextMatchHighlight>;
  /** The property matched on. */
  property: Scalars["String"]["output"];
};

/** Represents a single highlight in a search result match. */
export type TextMatchHighlight = {
  __typename?: "TextMatchHighlight";
  /** The indice in the fragment where the matched text begins. */
  beginIndice: Scalars["Int"]["output"];
  /** The indice in the fragment where the matched text ends. */
  endIndice: Scalars["Int"]["output"];
  /** The text matched. */
  text: Scalars["String"]["output"];
};

/** The possible states of a thread subscription form action */
export enum ThreadSubscriptionFormAction {
  /** The User cannot subscribe or unsubscribe to the thread */
  None = "NONE",
  /** The User can subscribe to the thread */
  Subscribe = "SUBSCRIBE",
  /** The User can unsubscribe to the thread */
  Unsubscribe = "UNSUBSCRIBE",
}

/** The possible states of a subscription. */
export enum ThreadSubscriptionState {
  /** The subscription status is currently disabled. */
  Disabled = "DISABLED",
  /** The User is never notified because they are ignoring the list */
  IgnoringList = "IGNORING_LIST",
  /** The User is never notified because they are ignoring the thread */
  IgnoringThread = "IGNORING_THREAD",
  /** The User is not recieving notifications from this thread */
  None = "NONE",
  /** The User is notified becuase they are watching the list */
  SubscribedToList = "SUBSCRIBED_TO_LIST",
  /** The User is notified because they are subscribed to the thread */
  SubscribedToThread = "SUBSCRIBED_TO_THREAD",
  /** The User is notified because they chose custom settings for this thread. */
  SubscribedToThreadEvents = "SUBSCRIBED_TO_THREAD_EVENTS",
  /** The User is notified because they chose custom settings for this thread. */
  SubscribedToThreadType = "SUBSCRIBED_TO_THREAD_TYPE",
  /** The subscription status is currently unavailable. */
  Unavailable = "UNAVAILABLE",
}

/** A topic aggregates entities that are related to a subject. */
export type Topic = Node &
  Starrable & {
    __typename?: "Topic";
    /** The Node ID of the Topic object */
    id: Scalars["ID"]["output"];
    /** The topic's name. */
    name: Scalars["String"]["output"];
    /**
     * A list of related topics, including aliases of this topic, sorted with the most relevant
     * first. Returns up to 10 Topics.
     */
    relatedTopics: Array<Topic>;
    /** A list of repositories. */
    repositories: RepositoryConnection;
    /** Returns a count of how many stargazers there are on this object */
    stargazerCount: Scalars["Int"]["output"];
    /** A list of users who have starred this starrable. */
    stargazers: StargazerConnection;
    /** Returns a boolean indicating whether the viewing user has starred this starrable. */
    viewerHasStarred: Scalars["Boolean"]["output"];
  };

/** A topic aggregates entities that are related to a subject. */
export type TopicRelatedTopicsArgs = {
  first?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A topic aggregates entities that are related to a subject. */
export type TopicRepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  hasIssuesEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  isLocked?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
  sponsorableOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  visibility?: InputMaybe<RepositoryVisibility>;
};

/** A topic aggregates entities that are related to a subject. */
export type TopicStargazersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<StarOrder>;
};

/** Metadata for an audit entry with a topic. */
export type TopicAuditEntryData = {
  /** The name of the topic added to the repository */
  topic?: Maybe<Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars["String"]["output"]>;
};

/** Reason that the suggested topic is declined. */
export enum TopicSuggestionDeclineReason {
  /**
   * The suggested topic is not relevant to the repository.
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  NotRelevant = "NOT_RELEVANT",
  /**
   * The viewer does not like the suggested topic.
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  PersonalPreference = "PERSONAL_PREFERENCE",
  /**
   * The suggested topic is too general for the repository.
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  TooGeneral = "TOO_GENERAL",
  /**
   * The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1).
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  TooSpecific = "TOO_SPECIFIC",
}

/** The possible states of a tracked issue. */
export enum TrackedIssueStates {
  /** The tracked issue is closed */
  Closed = "CLOSED",
  /** The tracked issue is open */
  Open = "OPEN",
}

/** Autogenerated input type of TransferEnterpriseOrganization */
export type TransferEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise where the organization should be transferred. */
  destinationEnterpriseId: Scalars["ID"]["input"];
  /** The ID of the organization to transfer. */
  organizationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of TransferEnterpriseOrganization. */
export type TransferEnterpriseOrganizationPayload = {
  __typename?: "TransferEnterpriseOrganizationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The organization for which a transfer was initiated. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of TransferIssue */
export type TransferIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether to create labels if they don't exist in the target repository (matched by name) */
  createLabelsIfMissing?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The Node ID of the issue to be transferred */
  issueId: Scalars["ID"]["input"];
  /** The Node ID of the repository the issue should be transferred to */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of TransferIssue. */
export type TransferIssuePayload = {
  __typename?: "TransferIssuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The issue that was transferred */
  issue?: Maybe<Issue>;
};

/** Represents a 'transferred' event on a given issue or pull request. */
export type TransferredEvent = Node & {
  __typename?: "TransferredEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The repository this came from */
  fromRepository?: Maybe<Repository>;
  /** The Node ID of the TransferredEvent object */
  id: Scalars["ID"]["output"];
  /** Identifies the issue associated with the event. */
  issue: Issue;
};

/** Represents a Git tree. */
export type Tree = GitObject &
  Node & {
    __typename?: "Tree";
    /** An abbreviated version of the Git object ID */
    abbreviatedOid: Scalars["String"]["output"];
    /** The HTTP path for this Git object */
    commitResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL for this Git object */
    commitUrl: Scalars["URI"]["output"];
    /** A list of tree entries. */
    entries?: Maybe<Array<TreeEntry>>;
    /** The Node ID of the Tree object */
    id: Scalars["ID"]["output"];
    /** The Git object ID */
    oid: Scalars["GitObjectID"]["output"];
    /** The Repository the Git object belongs to */
    repository: Repository;
  };

/** Represents a Git tree entry. */
export type TreeEntry = {
  __typename?: "TreeEntry";
  /** The extension of the file */
  extension?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not this tree entry is generated */
  isGenerated: Scalars["Boolean"]["output"];
  /** The programming language this file is written in. */
  language?: Maybe<Language>;
  /** Number of lines in the file. */
  lineCount?: Maybe<Scalars["Int"]["output"]>;
  /** Entry file mode. */
  mode: Scalars["Int"]["output"];
  /** Entry file name. */
  name: Scalars["String"]["output"];
  /** Entry file name. (Base64-encoded) */
  nameRaw: Scalars["Base64String"]["output"];
  /** Entry file object. */
  object?: Maybe<GitObject>;
  /** Entry file Git object ID. */
  oid: Scalars["GitObjectID"]["output"];
  /** The full path of the file. */
  path?: Maybe<Scalars["String"]["output"]>;
  /** The full path of the file. (Base64-encoded) */
  pathRaw?: Maybe<Scalars["Base64String"]["output"]>;
  /** The Repository the tree entry belongs to */
  repository: Repository;
  /** Entry byte size */
  size: Scalars["Int"]["output"];
  /** If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule */
  submodule?: Maybe<Submodule>;
  /** Entry file type. */
  type: Scalars["String"]["output"];
};

/** Autogenerated input type of UnarchiveProjectV2Item */
export type UnarchiveProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the ProjectV2Item to unarchive. */
  itemId: Scalars["ID"]["input"];
  /** The ID of the Project to archive the item from. */
  projectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnarchiveProjectV2Item. */
export type UnarchiveProjectV2ItemPayload = {
  __typename?: "UnarchiveProjectV2ItemPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The item unarchived from the project. */
  item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of UnarchiveRepository */
export type UnarchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the repository to unarchive. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnarchiveRepository. */
export type UnarchiveRepositoryPayload = {
  __typename?: "UnarchiveRepositoryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The repository that was unarchived. */
  repository?: Maybe<Repository>;
};

/** Represents an 'unassigned' event on any assignable object. */
export type UnassignedEvent = Node & {
  __typename?: "UnassignedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the assignable associated with the event. */
  assignable: Assignable;
  /** Identifies the user or mannequin that was unassigned. */
  assignee?: Maybe<Assignee>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the UnassignedEvent object */
  id: Scalars["ID"]["output"];
  /**
   * Identifies the subject (user) who was unassigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  user?: Maybe<User>;
};

/** Autogenerated input type of UnfollowOrganization */
export type UnfollowOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the organization to unfollow. */
  organizationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnfollowOrganization. */
export type UnfollowOrganizationPayload = {
  __typename?: "UnfollowOrganizationPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The organization that was unfollowed. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of UnfollowUser */
export type UnfollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the user to unfollow. */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnfollowUser. */
export type UnfollowUserPayload = {
  __typename?: "UnfollowUserPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The user that was unfollowed. */
  user?: Maybe<User>;
};

/** Represents a type that can be retrieved by a URL. */
export type UniformResourceLocatable = {
  /** The HTML path to this resource. */
  resourcePath: Scalars["URI"]["output"];
  /** The URL to this resource. */
  url: Scalars["URI"]["output"];
};

/** Represents an unknown signature on a Commit or Tag. */
export type UnknownSignature = GitSignature & {
  __typename?: "UnknownSignature";
  /** Email used to sign this object. */
  email: Scalars["String"]["output"];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars["Boolean"]["output"];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars["String"]["output"];
  /** ASCII-armored signature header from object. */
  signature: Scalars["String"]["output"];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars["Boolean"]["output"];
};

/** Represents an 'unlabeled' event on a given issue or pull request. */
export type UnlabeledEvent = Node & {
  __typename?: "UnlabeledEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the UnlabeledEvent object */
  id: Scalars["ID"]["output"];
  /** Identifies the label associated with the 'unlabeled' event. */
  label: Label;
  /** Identifies the `Labelable` associated with the event. */
  labelable: Labelable;
};

/** Autogenerated input type of UnlinkProjectV2FromRepository */
export type UnlinkProjectV2FromRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the project to unlink from the repository. */
  projectId: Scalars["ID"]["input"];
  /** The ID of the repository to unlink from the project. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnlinkProjectV2FromRepository. */
export type UnlinkProjectV2FromRepositoryPayload = {
  __typename?: "UnlinkProjectV2FromRepositoryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The repository the project is no longer linked to. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of UnlinkProjectV2FromTeam */
export type UnlinkProjectV2FromTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the project to unlink from the team. */
  projectId: Scalars["ID"]["input"];
  /** The ID of the team to unlink from the project. */
  teamId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnlinkProjectV2FromTeam. */
export type UnlinkProjectV2FromTeamPayload = {
  __typename?: "UnlinkProjectV2FromTeamPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The team the project is unlinked from */
  team?: Maybe<Team>;
};

/** Autogenerated input type of UnlinkRepositoryFromProject */
export type UnlinkRepositoryFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Project linked to the Repository. */
  projectId: Scalars["ID"]["input"];
  /** The ID of the Repository linked to the Project. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnlinkRepositoryFromProject. */
export type UnlinkRepositoryFromProjectPayload = {
  __typename?: "UnlinkRepositoryFromProjectPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The linked Project. */
  project?: Maybe<Project>;
  /** The linked Repository. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of UnlockLockable */
export type UnlockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the item to be unlocked. */
  lockableId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnlockLockable. */
export type UnlockLockablePayload = {
  __typename?: "UnlockLockablePayload";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The item that was unlocked. */
  unlockedRecord?: Maybe<Lockable>;
};

/** Represents an 'unlocked' event on a given issue or pull request. */
export type UnlockedEvent = Node & {
  __typename?: "UnlockedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the UnlockedEvent object */
  id: Scalars["ID"]["output"];
  /** Object that was unlocked. */
  lockable: Lockable;
};

/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */
export type UnmarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the discussion comment to unmark as an answer. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnmarkDiscussionCommentAsAnswer. */
export type UnmarkDiscussionCommentAsAnswerPayload = {
  __typename?: "UnmarkDiscussionCommentAsAnswerPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The discussion that includes the comment. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of UnmarkFileAsViewed */
export type UnmarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The path of the file to mark as unviewed */
  path: Scalars["String"]["input"];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnmarkFileAsViewed. */
export type UnmarkFileAsViewedPayload = {
  __typename?: "UnmarkFileAsViewedPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated pull request. */
  pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of UnmarkIssueAsDuplicate */
export type UnmarkIssueAsDuplicateInput = {
  /** ID of the issue or pull request currently considered canonical/authoritative/original. */
  canonicalId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** ID of the issue or pull request currently marked as a duplicate. */
  duplicateId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnmarkIssueAsDuplicate. */
export type UnmarkIssueAsDuplicatePayload = {
  __typename?: "UnmarkIssueAsDuplicatePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The issue or pull request that was marked as a duplicate. */
  duplicate?: Maybe<IssueOrPullRequest>;
};

/** Autogenerated input type of UnmarkProjectV2AsTemplate */
export type UnmarkProjectV2AsTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Project to unmark as a template. */
  projectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnmarkProjectV2AsTemplate. */
export type UnmarkProjectV2AsTemplatePayload = {
  __typename?: "UnmarkProjectV2AsTemplatePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The project. */
  projectV2?: Maybe<ProjectV2>;
};

/** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
export type UnmarkedAsDuplicateEvent = Node & {
  __typename?: "UnmarkedAsDuplicateEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** The authoritative issue or pull request which has been duplicated by another. */
  canonical?: Maybe<IssueOrPullRequest>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The issue or pull request which has been marked as a duplicate of another. */
  duplicate?: Maybe<IssueOrPullRequest>;
  /** The Node ID of the UnmarkedAsDuplicateEvent object */
  id: Scalars["ID"]["output"];
  /** Canonical and duplicate belong to different repositories. */
  isCrossRepository: Scalars["Boolean"]["output"];
};

/** Autogenerated input type of UnminimizeComment */
export type UnminimizeCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnminimizeComment. */
export type UnminimizeCommentPayload = {
  __typename?: "UnminimizeCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The comment that was unminimized. */
  unminimizedComment?: Maybe<Minimizable>;
};

/** Autogenerated input type of UnpinIssue */
export type UnpinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the issue to be unpinned */
  issueId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnpinIssue. */
export type UnpinIssuePayload = {
  __typename?: "UnpinIssuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The id of the pinned issue that was unpinned */
  id?: Maybe<Scalars["ID"]["output"]>;
  /** The issue that was unpinned */
  issue?: Maybe<Issue>;
};

/** Represents an 'unpinned' event on a given issue or pull request. */
export type UnpinnedEvent = Node & {
  __typename?: "UnpinnedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the UnpinnedEvent object */
  id: Scalars["ID"]["output"];
  /** Identifies the issue associated with the event. */
  issue: Issue;
};

/** Autogenerated input type of UnresolveReviewThread */
export type UnresolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the thread to unresolve */
  threadId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UnresolveReviewThread. */
export type UnresolveReviewThreadPayload = {
  __typename?: "UnresolveReviewThreadPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The thread to resolve. */
  thread?: Maybe<PullRequestReviewThread>;
};

/** Autogenerated input type of UnsubscribeFromNotifications */
export type UnsubscribeFromNotificationsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The NotificationThread IDs of the objects to unsubscribe from. */
  ids: Array<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of UnsubscribeFromNotifications. */
export type UnsubscribeFromNotificationsPayload = {
  __typename?: "UnsubscribeFromNotificationsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars["Boolean"]["output"]>;
};

/** Represents an 'unsubscribed' event on a given `Subscribable`. */
export type UnsubscribedEvent = Node & {
  __typename?: "UnsubscribedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the UnsubscribedEvent object */
  id: Scalars["ID"]["output"];
  /** Object referenced by event. */
  subscribable: Subscribable;
};

/** Entities that can be updated. */
export type Updatable = {
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars["Boolean"]["output"];
};

/** Comments that can be updated. */
export type UpdatableComment = {
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
};

/** Autogenerated input type of UpdateBranchProtectionRule */
export type UpdateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Is branch creation a protected operation. */
  blocksCreations?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The global relay id of the branch protection rule to be updated. */
  branchProtectionRuleId: Scalars["ID"]["input"];
  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */
  bypassForcePushActorIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */
  bypassPullRequestActorIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Can admins override branch protection. */
  isAdminEnforced?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The glob-like pattern used to determine matching branches. */
  pattern?: InputMaybe<Scalars["String"]["input"]>;
  /** A list of User, Team, or App IDs allowed to push to matching branches. */
  pushActorIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: InputMaybe<Scalars["Int"]["input"]>;
  /** The list of required deployment environments */
  requiredDeploymentEnvironments?: InputMaybe<
    Array<Scalars["String"]["input"]>
  >;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** The list of required status checks */
  requiredStatusChecks?: InputMaybe<Array<RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are successful deployments required before merging. */
  requiresDeployments?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

/** Autogenerated return type of UpdateBranchProtectionRule. */
export type UpdateBranchProtectionRulePayload = {
  __typename?: "UpdateBranchProtectionRulePayload";
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateCheckRun */
export type UpdateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: InputMaybe<Array<CheckRunAction>>;
  /** The node of the check. */
  checkRunId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The time that the check run finished. */
  completedAt?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** The final conclusion of the check. */
  conclusion?: InputMaybe<CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: InputMaybe<Scalars["URI"]["input"]>;
  /** A reference for the run on the integrator's system. */
  externalId?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the check. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** Descriptive details about the run. */
  output?: InputMaybe<CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars["ID"]["input"];
  /** The time that the check run began. */
  startedAt?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** The current status. */
  status?: InputMaybe<RequestableCheckStatusState>;
};

/** Autogenerated return type of UpdateCheckRun. */
export type UpdateCheckRunPayload = {
  __typename?: "UpdateCheckRunPayload";
  /** The updated check run. */
  checkRun?: Maybe<CheckRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateCheckSuitePreferences */
export type UpdateCheckSuitePreferencesInput = {
  /** The check suite preferences to modify. */
  autoTriggerPreferences: Array<CheckSuiteAutoTriggerPreference>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the repository. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdateCheckSuitePreferences. */
export type UpdateCheckSuitePreferencesPayload = {
  __typename?: "UpdateCheckSuitePreferencesPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated repository. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of UpdateDiscussionComment */
export type UpdateDiscussionCommentInput = {
  /** The new contents of the comment body. */
  body: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the discussion comment to update. */
  commentId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdateDiscussionComment. */
export type UpdateDiscussionCommentPayload = {
  __typename?: "UpdateDiscussionCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The modified discussion comment. */
  comment?: Maybe<DiscussionComment>;
};

/** Autogenerated input type of UpdateDiscussion */
export type UpdateDiscussionInput = {
  /** The new contents of the discussion body. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of a discussion category within the same repository to change this discussion to. */
  categoryId?: InputMaybe<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the discussion to update. */
  discussionId: Scalars["ID"]["input"];
  /** The new discussion title. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of UpdateDiscussion. */
export type UpdateDiscussionPayload = {
  __typename?: "UpdateDiscussionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The modified discussion. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of UpdateEnterpriseAdministratorRole */
export type UpdateEnterpriseAdministratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars["ID"]["input"];
  /** The login of a administrator whose role is being changed. */
  login: Scalars["String"]["input"];
  /** The new role for the Enterprise administrator. */
  role: EnterpriseAdministratorRole;
};

/** Autogenerated return type of UpdateEnterpriseAdministratorRole. */
export type UpdateEnterpriseAdministratorRolePayload = {
  __typename?: "UpdateEnterpriseAdministratorRolePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** A message confirming the result of changing the administrator's role. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the allow private repository forking setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the allow private repository forking policy on the enterprise. */
  policyValue?: InputMaybe<EnterpriseAllowPrivateRepositoryForkingPolicyValue>;
  /** The value for the allow private repository forking setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting. */
export type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload = {
  __typename?: "UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated allow private repository forking setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the base repository permission setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the base repository permission setting on the enterprise. */
  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting. */
export type UpdateEnterpriseDefaultRepositoryPermissionSettingPayload = {
  __typename?: "UpdateEnterpriseDefaultRepositoryPermissionSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated base repository permission setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the base repository permission setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the members can change repository visibility setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the members can change repository visibility setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting. */
export type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload =
  {
    __typename?: "UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: Maybe<Scalars["String"]["output"]>;
    /** The enterprise with the updated members can change repository visibility setting. */
    enterprise?: Maybe<Enterprise>;
    /** A message confirming the result of updating the members can change repository visibility setting. */
    message?: Maybe<Scalars["String"]["output"]>;
  };

/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** Allow members to create internal repositories. Defaults to current value. */
  membersCanCreateInternalRepositories?: InputMaybe<
    Scalars["Boolean"]["input"]
  >;
  /** Allow members to create private repositories. Defaults to current value. */
  membersCanCreatePrivateRepositories?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Allow members to create public repositories. Defaults to current value. */
  membersCanCreatePublicRepositories?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** When false, allow member organizations to set their own repository creation member privileges. */
  membersCanCreateRepositoriesPolicyEnabled?: InputMaybe<
    Scalars["Boolean"]["input"]
  >;
  /**
   * Value for the members can create repositories setting on the enterprise. This
   * or the granular public/private/internal allowed fields (but not both) must be provided.
   */
  settingValue?: InputMaybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting. */
export type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload = {
  __typename?: "UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated members can create repositories setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can create repositories setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the members can delete issues setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the members can delete issues setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting. */
export type UpdateEnterpriseMembersCanDeleteIssuesSettingPayload = {
  __typename?: "UpdateEnterpriseMembersCanDeleteIssuesSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated members can delete issues setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can delete issues setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the members can delete repositories setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the members can delete repositories setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting. */
export type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload = {
  __typename?: "UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated members can delete repositories setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can delete repositories setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the members can invite collaborators setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the members can invite collaborators setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting. */
export type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload = {
  __typename?: "UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated members can invite collaborators setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can invite collaborators setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type UpdateEnterpriseMembersCanMakePurchasesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the members can make purchases setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the members can make purchases setting on the enterprise. */
  settingValue: EnterpriseMembersCanMakePurchasesSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting. */
export type UpdateEnterpriseMembersCanMakePurchasesSettingPayload = {
  __typename?: "UpdateEnterpriseMembersCanMakePurchasesSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated members can make purchases setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can make purchases setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the members can update protected branches setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the members can update protected branches setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting. */
export type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload = {
  __typename?: "UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated members can update protected branches setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can update protected branches setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the members can view dependency insights setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the members can view dependency insights setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting. */
export type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload = {
  __typename?: "UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated members can view dependency insights setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can view dependency insights setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */
export type UpdateEnterpriseOrganizationProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the organization projects setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the organization projects setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting. */
export type UpdateEnterpriseOrganizationProjectsSettingPayload = {
  __typename?: "UpdateEnterpriseOrganizationProjectsSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated organization projects setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the organization projects setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseOwnerOrganizationRole */
export type UpdateEnterpriseOwnerOrganizationRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Enterprise which the owner belongs to. */
  enterpriseId: Scalars["ID"]["input"];
  /** The ID of the organization for membership change. */
  organizationId: Scalars["ID"]["input"];
  /** The role to assume in the organization. */
  organizationRole: RoleInOrganization;
};

/** Autogenerated return type of UpdateEnterpriseOwnerOrganizationRole. */
export type UpdateEnterpriseOwnerOrganizationRolePayload = {
  __typename?: "UpdateEnterpriseOwnerOrganizationRolePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** A message confirming the result of changing the owner's organization role. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseProfile */
export type UpdateEnterpriseProfileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The description of the enterprise. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** The Enterprise ID to update. */
  enterpriseId: Scalars["ID"]["input"];
  /** The location of the enterprise. */
  location?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the enterprise. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** The URL of the enterprise's website. */
  websiteUrl?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of UpdateEnterpriseProfile. */
export type UpdateEnterpriseProfilePayload = {
  __typename?: "UpdateEnterpriseProfilePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated enterprise. */
  enterprise?: Maybe<Enterprise>;
};

/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */
export type UpdateEnterpriseRepositoryProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the repository projects setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the repository projects setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting. */
export type UpdateEnterpriseRepositoryProjectsSettingPayload = {
  __typename?: "UpdateEnterpriseRepositoryProjectsSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated repository projects setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the repository projects setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */
export type UpdateEnterpriseTeamDiscussionsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the team discussions setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the team discussions setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting. */
export type UpdateEnterpriseTeamDiscussionsSettingPayload = {
  __typename?: "UpdateEnterpriseTeamDiscussionsSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated team discussions setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the team discussions setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the enterprise on which to set the two factor authentication required setting. */
  enterpriseId: Scalars["ID"]["input"];
  /** The value for the two factor authentication required setting on the enterprise. */
  settingValue: EnterpriseEnabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting. */
export type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload = {
  __typename?: "UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The enterprise with the updated two factor authentication required setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the two factor authentication required setting. */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateEnvironment */
export type UpdateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The node ID of the environment. */
  environmentId: Scalars["ID"]["input"];
  /** Whether deployments to this environment can be approved by the user who created the deployment. */
  preventSelfReview?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ids of users or teams that can approve deployments to this environment */
  reviewers?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The wait timer in minutes. */
  waitTimer?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Autogenerated return type of UpdateEnvironment. */
export type UpdateEnvironmentPayload = {
  __typename?: "UpdateEnvironmentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated environment. */
  environment?: Maybe<Environment>;
};

/** Autogenerated input type of UpdateIpAllowListEnabledSetting */
export type UpdateIpAllowListEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the owner on which to set the IP allow list enabled setting. */
  ownerId: Scalars["ID"]["input"];
  /** The value for the IP allow list enabled setting. */
  settingValue: IpAllowListEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListEnabledSetting. */
export type UpdateIpAllowListEnabledSettingPayload = {
  __typename?: "UpdateIpAllowListEnabledSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The IP allow list owner on which the setting was updated. */
  owner?: Maybe<IpAllowListOwner>;
};

/** Autogenerated input type of UpdateIpAllowListEntry */
export type UpdateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the IP allow list entry to update. */
  ipAllowListEntryId: Scalars["ID"]["input"];
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars["Boolean"]["input"];
  /** An optional name for the IP allow list entry. */
  name?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of UpdateIpAllowListEntry. */
export type UpdateIpAllowListEntryPayload = {
  __typename?: "UpdateIpAllowListEntryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The IP allow list entry that was updated. */
  ipAllowListEntry?: Maybe<IpAllowListEntry>;
};

/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */
export type UpdateIpAllowListForInstalledAppsEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the owner. */
  ownerId: Scalars["ID"]["input"];
  /** The value for the IP allow list configuration for installed GitHub Apps setting. */
  settingValue: IpAllowListForInstalledAppsEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListForInstalledAppsEnabledSetting. */
export type UpdateIpAllowListForInstalledAppsEnabledSettingPayload = {
  __typename?: "UpdateIpAllowListForInstalledAppsEnabledSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The IP allow list owner on which the setting was updated. */
  owner?: Maybe<IpAllowListOwner>;
};

/** Autogenerated input type of UpdateIssueComment */
export type UpdateIssueCommentInput = {
  /** The updated text of the comment. */
  body: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the IssueComment to modify. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdateIssueComment. */
export type UpdateIssueCommentPayload = {
  __typename?: "UpdateIssueCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated comment. */
  issueComment?: Maybe<IssueComment>;
};

/** Autogenerated input type of UpdateIssue */
export type UpdateIssueInput = {
  /** An array of Node IDs of users for this issue. */
  assigneeIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The body for the issue description. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Issue to modify. */
  id: Scalars["ID"]["input"];
  /** An array of Node IDs of labels for this issue. */
  labelIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: InputMaybe<Scalars["ID"]["input"]>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The desired issue state. */
  state?: InputMaybe<IssueState>;
  /** The title for the issue. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of UpdateIssue. */
export type UpdateIssuePayload = {
  __typename?: "UpdateIssuePayload";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The issue. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of UpdateLabel */
export type UpdateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */
  color?: InputMaybe<Scalars["String"]["input"]>;
  /** A brief description of the label, such as its purpose. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the label to be updated. */
  id: Scalars["ID"]["input"];
  /** The updated name of the label. */
  name?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of UpdateLabel. */
export type UpdateLabelPayload = {
  __typename?: "UpdateLabelPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated label. */
  label?: Maybe<Label>;
};

/** Autogenerated input type of UpdateNotificationRestrictionSetting */
export type UpdateNotificationRestrictionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the owner on which to set the restrict notifications setting. */
  ownerId: Scalars["ID"]["input"];
  /** The value for the restrict notifications setting. */
  settingValue: NotificationRestrictionSettingValue;
};

/** Autogenerated return type of UpdateNotificationRestrictionSetting. */
export type UpdateNotificationRestrictionSettingPayload = {
  __typename?: "UpdateNotificationRestrictionSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The owner on which the setting was updated. */
  owner?: Maybe<VerifiableDomainOwner>;
};

/** Autogenerated input type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */
export type UpdateOrganizationAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Enable forking of private repositories in the organization? */
  forkingEnabled: Scalars["Boolean"]["input"];
  /** The ID of the organization on which to set the allow private repository forking setting. */
  organizationId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdateOrganizationAllowPrivateRepositoryForkingSetting. */
export type UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload = {
  __typename?: "UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  message?: Maybe<Scalars["String"]["output"]>;
  /** The organization with the updated allow private repository forking setting. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of UpdateOrganizationWebCommitSignoffSetting */
export type UpdateOrganizationWebCommitSignoffSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the organization on which to set the web commit signoff setting. */
  organizationId: Scalars["ID"]["input"];
  /** Enable signoff on web-based commits for repositories in the organization? */
  webCommitSignoffRequired: Scalars["Boolean"]["input"];
};

/** Autogenerated return type of UpdateOrganizationWebCommitSignoffSetting. */
export type UpdateOrganizationWebCommitSignoffSettingPayload = {
  __typename?: "UpdateOrganizationWebCommitSignoffSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** A message confirming the result of updating the web commit signoff setting. */
  message?: Maybe<Scalars["String"]["output"]>;
  /** The organization with the updated web commit signoff setting. */
  organization?: Maybe<Organization>;
};

/** Only allow users with bypass permission to update matching refs. */
export type UpdateParameters = {
  __typename?: "UpdateParameters";
  /** Branch can pull changes from its upstream repository */
  updateAllowsFetchAndMerge: Scalars["Boolean"]["output"];
};

/** Only allow users with bypass permission to update matching refs. */
export type UpdateParametersInput = {
  /** Branch can pull changes from its upstream repository */
  updateAllowsFetchAndMerge: Scalars["Boolean"]["input"];
};

/** Autogenerated input type of UpdatePatreonSponsorability */
export type UpdatePatreonSponsorabilityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * Whether Patreon tiers should be shown on the GitHub Sponsors profile page,
   * allowing potential sponsors to make their payment through Patreon instead of GitHub.
   */
  enablePatreonSponsorships: Scalars["Boolean"]["input"];
  /**
   * The username of the organization with the GitHub Sponsors profile, if any.
   * Defaults to the GitHub Sponsors profile for the authenticated user if omitted.
   */
  sponsorableLogin?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of UpdatePatreonSponsorability. */
export type UpdatePatreonSponsorabilityPayload = {
  __typename?: "UpdatePatreonSponsorabilityPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The GitHub Sponsors profile. */
  sponsorsListing?: Maybe<SponsorsListing>;
};

/** Autogenerated input type of UpdateProjectCard */
export type UpdateProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not the ProjectCard should be archived */
  isArchived?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The note of ProjectCard. */
  note?: InputMaybe<Scalars["String"]["input"]>;
  /** The ProjectCard ID to update. */
  projectCardId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdateProjectCard. */
export type UpdateProjectCardPayload = {
  __typename?: "UpdateProjectCardPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated ProjectCard. */
  projectCard?: Maybe<ProjectCard>;
};

/** Autogenerated input type of UpdateProjectColumn */
export type UpdateProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of project column. */
  name: Scalars["String"]["input"];
  /** The ProjectColumn ID to update. */
  projectColumnId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdateProjectColumn. */
export type UpdateProjectColumnPayload = {
  __typename?: "UpdateProjectColumnPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated project column. */
  projectColumn?: Maybe<ProjectColumn>;
};

/** Autogenerated input type of UpdateProject */
export type UpdateProjectInput = {
  /** The description of project. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of project. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** The Project ID to update. */
  projectId: Scalars["ID"]["input"];
  /** Whether the project is public or not. */
  public?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether the project is open or closed. */
  state?: InputMaybe<ProjectState>;
};

/** Autogenerated return type of UpdateProject. */
export type UpdateProjectPayload = {
  __typename?: "UpdateProjectPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated project. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of UpdateProjectV2Collaborators */
export type UpdateProjectV2CollaboratorsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The collaborators to update. */
  collaborators: Array<ProjectV2Collaborator>;
  /** The ID of the project to update the collaborators for. */
  projectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdateProjectV2Collaborators. */
export type UpdateProjectV2CollaboratorsPayload = {
  __typename?: "UpdateProjectV2CollaboratorsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The collaborators granted a role */
  collaborators?: Maybe<ProjectV2ActorConnection>;
};

/** Autogenerated return type of UpdateProjectV2Collaborators. */
export type UpdateProjectV2CollaboratorsPayloadCollaboratorsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Autogenerated input type of UpdateProjectV2DraftIssue */
export type UpdateProjectV2DraftIssueInput = {
  /** The IDs of the assignees of the draft issue. */
  assigneeIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The body of the draft issue. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the draft issue to update. */
  draftIssueId: Scalars["ID"]["input"];
  /** The title of the draft issue. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of UpdateProjectV2DraftIssue. */
export type UpdateProjectV2DraftIssuePayload = {
  __typename?: "UpdateProjectV2DraftIssuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The draft issue updated in the project. */
  draftIssue?: Maybe<DraftIssue>;
};

/** Autogenerated input type of UpdateProjectV2 */
export type UpdateProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Set the project to closed or open. */
  closed?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the Project to update. */
  projectId: Scalars["ID"]["input"];
  /** Set the project to public or private. */
  public?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Set the readme description of the project. */
  readme?: InputMaybe<Scalars["String"]["input"]>;
  /** Set the short description of the project. */
  shortDescription?: InputMaybe<Scalars["String"]["input"]>;
  /** Set the title of the project. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateProjectV2ItemFieldValue */
export type UpdateProjectV2ItemFieldValueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the field to be updated. */
  fieldId: Scalars["ID"]["input"];
  /** The ID of the item to be updated. */
  itemId: Scalars["ID"]["input"];
  /** The ID of the Project. */
  projectId: Scalars["ID"]["input"];
  /** The value which will be set on the field. */
  value: ProjectV2FieldValue;
};

/** Autogenerated return type of UpdateProjectV2ItemFieldValue. */
export type UpdateProjectV2ItemFieldValuePayload = {
  __typename?: "UpdateProjectV2ItemFieldValuePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated item. */
  projectV2Item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of UpdateProjectV2ItemPosition */
export type UpdateProjectV2ItemPositionInput = {
  /** The ID of the item to position this item after. If omitted or set to null the item will be moved to top. */
  afterId?: InputMaybe<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the item to be moved. */
  itemId: Scalars["ID"]["input"];
  /** The ID of the Project. */
  projectId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdateProjectV2ItemPosition. */
export type UpdateProjectV2ItemPositionPayload = {
  __typename?: "UpdateProjectV2ItemPositionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The items in the new order */
  items?: Maybe<ProjectV2ItemConnection>;
};

/** Autogenerated return type of UpdateProjectV2ItemPosition. */
export type UpdateProjectV2ItemPositionPayloadItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Autogenerated return type of UpdateProjectV2. */
export type UpdateProjectV2Payload = {
  __typename?: "UpdateProjectV2Payload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated Project. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of UpdateProjectV2StatusUpdate */
export type UpdateProjectV2StatusUpdateInput = {
  /** The body of the status update. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The start date of the status update. */
  startDate?: InputMaybe<Scalars["Date"]["input"]>;
  /** The status of the status update. */
  status?: InputMaybe<ProjectV2StatusUpdateStatus>;
  /** The ID of the status update to be updated. */
  statusUpdateId: Scalars["ID"]["input"];
  /** The target date of the status update. */
  targetDate?: InputMaybe<Scalars["Date"]["input"]>;
};

/** Autogenerated return type of UpdateProjectV2StatusUpdate. */
export type UpdateProjectV2StatusUpdatePayload = {
  __typename?: "UpdateProjectV2StatusUpdatePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The status update updated in the project. */
  statusUpdate?: Maybe<ProjectV2StatusUpdate>;
};

/** Autogenerated input type of UpdatePullRequestBranch */
export type UpdatePullRequestBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The head ref oid for the upstream branch. */
  expectedHeadOid?: InputMaybe<Scalars["GitObjectID"]["input"]>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars["ID"]["input"];
  /** The update branch method to use. If omitted, defaults to 'MERGE' */
  updateMethod?: InputMaybe<PullRequestBranchUpdateMethod>;
};

/** Autogenerated return type of UpdatePullRequestBranch. */
export type UpdatePullRequestBranchPayload = {
  __typename?: "UpdatePullRequestBranchPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated pull request. */
  pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of UpdatePullRequest */
export type UpdatePullRequestInput = {
  /** An array of Node IDs of users for this pull request. */
  assigneeIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository.
   */
  baseRefName?: InputMaybe<Scalars["String"]["input"]>;
  /** The contents of the pull request. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** An array of Node IDs of labels for this pull request. */
  labelIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The Node ID of the milestone for this pull request. */
  milestoneId?: InputMaybe<Scalars["ID"]["input"]>;
  /** An array of Node IDs for projects associated with this pull request. */
  projectIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars["ID"]["input"];
  /** The target state of the pull request. */
  state?: InputMaybe<PullRequestUpdateState>;
  /** The title of the pull request. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of UpdatePullRequest. */
export type UpdatePullRequestPayload = {
  __typename?: "UpdatePullRequestPayload";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated pull request. */
  pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of UpdatePullRequestReviewComment */
export type UpdatePullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the comment to modify. */
  pullRequestReviewCommentId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdatePullRequestReviewComment. */
export type UpdatePullRequestReviewCommentPayload = {
  __typename?: "UpdatePullRequestReviewCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated comment. */
  pullRequestReviewComment?: Maybe<PullRequestReviewComment>;
};

/** Autogenerated input type of UpdatePullRequestReview */
export type UpdatePullRequestReviewInput = {
  /** The contents of the pull request review body. */
  body: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdatePullRequestReview. */
export type UpdatePullRequestReviewPayload = {
  __typename?: "UpdatePullRequestReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated pull request review. */
  pullRequestReview?: Maybe<PullRequestReview>;
};

/** Autogenerated input type of UpdateRef */
export type UpdateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Permit updates of branch Refs that are not fast-forwards? */
  force?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The GitObjectID that the Ref shall be updated to target. */
  oid: Scalars["GitObjectID"]["input"];
  /** The Node ID of the Ref to be updated. */
  refId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdateRef. */
export type UpdateRefPayload = {
  __typename?: "UpdateRefPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated Ref. */
  ref?: Maybe<Ref>;
};

/** Autogenerated input type of UpdateRefs */
export type UpdateRefsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A list of ref updates. */
  refUpdates: Array<RefUpdate>;
  /** The Node ID of the repository. */
  repositoryId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdateRefs. */
export type UpdateRefsPayload = {
  __typename?: "UpdateRefsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of UpdateRepository */
export type UpdateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A new description for the repository. Pass an empty string to erase the existing description. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** Indicates if the repository should have the discussions feature enabled. */
  hasDiscussionsEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Indicates if the repository should have the project boards feature enabled. */
  hasProjectsEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Indicates if the repository displays a Sponsor button for financial contributions. */
  hasSponsorshipsEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */
  homepageUrl?: InputMaybe<Scalars["URI"]["input"]>;
  /** The new name of the repository. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the repository to update. */
  repositoryId: Scalars["ID"]["input"];
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Autogenerated return type of UpdateRepository. */
export type UpdateRepositoryPayload = {
  __typename?: "UpdateRepositoryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated repository. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of UpdateRepositoryRuleset */
export type UpdateRepositoryRulesetInput = {
  /** A list of actors that are allowed to bypass rules in this ruleset. */
  bypassActors?: InputMaybe<Array<RepositoryRulesetBypassActorInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The list of conditions for this ruleset */
  conditions?: InputMaybe<RepositoryRuleConditionsInput>;
  /** The enforcement level for this ruleset */
  enforcement?: InputMaybe<RuleEnforcement>;
  /** The name of the ruleset. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** The global relay id of the repository ruleset to be updated. */
  repositoryRulesetId: Scalars["ID"]["input"];
  /** The list of rules for this ruleset */
  rules?: InputMaybe<Array<RepositoryRuleInput>>;
  /** The target of the ruleset. */
  target?: InputMaybe<RepositoryRulesetTarget>;
};

/** Autogenerated return type of UpdateRepositoryRuleset. */
export type UpdateRepositoryRulesetPayload = {
  __typename?: "UpdateRepositoryRulesetPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The newly created Ruleset. */
  ruleset?: Maybe<RepositoryRuleset>;
};

/** Autogenerated input type of UpdateRepositoryWebCommitSignoffSetting */
export type UpdateRepositoryWebCommitSignoffSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the repository to update. */
  repositoryId: Scalars["ID"]["input"];
  /** Indicates if the repository should require signoff on web-based commits. */
  webCommitSignoffRequired: Scalars["Boolean"]["input"];
};

/** Autogenerated return type of UpdateRepositoryWebCommitSignoffSetting. */
export type UpdateRepositoryWebCommitSignoffSettingPayload = {
  __typename?: "UpdateRepositoryWebCommitSignoffSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** A message confirming the result of updating the web commit signoff setting. */
  message?: Maybe<Scalars["String"]["output"]>;
  /** The updated repository. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of UpdateSponsorshipPreferences */
export type UpdateSponsorshipPreferencesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: InputMaybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of UpdateSponsorshipPreferences. */
export type UpdateSponsorshipPreferencesPayload = {
  __typename?: "UpdateSponsorshipPreferencesPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The sponsorship that was updated. */
  sponsorship?: Maybe<Sponsorship>;
};

/** Autogenerated input type of UpdateSubscription */
export type UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The new state of the subscription. */
  state: SubscriptionState;
  /** The Node ID of the subscribable object to modify. */
  subscribableId: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdateSubscription. */
export type UpdateSubscriptionPayload = {
  __typename?: "UpdateSubscriptionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The input subscribable entity. */
  subscribable?: Maybe<Subscribable>;
};

/** Autogenerated input type of UpdateTeamDiscussionComment */
export type UpdateTeamDiscussionCommentInput = {
  /** The updated text of the comment. */
  body: Scalars["String"]["input"];
  /** The current version of the body content. */
  bodyVersion?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the comment to modify. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of UpdateTeamDiscussionComment. */
export type UpdateTeamDiscussionCommentPayload = {
  __typename?: "UpdateTeamDiscussionCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated comment. */
  teamDiscussionComment?: Maybe<TeamDiscussionComment>;
};

/** Autogenerated input type of UpdateTeamDiscussion */
export type UpdateTeamDiscussionInput = {
  /** The updated text of the discussion. */
  body?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The current version of the body content. If provided, this update operation
   * will be rejected if the given version does not match the latest version on the server.
   */
  bodyVersion?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the discussion to modify. */
  id: Scalars["ID"]["input"];
  /** If provided, sets the pinned state of the updated discussion. */
  pinned?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The updated title of the discussion. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of UpdateTeamDiscussion. */
export type UpdateTeamDiscussionPayload = {
  __typename?: "UpdateTeamDiscussionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The updated discussion. */
  teamDiscussion?: Maybe<TeamDiscussion>;
};

/** Autogenerated input type of UpdateTeamReviewAssignment */
export type UpdateTeamReviewAssignmentInput = {
  /** The algorithm to use for review assignment */
  algorithm?: InputMaybe<TeamReviewAssignmentAlgorithm>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Count any members whose review has already been requested against the required number of members assigned to review */
  countMembersAlreadyRequested?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Turn on or off review assignment */
  enabled: Scalars["Boolean"]["input"];
  /** An array of team member IDs to exclude */
  excludedTeamMemberIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The Node ID of the team to update review assignments of */
  id: Scalars["ID"]["input"];
  /** Include the members of any child teams when assigning */
  includeChildTeamMembers?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Notify the entire team of the PR if it is delegated */
  notifyTeam?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Remove the team review request when assigning */
  removeTeamRequest?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The number of team members to assign */
  teamMemberCount?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Autogenerated return type of UpdateTeamReviewAssignment. */
export type UpdateTeamReviewAssignmentPayload = {
  __typename?: "UpdateTeamReviewAssignmentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The team that was modified */
  team?: Maybe<Team>;
};

/** Autogenerated input type of UpdateTeamsRepository */
export type UpdateTeamsRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Permission that should be granted to the teams. */
  permission: RepositoryPermission;
  /** Repository ID being granted access to. */
  repositoryId: Scalars["ID"]["input"];
  /** A list of teams being granted access. Limit: 10 */
  teamIds: Array<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of UpdateTeamsRepository. */
export type UpdateTeamsRepositoryPayload = {
  __typename?: "UpdateTeamsRepositoryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The repository that was updated. */
  repository?: Maybe<Repository>;
  /** The teams granted permission on the repository. */
  teams?: Maybe<Array<Team>>;
};

/** Autogenerated input type of UpdateTopics */
export type UpdateTopicsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Node ID of the repository. */
  repositoryId: Scalars["ID"]["input"];
  /** An array of topic names. */
  topicNames: Array<Scalars["String"]["input"]>;
};

/** Autogenerated return type of UpdateTopics. */
export type UpdateTopicsPayload = {
  __typename?: "UpdateTopicsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Names of the provided topics that are not valid. */
  invalidTopicNames?: Maybe<Array<Scalars["String"]["output"]>>;
  /** The updated repository. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of UpdateUserList */
export type UpdateUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A description of the list */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not the list is private */
  isPrivate?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the list to update. */
  listId: Scalars["ID"]["input"];
  /** The name of the list */
  name?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated return type of UpdateUserList. */
export type UpdateUserListPayload = {
  __typename?: "UpdateUserListPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The list that was just updated */
  list?: Maybe<UserList>;
};

/** Autogenerated input type of UpdateUserListsForItem */
export type UpdateUserListsForItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The item to add to the list */
  itemId: Scalars["ID"]["input"];
  /** The lists to which this item should belong */
  listIds: Array<Scalars["ID"]["input"]>;
  /** The suggested lists to create and add this item to */
  suggestedListIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

/** Autogenerated return type of UpdateUserListsForItem. */
export type UpdateUserListsForItemPayload = {
  __typename?: "UpdateUserListsForItemPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The item that was added */
  item?: Maybe<UserListItems>;
  /** The lists to which this item belongs */
  lists?: Maybe<Array<UserList>>;
  /** The user who owns the lists */
  user?: Maybe<User>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type User = Actor &
  Node &
  PackageOwner &
  ProfileOwner &
  ProjectOwner &
  ProjectV2Owner &
  ProjectV2Recent &
  RepositoryDiscussionAuthor &
  RepositoryDiscussionCommentAuthor &
  RepositoryOwner &
  Sponsorable &
  UniformResourceLocatable & {
    __typename?: "User";
    /** Determine if this repository owner has any items that can be pinned to their profile. */
    anyPinnableItems: Scalars["Boolean"]["output"];
    /** A URL pointing to the user's public avatar. */
    avatarUrl: Scalars["URI"]["output"];
    /** The user's public profile bio. */
    bio?: Maybe<Scalars["String"]["output"]>;
    /** The user's public profile bio as HTML. */
    bioHTML: Scalars["HTML"]["output"];
    /** Could this user receive email notifications, if the organization had notification restrictions enabled? */
    canReceiveOrganizationEmailsWhenNotificationsRestricted: Scalars["Boolean"]["output"];
    /** A list of commit comments made by this user. */
    commitComments: CommitCommentConnection;
    /** The user's public profile company. */
    company?: Maybe<Scalars["String"]["output"]>;
    /** The user's public profile company as HTML. */
    companyHTML: Scalars["HTML"]["output"];
    /** The collection of contributions this user has made to different repositories. */
    contributionsCollection: ContributionsCollection;
    /** The user's Copilot endpoint information */
    copilotEndpoints?: Maybe<CopilotEndpoints>;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The user's publicly visible profile email. */
    email: Scalars["String"]["output"];
    /** A list of enterprises that the user belongs to. */
    enterprises?: Maybe<EnterpriseConnection>;
    /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
    estimatedNextSponsorsPayoutInCents: Scalars["Int"]["output"];
    /** A list of users the given user is followed by. */
    followers: FollowerConnection;
    /** A list of users the given user is following. */
    following: FollowingConnection;
    /** Find gist by repo name. */
    gist?: Maybe<Gist>;
    /** A list of gist comments made by this user. */
    gistComments: GistCommentConnection;
    /** A list of the Gists the user has created. */
    gists: GistConnection;
    /** True if this user/organization has a GitHub Sponsors listing. */
    hasSponsorsListing: Scalars["Boolean"]["output"];
    /** The hovercard information for this user in a given context */
    hovercard: Hovercard;
    /** The Node ID of the User object */
    id: Scalars["ID"]["output"];
    /** The interaction ability settings for this user. */
    interactionAbility?: Maybe<RepositoryInteractionAbility>;
    /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */
    isBountyHunter: Scalars["Boolean"]["output"];
    /** Whether or not this user is a participant in the GitHub Campus Experts Program. */
    isCampusExpert: Scalars["Boolean"]["output"];
    /** Whether or not this user is a GitHub Developer Program member. */
    isDeveloperProgramMember: Scalars["Boolean"]["output"];
    /** Whether or not this user is a GitHub employee. */
    isEmployee: Scalars["Boolean"]["output"];
    /** Whether or not this user is following the viewer. Inverse of viewerIsFollowing */
    isFollowingViewer: Scalars["Boolean"]["output"];
    /** Whether or not this user is a member of the GitHub Stars Program. */
    isGitHubStar: Scalars["Boolean"]["output"];
    /** Whether or not the user has marked themselves as for hire. */
    isHireable: Scalars["Boolean"]["output"];
    /** Whether or not this user is a site administrator. */
    isSiteAdmin: Scalars["Boolean"]["output"];
    /** Whether the given account is sponsoring this user/organization. */
    isSponsoredBy: Scalars["Boolean"]["output"];
    /** True if the viewer is sponsored by this user/organization. */
    isSponsoringViewer: Scalars["Boolean"]["output"];
    /** Whether or not this user is the viewing user. */
    isViewer: Scalars["Boolean"]["output"];
    /** A list of issue comments made by this user. */
    issueComments: IssueCommentConnection;
    /** A list of issues associated with this user. */
    issues: IssueConnection;
    /**
     * Showcases a selection of repositories and gists that the profile owner has
     * either curated or that have been selected automatically based on popularity.
     */
    itemShowcase: ProfileItemShowcase;
    /**
     * Calculate how much each sponsor has ever paid total to this maintainer via
     * GitHub Sponsors. Does not include sponsorships paid via Patreon.
     */
    lifetimeReceivedSponsorshipValues: SponsorAndLifetimeValueConnection;
    /** A user-curated list of repositories */
    lists: UserListConnection;
    /** The user's public profile location. */
    location?: Maybe<Scalars["String"]["output"]>;
    /** The username used to login. */
    login: Scalars["String"]["output"];
    /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
    monthlyEstimatedSponsorsIncomeInCents: Scalars["Int"]["output"];
    /** The user's public profile name. */
    name?: Maybe<Scalars["String"]["output"]>;
    /** Find an organization by its login that the user belongs to. */
    organization?: Maybe<Organization>;
    /** Verified email addresses that match verified domains for a specified organization the user is a member of. */
    organizationVerifiedDomainEmails: Array<Scalars["String"]["output"]>;
    /** A list of organizations the user belongs to. */
    organizations: OrganizationConnection;
    /** A list of packages under the owner. */
    packages: PackageConnection;
    /** A list of repositories and gists this profile owner can pin to their profile. */
    pinnableItems: PinnableItemConnection;
    /** A list of repositories and gists this profile owner has pinned to their profile */
    pinnedItems: PinnableItemConnection;
    /** Returns how many more items this profile owner can pin to their profile. */
    pinnedItemsRemaining: Scalars["Int"]["output"];
    /** Find project by number. */
    project?: Maybe<Project>;
    /** Find a project by number. */
    projectV2?: Maybe<ProjectV2>;
    /** A list of projects under the owner. */
    projects: ProjectConnection;
    /** The HTTP path listing user's projects */
    projectsResourcePath: Scalars["URI"]["output"];
    /** The HTTP URL listing user's projects */
    projectsUrl: Scalars["URI"]["output"];
    /** A list of projects under the owner. */
    projectsV2: ProjectV2Connection;
    /** The user's profile pronouns */
    pronouns?: Maybe<Scalars["String"]["output"]>;
    /** A list of public keys associated with this user. */
    publicKeys: PublicKeyConnection;
    /** A list of pull requests associated with this user. */
    pullRequests: PullRequestConnection;
    /** Recent projects that this user has modified in the context of the owner. */
    recentProjects: ProjectV2Connection;
    /** A list of repositories that the user owns. */
    repositories: RepositoryConnection;
    /** A list of repositories that the user recently contributed to. */
    repositoriesContributedTo: RepositoryConnection;
    /** Find Repository. */
    repository?: Maybe<Repository>;
    /** Discussion comments this user has authored. */
    repositoryDiscussionComments: DiscussionCommentConnection;
    /** Discussions this user has started. */
    repositoryDiscussions: DiscussionConnection;
    /** The HTTP path for this user */
    resourcePath: Scalars["URI"]["output"];
    /** Replies this user has saved */
    savedReplies?: Maybe<SavedReplyConnection>;
    /** The user's social media accounts, ordered as they appear on the user's profile. */
    socialAccounts: SocialAccountConnection;
    /** List of users and organizations this entity is sponsoring. */
    sponsoring: SponsorConnection;
    /** List of sponsors for this user or organization. */
    sponsors: SponsorConnection;
    /** Events involving this sponsorable, such as new sponsorships. */
    sponsorsActivities: SponsorsActivityConnection;
    /** The GitHub Sponsors listing for this user or organization. */
    sponsorsListing?: Maybe<SponsorsListing>;
    /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
    sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;
    /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
    sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;
    /** List of sponsorship updates sent from this sponsorable to sponsors. */
    sponsorshipNewsletters: SponsorshipNewsletterConnection;
    /** The sponsorships where this user or organization is the maintainer receiving the funds. */
    sponsorshipsAsMaintainer: SponsorshipConnection;
    /** The sponsorships where this user or organization is the funder. */
    sponsorshipsAsSponsor: SponsorshipConnection;
    /** Repositories the user has starred. */
    starredRepositories: StarredRepositoryConnection;
    /** The user's description of what they're currently doing. */
    status?: Maybe<UserStatus>;
    /** Suggested names for user lists */
    suggestedListNames: Array<UserListSuggestion>;
    /** Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created */
    topRepositories: RepositoryConnection;
    /**
     * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
     * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
     * user themselves or by a user who can manage sponsorships for the requested organization.
     */
    totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars["Int"]["output"]>;
    /** The user's Twitter username. */
    twitterUsername?: Maybe<Scalars["String"]["output"]>;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this user */
    url: Scalars["URI"]["output"];
    /** Can the viewer pin repositories and gists to the profile? */
    viewerCanChangePinnedItems: Scalars["Boolean"]["output"];
    /** Can the current viewer create new projects on this owner. */
    viewerCanCreateProjects: Scalars["Boolean"]["output"];
    /** Whether or not the viewer is able to follow the user. */
    viewerCanFollow: Scalars["Boolean"]["output"];
    /** Whether or not the viewer is able to sponsor this user/organization. */
    viewerCanSponsor: Scalars["Boolean"]["output"];
    /** Whether or not this user is followed by the viewer. Inverse of isFollowingViewer. */
    viewerIsFollowing: Scalars["Boolean"]["output"];
    /** True if the viewer is sponsoring this user/organization. */
    viewerIsSponsoring: Scalars["Boolean"]["output"];
    /** A list of repositories the given user is watching. */
    watching: RepositoryConnection;
    /** A URL pointing to the user's public website/blog. */
    websiteUrl?: Maybe<Scalars["URI"]["output"]>;
  };

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserAnyPinnableItemsArgs = {
  type?: InputMaybe<PinnableItemType>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserAvatarUrlArgs = {
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserCanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs = {
  login: Scalars["String"]["input"];
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserCommitCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserContributionsCollectionArgs = {
  from?: InputMaybe<Scalars["DateTime"]["input"]>;
  organizationID?: InputMaybe<Scalars["ID"]["input"]>;
  to?: InputMaybe<Scalars["DateTime"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserEnterprisesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  membershipType?: InputMaybe<EnterpriseMembershipType>;
  orderBy?: InputMaybe<EnterpriseOrder>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserFollowersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserFollowingArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserGistArgs = {
  name: Scalars["String"]["input"];
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserGistCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserGistsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<GistOrder>;
  privacy?: InputMaybe<GistPrivacy>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserHovercardArgs = {
  primarySubjectId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserIsSponsoredByArgs = {
  accountLogin: Scalars["String"]["input"];
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserIssueCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueCommentOrder>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserIssuesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filterBy?: InputMaybe<IssueFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  labels?: InputMaybe<Array<Scalars["String"]["input"]>>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<IssueState>>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserLifetimeReceivedSponsorshipValuesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorAndLifetimeValueOrder>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserListsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserOrganizationArgs = {
  login: Scalars["String"]["input"];
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserOrganizationVerifiedDomainEmailsArgs = {
  login: Scalars["String"]["input"];
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserOrganizationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<OrganizationOrder>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserPackagesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  names?: InputMaybe<Array<InputMaybe<Scalars["String"]["input"]>>>;
  orderBy?: InputMaybe<PackageOrder>;
  packageType?: InputMaybe<PackageType>;
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserPinnableItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  types?: InputMaybe<Array<PinnableItemType>>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserPinnedItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  types?: InputMaybe<Array<PinnableItemType>>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserProjectArgs = {
  number: Scalars["Int"]["input"];
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserProjectV2Args = {
  number: Scalars["Int"]["input"];
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserProjectsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ProjectOrder>;
  search?: InputMaybe<Scalars["String"]["input"]>;
  states?: InputMaybe<Array<ProjectState>>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserProjectsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  minPermissionLevel?: InputMaybe<ProjectV2PermissionLevel>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserPublicKeysArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserPullRequestsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  baseRefName?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  headRefName?: InputMaybe<Scalars["String"]["input"]>;
  labels?: InputMaybe<Array<Scalars["String"]["input"]>>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<PullRequestState>>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserRecentProjectsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserRepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  hasIssuesEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  isArchived?: InputMaybe<Scalars["Boolean"]["input"]>;
  isFork?: InputMaybe<Scalars["Boolean"]["input"]>;
  isLocked?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
  visibility?: InputMaybe<RepositoryVisibility>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserRepositoriesContributedToArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  contributionTypes?: InputMaybe<Array<InputMaybe<RepositoryContributionType>>>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  hasIssues?: InputMaybe<Scalars["Boolean"]["input"]>;
  includeUserRepositories?: InputMaybe<Scalars["Boolean"]["input"]>;
  isLocked?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RepositoryOrder>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserRepositoryArgs = {
  followRenames?: InputMaybe<Scalars["Boolean"]["input"]>;
  name: Scalars["String"]["input"];
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserRepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  onlyAnswers?: InputMaybe<Scalars["Boolean"]["input"]>;
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserRepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  answered?: InputMaybe<Scalars["Boolean"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars["ID"]["input"]>;
  states?: InputMaybe<Array<DiscussionState>>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserSavedRepliesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SavedReplyOrder>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserSocialAccountsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserSponsoringArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorOrder>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserSponsorsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorOrder>;
  tierId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserSponsorsActivitiesArgs = {
  actions?: InputMaybe<Array<SponsorsActivityAction>>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includeAsSponsor?: InputMaybe<Scalars["Boolean"]["input"]>;
  includePrivate?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorsActivityOrder>;
  period?: InputMaybe<SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars["DateTime"]["input"]>;
  until?: InputMaybe<Scalars["DateTime"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserSponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserSponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserSponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserSponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  includePrivate?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserSponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  maintainerLogins?: InputMaybe<Array<Scalars["String"]["input"]>>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserStarredRepositoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<StarOrder>;
  ownedByViewer?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserTopRepositoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy: RepositoryOrder;
  since?: InputMaybe<Scalars["DateTime"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserTotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars["DateTime"]["input"]>;
  sponsorableLogins?: InputMaybe<Array<Scalars["String"]["input"]>>;
  until?: InputMaybe<Scalars["DateTime"]["input"]>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserWatchingArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  hasIssuesEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  isLocked?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
  visibility?: InputMaybe<RepositoryVisibility>;
};

/** The possible durations that a user can be blocked for. */
export enum UserBlockDuration {
  /** The user was blocked for 1 day */
  OneDay = "ONE_DAY",
  /** The user was blocked for 30 days */
  OneMonth = "ONE_MONTH",
  /** The user was blocked for 7 days */
  OneWeek = "ONE_WEEK",
  /** The user was blocked permanently */
  Permanent = "PERMANENT",
  /** The user was blocked for 3 days */
  ThreeDays = "THREE_DAYS",
}

/** Represents a 'user_blocked' event on a given user. */
export type UserBlockedEvent = Node & {
  __typename?: "UserBlockedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Number of days that the user was blocked for. */
  blockDuration: UserBlockDuration;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The Node ID of the UserBlockedEvent object */
  id: Scalars["ID"]["output"];
  /** The user who was blocked. */
  subject?: Maybe<User>;
};

/** A list of users. */
export type UserConnection = {
  __typename?: "UserConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edit on user content */
export type UserContentEdit = Node & {
  __typename?: "UserContentEdit";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the date and time when the object was deleted. */
  deletedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The actor who deleted this content */
  deletedBy?: Maybe<Actor>;
  /** A summary of the changes for this edit */
  diff?: Maybe<Scalars["String"]["output"]>;
  /** When this content was edited */
  editedAt: Scalars["DateTime"]["output"];
  /** The actor who edited this content */
  editor?: Maybe<Actor>;
  /** The Node ID of the UserContentEdit object */
  id: Scalars["ID"]["output"];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
};

/** A list of edits to content. */
export type UserContentEditConnection = {
  __typename?: "UserContentEditConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserContentEditEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserContentEdit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type UserContentEditEdge = {
  __typename?: "UserContentEditEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<UserContentEdit>;
};

/** Represents a user. */
export type UserEdge = {
  __typename?: "UserEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** Email attributes from External Identity */
export type UserEmailMetadata = {
  __typename?: "UserEmailMetadata";
  /** Boolean to identify primary emails */
  primary?: Maybe<Scalars["Boolean"]["output"]>;
  /** Type of email */
  type?: Maybe<Scalars["String"]["output"]>;
  /** Email id */
  value: Scalars["String"]["output"];
};

/** A user-curated list of repositories */
export type UserList = Node & {
  __typename?: "UserList";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The description of this list */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The Node ID of the UserList object */
  id: Scalars["ID"]["output"];
  /** Whether or not this list is private */
  isPrivate: Scalars["Boolean"]["output"];
  /** The items associated with this list */
  items: UserListItemsConnection;
  /** The date and time at which this list was created or last had items added to it */
  lastAddedAt: Scalars["DateTime"]["output"];
  /** The name of this list */
  name: Scalars["String"]["output"];
  /** The slug of this list */
  slug: Scalars["String"]["output"];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** The user to which this list belongs */
  user: User;
};

/** A user-curated list of repositories */
export type UserListItemsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for UserList. */
export type UserListConnection = {
  __typename?: "UserListConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserListEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserList>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type UserListEdge = {
  __typename?: "UserListEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<UserList>;
};

/** Types that can be added to a user list. */
export type UserListItems = Repository;

/** The connection type for UserListItems. */
export type UserListItemsConnection = {
  __typename?: "UserListItemsConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserListItemsEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserListItems>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type UserListItemsEdge = {
  __typename?: "UserListItemsEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<UserListItems>;
};

/** Represents a suggested user list. */
export type UserListSuggestion = {
  __typename?: "UserListSuggestion";
  /** The ID of the suggested user list */
  id?: Maybe<Scalars["ID"]["output"]>;
  /** The name of the suggested user list */
  name?: Maybe<Scalars["String"]["output"]>;
};

/** The user's description of what they're currently doing. */
export type UserStatus = Node & {
  __typename?: "UserStatus";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** An emoji summarizing the user's status. */
  emoji?: Maybe<Scalars["String"]["output"]>;
  /** The status emoji as HTML. */
  emojiHTML?: Maybe<Scalars["HTML"]["output"]>;
  /** If set, the status will not be shown after this date. */
  expiresAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The Node ID of the UserStatus object */
  id: Scalars["ID"]["output"];
  /** Whether this status indicates the user is not fully available on GitHub. */
  indicatesLimitedAvailability: Scalars["Boolean"]["output"];
  /** A brief message describing what the user is doing. */
  message?: Maybe<Scalars["String"]["output"]>;
  /** The organization whose members can see this status. If null, this status is publicly visible. */
  organization?: Maybe<Organization>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** The user who has this status. */
  user: User;
};

/** The connection type for UserStatus. */
export type UserStatusConnection = {
  __typename?: "UserStatusConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type UserStatusEdge = {
  __typename?: "UserStatusEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<UserStatus>;
};

/** Ordering options for user status connections. */
export type UserStatusOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order user statuses by. */
  field: UserStatusOrderField;
};

/** Properties by which user status connections can be ordered. */
export enum UserStatusOrderField {
  /** Order user statuses by when they were updated. */
  UpdatedAt = "UPDATED_AT",
}

/** A domain that can be verified or approved for an organization or an enterprise. */
export type VerifiableDomain = Node & {
  __typename?: "VerifiableDomain";
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars["Int"]["output"]>;
  /** The DNS host name that should be used for verification. */
  dnsHostName?: Maybe<Scalars["URI"]["output"]>;
  /** The unicode encoded domain. */
  domain: Scalars["URI"]["output"];
  /** Whether a TXT record for verification with the expected host name was found. */
  hasFoundHostName: Scalars["Boolean"]["output"];
  /** Whether a TXT record for verification with the expected verification token was found. */
  hasFoundVerificationToken: Scalars["Boolean"]["output"];
  /** The Node ID of the VerifiableDomain object */
  id: Scalars["ID"]["output"];
  /** Whether or not the domain is approved. */
  isApproved: Scalars["Boolean"]["output"];
  /** Whether this domain is required to exist for an organization or enterprise policy to be enforced. */
  isRequiredForPolicyEnforcement: Scalars["Boolean"]["output"];
  /** Whether or not the domain is verified. */
  isVerified: Scalars["Boolean"]["output"];
  /** The owner of the domain. */
  owner: VerifiableDomainOwner;
  /** The punycode encoded domain. */
  punycodeEncodedDomain: Scalars["URI"]["output"];
  /** The time that the current verification token will expire. */
  tokenExpirationTime?: Maybe<Scalars["DateTime"]["output"]>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars["DateTime"]["output"];
  /** The current verification token for the domain. */
  verificationToken?: Maybe<Scalars["String"]["output"]>;
};

/** The connection type for VerifiableDomain. */
export type VerifiableDomainConnection = {
  __typename?: "VerifiableDomainConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VerifiableDomainEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VerifiableDomain>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type VerifiableDomainEdge = {
  __typename?: "VerifiableDomainEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<VerifiableDomain>;
};

/** Ordering options for verifiable domain connections. */
export type VerifiableDomainOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order verifiable domains by. */
  field: VerifiableDomainOrderField;
};

/** Properties by which verifiable domain connections can be ordered. */
export enum VerifiableDomainOrderField {
  /** Order verifiable domains by their creation date. */
  CreatedAt = "CREATED_AT",
  /** Order verifiable domains by the domain name. */
  Domain = "DOMAIN",
}

/** Types that can own a verifiable domain. */
export type VerifiableDomainOwner = Enterprise | Organization;

/** Autogenerated input type of VerifyVerifiableDomain */
export type VerifyVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the verifiable domain to verify. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated return type of VerifyVerifiableDomain. */
export type VerifyVerifiableDomainPayload = {
  __typename?: "VerifyVerifiableDomainPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The verifiable domain that was verified. */
  domain?: Maybe<VerifiableDomain>;
};

/** A hovercard context with a message describing how the viewer is related. */
export type ViewerHovercardContext = HovercardContext & {
  __typename?: "ViewerHovercardContext";
  /** A string describing this context */
  message: Scalars["String"]["output"];
  /** An octicon to accompany this context */
  octicon: Scalars["String"]["output"];
  /** Identifies the user who is related to this context. */
  viewer: User;
};

/** A subject that may be upvoted. */
export type Votable = {
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars["Int"]["output"];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars["Boolean"]["output"];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars["Boolean"]["output"];
};

/** A workflow contains meta information about an Actions workflow file. */
export type Workflow = Node &
  UniformResourceLocatable & {
    __typename?: "Workflow";
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The Node ID of the Workflow object */
    id: Scalars["ID"]["output"];
    /** The name of the workflow. */
    name: Scalars["String"]["output"];
    /** The HTTP path for this workflow */
    resourcePath: Scalars["URI"]["output"];
    /** The runs of the workflow. */
    runs: WorkflowRunConnection;
    /** The state of the workflow. */
    state: WorkflowState;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this workflow */
    url: Scalars["URI"]["output"];
  };

/** A workflow contains meta information about an Actions workflow file. */
export type WorkflowRunsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<WorkflowRunOrder>;
};

/** A workflow that must run for this rule to pass */
export type WorkflowFileReference = {
  __typename?: "WorkflowFileReference";
  /** The path to the workflow file */
  path: Scalars["String"]["output"];
  /** The ref (branch or tag) of the workflow file to use */
  ref?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the repository where the workflow is defined */
  repositoryId: Scalars["Int"]["output"];
  /** The commit SHA of the workflow file to use */
  sha?: Maybe<Scalars["String"]["output"]>;
};

/** A workflow that must run for this rule to pass */
export type WorkflowFileReferenceInput = {
  /** The path to the workflow file */
  path: Scalars["String"]["input"];
  /** The ref (branch or tag) of the workflow file to use */
  ref?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the repository where the workflow is defined */
  repositoryId: Scalars["Int"]["input"];
  /** The commit SHA of the workflow file to use */
  sha?: InputMaybe<Scalars["String"]["input"]>;
};

/** A workflow run. */
export type WorkflowRun = Node &
  UniformResourceLocatable & {
    __typename?: "WorkflowRun";
    /** The check suite this workflow run belongs to. */
    checkSuite: CheckSuite;
    /** Identifies the date and time when the object was created. */
    createdAt: Scalars["DateTime"]["output"];
    /** Identifies the primary key from the database. */
    databaseId?: Maybe<Scalars["Int"]["output"]>;
    /** The log of deployment reviews */
    deploymentReviews: DeploymentReviewConnection;
    /** The event that triggered the workflow run */
    event: Scalars["String"]["output"];
    /** The workflow file */
    file?: Maybe<WorkflowRunFile>;
    /** The Node ID of the WorkflowRun object */
    id: Scalars["ID"]["output"];
    /** The pending deployment requests of all check runs in this workflow run */
    pendingDeploymentRequests: DeploymentRequestConnection;
    /** The HTTP path for this workflow run */
    resourcePath: Scalars["URI"]["output"];
    /** A number that uniquely identifies this workflow run in its parent workflow. */
    runNumber: Scalars["Int"]["output"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt: Scalars["DateTime"]["output"];
    /** The HTTP URL for this workflow run */
    url: Scalars["URI"]["output"];
    /** The workflow executed in this workflow run. */
    workflow: Workflow;
  };

/** A workflow run. */
export type WorkflowRunDeploymentReviewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A workflow run. */
export type WorkflowRunPendingDeploymentRequestsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for WorkflowRun. */
export type WorkflowRunConnection = {
  __typename?: "WorkflowRunConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkflowRunEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkflowRun>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type WorkflowRunEdge = {
  __typename?: "WorkflowRunEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<WorkflowRun>;
};

/** An executed workflow file for a workflow run. */
export type WorkflowRunFile = Node &
  UniformResourceLocatable & {
    __typename?: "WorkflowRunFile";
    /** The Node ID of the WorkflowRunFile object */
    id: Scalars["ID"]["output"];
    /** The path of the workflow file relative to its repository. */
    path: Scalars["String"]["output"];
    /** The direct link to the file in the repository which stores the workflow file. */
    repositoryFileUrl: Scalars["URI"]["output"];
    /** The repository name and owner which stores the workflow file. */
    repositoryName: Scalars["URI"]["output"];
    /** The HTTP path for this workflow run file */
    resourcePath: Scalars["URI"]["output"];
    /** The parent workflow run execution for this file. */
    run: WorkflowRun;
    /** The HTTP URL for this workflow run file */
    url: Scalars["URI"]["output"];
    /** If the viewer has permissions to push to the repository which stores the workflow. */
    viewerCanPushRepository: Scalars["Boolean"]["output"];
    /** If the viewer has permissions to read the repository which stores the workflow. */
    viewerCanReadRepository: Scalars["Boolean"]["output"];
  };

/** Ways in which lists of workflow runs can be ordered upon return. */
export type WorkflowRunOrder = {
  /** The direction in which to order workflow runs by the specified field. */
  direction: OrderDirection;
  /** The field by which to order workflows. */
  field: WorkflowRunOrderField;
};

/** Properties by which workflow run connections can be ordered. */
export enum WorkflowRunOrderField {
  /** Order workflow runs by most recently created */
  CreatedAt = "CREATED_AT",
}

/** The possible states for a workflow. */
export enum WorkflowState {
  /** The workflow is active. */
  Active = "ACTIVE",
  /** The workflow was deleted from the git repository. */
  Deleted = "DELETED",
  /** The workflow was disabled by default on a fork. */
  DisabledFork = "DISABLED_FORK",
  /** The workflow was disabled for inactivity in the repository. */
  DisabledInactivity = "DISABLED_INACTIVITY",
  /** The workflow was disabled manually. */
  DisabledManually = "DISABLED_MANUALLY",
}

/** Require all changes made to a targeted branch to pass the specified workflows before they can be merged. */
export type WorkflowsParameters = {
  __typename?: "WorkflowsParameters";
  /** Allow repositories and branches to be created if a check would otherwise prohibit it. */
  doNotEnforceOnCreate: Scalars["Boolean"]["output"];
  /** Workflows that must pass for this rule to pass. */
  workflows: Array<WorkflowFileReference>;
};

/** Require all changes made to a targeted branch to pass the specified workflows before they can be merged. */
export type WorkflowsParametersInput = {
  /** Allow repositories and branches to be created if a check would otherwise prohibit it. */
  doNotEnforceOnCreate?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Workflows that must pass for this rule to pass. */
  workflows: Array<WorkflowFileReferenceInput>;
};

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs,
> {
  subscribe: SubscriptionSubscribeFn<
    { [key in TKey]: TResult },
    TParent,
    TContext,
    TArgs
  >;
  resolve?: SubscriptionResolveFn<
    TResult,
    { [key in TKey]: TResult },
    TContext,
    TArgs
  >;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs,
> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
  TResult,
  TKey extends string,
  TParent = {},
  TContext = {},
  TArgs = {},
> =
  | ((
      ...args: any[]
    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo,
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
  obj: T,
  context: TContext,
  info: GraphQLResolveInfo,
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<
  TResult = {},
  TParent = {},
  TContext = {},
  TArgs = {},
> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping of union types */
export type ResolversUnionTypes<_RefType extends Record<string, unknown>> = {
  Assignee:
    | Bot
    | (Omit<Mannequin, "claimant"> & { claimant?: Maybe<_RefType["User"]> })
    | (Omit<
        Organization,
        | "auditLog"
        | "domains"
        | "enterpriseOwners"
        | "ipAllowListEntries"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "mannequins"
        | "memberStatuses"
        | "membersWithRole"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "recentProjects"
        | "repositories"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "ruleset"
        | "rulesets"
        | "samlIdentityProvider"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "team"
        | "teams"
      > & {
        auditLog: _RefType["OrganizationAuditEntryConnection"];
        domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
        enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        mannequins: _RefType["MannequinConnection"];
        memberStatuses: _RefType["UserStatusConnection"];
        membersWithRole: _RefType["OrganizationMemberConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        samlIdentityProvider?: Maybe<_RefType["OrganizationIdentityProvider"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        team?: Maybe<_RefType["Team"]>;
        teams: _RefType["TeamConnection"];
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  AuditEntryActor:
    | Bot
    | (Omit<
        Organization,
        | "auditLog"
        | "domains"
        | "enterpriseOwners"
        | "ipAllowListEntries"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "mannequins"
        | "memberStatuses"
        | "membersWithRole"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "recentProjects"
        | "repositories"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "ruleset"
        | "rulesets"
        | "samlIdentityProvider"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "team"
        | "teams"
      > & {
        auditLog: _RefType["OrganizationAuditEntryConnection"];
        domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
        enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        mannequins: _RefType["MannequinConnection"];
        memberStatuses: _RefType["UserStatusConnection"];
        membersWithRole: _RefType["OrganizationMemberConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        samlIdentityProvider?: Maybe<_RefType["OrganizationIdentityProvider"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        team?: Maybe<_RefType["Team"]>;
        teams: _RefType["TeamConnection"];
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  BranchActorAllowanceActor:
    | (Omit<App, "ipAllowListEntries"> & {
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
      })
    | (Omit<
        Team,
        | "ancestors"
        | "childTeams"
        | "discussion"
        | "discussions"
        | "invitations"
        | "memberStatuses"
        | "organization"
        | "parentTeam"
        | "projectV2"
        | "projectsV2"
        | "repositories"
      > & {
        ancestors: _RefType["TeamConnection"];
        childTeams: _RefType["TeamConnection"];
        discussion?: Maybe<_RefType["TeamDiscussion"]>;
        discussions: _RefType["TeamDiscussionConnection"];
        invitations?: Maybe<_RefType["OrganizationInvitationConnection"]>;
        memberStatuses: _RefType["UserStatusConnection"];
        organization: _RefType["Organization"];
        parentTeam?: Maybe<_RefType["Team"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        repositories: _RefType["TeamRepositoryConnection"];
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  BypassActor:
    | (Omit<App, "ipAllowListEntries"> & {
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
      })
    | (Omit<
        Team,
        | "ancestors"
        | "childTeams"
        | "discussion"
        | "discussions"
        | "invitations"
        | "memberStatuses"
        | "organization"
        | "parentTeam"
        | "projectV2"
        | "projectsV2"
        | "repositories"
      > & {
        ancestors: _RefType["TeamConnection"];
        childTeams: _RefType["TeamConnection"];
        discussion?: Maybe<_RefType["TeamDiscussion"]>;
        discussions: _RefType["TeamDiscussionConnection"];
        invitations?: Maybe<_RefType["OrganizationInvitationConnection"]>;
        memberStatuses: _RefType["UserStatusConnection"];
        organization: _RefType["Organization"];
        parentTeam?: Maybe<_RefType["Team"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        repositories: _RefType["TeamRepositoryConnection"];
      });
  Claimable:
    | (Omit<Mannequin, "claimant"> & { claimant?: Maybe<_RefType["User"]> })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  Closer:
    | (Omit<
        Commit,
        | "associatedPullRequests"
        | "blame"
        | "checkSuites"
        | "comments"
        | "deployments"
        | "file"
        | "history"
        | "onBehalfOf"
        | "parents"
        | "repository"
        | "signature"
        | "status"
        | "statusCheckRollup"
        | "tree"
      > & {
        associatedPullRequests?: Maybe<_RefType["PullRequestConnection"]>;
        blame: _RefType["Blame"];
        checkSuites?: Maybe<_RefType["CheckSuiteConnection"]>;
        comments: _RefType["CommitCommentConnection"];
        deployments?: Maybe<_RefType["DeploymentConnection"]>;
        file?: Maybe<_RefType["TreeEntry"]>;
        history: _RefType["CommitHistoryConnection"];
        onBehalfOf?: Maybe<_RefType["Organization"]>;
        parents: _RefType["CommitConnection"];
        repository: _RefType["Repository"];
        signature?: Maybe<_RefType["GitSignature"]>;
        status?: Maybe<_RefType["Status"]>;
        statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
        tree: _RefType["Tree"];
      })
    | (Omit<
        ProjectV2,
        | "creator"
        | "field"
        | "fields"
        | "items"
        | "owner"
        | "repositories"
        | "statusUpdates"
        | "teams"
        | "view"
        | "views"
        | "workflow"
        | "workflows"
      > & {
        creator?: Maybe<_RefType["Actor"]>;
        field?: Maybe<_RefType["ProjectV2FieldConfiguration"]>;
        fields: _RefType["ProjectV2FieldConfigurationConnection"];
        items: _RefType["ProjectV2ItemConnection"];
        owner: _RefType["ProjectV2Owner"];
        repositories: _RefType["RepositoryConnection"];
        statusUpdates: _RefType["ProjectV2StatusUpdateConnection"];
        teams: _RefType["TeamConnection"];
        view?: Maybe<_RefType["ProjectV2View"]>;
        views: _RefType["ProjectV2ViewConnection"];
        workflow?: Maybe<_RefType["ProjectV2Workflow"]>;
        workflows: _RefType["ProjectV2WorkflowConnection"];
      })
    | (Omit<
        PullRequest,
        | "author"
        | "autoMergeRequest"
        | "baseRef"
        | "baseRepository"
        | "closingIssuesReferences"
        | "comments"
        | "commits"
        | "editor"
        | "headRef"
        | "headRepository"
        | "headRepositoryOwner"
        | "hovercard"
        | "labels"
        | "latestOpinionatedReviews"
        | "latestReviews"
        | "mergeCommit"
        | "mergeQueue"
        | "mergeQueueEntry"
        | "mergedBy"
        | "milestone"
        | "potentialMergeCommit"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "reviewRequests"
        | "reviewThreads"
        | "reviews"
        | "statusCheckRollup"
        | "timeline"
        | "timelineItems"
        | "userContentEdits"
        | "viewerLatestReview"
        | "viewerLatestReviewRequest"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
        baseRef?: Maybe<_RefType["Ref"]>;
        baseRepository?: Maybe<_RefType["Repository"]>;
        closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
        comments: _RefType["IssueCommentConnection"];
        commits: _RefType["PullRequestCommitConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        headRef?: Maybe<_RefType["Ref"]>;
        headRepository?: Maybe<_RefType["Repository"]>;
        headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestOpinionatedReviews?: Maybe<
          _RefType["PullRequestReviewConnection"]
        >;
        latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        mergeCommit?: Maybe<_RefType["Commit"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
        mergedBy?: Maybe<_RefType["Actor"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        potentialMergeCommit?: Maybe<_RefType["Commit"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
        reviewThreads: _RefType["PullRequestReviewThreadConnection"];
        reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
        timeline: _RefType["PullRequestTimelineConnection"];
        timelineItems: _RefType["PullRequestTimelineItemsConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
        viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
      });
  CreatedIssueOrRestrictedContribution:
    | (Omit<CreatedIssueContribution, "issue" | "user"> & {
        issue: _RefType["Issue"];
        user: _RefType["User"];
      })
    | (Omit<RestrictedContribution, "user"> & { user: _RefType["User"] });
  CreatedPullRequestOrRestrictedContribution:
    | (Omit<CreatedPullRequestContribution, "pullRequest" | "user"> & {
        pullRequest: _RefType["PullRequest"];
        user: _RefType["User"];
      })
    | (Omit<RestrictedContribution, "user"> & { user: _RefType["User"] });
  CreatedRepositoryOrRestrictedContribution:
    | (Omit<CreatedRepositoryContribution, "repository" | "user"> & {
        repository: _RefType["Repository"];
        user: _RefType["User"];
      })
    | (Omit<RestrictedContribution, "user"> & { user: _RefType["User"] });
  DeploymentReviewer:
    | (Omit<
        Team,
        | "ancestors"
        | "childTeams"
        | "discussion"
        | "discussions"
        | "invitations"
        | "memberStatuses"
        | "organization"
        | "parentTeam"
        | "projectV2"
        | "projectsV2"
        | "repositories"
      > & {
        ancestors: _RefType["TeamConnection"];
        childTeams: _RefType["TeamConnection"];
        discussion?: Maybe<_RefType["TeamDiscussion"]>;
        discussions: _RefType["TeamDiscussionConnection"];
        invitations?: Maybe<_RefType["OrganizationInvitationConnection"]>;
        memberStatuses: _RefType["UserStatusConnection"];
        organization: _RefType["Organization"];
        parentTeam?: Maybe<_RefType["Team"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        repositories: _RefType["TeamRepositoryConnection"];
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  EnterpriseMember:
    | (Omit<
        EnterpriseUserAccount,
        "enterprise" | "enterpriseInstallations" | "organizations" | "user"
      > & {
        enterprise: _RefType["Enterprise"];
        enterpriseInstallations: _RefType["EnterpriseServerInstallationMembershipConnection"];
        organizations: _RefType["EnterpriseOrganizationMembershipConnection"];
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  IpAllowListOwner:
    | (Omit<App, "ipAllowListEntries"> & {
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
      })
    | (Omit<
        Enterprise,
        "billingInfo" | "members" | "organizations" | "ownerInfo"
      > & {
        billingInfo?: Maybe<_RefType["EnterpriseBillingInfo"]>;
        members: _RefType["EnterpriseMemberConnection"];
        organizations: _RefType["OrganizationConnection"];
        ownerInfo?: Maybe<_RefType["EnterpriseOwnerInfo"]>;
      })
    | (Omit<
        Organization,
        | "auditLog"
        | "domains"
        | "enterpriseOwners"
        | "ipAllowListEntries"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "mannequins"
        | "memberStatuses"
        | "membersWithRole"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "recentProjects"
        | "repositories"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "ruleset"
        | "rulesets"
        | "samlIdentityProvider"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "team"
        | "teams"
      > & {
        auditLog: _RefType["OrganizationAuditEntryConnection"];
        domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
        enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        mannequins: _RefType["MannequinConnection"];
        memberStatuses: _RefType["UserStatusConnection"];
        membersWithRole: _RefType["OrganizationMemberConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        samlIdentityProvider?: Maybe<_RefType["OrganizationIdentityProvider"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        team?: Maybe<_RefType["Team"]>;
        teams: _RefType["TeamConnection"];
      });
  IssueOrPullRequest:
    | (Omit<
        Issue,
        | "author"
        | "closedByPullRequestsReferences"
        | "comments"
        | "editor"
        | "hovercard"
        | "labels"
        | "milestone"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "timeline"
        | "timelineItems"
        | "trackedInIssues"
        | "trackedIssues"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        closedByPullRequestsReferences?: Maybe<
          _RefType["PullRequestConnection"]
        >;
        comments: _RefType["IssueCommentConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        timeline: _RefType["IssueTimelineConnection"];
        timelineItems: _RefType["IssueTimelineItemsConnection"];
        trackedInIssues: _RefType["IssueConnection"];
        trackedIssues: _RefType["IssueConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<
        PullRequest,
        | "author"
        | "autoMergeRequest"
        | "baseRef"
        | "baseRepository"
        | "closingIssuesReferences"
        | "comments"
        | "commits"
        | "editor"
        | "headRef"
        | "headRepository"
        | "headRepositoryOwner"
        | "hovercard"
        | "labels"
        | "latestOpinionatedReviews"
        | "latestReviews"
        | "mergeCommit"
        | "mergeQueue"
        | "mergeQueueEntry"
        | "mergedBy"
        | "milestone"
        | "potentialMergeCommit"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "reviewRequests"
        | "reviewThreads"
        | "reviews"
        | "statusCheckRollup"
        | "timeline"
        | "timelineItems"
        | "userContentEdits"
        | "viewerLatestReview"
        | "viewerLatestReviewRequest"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
        baseRef?: Maybe<_RefType["Ref"]>;
        baseRepository?: Maybe<_RefType["Repository"]>;
        closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
        comments: _RefType["IssueCommentConnection"];
        commits: _RefType["PullRequestCommitConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        headRef?: Maybe<_RefType["Ref"]>;
        headRepository?: Maybe<_RefType["Repository"]>;
        headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestOpinionatedReviews?: Maybe<
          _RefType["PullRequestReviewConnection"]
        >;
        latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        mergeCommit?: Maybe<_RefType["Commit"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
        mergedBy?: Maybe<_RefType["Actor"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        potentialMergeCommit?: Maybe<_RefType["Commit"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
        reviewThreads: _RefType["PullRequestReviewThreadConnection"];
        reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
        timeline: _RefType["PullRequestTimelineConnection"];
        timelineItems: _RefType["PullRequestTimelineItemsConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
        viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
      });
  IssueTimelineItem:
    | (Omit<AssignedEvent, "actor" | "assignable" | "assignee" | "user"> & {
        actor?: Maybe<_RefType["Actor"]>;
        assignable: _RefType["Assignable"];
        assignee?: Maybe<_RefType["Assignee"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<ClosedEvent, "actor" | "closable" | "closer"> & {
        actor?: Maybe<_RefType["Actor"]>;
        closable: _RefType["Closable"];
        closer?: Maybe<_RefType["Closer"]>;
      })
    | (Omit<
        Commit,
        | "associatedPullRequests"
        | "blame"
        | "checkSuites"
        | "comments"
        | "deployments"
        | "file"
        | "history"
        | "onBehalfOf"
        | "parents"
        | "repository"
        | "signature"
        | "status"
        | "statusCheckRollup"
        | "tree"
      > & {
        associatedPullRequests?: Maybe<_RefType["PullRequestConnection"]>;
        blame: _RefType["Blame"];
        checkSuites?: Maybe<_RefType["CheckSuiteConnection"]>;
        comments: _RefType["CommitCommentConnection"];
        deployments?: Maybe<_RefType["DeploymentConnection"]>;
        file?: Maybe<_RefType["TreeEntry"]>;
        history: _RefType["CommitHistoryConnection"];
        onBehalfOf?: Maybe<_RefType["Organization"]>;
        parents: _RefType["CommitConnection"];
        repository: _RefType["Repository"];
        signature?: Maybe<_RefType["GitSignature"]>;
        status?: Maybe<_RefType["Status"]>;
        statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
        tree: _RefType["Tree"];
      })
    | (Omit<CrossReferencedEvent, "actor" | "source" | "target"> & {
        actor?: Maybe<_RefType["Actor"]>;
        source: _RefType["ReferencedSubject"];
        target: _RefType["ReferencedSubject"];
      })
    | (Omit<DemilestonedEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject: _RefType["MilestoneItem"];
      })
    | (Omit<
        IssueComment,
        | "author"
        | "editor"
        | "issue"
        | "pullRequest"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        editor?: Maybe<_RefType["Actor"]>;
        issue: _RefType["Issue"];
        pullRequest?: Maybe<_RefType["PullRequest"]>;
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<LabeledEvent, "actor" | "label" | "labelable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        label: _RefType["Label"];
        labelable: _RefType["Labelable"];
      })
    | (Omit<LockedEvent, "actor" | "lockable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        lockable: _RefType["Lockable"];
      })
    | (Omit<MilestonedEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject: _RefType["MilestoneItem"];
      })
    | (Omit<
        ReferencedEvent,
        "actor" | "commit" | "commitRepository" | "subject"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        commit?: Maybe<_RefType["Commit"]>;
        commitRepository: _RefType["Repository"];
        subject: _RefType["ReferencedSubject"];
      })
    | (Omit<RenamedTitleEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject: _RefType["RenamedTitleSubject"];
      })
    | (Omit<ReopenedEvent, "actor" | "closable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        closable: _RefType["Closable"];
      })
    | (Omit<SubscribedEvent, "actor" | "subscribable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subscribable: _RefType["Subscribable"];
      })
    | (Omit<TransferredEvent, "actor" | "fromRepository" | "issue"> & {
        actor?: Maybe<_RefType["Actor"]>;
        fromRepository?: Maybe<_RefType["Repository"]>;
        issue: _RefType["Issue"];
      })
    | (Omit<UnassignedEvent, "actor" | "assignable" | "assignee" | "user"> & {
        actor?: Maybe<_RefType["Actor"]>;
        assignable: _RefType["Assignable"];
        assignee?: Maybe<_RefType["Assignee"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<UnlabeledEvent, "actor" | "label" | "labelable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        label: _RefType["Label"];
        labelable: _RefType["Labelable"];
      })
    | (Omit<UnlockedEvent, "actor" | "lockable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        lockable: _RefType["Lockable"];
      })
    | (Omit<UnsubscribedEvent, "actor" | "subscribable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subscribable: _RefType["Subscribable"];
      })
    | (Omit<UserBlockedEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject?: Maybe<_RefType["User"]>;
      });
  IssueTimelineItems:
    | (Omit<AddedToProjectEvent, "actor" | "project" | "projectCard"> & {
        actor?: Maybe<_RefType["Actor"]>;
        project?: Maybe<_RefType["Project"]>;
        projectCard?: Maybe<_RefType["ProjectCard"]>;
      })
    | (Omit<AssignedEvent, "actor" | "assignable" | "assignee" | "user"> & {
        actor?: Maybe<_RefType["Actor"]>;
        assignable: _RefType["Assignable"];
        assignee?: Maybe<_RefType["Assignee"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<ClosedEvent, "actor" | "closable" | "closer"> & {
        actor?: Maybe<_RefType["Actor"]>;
        closable: _RefType["Closable"];
        closer?: Maybe<_RefType["Closer"]>;
      })
    | (Omit<CommentDeletedEvent, "actor" | "deletedCommentAuthor"> & {
        actor?: Maybe<_RefType["Actor"]>;
        deletedCommentAuthor?: Maybe<_RefType["Actor"]>;
      })
    | (Omit<ConnectedEvent, "actor" | "source" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        source: _RefType["ReferencedSubject"];
        subject: _RefType["ReferencedSubject"];
      })
    | (Omit<ConvertedNoteToIssueEvent, "actor" | "project" | "projectCard"> & {
        actor?: Maybe<_RefType["Actor"]>;
        project?: Maybe<_RefType["Project"]>;
        projectCard?: Maybe<_RefType["ProjectCard"]>;
      })
    | (Omit<ConvertedToDiscussionEvent, "actor" | "discussion"> & {
        actor?: Maybe<_RefType["Actor"]>;
        discussion?: Maybe<_RefType["Discussion"]>;
      })
    | (Omit<CrossReferencedEvent, "actor" | "source" | "target"> & {
        actor?: Maybe<_RefType["Actor"]>;
        source: _RefType["ReferencedSubject"];
        target: _RefType["ReferencedSubject"];
      })
    | (Omit<DemilestonedEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject: _RefType["MilestoneItem"];
      })
    | (Omit<DisconnectedEvent, "actor" | "source" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        source: _RefType["ReferencedSubject"];
        subject: _RefType["ReferencedSubject"];
      })
    | (Omit<
        IssueComment,
        | "author"
        | "editor"
        | "issue"
        | "pullRequest"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        editor?: Maybe<_RefType["Actor"]>;
        issue: _RefType["Issue"];
        pullRequest?: Maybe<_RefType["PullRequest"]>;
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<LabeledEvent, "actor" | "label" | "labelable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        label: _RefType["Label"];
        labelable: _RefType["Labelable"];
      })
    | (Omit<LockedEvent, "actor" | "lockable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        lockable: _RefType["Lockable"];
      })
    | (Omit<MarkedAsDuplicateEvent, "actor" | "canonical" | "duplicate"> & {
        actor?: Maybe<_RefType["Actor"]>;
        canonical?: Maybe<_RefType["IssueOrPullRequest"]>;
        duplicate?: Maybe<_RefType["IssueOrPullRequest"]>;
      })
    | (Omit<MentionedEvent, "actor"> & { actor?: Maybe<_RefType["Actor"]> })
    | (Omit<MilestonedEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject: _RefType["MilestoneItem"];
      })
    | (Omit<MovedColumnsInProjectEvent, "actor" | "project" | "projectCard"> & {
        actor?: Maybe<_RefType["Actor"]>;
        project?: Maybe<_RefType["Project"]>;
        projectCard?: Maybe<_RefType["ProjectCard"]>;
      })
    | (Omit<PinnedEvent, "actor" | "issue"> & {
        actor?: Maybe<_RefType["Actor"]>;
        issue: _RefType["Issue"];
      })
    | (Omit<
        ReferencedEvent,
        "actor" | "commit" | "commitRepository" | "subject"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        commit?: Maybe<_RefType["Commit"]>;
        commitRepository: _RefType["Repository"];
        subject: _RefType["ReferencedSubject"];
      })
    | (Omit<RemovedFromProjectEvent, "actor" | "project"> & {
        actor?: Maybe<_RefType["Actor"]>;
        project?: Maybe<_RefType["Project"]>;
      })
    | (Omit<RenamedTitleEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject: _RefType["RenamedTitleSubject"];
      })
    | (Omit<ReopenedEvent, "actor" | "closable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        closable: _RefType["Closable"];
      })
    | (Omit<SubscribedEvent, "actor" | "subscribable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subscribable: _RefType["Subscribable"];
      })
    | (Omit<TransferredEvent, "actor" | "fromRepository" | "issue"> & {
        actor?: Maybe<_RefType["Actor"]>;
        fromRepository?: Maybe<_RefType["Repository"]>;
        issue: _RefType["Issue"];
      })
    | (Omit<UnassignedEvent, "actor" | "assignable" | "assignee" | "user"> & {
        actor?: Maybe<_RefType["Actor"]>;
        assignable: _RefType["Assignable"];
        assignee?: Maybe<_RefType["Assignee"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<UnlabeledEvent, "actor" | "label" | "labelable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        label: _RefType["Label"];
        labelable: _RefType["Labelable"];
      })
    | (Omit<UnlockedEvent, "actor" | "lockable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        lockable: _RefType["Lockable"];
      })
    | (Omit<UnmarkedAsDuplicateEvent, "actor" | "canonical" | "duplicate"> & {
        actor?: Maybe<_RefType["Actor"]>;
        canonical?: Maybe<_RefType["IssueOrPullRequest"]>;
        duplicate?: Maybe<_RefType["IssueOrPullRequest"]>;
      })
    | (Omit<UnpinnedEvent, "actor" | "issue"> & {
        actor?: Maybe<_RefType["Actor"]>;
        issue: _RefType["Issue"];
      })
    | (Omit<UnsubscribedEvent, "actor" | "subscribable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subscribable: _RefType["Subscribable"];
      })
    | (Omit<UserBlockedEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject?: Maybe<_RefType["User"]>;
      });
  MilestoneItem:
    | (Omit<
        Issue,
        | "author"
        | "closedByPullRequestsReferences"
        | "comments"
        | "editor"
        | "hovercard"
        | "labels"
        | "milestone"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "timeline"
        | "timelineItems"
        | "trackedInIssues"
        | "trackedIssues"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        closedByPullRequestsReferences?: Maybe<
          _RefType["PullRequestConnection"]
        >;
        comments: _RefType["IssueCommentConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        timeline: _RefType["IssueTimelineConnection"];
        timelineItems: _RefType["IssueTimelineItemsConnection"];
        trackedInIssues: _RefType["IssueConnection"];
        trackedIssues: _RefType["IssueConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<
        PullRequest,
        | "author"
        | "autoMergeRequest"
        | "baseRef"
        | "baseRepository"
        | "closingIssuesReferences"
        | "comments"
        | "commits"
        | "editor"
        | "headRef"
        | "headRepository"
        | "headRepositoryOwner"
        | "hovercard"
        | "labels"
        | "latestOpinionatedReviews"
        | "latestReviews"
        | "mergeCommit"
        | "mergeQueue"
        | "mergeQueueEntry"
        | "mergedBy"
        | "milestone"
        | "potentialMergeCommit"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "reviewRequests"
        | "reviewThreads"
        | "reviews"
        | "statusCheckRollup"
        | "timeline"
        | "timelineItems"
        | "userContentEdits"
        | "viewerLatestReview"
        | "viewerLatestReviewRequest"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
        baseRef?: Maybe<_RefType["Ref"]>;
        baseRepository?: Maybe<_RefType["Repository"]>;
        closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
        comments: _RefType["IssueCommentConnection"];
        commits: _RefType["PullRequestCommitConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        headRef?: Maybe<_RefType["Ref"]>;
        headRepository?: Maybe<_RefType["Repository"]>;
        headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestOpinionatedReviews?: Maybe<
          _RefType["PullRequestReviewConnection"]
        >;
        latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        mergeCommit?: Maybe<_RefType["Commit"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
        mergedBy?: Maybe<_RefType["Actor"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        potentialMergeCommit?: Maybe<_RefType["Commit"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
        reviewThreads: _RefType["PullRequestReviewThreadConnection"];
        reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
        timeline: _RefType["PullRequestTimelineConnection"];
        timelineItems: _RefType["PullRequestTimelineItemsConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
        viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
      });
  OrgRestoreMemberAuditEntryMembership:
    | (Omit<
        OrgRestoreMemberMembershipOrganizationAuditEntryData,
        "organization"
      > & { organization?: Maybe<_RefType["Organization"]> })
    | (Omit<
        OrgRestoreMemberMembershipRepositoryAuditEntryData,
        "repository"
      > & { repository?: Maybe<_RefType["Repository"]> })
    | (Omit<OrgRestoreMemberMembershipTeamAuditEntryData, "team"> & {
        team?: Maybe<_RefType["Team"]>;
      });
  OrganizationAuditEntry:
    | (Omit<
        MembersCanDeleteReposClearAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        MembersCanDeleteReposDisableAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        MembersCanDeleteReposEnableAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OauthApplicationCreateAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgAddBillingManagerAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<OrgAddMemberAuditEntry, "actor" | "organization" | "user"> & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgBlockUserAuditEntry,
        "actor" | "blockedUser" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        blockedUser?: Maybe<_RefType["User"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgConfigDisableCollaboratorsOnlyAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgConfigEnableCollaboratorsOnlyAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<OrgCreateAuditEntry, "actor" | "organization" | "user"> & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgDisableOauthAppRestrictionsAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<OrgDisableSamlAuditEntry, "actor" | "organization" | "user"> & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgDisableTwoFactorRequirementAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgEnableOauthAppRestrictionsAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<OrgEnableSamlAuditEntry, "actor" | "organization" | "user"> & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgEnableTwoFactorRequirementAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgInviteMemberAuditEntry,
        "actor" | "organization" | "organizationInvitation" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        organizationInvitation?: Maybe<_RefType["OrganizationInvitation"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgInviteToBusinessAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgOauthAppAccessApprovedAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgOauthAppAccessBlockedAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgOauthAppAccessDeniedAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgOauthAppAccessRequestedAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgOauthAppAccessUnblockedAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgRemoveBillingManagerAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<OrgRemoveMemberAuditEntry, "actor" | "organization" | "user"> & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgRemoveOutsideCollaboratorAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgRestoreMemberAuditEntry,
        "actor" | "organization" | "restoredMemberships" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        restoredMemberships?: Maybe<
          Array<_RefType["OrgRestoreMemberAuditEntryMembership"]>
        >;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgUnblockUserAuditEntry,
        "actor" | "blockedUser" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        blockedUser?: Maybe<_RefType["User"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgUpdateDefaultRepositoryPermissionAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<OrgUpdateMemberAuditEntry, "actor" | "organization" | "user"> & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgUpdateMemberRepositoryCreationPermissionAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        OrgUpdateMemberRepositoryInvitationPermissionAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        PrivateRepositoryForkingDisableAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        PrivateRepositoryForkingEnableAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoAccessAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoAddMemberAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoAddTopicAuditEntry,
        "actor" | "organization" | "repository" | "topic" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        topic?: Maybe<_RefType["Topic"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoArchivedAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoChangeMergeSettingAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoConfigDisableAnonymousGitAccessAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoConfigDisableCollaboratorsOnlyAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoConfigDisableContributorsOnlyAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoConfigDisableSockpuppetDisallowedAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoConfigEnableAnonymousGitAccessAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoConfigEnableCollaboratorsOnlyAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoConfigEnableContributorsOnlyAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoConfigEnableSockpuppetDisallowedAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoConfigLockAnonymousGitAccessAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoConfigUnlockAnonymousGitAccessAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoCreateAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoDestroyAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoRemoveMemberAuditEntry,
        "actor" | "organization" | "repository" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepoRemoveTopicAuditEntry,
        "actor" | "organization" | "repository" | "topic" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        topic?: Maybe<_RefType["Topic"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepositoryVisibilityChangeDisableAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        RepositoryVisibilityChangeEnableAuditEntry,
        "actor" | "organization" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        TeamAddMemberAuditEntry,
        "actor" | "organization" | "team" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        team?: Maybe<_RefType["Team"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        TeamAddRepositoryAuditEntry,
        "actor" | "organization" | "repository" | "team" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        team?: Maybe<_RefType["Team"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        TeamChangeParentTeamAuditEntry,
        | "actor"
        | "organization"
        | "parentTeam"
        | "parentTeamWas"
        | "team"
        | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        parentTeam?: Maybe<_RefType["Team"]>;
        parentTeamWas?: Maybe<_RefType["Team"]>;
        team?: Maybe<_RefType["Team"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        TeamRemoveMemberAuditEntry,
        "actor" | "organization" | "team" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        team?: Maybe<_RefType["Team"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        TeamRemoveRepositoryAuditEntry,
        "actor" | "organization" | "repository" | "team" | "user"
      > & {
        actor?: Maybe<_RefType["AuditEntryActor"]>;
        organization?: Maybe<_RefType["Organization"]>;
        repository?: Maybe<_RefType["Repository"]>;
        team?: Maybe<_RefType["Team"]>;
        user?: Maybe<_RefType["User"]>;
      });
  OrganizationOrUser:
    | (Omit<
        Organization,
        | "auditLog"
        | "domains"
        | "enterpriseOwners"
        | "ipAllowListEntries"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "mannequins"
        | "memberStatuses"
        | "membersWithRole"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "recentProjects"
        | "repositories"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "ruleset"
        | "rulesets"
        | "samlIdentityProvider"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "team"
        | "teams"
      > & {
        auditLog: _RefType["OrganizationAuditEntryConnection"];
        domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
        enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        mannequins: _RefType["MannequinConnection"];
        memberStatuses: _RefType["UserStatusConnection"];
        membersWithRole: _RefType["OrganizationMemberConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        samlIdentityProvider?: Maybe<_RefType["OrganizationIdentityProvider"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        team?: Maybe<_RefType["Team"]>;
        teams: _RefType["TeamConnection"];
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  PermissionGranter:
    | (Omit<
        Organization,
        | "auditLog"
        | "domains"
        | "enterpriseOwners"
        | "ipAllowListEntries"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "mannequins"
        | "memberStatuses"
        | "membersWithRole"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "recentProjects"
        | "repositories"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "ruleset"
        | "rulesets"
        | "samlIdentityProvider"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "team"
        | "teams"
      > & {
        auditLog: _RefType["OrganizationAuditEntryConnection"];
        domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
        enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        mannequins: _RefType["MannequinConnection"];
        memberStatuses: _RefType["UserStatusConnection"];
        membersWithRole: _RefType["OrganizationMemberConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        samlIdentityProvider?: Maybe<_RefType["OrganizationIdentityProvider"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        team?: Maybe<_RefType["Team"]>;
        teams: _RefType["TeamConnection"];
      })
    | (Omit<
        Repository,
        | "branchProtectionRules"
        | "collaborators"
        | "commitComments"
        | "defaultBranchRef"
        | "dependencyGraphManifests"
        | "deployments"
        | "discussion"
        | "discussionCategories"
        | "discussionCategory"
        | "discussions"
        | "environment"
        | "environments"
        | "forks"
        | "issue"
        | "issueOrPullRequest"
        | "issueTemplates"
        | "issues"
        | "label"
        | "labels"
        | "latestRelease"
        | "mergeQueue"
        | "milestone"
        | "milestones"
        | "object"
        | "owner"
        | "packages"
        | "parent"
        | "pinnedDiscussions"
        | "pinnedEnvironments"
        | "pinnedIssues"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequest"
        | "pullRequestTemplates"
        | "pullRequests"
        | "recentProjects"
        | "ref"
        | "release"
        | "releases"
        | "repositoryTopics"
        | "ruleset"
        | "rulesets"
        | "templateRepository"
        | "vulnerabilityAlert"
        | "vulnerabilityAlerts"
      > & {
        branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
        collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
        commitComments: _RefType["CommitCommentConnection"];
        defaultBranchRef?: Maybe<_RefType["Ref"]>;
        dependencyGraphManifests?: Maybe<
          _RefType["DependencyGraphManifestConnection"]
        >;
        deployments: _RefType["DeploymentConnection"];
        discussion?: Maybe<_RefType["Discussion"]>;
        discussionCategories: _RefType["DiscussionCategoryConnection"];
        discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
        discussions: _RefType["DiscussionConnection"];
        environment?: Maybe<_RefType["Environment"]>;
        environments: _RefType["EnvironmentConnection"];
        forks: _RefType["RepositoryConnection"];
        issue?: Maybe<_RefType["Issue"]>;
        issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
        issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
        issues: _RefType["IssueConnection"];
        label?: Maybe<_RefType["Label"]>;
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestRelease?: Maybe<_RefType["Release"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        milestones?: Maybe<_RefType["MilestoneConnection"]>;
        object?: Maybe<_RefType["GitObject"]>;
        owner: _RefType["RepositoryOwner"];
        packages: _RefType["PackageConnection"];
        parent?: Maybe<_RefType["Repository"]>;
        pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
        pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
        pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequest?: Maybe<_RefType["PullRequest"]>;
        pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        ref?: Maybe<_RefType["Ref"]>;
        release?: Maybe<_RefType["Release"]>;
        releases: _RefType["ReleaseConnection"];
        repositoryTopics: _RefType["RepositoryTopicConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        templateRepository?: Maybe<_RefType["Repository"]>;
        vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
        vulnerabilityAlerts?: Maybe<
          _RefType["RepositoryVulnerabilityAlertConnection"]
        >;
      })
    | (Omit<
        Team,
        | "ancestors"
        | "childTeams"
        | "discussion"
        | "discussions"
        | "invitations"
        | "memberStatuses"
        | "organization"
        | "parentTeam"
        | "projectV2"
        | "projectsV2"
        | "repositories"
      > & {
        ancestors: _RefType["TeamConnection"];
        childTeams: _RefType["TeamConnection"];
        discussion?: Maybe<_RefType["TeamDiscussion"]>;
        discussions: _RefType["TeamDiscussionConnection"];
        invitations?: Maybe<_RefType["OrganizationInvitationConnection"]>;
        memberStatuses: _RefType["UserStatusConnection"];
        organization: _RefType["Organization"];
        parentTeam?: Maybe<_RefType["Team"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        repositories: _RefType["TeamRepositoryConnection"];
      });
  PinnableItem:
    | (Omit<Gist, "comments" | "forks" | "owner"> & {
        comments: _RefType["GistCommentConnection"];
        forks: _RefType["GistConnection"];
        owner?: Maybe<_RefType["RepositoryOwner"]>;
      })
    | (Omit<
        Repository,
        | "branchProtectionRules"
        | "collaborators"
        | "commitComments"
        | "defaultBranchRef"
        | "dependencyGraphManifests"
        | "deployments"
        | "discussion"
        | "discussionCategories"
        | "discussionCategory"
        | "discussions"
        | "environment"
        | "environments"
        | "forks"
        | "issue"
        | "issueOrPullRequest"
        | "issueTemplates"
        | "issues"
        | "label"
        | "labels"
        | "latestRelease"
        | "mergeQueue"
        | "milestone"
        | "milestones"
        | "object"
        | "owner"
        | "packages"
        | "parent"
        | "pinnedDiscussions"
        | "pinnedEnvironments"
        | "pinnedIssues"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequest"
        | "pullRequestTemplates"
        | "pullRequests"
        | "recentProjects"
        | "ref"
        | "release"
        | "releases"
        | "repositoryTopics"
        | "ruleset"
        | "rulesets"
        | "templateRepository"
        | "vulnerabilityAlert"
        | "vulnerabilityAlerts"
      > & {
        branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
        collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
        commitComments: _RefType["CommitCommentConnection"];
        defaultBranchRef?: Maybe<_RefType["Ref"]>;
        dependencyGraphManifests?: Maybe<
          _RefType["DependencyGraphManifestConnection"]
        >;
        deployments: _RefType["DeploymentConnection"];
        discussion?: Maybe<_RefType["Discussion"]>;
        discussionCategories: _RefType["DiscussionCategoryConnection"];
        discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
        discussions: _RefType["DiscussionConnection"];
        environment?: Maybe<_RefType["Environment"]>;
        environments: _RefType["EnvironmentConnection"];
        forks: _RefType["RepositoryConnection"];
        issue?: Maybe<_RefType["Issue"]>;
        issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
        issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
        issues: _RefType["IssueConnection"];
        label?: Maybe<_RefType["Label"]>;
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestRelease?: Maybe<_RefType["Release"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        milestones?: Maybe<_RefType["MilestoneConnection"]>;
        object?: Maybe<_RefType["GitObject"]>;
        owner: _RefType["RepositoryOwner"];
        packages: _RefType["PackageConnection"];
        parent?: Maybe<_RefType["Repository"]>;
        pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
        pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
        pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequest?: Maybe<_RefType["PullRequest"]>;
        pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        ref?: Maybe<_RefType["Ref"]>;
        release?: Maybe<_RefType["Release"]>;
        releases: _RefType["ReleaseConnection"];
        repositoryTopics: _RefType["RepositoryTopicConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        templateRepository?: Maybe<_RefType["Repository"]>;
        vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
        vulnerabilityAlerts?: Maybe<
          _RefType["RepositoryVulnerabilityAlertConnection"]
        >;
      });
  ProjectCardItem:
    | (Omit<
        Issue,
        | "author"
        | "closedByPullRequestsReferences"
        | "comments"
        | "editor"
        | "hovercard"
        | "labels"
        | "milestone"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "timeline"
        | "timelineItems"
        | "trackedInIssues"
        | "trackedIssues"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        closedByPullRequestsReferences?: Maybe<
          _RefType["PullRequestConnection"]
        >;
        comments: _RefType["IssueCommentConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        timeline: _RefType["IssueTimelineConnection"];
        timelineItems: _RefType["IssueTimelineItemsConnection"];
        trackedInIssues: _RefType["IssueConnection"];
        trackedIssues: _RefType["IssueConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<
        PullRequest,
        | "author"
        | "autoMergeRequest"
        | "baseRef"
        | "baseRepository"
        | "closingIssuesReferences"
        | "comments"
        | "commits"
        | "editor"
        | "headRef"
        | "headRepository"
        | "headRepositoryOwner"
        | "hovercard"
        | "labels"
        | "latestOpinionatedReviews"
        | "latestReviews"
        | "mergeCommit"
        | "mergeQueue"
        | "mergeQueueEntry"
        | "mergedBy"
        | "milestone"
        | "potentialMergeCommit"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "reviewRequests"
        | "reviewThreads"
        | "reviews"
        | "statusCheckRollup"
        | "timeline"
        | "timelineItems"
        | "userContentEdits"
        | "viewerLatestReview"
        | "viewerLatestReviewRequest"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
        baseRef?: Maybe<_RefType["Ref"]>;
        baseRepository?: Maybe<_RefType["Repository"]>;
        closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
        comments: _RefType["IssueCommentConnection"];
        commits: _RefType["PullRequestCommitConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        headRef?: Maybe<_RefType["Ref"]>;
        headRepository?: Maybe<_RefType["Repository"]>;
        headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestOpinionatedReviews?: Maybe<
          _RefType["PullRequestReviewConnection"]
        >;
        latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        mergeCommit?: Maybe<_RefType["Commit"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
        mergedBy?: Maybe<_RefType["Actor"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        potentialMergeCommit?: Maybe<_RefType["Commit"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
        reviewThreads: _RefType["PullRequestReviewThreadConnection"];
        reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
        timeline: _RefType["PullRequestTimelineConnection"];
        timelineItems: _RefType["PullRequestTimelineItemsConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
        viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
      });
  ProjectV2Actor:
    | (Omit<
        Team,
        | "ancestors"
        | "childTeams"
        | "discussion"
        | "discussions"
        | "invitations"
        | "memberStatuses"
        | "organization"
        | "parentTeam"
        | "projectV2"
        | "projectsV2"
        | "repositories"
      > & {
        ancestors: _RefType["TeamConnection"];
        childTeams: _RefType["TeamConnection"];
        discussion?: Maybe<_RefType["TeamDiscussion"]>;
        discussions: _RefType["TeamDiscussionConnection"];
        invitations?: Maybe<_RefType["OrganizationInvitationConnection"]>;
        memberStatuses: _RefType["UserStatusConnection"];
        organization: _RefType["Organization"];
        parentTeam?: Maybe<_RefType["Team"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        repositories: _RefType["TeamRepositoryConnection"];
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  ProjectV2FieldConfiguration:
    | (Omit<ProjectV2Field, "project"> & { project: _RefType["ProjectV2"] })
    | (Omit<ProjectV2IterationField, "project"> & {
        project: _RefType["ProjectV2"];
      })
    | (Omit<ProjectV2SingleSelectField, "project"> & {
        project: _RefType["ProjectV2"];
      });
  ProjectV2ItemContent:
    | (Omit<DraftIssue, "creator" | "projectV2Items" | "projectsV2"> & {
        creator?: Maybe<_RefType["Actor"]>;
        projectV2Items: _RefType["ProjectV2ItemConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
      })
    | (Omit<
        Issue,
        | "author"
        | "closedByPullRequestsReferences"
        | "comments"
        | "editor"
        | "hovercard"
        | "labels"
        | "milestone"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "timeline"
        | "timelineItems"
        | "trackedInIssues"
        | "trackedIssues"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        closedByPullRequestsReferences?: Maybe<
          _RefType["PullRequestConnection"]
        >;
        comments: _RefType["IssueCommentConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        timeline: _RefType["IssueTimelineConnection"];
        timelineItems: _RefType["IssueTimelineItemsConnection"];
        trackedInIssues: _RefType["IssueConnection"];
        trackedIssues: _RefType["IssueConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<
        PullRequest,
        | "author"
        | "autoMergeRequest"
        | "baseRef"
        | "baseRepository"
        | "closingIssuesReferences"
        | "comments"
        | "commits"
        | "editor"
        | "headRef"
        | "headRepository"
        | "headRepositoryOwner"
        | "hovercard"
        | "labels"
        | "latestOpinionatedReviews"
        | "latestReviews"
        | "mergeCommit"
        | "mergeQueue"
        | "mergeQueueEntry"
        | "mergedBy"
        | "milestone"
        | "potentialMergeCommit"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "reviewRequests"
        | "reviewThreads"
        | "reviews"
        | "statusCheckRollup"
        | "timeline"
        | "timelineItems"
        | "userContentEdits"
        | "viewerLatestReview"
        | "viewerLatestReviewRequest"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
        baseRef?: Maybe<_RefType["Ref"]>;
        baseRepository?: Maybe<_RefType["Repository"]>;
        closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
        comments: _RefType["IssueCommentConnection"];
        commits: _RefType["PullRequestCommitConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        headRef?: Maybe<_RefType["Ref"]>;
        headRepository?: Maybe<_RefType["Repository"]>;
        headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestOpinionatedReviews?: Maybe<
          _RefType["PullRequestReviewConnection"]
        >;
        latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        mergeCommit?: Maybe<_RefType["Commit"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
        mergedBy?: Maybe<_RefType["Actor"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        potentialMergeCommit?: Maybe<_RefType["Commit"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
        reviewThreads: _RefType["PullRequestReviewThreadConnection"];
        reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
        timeline: _RefType["PullRequestTimelineConnection"];
        timelineItems: _RefType["PullRequestTimelineItemsConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
        viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
      });
  ProjectV2ItemFieldValue:
    | (Omit<ProjectV2ItemFieldDateValue, "creator" | "field" | "item"> & {
        creator?: Maybe<_RefType["Actor"]>;
        field: _RefType["ProjectV2FieldConfiguration"];
        item: _RefType["ProjectV2Item"];
      })
    | (Omit<ProjectV2ItemFieldIterationValue, "creator" | "field" | "item"> & {
        creator?: Maybe<_RefType["Actor"]>;
        field: _RefType["ProjectV2FieldConfiguration"];
        item: _RefType["ProjectV2Item"];
      })
    | (Omit<ProjectV2ItemFieldLabelValue, "field" | "labels"> & {
        field: _RefType["ProjectV2FieldConfiguration"];
        labels?: Maybe<_RefType["LabelConnection"]>;
      })
    | (Omit<ProjectV2ItemFieldMilestoneValue, "field" | "milestone"> & {
        field: _RefType["ProjectV2FieldConfiguration"];
        milestone?: Maybe<_RefType["Milestone"]>;
      })
    | (Omit<ProjectV2ItemFieldNumberValue, "creator" | "field" | "item"> & {
        creator?: Maybe<_RefType["Actor"]>;
        field: _RefType["ProjectV2FieldConfiguration"];
        item: _RefType["ProjectV2Item"];
      })
    | (Omit<ProjectV2ItemFieldPullRequestValue, "field" | "pullRequests"> & {
        field: _RefType["ProjectV2FieldConfiguration"];
        pullRequests?: Maybe<_RefType["PullRequestConnection"]>;
      })
    | (Omit<ProjectV2ItemFieldRepositoryValue, "field" | "repository"> & {
        field: _RefType["ProjectV2FieldConfiguration"];
        repository?: Maybe<_RefType["Repository"]>;
      })
    | (Omit<ProjectV2ItemFieldReviewerValue, "field" | "reviewers"> & {
        field: _RefType["ProjectV2FieldConfiguration"];
        reviewers?: Maybe<_RefType["RequestedReviewerConnection"]>;
      })
    | (Omit<
        ProjectV2ItemFieldSingleSelectValue,
        "creator" | "field" | "item"
      > & {
        creator?: Maybe<_RefType["Actor"]>;
        field: _RefType["ProjectV2FieldConfiguration"];
        item: _RefType["ProjectV2Item"];
      })
    | (Omit<ProjectV2ItemFieldTextValue, "creator" | "field" | "item"> & {
        creator?: Maybe<_RefType["Actor"]>;
        field: _RefType["ProjectV2FieldConfiguration"];
        item: _RefType["ProjectV2Item"];
      })
    | (Omit<ProjectV2ItemFieldUserValue, "field"> & {
        field: _RefType["ProjectV2FieldConfiguration"];
      });
  PullRequestTimelineItem:
    | (Omit<AssignedEvent, "actor" | "assignable" | "assignee" | "user"> & {
        actor?: Maybe<_RefType["Actor"]>;
        assignable: _RefType["Assignable"];
        assignee?: Maybe<_RefType["Assignee"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<BaseRefDeletedEvent, "actor" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest?: Maybe<_RefType["PullRequest"]>;
      })
    | (Omit<
        BaseRefForcePushedEvent,
        "actor" | "afterCommit" | "beforeCommit" | "pullRequest" | "ref"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        afterCommit?: Maybe<_RefType["Commit"]>;
        beforeCommit?: Maybe<_RefType["Commit"]>;
        pullRequest: _RefType["PullRequest"];
        ref?: Maybe<_RefType["Ref"]>;
      })
    | (Omit<ClosedEvent, "actor" | "closable" | "closer"> & {
        actor?: Maybe<_RefType["Actor"]>;
        closable: _RefType["Closable"];
        closer?: Maybe<_RefType["Closer"]>;
      })
    | (Omit<
        Commit,
        | "associatedPullRequests"
        | "blame"
        | "checkSuites"
        | "comments"
        | "deployments"
        | "file"
        | "history"
        | "onBehalfOf"
        | "parents"
        | "repository"
        | "signature"
        | "status"
        | "statusCheckRollup"
        | "tree"
      > & {
        associatedPullRequests?: Maybe<_RefType["PullRequestConnection"]>;
        blame: _RefType["Blame"];
        checkSuites?: Maybe<_RefType["CheckSuiteConnection"]>;
        comments: _RefType["CommitCommentConnection"];
        deployments?: Maybe<_RefType["DeploymentConnection"]>;
        file?: Maybe<_RefType["TreeEntry"]>;
        history: _RefType["CommitHistoryConnection"];
        onBehalfOf?: Maybe<_RefType["Organization"]>;
        parents: _RefType["CommitConnection"];
        repository: _RefType["Repository"];
        signature?: Maybe<_RefType["GitSignature"]>;
        status?: Maybe<_RefType["Status"]>;
        statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
        tree: _RefType["Tree"];
      })
    | (Omit<CommitCommentThread, "comments" | "commit" | "repository"> & {
        comments: _RefType["CommitCommentConnection"];
        commit?: Maybe<_RefType["Commit"]>;
        repository: _RefType["Repository"];
      })
    | (Omit<CrossReferencedEvent, "actor" | "source" | "target"> & {
        actor?: Maybe<_RefType["Actor"]>;
        source: _RefType["ReferencedSubject"];
        target: _RefType["ReferencedSubject"];
      })
    | (Omit<DemilestonedEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject: _RefType["MilestoneItem"];
      })
    | (Omit<DeployedEvent, "actor" | "deployment" | "pullRequest" | "ref"> & {
        actor?: Maybe<_RefType["Actor"]>;
        deployment: _RefType["Deployment"];
        pullRequest: _RefType["PullRequest"];
        ref?: Maybe<_RefType["Ref"]>;
      })
    | (Omit<
        DeploymentEnvironmentChangedEvent,
        "actor" | "deploymentStatus" | "pullRequest"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        deploymentStatus: _RefType["DeploymentStatus"];
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<HeadRefDeletedEvent, "actor" | "headRef" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        headRef?: Maybe<_RefType["Ref"]>;
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<
        HeadRefForcePushedEvent,
        "actor" | "afterCommit" | "beforeCommit" | "pullRequest" | "ref"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        afterCommit?: Maybe<_RefType["Commit"]>;
        beforeCommit?: Maybe<_RefType["Commit"]>;
        pullRequest: _RefType["PullRequest"];
        ref?: Maybe<_RefType["Ref"]>;
      })
    | (Omit<HeadRefRestoredEvent, "actor" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<
        IssueComment,
        | "author"
        | "editor"
        | "issue"
        | "pullRequest"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        editor?: Maybe<_RefType["Actor"]>;
        issue: _RefType["Issue"];
        pullRequest?: Maybe<_RefType["PullRequest"]>;
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<LabeledEvent, "actor" | "label" | "labelable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        label: _RefType["Label"];
        labelable: _RefType["Labelable"];
      })
    | (Omit<LockedEvent, "actor" | "lockable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        lockable: _RefType["Lockable"];
      })
    | (Omit<MergedEvent, "actor" | "commit" | "mergeRef" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        commit?: Maybe<_RefType["Commit"]>;
        mergeRef?: Maybe<_RefType["Ref"]>;
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<MilestonedEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject: _RefType["MilestoneItem"];
      })
    | (Omit<
        PullRequestReview,
        | "author"
        | "comments"
        | "commit"
        | "editor"
        | "onBehalfOf"
        | "pullRequest"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        comments: _RefType["PullRequestReviewCommentConnection"];
        commit?: Maybe<_RefType["Commit"]>;
        editor?: Maybe<_RefType["Actor"]>;
        onBehalfOf: _RefType["TeamConnection"];
        pullRequest: _RefType["PullRequest"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<
        PullRequestReviewComment,
        | "author"
        | "commit"
        | "editor"
        | "originalCommit"
        | "pullRequest"
        | "pullRequestReview"
        | "reactionGroups"
        | "reactions"
        | "replyTo"
        | "repository"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        commit?: Maybe<_RefType["Commit"]>;
        editor?: Maybe<_RefType["Actor"]>;
        originalCommit?: Maybe<_RefType["Commit"]>;
        pullRequest: _RefType["PullRequest"];
        pullRequestReview?: Maybe<_RefType["PullRequestReview"]>;
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        replyTo?: Maybe<_RefType["PullRequestReviewComment"]>;
        repository: _RefType["Repository"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<
        PullRequestReviewThread,
        "comments" | "pullRequest" | "repository" | "resolvedBy"
      > & {
        comments: _RefType["PullRequestReviewCommentConnection"];
        pullRequest: _RefType["PullRequest"];
        repository: _RefType["Repository"];
        resolvedBy?: Maybe<_RefType["User"]>;
      })
    | (Omit<
        ReferencedEvent,
        "actor" | "commit" | "commitRepository" | "subject"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        commit?: Maybe<_RefType["Commit"]>;
        commitRepository: _RefType["Repository"];
        subject: _RefType["ReferencedSubject"];
      })
    | (Omit<RenamedTitleEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject: _RefType["RenamedTitleSubject"];
      })
    | (Omit<ReopenedEvent, "actor" | "closable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        closable: _RefType["Closable"];
      })
    | (Omit<
        ReviewDismissedEvent,
        "actor" | "pullRequest" | "pullRequestCommit" | "review"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
        pullRequestCommit?: Maybe<_RefType["PullRequestCommit"]>;
        review?: Maybe<_RefType["PullRequestReview"]>;
      })
    | (Omit<
        ReviewRequestRemovedEvent,
        "actor" | "pullRequest" | "requestedReviewer"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
        requestedReviewer?: Maybe<_RefType["RequestedReviewer"]>;
      })
    | (Omit<
        ReviewRequestedEvent,
        "actor" | "pullRequest" | "requestedReviewer"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
        requestedReviewer?: Maybe<_RefType["RequestedReviewer"]>;
      })
    | (Omit<SubscribedEvent, "actor" | "subscribable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subscribable: _RefType["Subscribable"];
      })
    | (Omit<UnassignedEvent, "actor" | "assignable" | "assignee" | "user"> & {
        actor?: Maybe<_RefType["Actor"]>;
        assignable: _RefType["Assignable"];
        assignee?: Maybe<_RefType["Assignee"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<UnlabeledEvent, "actor" | "label" | "labelable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        label: _RefType["Label"];
        labelable: _RefType["Labelable"];
      })
    | (Omit<UnlockedEvent, "actor" | "lockable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        lockable: _RefType["Lockable"];
      })
    | (Omit<UnsubscribedEvent, "actor" | "subscribable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subscribable: _RefType["Subscribable"];
      })
    | (Omit<UserBlockedEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject?: Maybe<_RefType["User"]>;
      });
  PullRequestTimelineItems:
    | (Omit<
        AddedToMergeQueueEvent,
        "actor" | "enqueuer" | "mergeQueue" | "pullRequest"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        enqueuer?: Maybe<_RefType["User"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        pullRequest?: Maybe<_RefType["PullRequest"]>;
      })
    | (Omit<AddedToProjectEvent, "actor" | "project" | "projectCard"> & {
        actor?: Maybe<_RefType["Actor"]>;
        project?: Maybe<_RefType["Project"]>;
        projectCard?: Maybe<_RefType["ProjectCard"]>;
      })
    | (Omit<AssignedEvent, "actor" | "assignable" | "assignee" | "user"> & {
        actor?: Maybe<_RefType["Actor"]>;
        assignable: _RefType["Assignable"];
        assignee?: Maybe<_RefType["Assignee"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<AutoMergeDisabledEvent, "actor" | "disabler" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        disabler?: Maybe<_RefType["User"]>;
        pullRequest?: Maybe<_RefType["PullRequest"]>;
      })
    | (Omit<AutoMergeEnabledEvent, "actor" | "enabler" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        enabler?: Maybe<_RefType["User"]>;
        pullRequest?: Maybe<_RefType["PullRequest"]>;
      })
    | (Omit<AutoRebaseEnabledEvent, "actor" | "enabler" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        enabler?: Maybe<_RefType["User"]>;
        pullRequest?: Maybe<_RefType["PullRequest"]>;
      })
    | (Omit<AutoSquashEnabledEvent, "actor" | "enabler" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        enabler?: Maybe<_RefType["User"]>;
        pullRequest?: Maybe<_RefType["PullRequest"]>;
      })
    | (Omit<AutomaticBaseChangeFailedEvent, "actor" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<AutomaticBaseChangeSucceededEvent, "actor" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<BaseRefChangedEvent, "actor" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<BaseRefDeletedEvent, "actor" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest?: Maybe<_RefType["PullRequest"]>;
      })
    | (Omit<
        BaseRefForcePushedEvent,
        "actor" | "afterCommit" | "beforeCommit" | "pullRequest" | "ref"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        afterCommit?: Maybe<_RefType["Commit"]>;
        beforeCommit?: Maybe<_RefType["Commit"]>;
        pullRequest: _RefType["PullRequest"];
        ref?: Maybe<_RefType["Ref"]>;
      })
    | (Omit<ClosedEvent, "actor" | "closable" | "closer"> & {
        actor?: Maybe<_RefType["Actor"]>;
        closable: _RefType["Closable"];
        closer?: Maybe<_RefType["Closer"]>;
      })
    | (Omit<CommentDeletedEvent, "actor" | "deletedCommentAuthor"> & {
        actor?: Maybe<_RefType["Actor"]>;
        deletedCommentAuthor?: Maybe<_RefType["Actor"]>;
      })
    | (Omit<ConnectedEvent, "actor" | "source" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        source: _RefType["ReferencedSubject"];
        subject: _RefType["ReferencedSubject"];
      })
    | (Omit<ConvertToDraftEvent, "actor" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<ConvertedNoteToIssueEvent, "actor" | "project" | "projectCard"> & {
        actor?: Maybe<_RefType["Actor"]>;
        project?: Maybe<_RefType["Project"]>;
        projectCard?: Maybe<_RefType["ProjectCard"]>;
      })
    | (Omit<ConvertedToDiscussionEvent, "actor" | "discussion"> & {
        actor?: Maybe<_RefType["Actor"]>;
        discussion?: Maybe<_RefType["Discussion"]>;
      })
    | (Omit<CrossReferencedEvent, "actor" | "source" | "target"> & {
        actor?: Maybe<_RefType["Actor"]>;
        source: _RefType["ReferencedSubject"];
        target: _RefType["ReferencedSubject"];
      })
    | (Omit<DemilestonedEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject: _RefType["MilestoneItem"];
      })
    | (Omit<DeployedEvent, "actor" | "deployment" | "pullRequest" | "ref"> & {
        actor?: Maybe<_RefType["Actor"]>;
        deployment: _RefType["Deployment"];
        pullRequest: _RefType["PullRequest"];
        ref?: Maybe<_RefType["Ref"]>;
      })
    | (Omit<
        DeploymentEnvironmentChangedEvent,
        "actor" | "deploymentStatus" | "pullRequest"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        deploymentStatus: _RefType["DeploymentStatus"];
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<DisconnectedEvent, "actor" | "source" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        source: _RefType["ReferencedSubject"];
        subject: _RefType["ReferencedSubject"];
      })
    | (Omit<HeadRefDeletedEvent, "actor" | "headRef" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        headRef?: Maybe<_RefType["Ref"]>;
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<
        HeadRefForcePushedEvent,
        "actor" | "afterCommit" | "beforeCommit" | "pullRequest" | "ref"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        afterCommit?: Maybe<_RefType["Commit"]>;
        beforeCommit?: Maybe<_RefType["Commit"]>;
        pullRequest: _RefType["PullRequest"];
        ref?: Maybe<_RefType["Ref"]>;
      })
    | (Omit<HeadRefRestoredEvent, "actor" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<
        IssueComment,
        | "author"
        | "editor"
        | "issue"
        | "pullRequest"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        editor?: Maybe<_RefType["Actor"]>;
        issue: _RefType["Issue"];
        pullRequest?: Maybe<_RefType["PullRequest"]>;
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<LabeledEvent, "actor" | "label" | "labelable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        label: _RefType["Label"];
        labelable: _RefType["Labelable"];
      })
    | (Omit<LockedEvent, "actor" | "lockable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        lockable: _RefType["Lockable"];
      })
    | (Omit<MarkedAsDuplicateEvent, "actor" | "canonical" | "duplicate"> & {
        actor?: Maybe<_RefType["Actor"]>;
        canonical?: Maybe<_RefType["IssueOrPullRequest"]>;
        duplicate?: Maybe<_RefType["IssueOrPullRequest"]>;
      })
    | (Omit<MentionedEvent, "actor"> & { actor?: Maybe<_RefType["Actor"]> })
    | (Omit<MergedEvent, "actor" | "commit" | "mergeRef" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        commit?: Maybe<_RefType["Commit"]>;
        mergeRef?: Maybe<_RefType["Ref"]>;
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<MilestonedEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject: _RefType["MilestoneItem"];
      })
    | (Omit<MovedColumnsInProjectEvent, "actor" | "project" | "projectCard"> & {
        actor?: Maybe<_RefType["Actor"]>;
        project?: Maybe<_RefType["Project"]>;
        projectCard?: Maybe<_RefType["ProjectCard"]>;
      })
    | (Omit<PinnedEvent, "actor" | "issue"> & {
        actor?: Maybe<_RefType["Actor"]>;
        issue: _RefType["Issue"];
      })
    | (Omit<PullRequestCommit, "commit" | "pullRequest"> & {
        commit: _RefType["Commit"];
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<
        PullRequestCommitCommentThread,
        "comments" | "commit" | "pullRequest" | "repository"
      > & {
        comments: _RefType["CommitCommentConnection"];
        commit: _RefType["Commit"];
        pullRequest: _RefType["PullRequest"];
        repository: _RefType["Repository"];
      })
    | (Omit<
        PullRequestReview,
        | "author"
        | "comments"
        | "commit"
        | "editor"
        | "onBehalfOf"
        | "pullRequest"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        comments: _RefType["PullRequestReviewCommentConnection"];
        commit?: Maybe<_RefType["Commit"]>;
        editor?: Maybe<_RefType["Actor"]>;
        onBehalfOf: _RefType["TeamConnection"];
        pullRequest: _RefType["PullRequest"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<
        PullRequestReviewThread,
        "comments" | "pullRequest" | "repository" | "resolvedBy"
      > & {
        comments: _RefType["PullRequestReviewCommentConnection"];
        pullRequest: _RefType["PullRequest"];
        repository: _RefType["Repository"];
        resolvedBy?: Maybe<_RefType["User"]>;
      })
    | (Omit<PullRequestRevisionMarker, "lastSeenCommit" | "pullRequest"> & {
        lastSeenCommit: _RefType["Commit"];
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<ReadyForReviewEvent, "actor" | "pullRequest"> & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
      })
    | (Omit<
        ReferencedEvent,
        "actor" | "commit" | "commitRepository" | "subject"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        commit?: Maybe<_RefType["Commit"]>;
        commitRepository: _RefType["Repository"];
        subject: _RefType["ReferencedSubject"];
      })
    | (Omit<
        RemovedFromMergeQueueEvent,
        "actor" | "beforeCommit" | "enqueuer" | "mergeQueue" | "pullRequest"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        beforeCommit?: Maybe<_RefType["Commit"]>;
        enqueuer?: Maybe<_RefType["User"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        pullRequest?: Maybe<_RefType["PullRequest"]>;
      })
    | (Omit<RemovedFromProjectEvent, "actor" | "project"> & {
        actor?: Maybe<_RefType["Actor"]>;
        project?: Maybe<_RefType["Project"]>;
      })
    | (Omit<RenamedTitleEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject: _RefType["RenamedTitleSubject"];
      })
    | (Omit<ReopenedEvent, "actor" | "closable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        closable: _RefType["Closable"];
      })
    | (Omit<
        ReviewDismissedEvent,
        "actor" | "pullRequest" | "pullRequestCommit" | "review"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
        pullRequestCommit?: Maybe<_RefType["PullRequestCommit"]>;
        review?: Maybe<_RefType["PullRequestReview"]>;
      })
    | (Omit<
        ReviewRequestRemovedEvent,
        "actor" | "pullRequest" | "requestedReviewer"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
        requestedReviewer?: Maybe<_RefType["RequestedReviewer"]>;
      })
    | (Omit<
        ReviewRequestedEvent,
        "actor" | "pullRequest" | "requestedReviewer"
      > & {
        actor?: Maybe<_RefType["Actor"]>;
        pullRequest: _RefType["PullRequest"];
        requestedReviewer?: Maybe<_RefType["RequestedReviewer"]>;
      })
    | (Omit<SubscribedEvent, "actor" | "subscribable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subscribable: _RefType["Subscribable"];
      })
    | (Omit<TransferredEvent, "actor" | "fromRepository" | "issue"> & {
        actor?: Maybe<_RefType["Actor"]>;
        fromRepository?: Maybe<_RefType["Repository"]>;
        issue: _RefType["Issue"];
      })
    | (Omit<UnassignedEvent, "actor" | "assignable" | "assignee" | "user"> & {
        actor?: Maybe<_RefType["Actor"]>;
        assignable: _RefType["Assignable"];
        assignee?: Maybe<_RefType["Assignee"]>;
        user?: Maybe<_RefType["User"]>;
      })
    | (Omit<UnlabeledEvent, "actor" | "label" | "labelable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        label: _RefType["Label"];
        labelable: _RefType["Labelable"];
      })
    | (Omit<UnlockedEvent, "actor" | "lockable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        lockable: _RefType["Lockable"];
      })
    | (Omit<UnmarkedAsDuplicateEvent, "actor" | "canonical" | "duplicate"> & {
        actor?: Maybe<_RefType["Actor"]>;
        canonical?: Maybe<_RefType["IssueOrPullRequest"]>;
        duplicate?: Maybe<_RefType["IssueOrPullRequest"]>;
      })
    | (Omit<UnpinnedEvent, "actor" | "issue"> & {
        actor?: Maybe<_RefType["Actor"]>;
        issue: _RefType["Issue"];
      })
    | (Omit<UnsubscribedEvent, "actor" | "subscribable"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subscribable: _RefType["Subscribable"];
      })
    | (Omit<UserBlockedEvent, "actor" | "subject"> & {
        actor?: Maybe<_RefType["Actor"]>;
        subject?: Maybe<_RefType["User"]>;
      });
  PushAllowanceActor:
    | (Omit<App, "ipAllowListEntries"> & {
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
      })
    | (Omit<
        Team,
        | "ancestors"
        | "childTeams"
        | "discussion"
        | "discussions"
        | "invitations"
        | "memberStatuses"
        | "organization"
        | "parentTeam"
        | "projectV2"
        | "projectsV2"
        | "repositories"
      > & {
        ancestors: _RefType["TeamConnection"];
        childTeams: _RefType["TeamConnection"];
        discussion?: Maybe<_RefType["TeamDiscussion"]>;
        discussions: _RefType["TeamDiscussionConnection"];
        invitations?: Maybe<_RefType["OrganizationInvitationConnection"]>;
        memberStatuses: _RefType["UserStatusConnection"];
        organization: _RefType["Organization"];
        parentTeam?: Maybe<_RefType["Team"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        repositories: _RefType["TeamRepositoryConnection"];
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  Reactor:
    | Bot
    | (Omit<Mannequin, "claimant"> & { claimant?: Maybe<_RefType["User"]> })
    | (Omit<
        Organization,
        | "auditLog"
        | "domains"
        | "enterpriseOwners"
        | "ipAllowListEntries"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "mannequins"
        | "memberStatuses"
        | "membersWithRole"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "recentProjects"
        | "repositories"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "ruleset"
        | "rulesets"
        | "samlIdentityProvider"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "team"
        | "teams"
      > & {
        auditLog: _RefType["OrganizationAuditEntryConnection"];
        domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
        enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        mannequins: _RefType["MannequinConnection"];
        memberStatuses: _RefType["UserStatusConnection"];
        membersWithRole: _RefType["OrganizationMemberConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        samlIdentityProvider?: Maybe<_RefType["OrganizationIdentityProvider"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        team?: Maybe<_RefType["Team"]>;
        teams: _RefType["TeamConnection"];
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  ReferencedSubject:
    | (Omit<
        Issue,
        | "author"
        | "closedByPullRequestsReferences"
        | "comments"
        | "editor"
        | "hovercard"
        | "labels"
        | "milestone"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "timeline"
        | "timelineItems"
        | "trackedInIssues"
        | "trackedIssues"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        closedByPullRequestsReferences?: Maybe<
          _RefType["PullRequestConnection"]
        >;
        comments: _RefType["IssueCommentConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        timeline: _RefType["IssueTimelineConnection"];
        timelineItems: _RefType["IssueTimelineItemsConnection"];
        trackedInIssues: _RefType["IssueConnection"];
        trackedIssues: _RefType["IssueConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<
        PullRequest,
        | "author"
        | "autoMergeRequest"
        | "baseRef"
        | "baseRepository"
        | "closingIssuesReferences"
        | "comments"
        | "commits"
        | "editor"
        | "headRef"
        | "headRepository"
        | "headRepositoryOwner"
        | "hovercard"
        | "labels"
        | "latestOpinionatedReviews"
        | "latestReviews"
        | "mergeCommit"
        | "mergeQueue"
        | "mergeQueueEntry"
        | "mergedBy"
        | "milestone"
        | "potentialMergeCommit"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "reviewRequests"
        | "reviewThreads"
        | "reviews"
        | "statusCheckRollup"
        | "timeline"
        | "timelineItems"
        | "userContentEdits"
        | "viewerLatestReview"
        | "viewerLatestReviewRequest"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
        baseRef?: Maybe<_RefType["Ref"]>;
        baseRepository?: Maybe<_RefType["Repository"]>;
        closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
        comments: _RefType["IssueCommentConnection"];
        commits: _RefType["PullRequestCommitConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        headRef?: Maybe<_RefType["Ref"]>;
        headRepository?: Maybe<_RefType["Repository"]>;
        headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestOpinionatedReviews?: Maybe<
          _RefType["PullRequestReviewConnection"]
        >;
        latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        mergeCommit?: Maybe<_RefType["Commit"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
        mergedBy?: Maybe<_RefType["Actor"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        potentialMergeCommit?: Maybe<_RefType["Commit"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
        reviewThreads: _RefType["PullRequestReviewThreadConnection"];
        reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
        timeline: _RefType["PullRequestTimelineConnection"];
        timelineItems: _RefType["PullRequestTimelineItemsConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
        viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
      });
  RenamedTitleSubject:
    | (Omit<
        Issue,
        | "author"
        | "closedByPullRequestsReferences"
        | "comments"
        | "editor"
        | "hovercard"
        | "labels"
        | "milestone"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "timeline"
        | "timelineItems"
        | "trackedInIssues"
        | "trackedIssues"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        closedByPullRequestsReferences?: Maybe<
          _RefType["PullRequestConnection"]
        >;
        comments: _RefType["IssueCommentConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        timeline: _RefType["IssueTimelineConnection"];
        timelineItems: _RefType["IssueTimelineItemsConnection"];
        trackedInIssues: _RefType["IssueConnection"];
        trackedIssues: _RefType["IssueConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<
        PullRequest,
        | "author"
        | "autoMergeRequest"
        | "baseRef"
        | "baseRepository"
        | "closingIssuesReferences"
        | "comments"
        | "commits"
        | "editor"
        | "headRef"
        | "headRepository"
        | "headRepositoryOwner"
        | "hovercard"
        | "labels"
        | "latestOpinionatedReviews"
        | "latestReviews"
        | "mergeCommit"
        | "mergeQueue"
        | "mergeQueueEntry"
        | "mergedBy"
        | "milestone"
        | "potentialMergeCommit"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "reviewRequests"
        | "reviewThreads"
        | "reviews"
        | "statusCheckRollup"
        | "timeline"
        | "timelineItems"
        | "userContentEdits"
        | "viewerLatestReview"
        | "viewerLatestReviewRequest"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
        baseRef?: Maybe<_RefType["Ref"]>;
        baseRepository?: Maybe<_RefType["Repository"]>;
        closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
        comments: _RefType["IssueCommentConnection"];
        commits: _RefType["PullRequestCommitConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        headRef?: Maybe<_RefType["Ref"]>;
        headRepository?: Maybe<_RefType["Repository"]>;
        headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestOpinionatedReviews?: Maybe<
          _RefType["PullRequestReviewConnection"]
        >;
        latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        mergeCommit?: Maybe<_RefType["Commit"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
        mergedBy?: Maybe<_RefType["Actor"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        potentialMergeCommit?: Maybe<_RefType["Commit"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
        reviewThreads: _RefType["PullRequestReviewThreadConnection"];
        reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
        timeline: _RefType["PullRequestTimelineConnection"];
        timelineItems: _RefType["PullRequestTimelineItemsConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
        viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
      });
  RequestedReviewer:
    | Bot
    | (Omit<Mannequin, "claimant"> & { claimant?: Maybe<_RefType["User"]> })
    | (Omit<
        Team,
        | "ancestors"
        | "childTeams"
        | "discussion"
        | "discussions"
        | "invitations"
        | "memberStatuses"
        | "organization"
        | "parentTeam"
        | "projectV2"
        | "projectsV2"
        | "repositories"
      > & {
        ancestors: _RefType["TeamConnection"];
        childTeams: _RefType["TeamConnection"];
        discussion?: Maybe<_RefType["TeamDiscussion"]>;
        discussions: _RefType["TeamDiscussionConnection"];
        invitations?: Maybe<_RefType["OrganizationInvitationConnection"]>;
        memberStatuses: _RefType["UserStatusConnection"];
        organization: _RefType["Organization"];
        parentTeam?: Maybe<_RefType["Team"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        repositories: _RefType["TeamRepositoryConnection"];
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  ReviewDismissalAllowanceActor:
    | (Omit<App, "ipAllowListEntries"> & {
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
      })
    | (Omit<
        Team,
        | "ancestors"
        | "childTeams"
        | "discussion"
        | "discussions"
        | "invitations"
        | "memberStatuses"
        | "organization"
        | "parentTeam"
        | "projectV2"
        | "projectsV2"
        | "repositories"
      > & {
        ancestors: _RefType["TeamConnection"];
        childTeams: _RefType["TeamConnection"];
        discussion?: Maybe<_RefType["TeamDiscussion"]>;
        discussions: _RefType["TeamDiscussionConnection"];
        invitations?: Maybe<_RefType["OrganizationInvitationConnection"]>;
        memberStatuses: _RefType["UserStatusConnection"];
        organization: _RefType["Organization"];
        parentTeam?: Maybe<_RefType["Team"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        repositories: _RefType["TeamRepositoryConnection"];
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  RuleParameters:
    | BranchNamePatternParameters
    | CodeScanningParameters
    | CommitAuthorEmailPatternParameters
    | CommitMessagePatternParameters
    | CommitterEmailPatternParameters
    | FileExtensionRestrictionParameters
    | FilePathRestrictionParameters
    | MaxFilePathLengthParameters
    | MaxFileSizeParameters
    | MergeQueueParameters
    | PullRequestParameters
    | RequiredDeploymentsParameters
    | RequiredStatusChecksParameters
    | TagNamePatternParameters
    | UpdateParameters
    | WorkflowsParameters;
  RuleSource:
    | (Omit<
        Organization,
        | "auditLog"
        | "domains"
        | "enterpriseOwners"
        | "ipAllowListEntries"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "mannequins"
        | "memberStatuses"
        | "membersWithRole"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "recentProjects"
        | "repositories"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "ruleset"
        | "rulesets"
        | "samlIdentityProvider"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "team"
        | "teams"
      > & {
        auditLog: _RefType["OrganizationAuditEntryConnection"];
        domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
        enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        mannequins: _RefType["MannequinConnection"];
        memberStatuses: _RefType["UserStatusConnection"];
        membersWithRole: _RefType["OrganizationMemberConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        samlIdentityProvider?: Maybe<_RefType["OrganizationIdentityProvider"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        team?: Maybe<_RefType["Team"]>;
        teams: _RefType["TeamConnection"];
      })
    | (Omit<
        Repository,
        | "branchProtectionRules"
        | "collaborators"
        | "commitComments"
        | "defaultBranchRef"
        | "dependencyGraphManifests"
        | "deployments"
        | "discussion"
        | "discussionCategories"
        | "discussionCategory"
        | "discussions"
        | "environment"
        | "environments"
        | "forks"
        | "issue"
        | "issueOrPullRequest"
        | "issueTemplates"
        | "issues"
        | "label"
        | "labels"
        | "latestRelease"
        | "mergeQueue"
        | "milestone"
        | "milestones"
        | "object"
        | "owner"
        | "packages"
        | "parent"
        | "pinnedDiscussions"
        | "pinnedEnvironments"
        | "pinnedIssues"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequest"
        | "pullRequestTemplates"
        | "pullRequests"
        | "recentProjects"
        | "ref"
        | "release"
        | "releases"
        | "repositoryTopics"
        | "ruleset"
        | "rulesets"
        | "templateRepository"
        | "vulnerabilityAlert"
        | "vulnerabilityAlerts"
      > & {
        branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
        collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
        commitComments: _RefType["CommitCommentConnection"];
        defaultBranchRef?: Maybe<_RefType["Ref"]>;
        dependencyGraphManifests?: Maybe<
          _RefType["DependencyGraphManifestConnection"]
        >;
        deployments: _RefType["DeploymentConnection"];
        discussion?: Maybe<_RefType["Discussion"]>;
        discussionCategories: _RefType["DiscussionCategoryConnection"];
        discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
        discussions: _RefType["DiscussionConnection"];
        environment?: Maybe<_RefType["Environment"]>;
        environments: _RefType["EnvironmentConnection"];
        forks: _RefType["RepositoryConnection"];
        issue?: Maybe<_RefType["Issue"]>;
        issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
        issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
        issues: _RefType["IssueConnection"];
        label?: Maybe<_RefType["Label"]>;
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestRelease?: Maybe<_RefType["Release"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        milestones?: Maybe<_RefType["MilestoneConnection"]>;
        object?: Maybe<_RefType["GitObject"]>;
        owner: _RefType["RepositoryOwner"];
        packages: _RefType["PackageConnection"];
        parent?: Maybe<_RefType["Repository"]>;
        pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
        pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
        pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequest?: Maybe<_RefType["PullRequest"]>;
        pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        ref?: Maybe<_RefType["Ref"]>;
        release?: Maybe<_RefType["Release"]>;
        releases: _RefType["ReleaseConnection"];
        repositoryTopics: _RefType["RepositoryTopicConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        templateRepository?: Maybe<_RefType["Repository"]>;
        vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
        vulnerabilityAlerts?: Maybe<
          _RefType["RepositoryVulnerabilityAlertConnection"]
        >;
      });
  SearchResultItem:
    | (Omit<App, "ipAllowListEntries"> & {
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
      })
    | (Omit<
        Discussion,
        | "answer"
        | "answerChosenBy"
        | "author"
        | "category"
        | "comments"
        | "editor"
        | "labels"
        | "poll"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "userContentEdits"
      > & {
        answer?: Maybe<_RefType["DiscussionComment"]>;
        answerChosenBy?: Maybe<_RefType["Actor"]>;
        author?: Maybe<_RefType["Actor"]>;
        category: _RefType["DiscussionCategory"];
        comments: _RefType["DiscussionCommentConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        labels?: Maybe<_RefType["LabelConnection"]>;
        poll?: Maybe<_RefType["DiscussionPoll"]>;
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<
        Issue,
        | "author"
        | "closedByPullRequestsReferences"
        | "comments"
        | "editor"
        | "hovercard"
        | "labels"
        | "milestone"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "timeline"
        | "timelineItems"
        | "trackedInIssues"
        | "trackedIssues"
        | "userContentEdits"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        closedByPullRequestsReferences?: Maybe<
          _RefType["PullRequestConnection"]
        >;
        comments: _RefType["IssueCommentConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        timeline: _RefType["IssueTimelineConnection"];
        timelineItems: _RefType["IssueTimelineItemsConnection"];
        trackedInIssues: _RefType["IssueConnection"];
        trackedIssues: _RefType["IssueConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
      })
    | (Omit<MarketplaceListing, "app"> & { app?: Maybe<_RefType["App"]> })
    | (Omit<
        Organization,
        | "auditLog"
        | "domains"
        | "enterpriseOwners"
        | "ipAllowListEntries"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "mannequins"
        | "memberStatuses"
        | "membersWithRole"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "recentProjects"
        | "repositories"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "ruleset"
        | "rulesets"
        | "samlIdentityProvider"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "team"
        | "teams"
      > & {
        auditLog: _RefType["OrganizationAuditEntryConnection"];
        domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
        enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        mannequins: _RefType["MannequinConnection"];
        memberStatuses: _RefType["UserStatusConnection"];
        membersWithRole: _RefType["OrganizationMemberConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        samlIdentityProvider?: Maybe<_RefType["OrganizationIdentityProvider"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        team?: Maybe<_RefType["Team"]>;
        teams: _RefType["TeamConnection"];
      })
    | (Omit<
        PullRequest,
        | "author"
        | "autoMergeRequest"
        | "baseRef"
        | "baseRepository"
        | "closingIssuesReferences"
        | "comments"
        | "commits"
        | "editor"
        | "headRef"
        | "headRepository"
        | "headRepositoryOwner"
        | "hovercard"
        | "labels"
        | "latestOpinionatedReviews"
        | "latestReviews"
        | "mergeCommit"
        | "mergeQueue"
        | "mergeQueueEntry"
        | "mergedBy"
        | "milestone"
        | "potentialMergeCommit"
        | "projectCards"
        | "projectItems"
        | "projectV2"
        | "projectsV2"
        | "reactionGroups"
        | "reactions"
        | "repository"
        | "reviewRequests"
        | "reviewThreads"
        | "reviews"
        | "statusCheckRollup"
        | "timeline"
        | "timelineItems"
        | "userContentEdits"
        | "viewerLatestReview"
        | "viewerLatestReviewRequest"
      > & {
        author?: Maybe<_RefType["Actor"]>;
        autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
        baseRef?: Maybe<_RefType["Ref"]>;
        baseRepository?: Maybe<_RefType["Repository"]>;
        closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
        comments: _RefType["IssueCommentConnection"];
        commits: _RefType["PullRequestCommitConnection"];
        editor?: Maybe<_RefType["Actor"]>;
        headRef?: Maybe<_RefType["Ref"]>;
        headRepository?: Maybe<_RefType["Repository"]>;
        headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
        hovercard: _RefType["Hovercard"];
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestOpinionatedReviews?: Maybe<
          _RefType["PullRequestReviewConnection"]
        >;
        latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        mergeCommit?: Maybe<_RefType["Commit"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
        mergedBy?: Maybe<_RefType["Actor"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        potentialMergeCommit?: Maybe<_RefType["Commit"]>;
        projectCards: _RefType["ProjectCardConnection"];
        projectItems: _RefType["ProjectV2ItemConnection"];
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projectsV2: _RefType["ProjectV2Connection"];
        reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
        reactions: _RefType["ReactionConnection"];
        repository: _RefType["Repository"];
        reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
        reviewThreads: _RefType["PullRequestReviewThreadConnection"];
        reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
        statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
        timeline: _RefType["PullRequestTimelineConnection"];
        timelineItems: _RefType["PullRequestTimelineItemsConnection"];
        userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
        viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
      })
    | (Omit<
        Repository,
        | "branchProtectionRules"
        | "collaborators"
        | "commitComments"
        | "defaultBranchRef"
        | "dependencyGraphManifests"
        | "deployments"
        | "discussion"
        | "discussionCategories"
        | "discussionCategory"
        | "discussions"
        | "environment"
        | "environments"
        | "forks"
        | "issue"
        | "issueOrPullRequest"
        | "issueTemplates"
        | "issues"
        | "label"
        | "labels"
        | "latestRelease"
        | "mergeQueue"
        | "milestone"
        | "milestones"
        | "object"
        | "owner"
        | "packages"
        | "parent"
        | "pinnedDiscussions"
        | "pinnedEnvironments"
        | "pinnedIssues"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequest"
        | "pullRequestTemplates"
        | "pullRequests"
        | "recentProjects"
        | "ref"
        | "release"
        | "releases"
        | "repositoryTopics"
        | "ruleset"
        | "rulesets"
        | "templateRepository"
        | "vulnerabilityAlert"
        | "vulnerabilityAlerts"
      > & {
        branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
        collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
        commitComments: _RefType["CommitCommentConnection"];
        defaultBranchRef?: Maybe<_RefType["Ref"]>;
        dependencyGraphManifests?: Maybe<
          _RefType["DependencyGraphManifestConnection"]
        >;
        deployments: _RefType["DeploymentConnection"];
        discussion?: Maybe<_RefType["Discussion"]>;
        discussionCategories: _RefType["DiscussionCategoryConnection"];
        discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
        discussions: _RefType["DiscussionConnection"];
        environment?: Maybe<_RefType["Environment"]>;
        environments: _RefType["EnvironmentConnection"];
        forks: _RefType["RepositoryConnection"];
        issue?: Maybe<_RefType["Issue"]>;
        issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
        issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
        issues: _RefType["IssueConnection"];
        label?: Maybe<_RefType["Label"]>;
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestRelease?: Maybe<_RefType["Release"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        milestones?: Maybe<_RefType["MilestoneConnection"]>;
        object?: Maybe<_RefType["GitObject"]>;
        owner: _RefType["RepositoryOwner"];
        packages: _RefType["PackageConnection"];
        parent?: Maybe<_RefType["Repository"]>;
        pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
        pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
        pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequest?: Maybe<_RefType["PullRequest"]>;
        pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        ref?: Maybe<_RefType["Ref"]>;
        release?: Maybe<_RefType["Release"]>;
        releases: _RefType["ReleaseConnection"];
        repositoryTopics: _RefType["RepositoryTopicConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        templateRepository?: Maybe<_RefType["Repository"]>;
        vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
        vulnerabilityAlerts?: Maybe<
          _RefType["RepositoryVulnerabilityAlertConnection"]
        >;
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  Sponsor:
    | (Omit<
        Organization,
        | "auditLog"
        | "domains"
        | "enterpriseOwners"
        | "ipAllowListEntries"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "mannequins"
        | "memberStatuses"
        | "membersWithRole"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "recentProjects"
        | "repositories"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "ruleset"
        | "rulesets"
        | "samlIdentityProvider"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "team"
        | "teams"
      > & {
        auditLog: _RefType["OrganizationAuditEntryConnection"];
        domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
        enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        mannequins: _RefType["MannequinConnection"];
        memberStatuses: _RefType["UserStatusConnection"];
        membersWithRole: _RefType["OrganizationMemberConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        samlIdentityProvider?: Maybe<_RefType["OrganizationIdentityProvider"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        team?: Maybe<_RefType["Team"]>;
        teams: _RefType["TeamConnection"];
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  SponsorableItem:
    | (Omit<
        Organization,
        | "auditLog"
        | "domains"
        | "enterpriseOwners"
        | "ipAllowListEntries"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "mannequins"
        | "memberStatuses"
        | "membersWithRole"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "recentProjects"
        | "repositories"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "ruleset"
        | "rulesets"
        | "samlIdentityProvider"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "team"
        | "teams"
      > & {
        auditLog: _RefType["OrganizationAuditEntryConnection"];
        domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
        enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        mannequins: _RefType["MannequinConnection"];
        memberStatuses: _RefType["UserStatusConnection"];
        membersWithRole: _RefType["OrganizationMemberConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        samlIdentityProvider?: Maybe<_RefType["OrganizationIdentityProvider"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        team?: Maybe<_RefType["Team"]>;
        teams: _RefType["TeamConnection"];
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  SponsorsListingFeatureableItem:
    | (Omit<
        Repository,
        | "branchProtectionRules"
        | "collaborators"
        | "commitComments"
        | "defaultBranchRef"
        | "dependencyGraphManifests"
        | "deployments"
        | "discussion"
        | "discussionCategories"
        | "discussionCategory"
        | "discussions"
        | "environment"
        | "environments"
        | "forks"
        | "issue"
        | "issueOrPullRequest"
        | "issueTemplates"
        | "issues"
        | "label"
        | "labels"
        | "latestRelease"
        | "mergeQueue"
        | "milestone"
        | "milestones"
        | "object"
        | "owner"
        | "packages"
        | "parent"
        | "pinnedDiscussions"
        | "pinnedEnvironments"
        | "pinnedIssues"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequest"
        | "pullRequestTemplates"
        | "pullRequests"
        | "recentProjects"
        | "ref"
        | "release"
        | "releases"
        | "repositoryTopics"
        | "ruleset"
        | "rulesets"
        | "templateRepository"
        | "vulnerabilityAlert"
        | "vulnerabilityAlerts"
      > & {
        branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
        collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
        commitComments: _RefType["CommitCommentConnection"];
        defaultBranchRef?: Maybe<_RefType["Ref"]>;
        dependencyGraphManifests?: Maybe<
          _RefType["DependencyGraphManifestConnection"]
        >;
        deployments: _RefType["DeploymentConnection"];
        discussion?: Maybe<_RefType["Discussion"]>;
        discussionCategories: _RefType["DiscussionCategoryConnection"];
        discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
        discussions: _RefType["DiscussionConnection"];
        environment?: Maybe<_RefType["Environment"]>;
        environments: _RefType["EnvironmentConnection"];
        forks: _RefType["RepositoryConnection"];
        issue?: Maybe<_RefType["Issue"]>;
        issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
        issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
        issues: _RefType["IssueConnection"];
        label?: Maybe<_RefType["Label"]>;
        labels?: Maybe<_RefType["LabelConnection"]>;
        latestRelease?: Maybe<_RefType["Release"]>;
        mergeQueue?: Maybe<_RefType["MergeQueue"]>;
        milestone?: Maybe<_RefType["Milestone"]>;
        milestones?: Maybe<_RefType["MilestoneConnection"]>;
        object?: Maybe<_RefType["GitObject"]>;
        owner: _RefType["RepositoryOwner"];
        packages: _RefType["PackageConnection"];
        parent?: Maybe<_RefType["Repository"]>;
        pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
        pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
        pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequest?: Maybe<_RefType["PullRequest"]>;
        pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        ref?: Maybe<_RefType["Ref"]>;
        release?: Maybe<_RefType["Release"]>;
        releases: _RefType["ReleaseConnection"];
        repositoryTopics: _RefType["RepositoryTopicConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        templateRepository?: Maybe<_RefType["Repository"]>;
        vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
        vulnerabilityAlerts?: Maybe<
          _RefType["RepositoryVulnerabilityAlertConnection"]
        >;
      })
    | (Omit<
        User,
        | "commitComments"
        | "contributionsCollection"
        | "enterprises"
        | "followers"
        | "following"
        | "gist"
        | "gistComments"
        | "gists"
        | "hovercard"
        | "issueComments"
        | "issues"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "lists"
        | "organization"
        | "organizations"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "pullRequests"
        | "recentProjects"
        | "repositories"
        | "repositoriesContributedTo"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "savedReplies"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "starredRepositories"
        | "status"
        | "topRepositories"
        | "watching"
      > & {
        commitComments: _RefType["CommitCommentConnection"];
        contributionsCollection: _RefType["ContributionsCollection"];
        enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
        followers: _RefType["FollowerConnection"];
        following: _RefType["FollowingConnection"];
        gist?: Maybe<_RefType["Gist"]>;
        gistComments: _RefType["GistCommentConnection"];
        gists: _RefType["GistConnection"];
        hovercard: _RefType["Hovercard"];
        issueComments: _RefType["IssueCommentConnection"];
        issues: _RefType["IssueConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        lists: _RefType["UserListConnection"];
        organization?: Maybe<_RefType["Organization"]>;
        organizations: _RefType["OrganizationConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        pullRequests: _RefType["PullRequestConnection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repositoriesContributedTo: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        starredRepositories: _RefType["StarredRepositoryConnection"];
        status?: Maybe<_RefType["UserStatus"]>;
        topRepositories: _RefType["RepositoryConnection"];
        watching: _RefType["RepositoryConnection"];
      });
  StatusCheckRollupContext:
    | (Omit<
        CheckRun,
        "checkSuite" | "deployment" | "pendingDeploymentRequest" | "repository"
      > & {
        checkSuite: _RefType["CheckSuite"];
        deployment?: Maybe<_RefType["Deployment"]>;
        pendingDeploymentRequest?: Maybe<_RefType["DeploymentRequest"]>;
        repository: _RefType["Repository"];
      })
    | (Omit<StatusContext, "commit" | "creator"> & {
        commit?: Maybe<_RefType["Commit"]>;
        creator?: Maybe<_RefType["Actor"]>;
      });
  UserListItems: Omit<
    Repository,
    | "branchProtectionRules"
    | "collaborators"
    | "commitComments"
    | "defaultBranchRef"
    | "dependencyGraphManifests"
    | "deployments"
    | "discussion"
    | "discussionCategories"
    | "discussionCategory"
    | "discussions"
    | "environment"
    | "environments"
    | "forks"
    | "issue"
    | "issueOrPullRequest"
    | "issueTemplates"
    | "issues"
    | "label"
    | "labels"
    | "latestRelease"
    | "mergeQueue"
    | "milestone"
    | "milestones"
    | "object"
    | "owner"
    | "packages"
    | "parent"
    | "pinnedDiscussions"
    | "pinnedEnvironments"
    | "pinnedIssues"
    | "project"
    | "projectV2"
    | "projects"
    | "projectsV2"
    | "pullRequest"
    | "pullRequestTemplates"
    | "pullRequests"
    | "recentProjects"
    | "ref"
    | "release"
    | "releases"
    | "repositoryTopics"
    | "ruleset"
    | "rulesets"
    | "templateRepository"
    | "vulnerabilityAlert"
    | "vulnerabilityAlerts"
  > & {
    branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
    collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
    commitComments: _RefType["CommitCommentConnection"];
    defaultBranchRef?: Maybe<_RefType["Ref"]>;
    dependencyGraphManifests?: Maybe<
      _RefType["DependencyGraphManifestConnection"]
    >;
    deployments: _RefType["DeploymentConnection"];
    discussion?: Maybe<_RefType["Discussion"]>;
    discussionCategories: _RefType["DiscussionCategoryConnection"];
    discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
    discussions: _RefType["DiscussionConnection"];
    environment?: Maybe<_RefType["Environment"]>;
    environments: _RefType["EnvironmentConnection"];
    forks: _RefType["RepositoryConnection"];
    issue?: Maybe<_RefType["Issue"]>;
    issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
    issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
    issues: _RefType["IssueConnection"];
    label?: Maybe<_RefType["Label"]>;
    labels?: Maybe<_RefType["LabelConnection"]>;
    latestRelease?: Maybe<_RefType["Release"]>;
    mergeQueue?: Maybe<_RefType["MergeQueue"]>;
    milestone?: Maybe<_RefType["Milestone"]>;
    milestones?: Maybe<_RefType["MilestoneConnection"]>;
    object?: Maybe<_RefType["GitObject"]>;
    owner: _RefType["RepositoryOwner"];
    packages: _RefType["PackageConnection"];
    parent?: Maybe<_RefType["Repository"]>;
    pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
    pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
    pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
    project?: Maybe<_RefType["Project"]>;
    projectV2?: Maybe<_RefType["ProjectV2"]>;
    projects: _RefType["ProjectConnection"];
    projectsV2: _RefType["ProjectV2Connection"];
    pullRequest?: Maybe<_RefType["PullRequest"]>;
    pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
    pullRequests: _RefType["PullRequestConnection"];
    recentProjects: _RefType["ProjectV2Connection"];
    ref?: Maybe<_RefType["Ref"]>;
    release?: Maybe<_RefType["Release"]>;
    releases: _RefType["ReleaseConnection"];
    repositoryTopics: _RefType["RepositoryTopicConnection"];
    ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
    rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
    templateRepository?: Maybe<_RefType["Repository"]>;
    vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
    vulnerabilityAlerts?: Maybe<
      _RefType["RepositoryVulnerabilityAlertConnection"]
    >;
  };
  VerifiableDomainOwner:
    | (Omit<
        Enterprise,
        "billingInfo" | "members" | "organizations" | "ownerInfo"
      > & {
        billingInfo?: Maybe<_RefType["EnterpriseBillingInfo"]>;
        members: _RefType["EnterpriseMemberConnection"];
        organizations: _RefType["OrganizationConnection"];
        ownerInfo?: Maybe<_RefType["EnterpriseOwnerInfo"]>;
      })
    | (Omit<
        Organization,
        | "auditLog"
        | "domains"
        | "enterpriseOwners"
        | "ipAllowListEntries"
        | "itemShowcase"
        | "lifetimeReceivedSponsorshipValues"
        | "mannequins"
        | "memberStatuses"
        | "membersWithRole"
        | "packages"
        | "pinnableItems"
        | "pinnedItems"
        | "project"
        | "projectV2"
        | "projects"
        | "projectsV2"
        | "recentProjects"
        | "repositories"
        | "repository"
        | "repositoryDiscussionComments"
        | "repositoryDiscussions"
        | "ruleset"
        | "rulesets"
        | "samlIdentityProvider"
        | "sponsoring"
        | "sponsors"
        | "sponsorsActivities"
        | "sponsorsListing"
        | "sponsorshipForViewerAsSponsor"
        | "sponsorshipForViewerAsSponsorable"
        | "sponsorshipNewsletters"
        | "sponsorshipsAsMaintainer"
        | "sponsorshipsAsSponsor"
        | "team"
        | "teams"
      > & {
        auditLog: _RefType["OrganizationAuditEntryConnection"];
        domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
        enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
        ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
        itemShowcase: _RefType["ProfileItemShowcase"];
        lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
        mannequins: _RefType["MannequinConnection"];
        memberStatuses: _RefType["UserStatusConnection"];
        membersWithRole: _RefType["OrganizationMemberConnection"];
        packages: _RefType["PackageConnection"];
        pinnableItems: _RefType["PinnableItemConnection"];
        pinnedItems: _RefType["PinnableItemConnection"];
        project?: Maybe<_RefType["Project"]>;
        projectV2?: Maybe<_RefType["ProjectV2"]>;
        projects: _RefType["ProjectConnection"];
        projectsV2: _RefType["ProjectV2Connection"];
        recentProjects: _RefType["ProjectV2Connection"];
        repositories: _RefType["RepositoryConnection"];
        repository?: Maybe<_RefType["Repository"]>;
        repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
        repositoryDiscussions: _RefType["DiscussionConnection"];
        ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
        rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
        samlIdentityProvider?: Maybe<_RefType["OrganizationIdentityProvider"]>;
        sponsoring: _RefType["SponsorConnection"];
        sponsors: _RefType["SponsorConnection"];
        sponsorsActivities: _RefType["SponsorsActivityConnection"];
        sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
        sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
        sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
        sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
        sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
        team?: Maybe<_RefType["Team"]>;
        teams: _RefType["TeamConnection"];
      });
};

/** Mapping of interface types */
export type ResolversInterfaceTypes<_RefType extends Record<string, unknown>> =
  {
    Actor:
      | Bot
      | (Omit<
          EnterpriseUserAccount,
          "enterprise" | "enterpriseInstallations" | "organizations" | "user"
        > & {
          enterprise: _RefType["Enterprise"];
          enterpriseInstallations: _RefType["EnterpriseServerInstallationMembershipConnection"];
          organizations: _RefType["EnterpriseOrganizationMembershipConnection"];
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<Mannequin, "claimant"> & { claimant?: Maybe<_RefType["User"]> })
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          User,
          | "commitComments"
          | "contributionsCollection"
          | "enterprises"
          | "followers"
          | "following"
          | "gist"
          | "gistComments"
          | "gists"
          | "hovercard"
          | "issueComments"
          | "issues"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "lists"
          | "organization"
          | "organizations"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequests"
          | "recentProjects"
          | "repositories"
          | "repositoriesContributedTo"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "savedReplies"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "starredRepositories"
          | "status"
          | "topRepositories"
          | "watching"
        > & {
          commitComments: _RefType["CommitCommentConnection"];
          contributionsCollection: _RefType["ContributionsCollection"];
          enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
          followers: _RefType["FollowerConnection"];
          following: _RefType["FollowingConnection"];
          gist?: Maybe<_RefType["Gist"]>;
          gistComments: _RefType["GistCommentConnection"];
          gists: _RefType["GistConnection"];
          hovercard: _RefType["Hovercard"];
          issueComments: _RefType["IssueCommentConnection"];
          issues: _RefType["IssueConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          lists: _RefType["UserListConnection"];
          organization?: Maybe<_RefType["Organization"]>;
          organizations: _RefType["OrganizationConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repositoriesContributedTo: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          starredRepositories: _RefType["StarredRepositoryConnection"];
          status?: Maybe<_RefType["UserStatus"]>;
          topRepositories: _RefType["RepositoryConnection"];
          watching: _RefType["RepositoryConnection"];
        });
    AnnouncementBanner:
      | (Omit<
          Enterprise,
          "billingInfo" | "members" | "organizations" | "ownerInfo"
        > & {
          billingInfo?: Maybe<_RefType["EnterpriseBillingInfo"]>;
          members: _RefType["EnterpriseMemberConnection"];
          organizations: _RefType["OrganizationConnection"];
          ownerInfo?: Maybe<_RefType["EnterpriseOwnerInfo"]>;
        })
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        });
    Assignable:
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        });
    AuditEntry:
      | (Omit<
          MembersCanDeleteReposClearAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          MembersCanDeleteReposDisableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          MembersCanDeleteReposEnableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OauthApplicationCreateAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgAddBillingManagerAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgAddMemberAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgBlockUserAuditEntry,
          "actor" | "blockedUser" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          blockedUser?: Maybe<_RefType["User"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgConfigDisableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgConfigEnableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgCreateAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgDisableOauthAppRestrictionsAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgDisableSamlAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgDisableTwoFactorRequirementAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgEnableOauthAppRestrictionsAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgEnableSamlAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgEnableTwoFactorRequirementAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgInviteMemberAuditEntry,
          "actor" | "organization" | "organizationInvitation" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          organizationInvitation?: Maybe<_RefType["OrganizationInvitation"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgInviteToBusinessAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessApprovedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessBlockedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessDeniedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessRequestedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessUnblockedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgRemoveBillingManagerAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgRemoveMemberAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgRemoveOutsideCollaboratorAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgRestoreMemberAuditEntry,
          "actor" | "organization" | "restoredMemberships" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          restoredMemberships?: Maybe<
            Array<_RefType["OrgRestoreMemberAuditEntryMembership"]>
          >;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgUnblockUserAuditEntry,
          "actor" | "blockedUser" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          blockedUser?: Maybe<_RefType["User"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgUpdateDefaultRepositoryPermissionAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgUpdateMemberAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgUpdateMemberRepositoryCreationPermissionAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgUpdateMemberRepositoryInvitationPermissionAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          PrivateRepositoryForkingDisableAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          PrivateRepositoryForkingEnableAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoAddMemberAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoAddTopicAuditEntry,
          "actor" | "organization" | "repository" | "topic" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          topic?: Maybe<_RefType["Topic"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoArchivedAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoChangeMergeSettingAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableContributorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableSockpuppetDisallowedAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableContributorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableSockpuppetDisallowedAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigLockAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigUnlockAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoCreateAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoDestroyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoRemoveMemberAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoRemoveTopicAuditEntry,
          "actor" | "organization" | "repository" | "topic" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          topic?: Maybe<_RefType["Topic"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepositoryVisibilityChangeDisableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepositoryVisibilityChangeEnableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamAddMemberAuditEntry,
          "actor" | "organization" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamAddRepositoryAuditEntry,
          "actor" | "organization" | "repository" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamChangeParentTeamAuditEntry,
          | "actor"
          | "organization"
          | "parentTeam"
          | "parentTeamWas"
          | "team"
          | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          parentTeam?: Maybe<_RefType["Team"]>;
          parentTeamWas?: Maybe<_RefType["Team"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamRemoveMemberAuditEntry,
          "actor" | "organization" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamRemoveRepositoryAuditEntry,
          "actor" | "organization" | "repository" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        });
    Closable:
      | (Omit<
          Discussion,
          | "answer"
          | "answerChosenBy"
          | "author"
          | "category"
          | "comments"
          | "editor"
          | "labels"
          | "poll"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          answer?: Maybe<_RefType["DiscussionComment"]>;
          answerChosenBy?: Maybe<_RefType["Actor"]>;
          author?: Maybe<_RefType["Actor"]>;
          category: _RefType["DiscussionCategory"];
          comments: _RefType["DiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          poll?: Maybe<_RefType["DiscussionPoll"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Milestone,
          "creator" | "issues" | "pullRequests" | "repository"
        > & {
          creator?: Maybe<_RefType["Actor"]>;
          issues: _RefType["IssueConnection"];
          pullRequests: _RefType["PullRequestConnection"];
          repository: _RefType["Repository"];
        })
      | (Omit<Project, "creator" | "owner" | "pendingCards"> & {
          creator?: Maybe<_RefType["Actor"]>;
          owner: _RefType["ProjectOwner"];
          pendingCards: _RefType["ProjectCardConnection"];
        })
      | (Omit<
          ProjectV2,
          | "creator"
          | "field"
          | "fields"
          | "items"
          | "owner"
          | "repositories"
          | "statusUpdates"
          | "teams"
          | "view"
          | "views"
          | "workflow"
          | "workflows"
        > & {
          creator?: Maybe<_RefType["Actor"]>;
          field?: Maybe<_RefType["ProjectV2FieldConfiguration"]>;
          fields: _RefType["ProjectV2FieldConfigurationConnection"];
          items: _RefType["ProjectV2ItemConnection"];
          owner: _RefType["ProjectV2Owner"];
          repositories: _RefType["RepositoryConnection"];
          statusUpdates: _RefType["ProjectV2StatusUpdateConnection"];
          teams: _RefType["TeamConnection"];
          view?: Maybe<_RefType["ProjectV2View"]>;
          views: _RefType["ProjectV2ViewConnection"];
          workflow?: Maybe<_RefType["ProjectV2Workflow"]>;
          workflows: _RefType["ProjectV2WorkflowConnection"];
        })
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        });
    Comment:
      | (Omit<
          CommitComment,
          | "author"
          | "commit"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Discussion,
          | "answer"
          | "answerChosenBy"
          | "author"
          | "category"
          | "comments"
          | "editor"
          | "labels"
          | "poll"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          answer?: Maybe<_RefType["DiscussionComment"]>;
          answerChosenBy?: Maybe<_RefType["Actor"]>;
          author?: Maybe<_RefType["Actor"]>;
          category: _RefType["DiscussionCategory"];
          comments: _RefType["DiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          poll?: Maybe<_RefType["DiscussionPoll"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          DiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "replies"
          | "replyTo"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion?: Maybe<_RefType["Discussion"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replies: _RefType["DiscussionCommentConnection"];
          replyTo?: Maybe<_RefType["DiscussionComment"]>;
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          GistComment,
          "author" | "editor" | "gist" | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          gist: _RefType["Gist"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          IssueComment,
          | "author"
          | "editor"
          | "issue"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          issue: _RefType["Issue"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        })
      | (Omit<
          PullRequestReview,
          | "author"
          | "comments"
          | "commit"
          | "editor"
          | "onBehalfOf"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["PullRequestReviewCommentConnection"];
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          onBehalfOf: _RefType["TeamConnection"];
          pullRequest: _RefType["PullRequest"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequestReviewComment,
          | "author"
          | "commit"
          | "editor"
          | "originalCommit"
          | "pullRequest"
          | "pullRequestReview"
          | "reactionGroups"
          | "reactions"
          | "replyTo"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          originalCommit?: Maybe<_RefType["Commit"]>;
          pullRequest: _RefType["PullRequest"];
          pullRequestReview?: Maybe<_RefType["PullRequestReview"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replyTo?: Maybe<_RefType["PullRequestReviewComment"]>;
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          TeamDiscussion,
          | "author"
          | "comments"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "team"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["TeamDiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          team: _RefType["Team"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          TeamDiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion: _RefType["TeamDiscussion"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        });
    Contribution:
      | (Omit<CreatedCommitContribution, "repository" | "user"> & {
          repository: _RefType["Repository"];
          user: _RefType["User"];
        })
      | (Omit<CreatedIssueContribution, "issue" | "user"> & {
          issue: _RefType["Issue"];
          user: _RefType["User"];
        })
      | (Omit<CreatedPullRequestContribution, "pullRequest" | "user"> & {
          pullRequest: _RefType["PullRequest"];
          user: _RefType["User"];
        })
      | (Omit<
          CreatedPullRequestReviewContribution,
          "pullRequest" | "pullRequestReview" | "repository" | "user"
        > & {
          pullRequest: _RefType["PullRequest"];
          pullRequestReview: _RefType["PullRequestReview"];
          repository: _RefType["Repository"];
          user: _RefType["User"];
        })
      | (Omit<CreatedRepositoryContribution, "repository" | "user"> & {
          repository: _RefType["Repository"];
          user: _RefType["User"];
        })
      | (Omit<JoinedGitHubContribution, "user"> & { user: _RefType["User"] })
      | (Omit<RestrictedContribution, "user"> & { user: _RefType["User"] });
    Deletable:
      | (Omit<
          CommitComment,
          | "author"
          | "commit"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Discussion,
          | "answer"
          | "answerChosenBy"
          | "author"
          | "category"
          | "comments"
          | "editor"
          | "labels"
          | "poll"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          answer?: Maybe<_RefType["DiscussionComment"]>;
          answerChosenBy?: Maybe<_RefType["Actor"]>;
          author?: Maybe<_RefType["Actor"]>;
          category: _RefType["DiscussionCategory"];
          comments: _RefType["DiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          poll?: Maybe<_RefType["DiscussionPoll"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          DiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "replies"
          | "replyTo"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion?: Maybe<_RefType["Discussion"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replies: _RefType["DiscussionCommentConnection"];
          replyTo?: Maybe<_RefType["DiscussionComment"]>;
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          GistComment,
          "author" | "editor" | "gist" | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          gist: _RefType["Gist"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          IssueComment,
          | "author"
          | "editor"
          | "issue"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          issue: _RefType["Issue"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequestReview,
          | "author"
          | "comments"
          | "commit"
          | "editor"
          | "onBehalfOf"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["PullRequestReviewCommentConnection"];
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          onBehalfOf: _RefType["TeamConnection"];
          pullRequest: _RefType["PullRequest"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequestReviewComment,
          | "author"
          | "commit"
          | "editor"
          | "originalCommit"
          | "pullRequest"
          | "pullRequestReview"
          | "reactionGroups"
          | "reactions"
          | "replyTo"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          originalCommit?: Maybe<_RefType["Commit"]>;
          pullRequest: _RefType["PullRequest"];
          pullRequestReview?: Maybe<_RefType["PullRequestReview"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replyTo?: Maybe<_RefType["PullRequestReviewComment"]>;
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          TeamDiscussion,
          | "author"
          | "comments"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "team"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["TeamDiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          team: _RefType["Team"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          TeamDiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion: _RefType["TeamDiscussion"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        });
    EnterpriseAuditEntryData:
      | (Omit<
          MembersCanDeleteReposClearAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          MembersCanDeleteReposDisableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          MembersCanDeleteReposEnableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgInviteToBusinessAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          PrivateRepositoryForkingDisableAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          PrivateRepositoryForkingEnableAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepositoryVisibilityChangeDisableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepositoryVisibilityChangeEnableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        });
    GitObject:
      | (Omit<Blob, "repository"> & { repository: _RefType["Repository"] })
      | (Omit<
          Commit,
          | "associatedPullRequests"
          | "blame"
          | "checkSuites"
          | "comments"
          | "deployments"
          | "file"
          | "history"
          | "onBehalfOf"
          | "parents"
          | "repository"
          | "signature"
          | "status"
          | "statusCheckRollup"
          | "tree"
        > & {
          associatedPullRequests?: Maybe<_RefType["PullRequestConnection"]>;
          blame: _RefType["Blame"];
          checkSuites?: Maybe<_RefType["CheckSuiteConnection"]>;
          comments: _RefType["CommitCommentConnection"];
          deployments?: Maybe<_RefType["DeploymentConnection"]>;
          file?: Maybe<_RefType["TreeEntry"]>;
          history: _RefType["CommitHistoryConnection"];
          onBehalfOf?: Maybe<_RefType["Organization"]>;
          parents: _RefType["CommitConnection"];
          repository: _RefType["Repository"];
          signature?: Maybe<_RefType["GitSignature"]>;
          status?: Maybe<_RefType["Status"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          tree: _RefType["Tree"];
        })
      | (Omit<Tag, "repository" | "target"> & {
          repository: _RefType["Repository"];
          target: _RefType["GitObject"];
        })
      | (Omit<Tree, "entries" | "repository"> & {
          entries?: Maybe<Array<_RefType["TreeEntry"]>>;
          repository: _RefType["Repository"];
        });
    GitSignature:
      | (Omit<GpgSignature, "signer"> & { signer?: Maybe<_RefType["User"]> })
      | (Omit<SmimeSignature, "signer"> & { signer?: Maybe<_RefType["User"]> })
      | (Omit<SshSignature, "signer"> & { signer?: Maybe<_RefType["User"]> })
      | (Omit<UnknownSignature, "signer"> & {
          signer?: Maybe<_RefType["User"]>;
        });
    HovercardContext:
      | GenericHovercardContext
      | (Omit<OrganizationTeamsHovercardContext, "relevantTeams"> & {
          relevantTeams: _RefType["TeamConnection"];
        })
      | (Omit<OrganizationsHovercardContext, "relevantOrganizations"> & {
          relevantOrganizations: _RefType["OrganizationConnection"];
        })
      | ReviewStatusHovercardContext
      | (Omit<ViewerHovercardContext, "viewer"> & { viewer: _RefType["User"] });
    Labelable:
      | (Omit<
          Discussion,
          | "answer"
          | "answerChosenBy"
          | "author"
          | "category"
          | "comments"
          | "editor"
          | "labels"
          | "poll"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          answer?: Maybe<_RefType["DiscussionComment"]>;
          answerChosenBy?: Maybe<_RefType["Actor"]>;
          author?: Maybe<_RefType["Actor"]>;
          category: _RefType["DiscussionCategory"];
          comments: _RefType["DiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          poll?: Maybe<_RefType["DiscussionPoll"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        });
    Lockable:
      | (Omit<
          Discussion,
          | "answer"
          | "answerChosenBy"
          | "author"
          | "category"
          | "comments"
          | "editor"
          | "labels"
          | "poll"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          answer?: Maybe<_RefType["DiscussionComment"]>;
          answerChosenBy?: Maybe<_RefType["Actor"]>;
          author?: Maybe<_RefType["Actor"]>;
          category: _RefType["DiscussionCategory"];
          comments: _RefType["DiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          poll?: Maybe<_RefType["DiscussionPoll"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        });
    MemberStatusable:
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          Team,
          | "ancestors"
          | "childTeams"
          | "discussion"
          | "discussions"
          | "invitations"
          | "memberStatuses"
          | "organization"
          | "parentTeam"
          | "projectV2"
          | "projectsV2"
          | "repositories"
        > & {
          ancestors: _RefType["TeamConnection"];
          childTeams: _RefType["TeamConnection"];
          discussion?: Maybe<_RefType["TeamDiscussion"]>;
          discussions: _RefType["TeamDiscussionConnection"];
          invitations?: Maybe<_RefType["OrganizationInvitationConnection"]>;
          memberStatuses: _RefType["UserStatusConnection"];
          organization: _RefType["Organization"];
          parentTeam?: Maybe<_RefType["Team"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          repositories: _RefType["TeamRepositoryConnection"];
        });
    Migration: RepositoryMigration;
    Minimizable:
      | (Omit<
          CommitComment,
          | "author"
          | "commit"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          DiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "replies"
          | "replyTo"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion?: Maybe<_RefType["Discussion"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replies: _RefType["DiscussionCommentConnection"];
          replyTo?: Maybe<_RefType["DiscussionComment"]>;
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          GistComment,
          "author" | "editor" | "gist" | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          gist: _RefType["Gist"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          IssueComment,
          | "author"
          | "editor"
          | "issue"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          issue: _RefType["Issue"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequestReview,
          | "author"
          | "comments"
          | "commit"
          | "editor"
          | "onBehalfOf"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["PullRequestReviewCommentConnection"];
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          onBehalfOf: _RefType["TeamConnection"];
          pullRequest: _RefType["PullRequest"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequestReviewComment,
          | "author"
          | "commit"
          | "editor"
          | "originalCommit"
          | "pullRequest"
          | "pullRequestReview"
          | "reactionGroups"
          | "reactions"
          | "replyTo"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          originalCommit?: Maybe<_RefType["Commit"]>;
          pullRequest: _RefType["PullRequest"];
          pullRequestReview?: Maybe<_RefType["PullRequestReview"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replyTo?: Maybe<_RefType["PullRequestReviewComment"]>;
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        });
    Node:
      | (Omit<
          AddedToMergeQueueEvent,
          "actor" | "enqueuer" | "mergeQueue" | "pullRequest"
        > & {
          actor?: Maybe<_RefType["Actor"]>;
          enqueuer?: Maybe<_RefType["User"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          pullRequest?: Maybe<_RefType["PullRequest"]>;
        })
      | (Omit<AddedToProjectEvent, "actor" | "project" | "projectCard"> & {
          actor?: Maybe<_RefType["Actor"]>;
          project?: Maybe<_RefType["Project"]>;
          projectCard?: Maybe<_RefType["ProjectCard"]>;
        })
      | (Omit<App, "ipAllowListEntries"> & {
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
        })
      | (Omit<AssignedEvent, "actor" | "assignable" | "assignee" | "user"> & {
          actor?: Maybe<_RefType["Actor"]>;
          assignable: _RefType["Assignable"];
          assignee?: Maybe<_RefType["Assignee"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<AutoMergeDisabledEvent, "actor" | "disabler" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          disabler?: Maybe<_RefType["User"]>;
          pullRequest?: Maybe<_RefType["PullRequest"]>;
        })
      | (Omit<AutoMergeEnabledEvent, "actor" | "enabler" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          enabler?: Maybe<_RefType["User"]>;
          pullRequest?: Maybe<_RefType["PullRequest"]>;
        })
      | (Omit<AutoRebaseEnabledEvent, "actor" | "enabler" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          enabler?: Maybe<_RefType["User"]>;
          pullRequest?: Maybe<_RefType["PullRequest"]>;
        })
      | (Omit<AutoSquashEnabledEvent, "actor" | "enabler" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          enabler?: Maybe<_RefType["User"]>;
          pullRequest?: Maybe<_RefType["PullRequest"]>;
        })
      | (Omit<AutomaticBaseChangeFailedEvent, "actor" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<AutomaticBaseChangeSucceededEvent, "actor" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<BaseRefChangedEvent, "actor" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<BaseRefDeletedEvent, "actor" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest?: Maybe<_RefType["PullRequest"]>;
        })
      | (Omit<
          BaseRefForcePushedEvent,
          "actor" | "afterCommit" | "beforeCommit" | "pullRequest" | "ref"
        > & {
          actor?: Maybe<_RefType["Actor"]>;
          afterCommit?: Maybe<_RefType["Commit"]>;
          beforeCommit?: Maybe<_RefType["Commit"]>;
          pullRequest: _RefType["PullRequest"];
          ref?: Maybe<_RefType["Ref"]>;
        })
      | (Omit<Blob, "repository"> & { repository: _RefType["Repository"] })
      | Bot
      | (Omit<
          BranchProtectionRule,
          | "bypassForcePushAllowances"
          | "bypassPullRequestAllowances"
          | "creator"
          | "pushAllowances"
          | "repository"
          | "requiredStatusChecks"
          | "reviewDismissalAllowances"
        > & {
          bypassForcePushAllowances: _RefType["BypassForcePushAllowanceConnection"];
          bypassPullRequestAllowances: _RefType["BypassPullRequestAllowanceConnection"];
          creator?: Maybe<_RefType["Actor"]>;
          pushAllowances: _RefType["PushAllowanceConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          requiredStatusChecks?: Maybe<
            Array<_RefType["RequiredStatusCheckDescription"]>
          >;
          reviewDismissalAllowances: _RefType["ReviewDismissalAllowanceConnection"];
        })
      | (Omit<BypassForcePushAllowance, "actor" | "branchProtectionRule"> & {
          actor?: Maybe<_RefType["BranchActorAllowanceActor"]>;
          branchProtectionRule?: Maybe<_RefType["BranchProtectionRule"]>;
        })
      | (Omit<BypassPullRequestAllowance, "actor" | "branchProtectionRule"> & {
          actor?: Maybe<_RefType["BranchActorAllowanceActor"]>;
          branchProtectionRule?: Maybe<_RefType["BranchProtectionRule"]>;
        })
      | Cwe
      | (Omit<
          CheckRun,
          | "checkSuite"
          | "deployment"
          | "pendingDeploymentRequest"
          | "repository"
        > & {
          checkSuite: _RefType["CheckSuite"];
          deployment?: Maybe<_RefType["Deployment"]>;
          pendingDeploymentRequest?: Maybe<_RefType["DeploymentRequest"]>;
          repository: _RefType["Repository"];
        })
      | (Omit<
          CheckSuite,
          | "app"
          | "branch"
          | "checkRuns"
          | "commit"
          | "creator"
          | "matchingPullRequests"
          | "push"
          | "repository"
          | "workflowRun"
        > & {
          app?: Maybe<_RefType["App"]>;
          branch?: Maybe<_RefType["Ref"]>;
          checkRuns?: Maybe<_RefType["CheckRunConnection"]>;
          commit: _RefType["Commit"];
          creator?: Maybe<_RefType["User"]>;
          matchingPullRequests?: Maybe<_RefType["PullRequestConnection"]>;
          push?: Maybe<_RefType["Push"]>;
          repository: _RefType["Repository"];
          workflowRun?: Maybe<_RefType["WorkflowRun"]>;
        })
      | (Omit<ClosedEvent, "actor" | "closable" | "closer"> & {
          actor?: Maybe<_RefType["Actor"]>;
          closable: _RefType["Closable"];
          closer?: Maybe<_RefType["Closer"]>;
        })
      | CodeOfConduct
      | (Omit<CommentDeletedEvent, "actor" | "deletedCommentAuthor"> & {
          actor?: Maybe<_RefType["Actor"]>;
          deletedCommentAuthor?: Maybe<_RefType["Actor"]>;
        })
      | (Omit<
          Commit,
          | "associatedPullRequests"
          | "blame"
          | "checkSuites"
          | "comments"
          | "deployments"
          | "file"
          | "history"
          | "onBehalfOf"
          | "parents"
          | "repository"
          | "signature"
          | "status"
          | "statusCheckRollup"
          | "tree"
        > & {
          associatedPullRequests?: Maybe<_RefType["PullRequestConnection"]>;
          blame: _RefType["Blame"];
          checkSuites?: Maybe<_RefType["CheckSuiteConnection"]>;
          comments: _RefType["CommitCommentConnection"];
          deployments?: Maybe<_RefType["DeploymentConnection"]>;
          file?: Maybe<_RefType["TreeEntry"]>;
          history: _RefType["CommitHistoryConnection"];
          onBehalfOf?: Maybe<_RefType["Organization"]>;
          parents: _RefType["CommitConnection"];
          repository: _RefType["Repository"];
          signature?: Maybe<_RefType["GitSignature"]>;
          status?: Maybe<_RefType["Status"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          tree: _RefType["Tree"];
        })
      | (Omit<
          CommitComment,
          | "author"
          | "commit"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<CommitCommentThread, "comments" | "commit" | "repository"> & {
          comments: _RefType["CommitCommentConnection"];
          commit?: Maybe<_RefType["Commit"]>;
          repository: _RefType["Repository"];
        })
      | (Omit<Comparison, "baseTarget" | "headTarget"> & {
          baseTarget: _RefType["GitObject"];
          headTarget: _RefType["GitObject"];
        })
      | (Omit<ConnectedEvent, "actor" | "source" | "subject"> & {
          actor?: Maybe<_RefType["Actor"]>;
          source: _RefType["ReferencedSubject"];
          subject: _RefType["ReferencedSubject"];
        })
      | (Omit<ConvertToDraftEvent, "actor" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<
          ConvertedNoteToIssueEvent,
          "actor" | "project" | "projectCard"
        > & {
          actor?: Maybe<_RefType["Actor"]>;
          project?: Maybe<_RefType["Project"]>;
          projectCard?: Maybe<_RefType["ProjectCard"]>;
        })
      | (Omit<ConvertedToDiscussionEvent, "actor" | "discussion"> & {
          actor?: Maybe<_RefType["Actor"]>;
          discussion?: Maybe<_RefType["Discussion"]>;
        })
      | (Omit<CrossReferencedEvent, "actor" | "source" | "target"> & {
          actor?: Maybe<_RefType["Actor"]>;
          source: _RefType["ReferencedSubject"];
          target: _RefType["ReferencedSubject"];
        })
      | (Omit<DemilestonedEvent, "actor" | "subject"> & {
          actor?: Maybe<_RefType["Actor"]>;
          subject: _RefType["MilestoneItem"];
        })
      | (Omit<DependencyGraphManifest, "dependencies" | "repository"> & {
          dependencies?: Maybe<_RefType["DependencyGraphDependencyConnection"]>;
          repository: _RefType["Repository"];
        })
      | DeployKey
      | (Omit<DeployedEvent, "actor" | "deployment" | "pullRequest" | "ref"> & {
          actor?: Maybe<_RefType["Actor"]>;
          deployment: _RefType["Deployment"];
          pullRequest: _RefType["PullRequest"];
          ref?: Maybe<_RefType["Ref"]>;
        })
      | (Omit<
          Deployment,
          | "commit"
          | "creator"
          | "latestStatus"
          | "ref"
          | "repository"
          | "statuses"
        > & {
          commit?: Maybe<_RefType["Commit"]>;
          creator: _RefType["Actor"];
          latestStatus?: Maybe<_RefType["DeploymentStatus"]>;
          ref?: Maybe<_RefType["Ref"]>;
          repository: _RefType["Repository"];
          statuses?: Maybe<_RefType["DeploymentStatusConnection"]>;
        })
      | (Omit<
          DeploymentEnvironmentChangedEvent,
          "actor" | "deploymentStatus" | "pullRequest"
        > & {
          actor?: Maybe<_RefType["Actor"]>;
          deploymentStatus: _RefType["DeploymentStatus"];
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<DeploymentReview, "environments" | "user"> & {
          environments: _RefType["EnvironmentConnection"];
          user: _RefType["User"];
        })
      | (Omit<DeploymentStatus, "creator" | "deployment"> & {
          creator: _RefType["Actor"];
          deployment: _RefType["Deployment"];
        })
      | (Omit<DisconnectedEvent, "actor" | "source" | "subject"> & {
          actor?: Maybe<_RefType["Actor"]>;
          source: _RefType["ReferencedSubject"];
          subject: _RefType["ReferencedSubject"];
        })
      | (Omit<
          Discussion,
          | "answer"
          | "answerChosenBy"
          | "author"
          | "category"
          | "comments"
          | "editor"
          | "labels"
          | "poll"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          answer?: Maybe<_RefType["DiscussionComment"]>;
          answerChosenBy?: Maybe<_RefType["Actor"]>;
          author?: Maybe<_RefType["Actor"]>;
          category: _RefType["DiscussionCategory"];
          comments: _RefType["DiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          poll?: Maybe<_RefType["DiscussionPoll"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<DiscussionCategory, "repository"> & {
          repository: _RefType["Repository"];
        })
      | (Omit<
          DiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "replies"
          | "replyTo"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion?: Maybe<_RefType["Discussion"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replies: _RefType["DiscussionCommentConnection"];
          replyTo?: Maybe<_RefType["DiscussionComment"]>;
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<DiscussionPoll, "discussion" | "options"> & {
          discussion?: Maybe<_RefType["Discussion"]>;
          options?: Maybe<_RefType["DiscussionPollOptionConnection"]>;
        })
      | (Omit<DiscussionPollOption, "poll"> & {
          poll?: Maybe<_RefType["DiscussionPoll"]>;
        })
      | (Omit<DraftIssue, "creator" | "projectV2Items" | "projectsV2"> & {
          creator?: Maybe<_RefType["Actor"]>;
          projectV2Items: _RefType["ProjectV2ItemConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
        })
      | (Omit<
          Enterprise,
          "billingInfo" | "members" | "organizations" | "ownerInfo"
        > & {
          billingInfo?: Maybe<_RefType["EnterpriseBillingInfo"]>;
          members: _RefType["EnterpriseMemberConnection"];
          organizations: _RefType["OrganizationConnection"];
          ownerInfo?: Maybe<_RefType["EnterpriseOwnerInfo"]>;
        })
      | (Omit<
          EnterpriseAdministratorInvitation,
          "enterprise" | "invitee" | "inviter"
        > & {
          enterprise: _RefType["Enterprise"];
          invitee?: Maybe<_RefType["User"]>;
          inviter?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          EnterpriseIdentityProvider,
          "enterprise" | "externalIdentities"
        > & {
          enterprise?: Maybe<_RefType["Enterprise"]>;
          externalIdentities: _RefType["ExternalIdentityConnection"];
        })
      | (Omit<
          EnterpriseMemberInvitation,
          "enterprise" | "invitee" | "inviter"
        > & {
          enterprise: _RefType["Enterprise"];
          invitee?: Maybe<_RefType["User"]>;
          inviter?: Maybe<_RefType["User"]>;
        })
      | EnterpriseRepositoryInfo
      | (Omit<EnterpriseServerInstallation, "userAccountsUploads"> & {
          userAccountsUploads: _RefType["EnterpriseServerUserAccountsUploadConnection"];
        })
      | (Omit<EnterpriseServerUserAccount, "enterpriseServerInstallation"> & {
          enterpriseServerInstallation: _RefType["EnterpriseServerInstallation"];
        })
      | EnterpriseServerUserAccountEmail
      | (Omit<
          EnterpriseServerUserAccountsUpload,
          "enterprise" | "enterpriseServerInstallation"
        > & {
          enterprise: _RefType["Enterprise"];
          enterpriseServerInstallation: _RefType["EnterpriseServerInstallation"];
        })
      | (Omit<
          EnterpriseUserAccount,
          "enterprise" | "enterpriseInstallations" | "organizations" | "user"
        > & {
          enterprise: _RefType["Enterprise"];
          enterpriseInstallations: _RefType["EnterpriseServerInstallationMembershipConnection"];
          organizations: _RefType["EnterpriseOrganizationMembershipConnection"];
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<Environment, "latestCompletedDeployment" | "protectionRules"> & {
          latestCompletedDeployment?: Maybe<_RefType["Deployment"]>;
          protectionRules: _RefType["DeploymentProtectionRuleConnection"];
        })
      | (Omit<ExternalIdentity, "organizationInvitation" | "user"> & {
          organizationInvitation?: Maybe<_RefType["OrganizationInvitation"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<Gist, "comments" | "forks" | "owner"> & {
          comments: _RefType["GistCommentConnection"];
          forks: _RefType["GistConnection"];
          owner?: Maybe<_RefType["RepositoryOwner"]>;
        })
      | (Omit<
          GistComment,
          "author" | "editor" | "gist" | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          gist: _RefType["Gist"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<HeadRefDeletedEvent, "actor" | "headRef" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<
          HeadRefForcePushedEvent,
          "actor" | "afterCommit" | "beforeCommit" | "pullRequest" | "ref"
        > & {
          actor?: Maybe<_RefType["Actor"]>;
          afterCommit?: Maybe<_RefType["Commit"]>;
          beforeCommit?: Maybe<_RefType["Commit"]>;
          pullRequest: _RefType["PullRequest"];
          ref?: Maybe<_RefType["Ref"]>;
        })
      | (Omit<HeadRefRestoredEvent, "actor" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<IpAllowListEntry, "owner"> & {
          owner: _RefType["IpAllowListOwner"];
        })
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          IssueComment,
          | "author"
          | "editor"
          | "issue"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          issue: _RefType["Issue"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<Label, "issues" | "pullRequests" | "repository"> & {
          issues: _RefType["IssueConnection"];
          pullRequests: _RefType["PullRequestConnection"];
          repository: _RefType["Repository"];
        })
      | (Omit<LabeledEvent, "actor" | "label" | "labelable"> & {
          actor?: Maybe<_RefType["Actor"]>;
          label: _RefType["Label"];
          labelable: _RefType["Labelable"];
        })
      | Language
      | License
      | (Omit<LinkedBranch, "ref"> & { ref?: Maybe<_RefType["Ref"]> })
      | (Omit<LockedEvent, "actor" | "lockable"> & {
          actor?: Maybe<_RefType["Actor"]>;
          lockable: _RefType["Lockable"];
        })
      | (Omit<Mannequin, "claimant"> & { claimant?: Maybe<_RefType["User"]> })
      | (Omit<MarkedAsDuplicateEvent, "actor" | "canonical" | "duplicate"> & {
          actor?: Maybe<_RefType["Actor"]>;
          canonical?: Maybe<_RefType["IssueOrPullRequest"]>;
          duplicate?: Maybe<_RefType["IssueOrPullRequest"]>;
        })
      | MarketplaceCategory
      | (Omit<MarketplaceListing, "app"> & { app?: Maybe<_RefType["App"]> })
      | MemberFeatureRequestNotification
      | (Omit<
          MembersCanDeleteReposClearAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          MembersCanDeleteReposDisableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          MembersCanDeleteReposEnableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<MentionedEvent, "actor"> & { actor?: Maybe<_RefType["Actor"]> })
      | (Omit<MergeQueue, "configuration" | "entries" | "repository"> & {
          configuration?: Maybe<_RefType["MergeQueueConfiguration"]>;
          entries?: Maybe<_RefType["MergeQueueEntryConnection"]>;
          repository?: Maybe<_RefType["Repository"]>;
        })
      | (Omit<
          MergeQueueEntry,
          | "baseCommit"
          | "enqueuer"
          | "headCommit"
          | "mergeQueue"
          | "pullRequest"
        > & {
          baseCommit?: Maybe<_RefType["Commit"]>;
          enqueuer: _RefType["Actor"];
          headCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          pullRequest?: Maybe<_RefType["PullRequest"]>;
        })
      | (Omit<MergedEvent, "actor" | "commit" | "mergeRef" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          mergeRef?: Maybe<_RefType["Ref"]>;
          pullRequest: _RefType["PullRequest"];
        })
      | MigrationSource
      | (Omit<
          Milestone,
          "creator" | "issues" | "pullRequests" | "repository"
        > & {
          creator?: Maybe<_RefType["Actor"]>;
          issues: _RefType["IssueConnection"];
          pullRequests: _RefType["PullRequestConnection"];
          repository: _RefType["Repository"];
        })
      | (Omit<MilestonedEvent, "actor" | "subject"> & {
          actor?: Maybe<_RefType["Actor"]>;
          subject: _RefType["MilestoneItem"];
        })
      | (Omit<
          MovedColumnsInProjectEvent,
          "actor" | "project" | "projectCard"
        > & {
          actor?: Maybe<_RefType["Actor"]>;
          project?: Maybe<_RefType["Project"]>;
          projectCard?: Maybe<_RefType["ProjectCard"]>;
        })
      | (Omit<OidcProvider, "enterprise" | "externalIdentities"> & {
          enterprise?: Maybe<_RefType["Enterprise"]>;
          externalIdentities: _RefType["ExternalIdentityConnection"];
        })
      | (Omit<
          OauthApplicationCreateAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgAddBillingManagerAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgAddMemberAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgBlockUserAuditEntry,
          "actor" | "blockedUser" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          blockedUser?: Maybe<_RefType["User"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgConfigDisableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgConfigEnableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgCreateAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgDisableOauthAppRestrictionsAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgDisableSamlAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgDisableTwoFactorRequirementAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgEnableOauthAppRestrictionsAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgEnableSamlAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgEnableTwoFactorRequirementAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgInviteMemberAuditEntry,
          "actor" | "organization" | "organizationInvitation" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          organizationInvitation?: Maybe<_RefType["OrganizationInvitation"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgInviteToBusinessAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessApprovedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessBlockedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessDeniedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessRequestedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessUnblockedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgRemoveBillingManagerAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgRemoveMemberAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgRemoveOutsideCollaboratorAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgRestoreMemberAuditEntry,
          "actor" | "organization" | "restoredMemberships" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          restoredMemberships?: Maybe<
            Array<_RefType["OrgRestoreMemberAuditEntryMembership"]>
          >;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgUnblockUserAuditEntry,
          "actor" | "blockedUser" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          blockedUser?: Maybe<_RefType["User"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgUpdateDefaultRepositoryPermissionAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgUpdateMemberAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgUpdateMemberRepositoryCreationPermissionAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgUpdateMemberRepositoryInvitationPermissionAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          OrganizationIdentityProvider,
          "externalIdentities" | "organization"
        > & {
          externalIdentities: _RefType["ExternalIdentityConnection"];
          organization?: Maybe<_RefType["Organization"]>;
        })
      | (Omit<
          OrganizationInvitation,
          "invitee" | "inviter" | "inviterActor" | "organization"
        > & {
          invitee?: Maybe<_RefType["User"]>;
          inviter: _RefType["User"];
          inviterActor?: Maybe<_RefType["User"]>;
          organization: _RefType["Organization"];
        })
      | OrganizationMigration
      | (Omit<
          Package,
          "latestVersion" | "repository" | "version" | "versions"
        > & {
          latestVersion?: Maybe<_RefType["PackageVersion"]>;
          repository?: Maybe<_RefType["Repository"]>;
          version?: Maybe<_RefType["PackageVersion"]>;
          versions: _RefType["PackageVersionConnection"];
        })
      | (Omit<PackageFile, "packageVersion"> & {
          packageVersion?: Maybe<_RefType["PackageVersion"]>;
        })
      | (Omit<PackageTag, "version"> & {
          version?: Maybe<_RefType["PackageVersion"]>;
        })
      | (Omit<PackageVersion, "package" | "release"> & {
          package?: Maybe<_RefType["Package"]>;
          release?: Maybe<_RefType["Release"]>;
        })
      | (Omit<PinnedDiscussion, "discussion" | "pinnedBy" | "repository"> & {
          discussion: _RefType["Discussion"];
          pinnedBy: _RefType["Actor"];
          repository: _RefType["Repository"];
        })
      | (Omit<PinnedEnvironment, "environment" | "repository"> & {
          environment: _RefType["Environment"];
          repository: _RefType["Repository"];
        })
      | (Omit<PinnedEvent, "actor" | "issue"> & {
          actor?: Maybe<_RefType["Actor"]>;
          issue: _RefType["Issue"];
        })
      | (Omit<PinnedIssue, "issue" | "pinnedBy" | "repository"> & {
          issue: _RefType["Issue"];
          pinnedBy: _RefType["Actor"];
          repository: _RefType["Repository"];
        })
      | (Omit<
          PrivateRepositoryForkingDisableAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          PrivateRepositoryForkingEnableAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<Project, "creator" | "owner" | "pendingCards"> & {
          creator?: Maybe<_RefType["Actor"]>;
          owner: _RefType["ProjectOwner"];
          pendingCards: _RefType["ProjectCardConnection"];
        })
      | (Omit<ProjectCard, "column" | "content" | "creator" | "project"> & {
          column?: Maybe<_RefType["ProjectColumn"]>;
          content?: Maybe<_RefType["ProjectCardItem"]>;
          creator?: Maybe<_RefType["Actor"]>;
          project: _RefType["Project"];
        })
      | (Omit<ProjectColumn, "cards" | "project"> & {
          cards: _RefType["ProjectCardConnection"];
          project: _RefType["Project"];
        })
      | (Omit<
          ProjectV2,
          | "creator"
          | "field"
          | "fields"
          | "items"
          | "owner"
          | "repositories"
          | "statusUpdates"
          | "teams"
          | "view"
          | "views"
          | "workflow"
          | "workflows"
        > & {
          creator?: Maybe<_RefType["Actor"]>;
          field?: Maybe<_RefType["ProjectV2FieldConfiguration"]>;
          fields: _RefType["ProjectV2FieldConfigurationConnection"];
          items: _RefType["ProjectV2ItemConnection"];
          owner: _RefType["ProjectV2Owner"];
          repositories: _RefType["RepositoryConnection"];
          statusUpdates: _RefType["ProjectV2StatusUpdateConnection"];
          teams: _RefType["TeamConnection"];
          view?: Maybe<_RefType["ProjectV2View"]>;
          views: _RefType["ProjectV2ViewConnection"];
          workflow?: Maybe<_RefType["ProjectV2Workflow"]>;
          workflows: _RefType["ProjectV2WorkflowConnection"];
        })
      | (Omit<ProjectV2Field, "project"> & { project: _RefType["ProjectV2"] })
      | (Omit<
          ProjectV2Item,
          "content" | "creator" | "fieldValueByName" | "fieldValues" | "project"
        > & {
          content?: Maybe<_RefType["ProjectV2ItemContent"]>;
          creator?: Maybe<_RefType["Actor"]>;
          fieldValueByName?: Maybe<_RefType["ProjectV2ItemFieldValue"]>;
          fieldValues: _RefType["ProjectV2ItemFieldValueConnection"];
          project: _RefType["ProjectV2"];
        })
      | (Omit<ProjectV2ItemFieldDateValue, "creator" | "field" | "item"> & {
          creator?: Maybe<_RefType["Actor"]>;
          field: _RefType["ProjectV2FieldConfiguration"];
          item: _RefType["ProjectV2Item"];
        })
      | (Omit<
          ProjectV2ItemFieldIterationValue,
          "creator" | "field" | "item"
        > & {
          creator?: Maybe<_RefType["Actor"]>;
          field: _RefType["ProjectV2FieldConfiguration"];
          item: _RefType["ProjectV2Item"];
        })
      | (Omit<ProjectV2ItemFieldNumberValue, "creator" | "field" | "item"> & {
          creator?: Maybe<_RefType["Actor"]>;
          field: _RefType["ProjectV2FieldConfiguration"];
          item: _RefType["ProjectV2Item"];
        })
      | (Omit<
          ProjectV2ItemFieldSingleSelectValue,
          "creator" | "field" | "item"
        > & {
          creator?: Maybe<_RefType["Actor"]>;
          field: _RefType["ProjectV2FieldConfiguration"];
          item: _RefType["ProjectV2Item"];
        })
      | (Omit<ProjectV2ItemFieldTextValue, "creator" | "field" | "item"> & {
          creator?: Maybe<_RefType["Actor"]>;
          field: _RefType["ProjectV2FieldConfiguration"];
          item: _RefType["ProjectV2Item"];
        })
      | (Omit<ProjectV2IterationField, "project"> & {
          project: _RefType["ProjectV2"];
        })
      | (Omit<ProjectV2SingleSelectField, "project"> & {
          project: _RefType["ProjectV2"];
        })
      | (Omit<ProjectV2StatusUpdate, "creator" | "project"> & {
          creator?: Maybe<_RefType["Actor"]>;
          project: _RefType["ProjectV2"];
        })
      | (Omit<
          ProjectV2View,
          | "fields"
          | "groupBy"
          | "groupByFields"
          | "project"
          | "sortBy"
          | "sortByFields"
          | "verticalGroupBy"
          | "verticalGroupByFields"
          | "visibleFields"
        > & {
          fields?: Maybe<_RefType["ProjectV2FieldConfigurationConnection"]>;
          groupBy?: Maybe<_RefType["ProjectV2FieldConnection"]>;
          groupByFields?: Maybe<
            _RefType["ProjectV2FieldConfigurationConnection"]
          >;
          project: _RefType["ProjectV2"];
          sortBy?: Maybe<_RefType["ProjectV2SortByConnection"]>;
          sortByFields?: Maybe<_RefType["ProjectV2SortByFieldConnection"]>;
          verticalGroupBy?: Maybe<_RefType["ProjectV2FieldConnection"]>;
          verticalGroupByFields?: Maybe<
            _RefType["ProjectV2FieldConfigurationConnection"]
          >;
          visibleFields?: Maybe<_RefType["ProjectV2FieldConnection"]>;
        })
      | (Omit<ProjectV2Workflow, "project"> & {
          project: _RefType["ProjectV2"];
        })
      | PublicKey
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        })
      | (Omit<PullRequestCommit, "commit" | "pullRequest"> & {
          commit: _RefType["Commit"];
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<
          PullRequestCommitCommentThread,
          "comments" | "commit" | "pullRequest" | "repository"
        > & {
          comments: _RefType["CommitCommentConnection"];
          commit: _RefType["Commit"];
          pullRequest: _RefType["PullRequest"];
          repository: _RefType["Repository"];
        })
      | (Omit<
          PullRequestReview,
          | "author"
          | "comments"
          | "commit"
          | "editor"
          | "onBehalfOf"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["PullRequestReviewCommentConnection"];
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          onBehalfOf: _RefType["TeamConnection"];
          pullRequest: _RefType["PullRequest"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequestReviewComment,
          | "author"
          | "commit"
          | "editor"
          | "originalCommit"
          | "pullRequest"
          | "pullRequestReview"
          | "reactionGroups"
          | "reactions"
          | "replyTo"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          originalCommit?: Maybe<_RefType["Commit"]>;
          pullRequest: _RefType["PullRequest"];
          pullRequestReview?: Maybe<_RefType["PullRequestReview"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replyTo?: Maybe<_RefType["PullRequestReviewComment"]>;
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequestReviewThread,
          "comments" | "pullRequest" | "repository" | "resolvedBy"
        > & {
          comments: _RefType["PullRequestReviewCommentConnection"];
          pullRequest: _RefType["PullRequest"];
          repository: _RefType["Repository"];
          resolvedBy?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          PullRequestThread,
          "comments" | "pullRequest" | "repository" | "resolvedBy"
        > & {
          comments: _RefType["PullRequestReviewCommentConnection"];
          pullRequest: _RefType["PullRequest"];
          repository: _RefType["Repository"];
          resolvedBy?: Maybe<_RefType["User"]>;
        })
      | (Omit<Push, "pusher" | "repository"> & {
          pusher: _RefType["Actor"];
          repository: _RefType["Repository"];
        })
      | (Omit<PushAllowance, "actor" | "branchProtectionRule"> & {
          actor?: Maybe<_RefType["PushAllowanceActor"]>;
          branchProtectionRule?: Maybe<_RefType["BranchProtectionRule"]>;
        })
      | (Omit<Reaction, "reactable" | "user"> & {
          reactable: _RefType["Reactable"];
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<ReadyForReviewEvent, "actor" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<
          Ref,
          | "associatedPullRequests"
          | "branchProtectionRule"
          | "compare"
          | "repository"
          | "rules"
          | "target"
        > & {
          associatedPullRequests: _RefType["PullRequestConnection"];
          branchProtectionRule?: Maybe<_RefType["BranchProtectionRule"]>;
          compare?: Maybe<_RefType["Comparison"]>;
          repository: _RefType["Repository"];
          rules?: Maybe<_RefType["RepositoryRuleConnection"]>;
          target?: Maybe<_RefType["GitObject"]>;
        })
      | (Omit<
          ReferencedEvent,
          "actor" | "commit" | "commitRepository" | "subject"
        > & {
          actor?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          commitRepository: _RefType["Repository"];
          subject: _RefType["ReferencedSubject"];
        })
      | (Omit<
          Release,
          | "author"
          | "reactionGroups"
          | "reactions"
          | "releaseAssets"
          | "repository"
          | "tag"
          | "tagCommit"
        > & {
          author?: Maybe<_RefType["User"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          releaseAssets: _RefType["ReleaseAssetConnection"];
          repository: _RefType["Repository"];
          tag?: Maybe<_RefType["Ref"]>;
          tagCommit?: Maybe<_RefType["Commit"]>;
        })
      | (Omit<ReleaseAsset, "release" | "uploadedBy"> & {
          release?: Maybe<_RefType["Release"]>;
          uploadedBy: _RefType["User"];
        })
      | (Omit<
          RemovedFromMergeQueueEvent,
          "actor" | "beforeCommit" | "enqueuer" | "mergeQueue" | "pullRequest"
        > & {
          actor?: Maybe<_RefType["Actor"]>;
          beforeCommit?: Maybe<_RefType["Commit"]>;
          enqueuer?: Maybe<_RefType["User"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          pullRequest?: Maybe<_RefType["PullRequest"]>;
        })
      | (Omit<RemovedFromProjectEvent, "actor" | "project"> & {
          actor?: Maybe<_RefType["Actor"]>;
          project?: Maybe<_RefType["Project"]>;
        })
      | (Omit<RenamedTitleEvent, "actor" | "subject"> & {
          actor?: Maybe<_RefType["Actor"]>;
          subject: _RefType["RenamedTitleSubject"];
        })
      | (Omit<ReopenedEvent, "actor" | "closable"> & {
          actor?: Maybe<_RefType["Actor"]>;
          closable: _RefType["Closable"];
        })
      | (Omit<
          RepoAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoAddMemberAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoAddTopicAuditEntry,
          "actor" | "organization" | "repository" | "topic" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          topic?: Maybe<_RefType["Topic"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoArchivedAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoChangeMergeSettingAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableContributorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableSockpuppetDisallowedAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableContributorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableSockpuppetDisallowedAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigLockAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigUnlockAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoCreateAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoDestroyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoRemoveMemberAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoRemoveTopicAuditEntry,
          "actor" | "organization" | "repository" | "topic" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          topic?: Maybe<_RefType["Topic"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          Repository,
          | "branchProtectionRules"
          | "collaborators"
          | "commitComments"
          | "defaultBranchRef"
          | "dependencyGraphManifests"
          | "deployments"
          | "discussion"
          | "discussionCategories"
          | "discussionCategory"
          | "discussions"
          | "environment"
          | "environments"
          | "forks"
          | "issue"
          | "issueOrPullRequest"
          | "issueTemplates"
          | "issues"
          | "label"
          | "labels"
          | "latestRelease"
          | "mergeQueue"
          | "milestone"
          | "milestones"
          | "object"
          | "owner"
          | "packages"
          | "parent"
          | "pinnedDiscussions"
          | "pinnedEnvironments"
          | "pinnedIssues"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequest"
          | "pullRequestTemplates"
          | "pullRequests"
          | "recentProjects"
          | "ref"
          | "release"
          | "releases"
          | "repositoryTopics"
          | "ruleset"
          | "rulesets"
          | "templateRepository"
          | "vulnerabilityAlert"
          | "vulnerabilityAlerts"
        > & {
          branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
          collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
          commitComments: _RefType["CommitCommentConnection"];
          defaultBranchRef?: Maybe<_RefType["Ref"]>;
          dependencyGraphManifests?: Maybe<
            _RefType["DependencyGraphManifestConnection"]
          >;
          deployments: _RefType["DeploymentConnection"];
          discussion?: Maybe<_RefType["Discussion"]>;
          discussionCategories: _RefType["DiscussionCategoryConnection"];
          discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
          discussions: _RefType["DiscussionConnection"];
          environment?: Maybe<_RefType["Environment"]>;
          environments: _RefType["EnvironmentConnection"];
          forks: _RefType["RepositoryConnection"];
          issue?: Maybe<_RefType["Issue"]>;
          issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
          issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
          issues: _RefType["IssueConnection"];
          label?: Maybe<_RefType["Label"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestRelease?: Maybe<_RefType["Release"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          milestones?: Maybe<_RefType["MilestoneConnection"]>;
          object?: Maybe<_RefType["GitObject"]>;
          owner: _RefType["RepositoryOwner"];
          packages: _RefType["PackageConnection"];
          parent?: Maybe<_RefType["Repository"]>;
          pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
          pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
          pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          ref?: Maybe<_RefType["Ref"]>;
          release?: Maybe<_RefType["Release"]>;
          releases: _RefType["ReleaseConnection"];
          repositoryTopics: _RefType["RepositoryTopicConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          templateRepository?: Maybe<_RefType["Repository"]>;
          vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
          vulnerabilityAlerts?: Maybe<
            _RefType["RepositoryVulnerabilityAlertConnection"]
          >;
        })
      | (Omit<RepositoryInvitation, "invitee" | "inviter" | "repository"> & {
          invitee?: Maybe<_RefType["User"]>;
          inviter: _RefType["User"];
          repository?: Maybe<_RefType["RepositoryInfo"]>;
        })
      | RepositoryMigration
      | (Omit<RepositoryRule, "parameters" | "repositoryRuleset"> & {
          parameters?: Maybe<_RefType["RuleParameters"]>;
          repositoryRuleset?: Maybe<_RefType["RepositoryRuleset"]>;
        })
      | (Omit<RepositoryRuleset, "bypassActors" | "rules" | "source"> & {
          bypassActors?: Maybe<
            _RefType["RepositoryRulesetBypassActorConnection"]
          >;
          rules?: Maybe<_RefType["RepositoryRuleConnection"]>;
          source: _RefType["RuleSource"];
        })
      | (Omit<RepositoryRulesetBypassActor, "actor" | "repositoryRuleset"> & {
          actor?: Maybe<_RefType["BypassActor"]>;
          repositoryRuleset?: Maybe<_RefType["RepositoryRuleset"]>;
        })
      | (Omit<RepositoryTopic, "topic"> & { topic: _RefType["Topic"] })
      | (Omit<
          RepositoryVisibilityChangeDisableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepositoryVisibilityChangeEnableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepositoryVulnerabilityAlert,
          "dependabotUpdate" | "dismisser" | "repository"
        > & {
          dependabotUpdate?: Maybe<_RefType["DependabotUpdate"]>;
          dismisser?: Maybe<_RefType["User"]>;
          repository: _RefType["Repository"];
        })
      | (Omit<ReviewDismissalAllowance, "actor" | "branchProtectionRule"> & {
          actor?: Maybe<_RefType["ReviewDismissalAllowanceActor"]>;
          branchProtectionRule?: Maybe<_RefType["BranchProtectionRule"]>;
        })
      | (Omit<
          ReviewDismissedEvent,
          "actor" | "pullRequest" | "pullRequestCommit" | "review"
        > & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest: _RefType["PullRequest"];
          pullRequestCommit?: Maybe<_RefType["PullRequestCommit"]>;
          review?: Maybe<_RefType["PullRequestReview"]>;
        })
      | (Omit<ReviewRequest, "pullRequest" | "requestedReviewer"> & {
          pullRequest: _RefType["PullRequest"];
          requestedReviewer?: Maybe<_RefType["RequestedReviewer"]>;
        })
      | (Omit<
          ReviewRequestRemovedEvent,
          "actor" | "pullRequest" | "requestedReviewer"
        > & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest: _RefType["PullRequest"];
          requestedReviewer?: Maybe<_RefType["RequestedReviewer"]>;
        })
      | (Omit<
          ReviewRequestedEvent,
          "actor" | "pullRequest" | "requestedReviewer"
        > & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest: _RefType["PullRequest"];
          requestedReviewer?: Maybe<_RefType["RequestedReviewer"]>;
        })
      | (Omit<SavedReply, "user"> & { user?: Maybe<_RefType["Actor"]> })
      | SecurityAdvisory
      | (Omit<
          SponsorsActivity,
          "previousSponsorsTier" | "sponsor" | "sponsorable" | "sponsorsTier"
        > & {
          previousSponsorsTier?: Maybe<_RefType["SponsorsTier"]>;
          sponsor?: Maybe<_RefType["Sponsor"]>;
          sponsorable: _RefType["Sponsorable"];
          sponsorsTier?: Maybe<_RefType["SponsorsTier"]>;
        })
      | (Omit<
          SponsorsListing,
          | "activeGoal"
          | "featuredItems"
          | "fiscalHost"
          | "sponsorable"
          | "tiers"
        > & {
          activeGoal?: Maybe<_RefType["SponsorsGoal"]>;
          featuredItems: Array<_RefType["SponsorsListingFeaturedItem"]>;
          fiscalHost?: Maybe<_RefType["Organization"]>;
          sponsorable: _RefType["Sponsorable"];
          tiers?: Maybe<_RefType["SponsorsTierConnection"]>;
        })
      | (Omit<
          SponsorsListingFeaturedItem,
          "featureable" | "sponsorsListing"
        > & {
          featureable: _RefType["SponsorsListingFeatureableItem"];
          sponsorsListing: _RefType["SponsorsListing"];
        })
      | (Omit<
          SponsorsTier,
          "adminInfo" | "closestLesserValueTier" | "sponsorsListing"
        > & {
          adminInfo?: Maybe<_RefType["SponsorsTierAdminInfo"]>;
          closestLesserValueTier?: Maybe<_RefType["SponsorsTier"]>;
          sponsorsListing: _RefType["SponsorsListing"];
        })
      | (Omit<
          Sponsorship,
          "maintainer" | "sponsor" | "sponsorEntity" | "sponsorable" | "tier"
        > & {
          maintainer: _RefType["User"];
          sponsor?: Maybe<_RefType["User"]>;
          sponsorEntity?: Maybe<_RefType["Sponsor"]>;
          sponsorable: _RefType["Sponsorable"];
          tier?: Maybe<_RefType["SponsorsTier"]>;
        })
      | (Omit<SponsorshipNewsletter, "author" | "sponsorable"> & {
          author?: Maybe<_RefType["User"]>;
          sponsorable: _RefType["Sponsorable"];
        })
      | (Omit<
          Status,
          "combinedContexts" | "commit" | "context" | "contexts"
        > & {
          combinedContexts: _RefType["StatusCheckRollupContextConnection"];
          commit?: Maybe<_RefType["Commit"]>;
          context?: Maybe<_RefType["StatusContext"]>;
          contexts: Array<_RefType["StatusContext"]>;
        })
      | (Omit<StatusCheckRollup, "commit" | "contexts"> & {
          commit?: Maybe<_RefType["Commit"]>;
          contexts: _RefType["StatusCheckRollupContextConnection"];
        })
      | (Omit<StatusContext, "commit" | "creator"> & {
          commit?: Maybe<_RefType["Commit"]>;
          creator?: Maybe<_RefType["Actor"]>;
        })
      | (Omit<SubscribedEvent, "actor" | "subscribable"> & {
          actor?: Maybe<_RefType["Actor"]>;
          subscribable: _RefType["Subscribable"];
        })
      | (Omit<Tag, "repository" | "target"> & {
          repository: _RefType["Repository"];
          target: _RefType["GitObject"];
        })
      | (Omit<
          Team,
          | "ancestors"
          | "childTeams"
          | "discussion"
          | "discussions"
          | "invitations"
          | "memberStatuses"
          | "organization"
          | "parentTeam"
          | "projectV2"
          | "projectsV2"
          | "repositories"
        > & {
          ancestors: _RefType["TeamConnection"];
          childTeams: _RefType["TeamConnection"];
          discussion?: Maybe<_RefType["TeamDiscussion"]>;
          discussions: _RefType["TeamDiscussionConnection"];
          invitations?: Maybe<_RefType["OrganizationInvitationConnection"]>;
          memberStatuses: _RefType["UserStatusConnection"];
          organization: _RefType["Organization"];
          parentTeam?: Maybe<_RefType["Team"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          repositories: _RefType["TeamRepositoryConnection"];
        })
      | (Omit<
          TeamAddMemberAuditEntry,
          "actor" | "organization" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamAddRepositoryAuditEntry,
          "actor" | "organization" | "repository" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamChangeParentTeamAuditEntry,
          | "actor"
          | "organization"
          | "parentTeam"
          | "parentTeamWas"
          | "team"
          | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          parentTeam?: Maybe<_RefType["Team"]>;
          parentTeamWas?: Maybe<_RefType["Team"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamDiscussion,
          | "author"
          | "comments"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "team"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["TeamDiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          team: _RefType["Team"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          TeamDiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion: _RefType["TeamDiscussion"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          TeamRemoveMemberAuditEntry,
          "actor" | "organization" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamRemoveRepositoryAuditEntry,
          "actor" | "organization" | "repository" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<Topic, "relatedTopics" | "repositories"> & {
          relatedTopics: Array<_RefType["Topic"]>;
          repositories: _RefType["RepositoryConnection"];
        })
      | (Omit<TransferredEvent, "actor" | "fromRepository" | "issue"> & {
          actor?: Maybe<_RefType["Actor"]>;
          fromRepository?: Maybe<_RefType["Repository"]>;
          issue: _RefType["Issue"];
        })
      | (Omit<Tree, "entries" | "repository"> & {
          entries?: Maybe<Array<_RefType["TreeEntry"]>>;
          repository: _RefType["Repository"];
        })
      | (Omit<UnassignedEvent, "actor" | "assignable" | "assignee" | "user"> & {
          actor?: Maybe<_RefType["Actor"]>;
          assignable: _RefType["Assignable"];
          assignee?: Maybe<_RefType["Assignee"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<UnlabeledEvent, "actor" | "label" | "labelable"> & {
          actor?: Maybe<_RefType["Actor"]>;
          label: _RefType["Label"];
          labelable: _RefType["Labelable"];
        })
      | (Omit<UnlockedEvent, "actor" | "lockable"> & {
          actor?: Maybe<_RefType["Actor"]>;
          lockable: _RefType["Lockable"];
        })
      | (Omit<UnmarkedAsDuplicateEvent, "actor" | "canonical" | "duplicate"> & {
          actor?: Maybe<_RefType["Actor"]>;
          canonical?: Maybe<_RefType["IssueOrPullRequest"]>;
          duplicate?: Maybe<_RefType["IssueOrPullRequest"]>;
        })
      | (Omit<UnpinnedEvent, "actor" | "issue"> & {
          actor?: Maybe<_RefType["Actor"]>;
          issue: _RefType["Issue"];
        })
      | (Omit<UnsubscribedEvent, "actor" | "subscribable"> & {
          actor?: Maybe<_RefType["Actor"]>;
          subscribable: _RefType["Subscribable"];
        })
      | (Omit<
          User,
          | "commitComments"
          | "contributionsCollection"
          | "enterprises"
          | "followers"
          | "following"
          | "gist"
          | "gistComments"
          | "gists"
          | "hovercard"
          | "issueComments"
          | "issues"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "lists"
          | "organization"
          | "organizations"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequests"
          | "recentProjects"
          | "repositories"
          | "repositoriesContributedTo"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "savedReplies"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "starredRepositories"
          | "status"
          | "topRepositories"
          | "watching"
        > & {
          commitComments: _RefType["CommitCommentConnection"];
          contributionsCollection: _RefType["ContributionsCollection"];
          enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
          followers: _RefType["FollowerConnection"];
          following: _RefType["FollowingConnection"];
          gist?: Maybe<_RefType["Gist"]>;
          gistComments: _RefType["GistCommentConnection"];
          gists: _RefType["GistConnection"];
          hovercard: _RefType["Hovercard"];
          issueComments: _RefType["IssueCommentConnection"];
          issues: _RefType["IssueConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          lists: _RefType["UserListConnection"];
          organization?: Maybe<_RefType["Organization"]>;
          organizations: _RefType["OrganizationConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repositoriesContributedTo: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          starredRepositories: _RefType["StarredRepositoryConnection"];
          status?: Maybe<_RefType["UserStatus"]>;
          topRepositories: _RefType["RepositoryConnection"];
          watching: _RefType["RepositoryConnection"];
        })
      | (Omit<UserBlockedEvent, "actor" | "subject"> & {
          actor?: Maybe<_RefType["Actor"]>;
          subject?: Maybe<_RefType["User"]>;
        })
      | (Omit<UserContentEdit, "deletedBy" | "editor"> & {
          deletedBy?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
        })
      | (Omit<UserList, "items" | "user"> & {
          items: _RefType["UserListItemsConnection"];
          user: _RefType["User"];
        })
      | (Omit<UserStatus, "organization" | "user"> & {
          organization?: Maybe<_RefType["Organization"]>;
          user: _RefType["User"];
        })
      | (Omit<VerifiableDomain, "owner"> & {
          owner: _RefType["VerifiableDomainOwner"];
        })
      | (Omit<Workflow, "runs"> & { runs: _RefType["WorkflowRunConnection"] })
      | (Omit<
          WorkflowRun,
          | "checkSuite"
          | "deploymentReviews"
          | "file"
          | "pendingDeploymentRequests"
          | "workflow"
        > & {
          checkSuite: _RefType["CheckSuite"];
          deploymentReviews: _RefType["DeploymentReviewConnection"];
          file?: Maybe<_RefType["WorkflowRunFile"]>;
          pendingDeploymentRequests: _RefType["DeploymentRequestConnection"];
          workflow: _RefType["Workflow"];
        })
      | (Omit<WorkflowRunFile, "run"> & { run: _RefType["WorkflowRun"] });
    OauthApplicationAuditEntryData:
      | (Omit<
          OauthApplicationCreateAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessApprovedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessBlockedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessDeniedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessRequestedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessUnblockedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        });
    OrganizationAuditEntryData:
      | (Omit<
          MembersCanDeleteReposClearAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          MembersCanDeleteReposDisableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          MembersCanDeleteReposEnableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OauthApplicationCreateAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgAddBillingManagerAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgAddMemberAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgBlockUserAuditEntry,
          "actor" | "blockedUser" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          blockedUser?: Maybe<_RefType["User"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgConfigDisableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgConfigEnableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgCreateAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgDisableOauthAppRestrictionsAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgDisableSamlAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgDisableTwoFactorRequirementAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgEnableOauthAppRestrictionsAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgEnableSamlAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgEnableTwoFactorRequirementAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgInviteMemberAuditEntry,
          "actor" | "organization" | "organizationInvitation" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          organizationInvitation?: Maybe<_RefType["OrganizationInvitation"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgInviteToBusinessAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessApprovedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessBlockedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessDeniedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessRequestedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgOauthAppAccessUnblockedAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgRemoveBillingManagerAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgRemoveMemberAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgRemoveOutsideCollaboratorAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgRestoreMemberAuditEntry,
          "actor" | "organization" | "restoredMemberships" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          restoredMemberships?: Maybe<
            Array<_RefType["OrgRestoreMemberAuditEntryMembership"]>
          >;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgRestoreMemberMembershipOrganizationAuditEntryData,
          "organization"
        > & { organization?: Maybe<_RefType["Organization"]> })
      | (Omit<
          OrgUnblockUserAuditEntry,
          "actor" | "blockedUser" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          blockedUser?: Maybe<_RefType["User"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgUpdateDefaultRepositoryPermissionAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<OrgUpdateMemberAuditEntry, "actor" | "organization" | "user"> & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgUpdateMemberRepositoryCreationPermissionAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          OrgUpdateMemberRepositoryInvitationPermissionAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          PrivateRepositoryForkingDisableAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          PrivateRepositoryForkingEnableAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoAddMemberAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoAddTopicAuditEntry,
          "actor" | "organization" | "repository" | "topic" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          topic?: Maybe<_RefType["Topic"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoArchivedAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoChangeMergeSettingAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableContributorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableSockpuppetDisallowedAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableContributorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableSockpuppetDisallowedAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigLockAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigUnlockAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoCreateAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoDestroyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoRemoveMemberAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoRemoveTopicAuditEntry,
          "actor" | "organization" | "repository" | "topic" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          topic?: Maybe<_RefType["Topic"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepositoryVisibilityChangeDisableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepositoryVisibilityChangeEnableAuditEntry,
          "actor" | "organization" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamAddMemberAuditEntry,
          "actor" | "organization" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamAddRepositoryAuditEntry,
          "actor" | "organization" | "repository" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamChangeParentTeamAuditEntry,
          | "actor"
          | "organization"
          | "parentTeam"
          | "parentTeamWas"
          | "team"
          | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          parentTeam?: Maybe<_RefType["Team"]>;
          parentTeamWas?: Maybe<_RefType["Team"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamRemoveMemberAuditEntry,
          "actor" | "organization" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamRemoveRepositoryAuditEntry,
          "actor" | "organization" | "repository" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        });
    PackageOwner:
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          Repository,
          | "branchProtectionRules"
          | "collaborators"
          | "commitComments"
          | "defaultBranchRef"
          | "dependencyGraphManifests"
          | "deployments"
          | "discussion"
          | "discussionCategories"
          | "discussionCategory"
          | "discussions"
          | "environment"
          | "environments"
          | "forks"
          | "issue"
          | "issueOrPullRequest"
          | "issueTemplates"
          | "issues"
          | "label"
          | "labels"
          | "latestRelease"
          | "mergeQueue"
          | "milestone"
          | "milestones"
          | "object"
          | "owner"
          | "packages"
          | "parent"
          | "pinnedDiscussions"
          | "pinnedEnvironments"
          | "pinnedIssues"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequest"
          | "pullRequestTemplates"
          | "pullRequests"
          | "recentProjects"
          | "ref"
          | "release"
          | "releases"
          | "repositoryTopics"
          | "ruleset"
          | "rulesets"
          | "templateRepository"
          | "vulnerabilityAlert"
          | "vulnerabilityAlerts"
        > & {
          branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
          collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
          commitComments: _RefType["CommitCommentConnection"];
          defaultBranchRef?: Maybe<_RefType["Ref"]>;
          dependencyGraphManifests?: Maybe<
            _RefType["DependencyGraphManifestConnection"]
          >;
          deployments: _RefType["DeploymentConnection"];
          discussion?: Maybe<_RefType["Discussion"]>;
          discussionCategories: _RefType["DiscussionCategoryConnection"];
          discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
          discussions: _RefType["DiscussionConnection"];
          environment?: Maybe<_RefType["Environment"]>;
          environments: _RefType["EnvironmentConnection"];
          forks: _RefType["RepositoryConnection"];
          issue?: Maybe<_RefType["Issue"]>;
          issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
          issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
          issues: _RefType["IssueConnection"];
          label?: Maybe<_RefType["Label"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestRelease?: Maybe<_RefType["Release"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          milestones?: Maybe<_RefType["MilestoneConnection"]>;
          object?: Maybe<_RefType["GitObject"]>;
          owner: _RefType["RepositoryOwner"];
          packages: _RefType["PackageConnection"];
          parent?: Maybe<_RefType["Repository"]>;
          pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
          pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
          pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          ref?: Maybe<_RefType["Ref"]>;
          release?: Maybe<_RefType["Release"]>;
          releases: _RefType["ReleaseConnection"];
          repositoryTopics: _RefType["RepositoryTopicConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          templateRepository?: Maybe<_RefType["Repository"]>;
          vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
          vulnerabilityAlerts?: Maybe<
            _RefType["RepositoryVulnerabilityAlertConnection"]
          >;
        })
      | (Omit<
          User,
          | "commitComments"
          | "contributionsCollection"
          | "enterprises"
          | "followers"
          | "following"
          | "gist"
          | "gistComments"
          | "gists"
          | "hovercard"
          | "issueComments"
          | "issues"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "lists"
          | "organization"
          | "organizations"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequests"
          | "recentProjects"
          | "repositories"
          | "repositoriesContributedTo"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "savedReplies"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "starredRepositories"
          | "status"
          | "topRepositories"
          | "watching"
        > & {
          commitComments: _RefType["CommitCommentConnection"];
          contributionsCollection: _RefType["ContributionsCollection"];
          enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
          followers: _RefType["FollowerConnection"];
          following: _RefType["FollowingConnection"];
          gist?: Maybe<_RefType["Gist"]>;
          gistComments: _RefType["GistCommentConnection"];
          gists: _RefType["GistConnection"];
          hovercard: _RefType["Hovercard"];
          issueComments: _RefType["IssueCommentConnection"];
          issues: _RefType["IssueConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          lists: _RefType["UserListConnection"];
          organization?: Maybe<_RefType["Organization"]>;
          organizations: _RefType["OrganizationConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repositoriesContributedTo: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          starredRepositories: _RefType["StarredRepositoryConnection"];
          status?: Maybe<_RefType["UserStatus"]>;
          topRepositories: _RefType["RepositoryConnection"];
          watching: _RefType["RepositoryConnection"];
        });
    ProfileOwner:
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          User,
          | "commitComments"
          | "contributionsCollection"
          | "enterprises"
          | "followers"
          | "following"
          | "gist"
          | "gistComments"
          | "gists"
          | "hovercard"
          | "issueComments"
          | "issues"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "lists"
          | "organization"
          | "organizations"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequests"
          | "recentProjects"
          | "repositories"
          | "repositoriesContributedTo"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "savedReplies"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "starredRepositories"
          | "status"
          | "topRepositories"
          | "watching"
        > & {
          commitComments: _RefType["CommitCommentConnection"];
          contributionsCollection: _RefType["ContributionsCollection"];
          enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
          followers: _RefType["FollowerConnection"];
          following: _RefType["FollowingConnection"];
          gist?: Maybe<_RefType["Gist"]>;
          gistComments: _RefType["GistCommentConnection"];
          gists: _RefType["GistConnection"];
          hovercard: _RefType["Hovercard"];
          issueComments: _RefType["IssueCommentConnection"];
          issues: _RefType["IssueConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          lists: _RefType["UserListConnection"];
          organization?: Maybe<_RefType["Organization"]>;
          organizations: _RefType["OrganizationConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repositoriesContributedTo: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          starredRepositories: _RefType["StarredRepositoryConnection"];
          status?: Maybe<_RefType["UserStatus"]>;
          topRepositories: _RefType["RepositoryConnection"];
          watching: _RefType["RepositoryConnection"];
        });
    ProjectOwner:
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          Repository,
          | "branchProtectionRules"
          | "collaborators"
          | "commitComments"
          | "defaultBranchRef"
          | "dependencyGraphManifests"
          | "deployments"
          | "discussion"
          | "discussionCategories"
          | "discussionCategory"
          | "discussions"
          | "environment"
          | "environments"
          | "forks"
          | "issue"
          | "issueOrPullRequest"
          | "issueTemplates"
          | "issues"
          | "label"
          | "labels"
          | "latestRelease"
          | "mergeQueue"
          | "milestone"
          | "milestones"
          | "object"
          | "owner"
          | "packages"
          | "parent"
          | "pinnedDiscussions"
          | "pinnedEnvironments"
          | "pinnedIssues"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequest"
          | "pullRequestTemplates"
          | "pullRequests"
          | "recentProjects"
          | "ref"
          | "release"
          | "releases"
          | "repositoryTopics"
          | "ruleset"
          | "rulesets"
          | "templateRepository"
          | "vulnerabilityAlert"
          | "vulnerabilityAlerts"
        > & {
          branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
          collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
          commitComments: _RefType["CommitCommentConnection"];
          defaultBranchRef?: Maybe<_RefType["Ref"]>;
          dependencyGraphManifests?: Maybe<
            _RefType["DependencyGraphManifestConnection"]
          >;
          deployments: _RefType["DeploymentConnection"];
          discussion?: Maybe<_RefType["Discussion"]>;
          discussionCategories: _RefType["DiscussionCategoryConnection"];
          discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
          discussions: _RefType["DiscussionConnection"];
          environment?: Maybe<_RefType["Environment"]>;
          environments: _RefType["EnvironmentConnection"];
          forks: _RefType["RepositoryConnection"];
          issue?: Maybe<_RefType["Issue"]>;
          issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
          issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
          issues: _RefType["IssueConnection"];
          label?: Maybe<_RefType["Label"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestRelease?: Maybe<_RefType["Release"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          milestones?: Maybe<_RefType["MilestoneConnection"]>;
          object?: Maybe<_RefType["GitObject"]>;
          owner: _RefType["RepositoryOwner"];
          packages: _RefType["PackageConnection"];
          parent?: Maybe<_RefType["Repository"]>;
          pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
          pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
          pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          ref?: Maybe<_RefType["Ref"]>;
          release?: Maybe<_RefType["Release"]>;
          releases: _RefType["ReleaseConnection"];
          repositoryTopics: _RefType["RepositoryTopicConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          templateRepository?: Maybe<_RefType["Repository"]>;
          vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
          vulnerabilityAlerts?: Maybe<
            _RefType["RepositoryVulnerabilityAlertConnection"]
          >;
        })
      | (Omit<
          User,
          | "commitComments"
          | "contributionsCollection"
          | "enterprises"
          | "followers"
          | "following"
          | "gist"
          | "gistComments"
          | "gists"
          | "hovercard"
          | "issueComments"
          | "issues"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "lists"
          | "organization"
          | "organizations"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequests"
          | "recentProjects"
          | "repositories"
          | "repositoriesContributedTo"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "savedReplies"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "starredRepositories"
          | "status"
          | "topRepositories"
          | "watching"
        > & {
          commitComments: _RefType["CommitCommentConnection"];
          contributionsCollection: _RefType["ContributionsCollection"];
          enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
          followers: _RefType["FollowerConnection"];
          following: _RefType["FollowingConnection"];
          gist?: Maybe<_RefType["Gist"]>;
          gistComments: _RefType["GistCommentConnection"];
          gists: _RefType["GistConnection"];
          hovercard: _RefType["Hovercard"];
          issueComments: _RefType["IssueCommentConnection"];
          issues: _RefType["IssueConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          lists: _RefType["UserListConnection"];
          organization?: Maybe<_RefType["Organization"]>;
          organizations: _RefType["OrganizationConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repositoriesContributedTo: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          starredRepositories: _RefType["StarredRepositoryConnection"];
          status?: Maybe<_RefType["UserStatus"]>;
          topRepositories: _RefType["RepositoryConnection"];
          watching: _RefType["RepositoryConnection"];
        });
    ProjectV2FieldCommon:
      | (Omit<ProjectV2Field, "project"> & { project: _RefType["ProjectV2"] })
      | (Omit<ProjectV2IterationField, "project"> & {
          project: _RefType["ProjectV2"];
        })
      | (Omit<ProjectV2SingleSelectField, "project"> & {
          project: _RefType["ProjectV2"];
        });
    ProjectV2ItemFieldValueCommon:
      | (Omit<ProjectV2ItemFieldDateValue, "creator" | "field" | "item"> & {
          creator?: Maybe<_RefType["Actor"]>;
          field: _RefType["ProjectV2FieldConfiguration"];
          item: _RefType["ProjectV2Item"];
        })
      | (Omit<
          ProjectV2ItemFieldIterationValue,
          "creator" | "field" | "item"
        > & {
          creator?: Maybe<_RefType["Actor"]>;
          field: _RefType["ProjectV2FieldConfiguration"];
          item: _RefType["ProjectV2Item"];
        })
      | (Omit<ProjectV2ItemFieldNumberValue, "creator" | "field" | "item"> & {
          creator?: Maybe<_RefType["Actor"]>;
          field: _RefType["ProjectV2FieldConfiguration"];
          item: _RefType["ProjectV2Item"];
        })
      | (Omit<
          ProjectV2ItemFieldSingleSelectValue,
          "creator" | "field" | "item"
        > & {
          creator?: Maybe<_RefType["Actor"]>;
          field: _RefType["ProjectV2FieldConfiguration"];
          item: _RefType["ProjectV2Item"];
        })
      | (Omit<ProjectV2ItemFieldTextValue, "creator" | "field" | "item"> & {
          creator?: Maybe<_RefType["Actor"]>;
          field: _RefType["ProjectV2FieldConfiguration"];
          item: _RefType["ProjectV2Item"];
        });
    ProjectV2Owner:
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        })
      | (Omit<
          User,
          | "commitComments"
          | "contributionsCollection"
          | "enterprises"
          | "followers"
          | "following"
          | "gist"
          | "gistComments"
          | "gists"
          | "hovercard"
          | "issueComments"
          | "issues"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "lists"
          | "organization"
          | "organizations"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequests"
          | "recentProjects"
          | "repositories"
          | "repositoriesContributedTo"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "savedReplies"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "starredRepositories"
          | "status"
          | "topRepositories"
          | "watching"
        > & {
          commitComments: _RefType["CommitCommentConnection"];
          contributionsCollection: _RefType["ContributionsCollection"];
          enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
          followers: _RefType["FollowerConnection"];
          following: _RefType["FollowingConnection"];
          gist?: Maybe<_RefType["Gist"]>;
          gistComments: _RefType["GistCommentConnection"];
          gists: _RefType["GistConnection"];
          hovercard: _RefType["Hovercard"];
          issueComments: _RefType["IssueCommentConnection"];
          issues: _RefType["IssueConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          lists: _RefType["UserListConnection"];
          organization?: Maybe<_RefType["Organization"]>;
          organizations: _RefType["OrganizationConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repositoriesContributedTo: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          starredRepositories: _RefType["StarredRepositoryConnection"];
          status?: Maybe<_RefType["UserStatus"]>;
          topRepositories: _RefType["RepositoryConnection"];
          watching: _RefType["RepositoryConnection"];
        });
    ProjectV2Recent:
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          Repository,
          | "branchProtectionRules"
          | "collaborators"
          | "commitComments"
          | "defaultBranchRef"
          | "dependencyGraphManifests"
          | "deployments"
          | "discussion"
          | "discussionCategories"
          | "discussionCategory"
          | "discussions"
          | "environment"
          | "environments"
          | "forks"
          | "issue"
          | "issueOrPullRequest"
          | "issueTemplates"
          | "issues"
          | "label"
          | "labels"
          | "latestRelease"
          | "mergeQueue"
          | "milestone"
          | "milestones"
          | "object"
          | "owner"
          | "packages"
          | "parent"
          | "pinnedDiscussions"
          | "pinnedEnvironments"
          | "pinnedIssues"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequest"
          | "pullRequestTemplates"
          | "pullRequests"
          | "recentProjects"
          | "ref"
          | "release"
          | "releases"
          | "repositoryTopics"
          | "ruleset"
          | "rulesets"
          | "templateRepository"
          | "vulnerabilityAlert"
          | "vulnerabilityAlerts"
        > & {
          branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
          collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
          commitComments: _RefType["CommitCommentConnection"];
          defaultBranchRef?: Maybe<_RefType["Ref"]>;
          dependencyGraphManifests?: Maybe<
            _RefType["DependencyGraphManifestConnection"]
          >;
          deployments: _RefType["DeploymentConnection"];
          discussion?: Maybe<_RefType["Discussion"]>;
          discussionCategories: _RefType["DiscussionCategoryConnection"];
          discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
          discussions: _RefType["DiscussionConnection"];
          environment?: Maybe<_RefType["Environment"]>;
          environments: _RefType["EnvironmentConnection"];
          forks: _RefType["RepositoryConnection"];
          issue?: Maybe<_RefType["Issue"]>;
          issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
          issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
          issues: _RefType["IssueConnection"];
          label?: Maybe<_RefType["Label"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestRelease?: Maybe<_RefType["Release"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          milestones?: Maybe<_RefType["MilestoneConnection"]>;
          object?: Maybe<_RefType["GitObject"]>;
          owner: _RefType["RepositoryOwner"];
          packages: _RefType["PackageConnection"];
          parent?: Maybe<_RefType["Repository"]>;
          pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
          pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
          pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          ref?: Maybe<_RefType["Ref"]>;
          release?: Maybe<_RefType["Release"]>;
          releases: _RefType["ReleaseConnection"];
          repositoryTopics: _RefType["RepositoryTopicConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          templateRepository?: Maybe<_RefType["Repository"]>;
          vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
          vulnerabilityAlerts?: Maybe<
            _RefType["RepositoryVulnerabilityAlertConnection"]
          >;
        })
      | (Omit<
          User,
          | "commitComments"
          | "contributionsCollection"
          | "enterprises"
          | "followers"
          | "following"
          | "gist"
          | "gistComments"
          | "gists"
          | "hovercard"
          | "issueComments"
          | "issues"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "lists"
          | "organization"
          | "organizations"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequests"
          | "recentProjects"
          | "repositories"
          | "repositoriesContributedTo"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "savedReplies"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "starredRepositories"
          | "status"
          | "topRepositories"
          | "watching"
        > & {
          commitComments: _RefType["CommitCommentConnection"];
          contributionsCollection: _RefType["ContributionsCollection"];
          enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
          followers: _RefType["FollowerConnection"];
          following: _RefType["FollowingConnection"];
          gist?: Maybe<_RefType["Gist"]>;
          gistComments: _RefType["GistCommentConnection"];
          gists: _RefType["GistConnection"];
          hovercard: _RefType["Hovercard"];
          issueComments: _RefType["IssueCommentConnection"];
          issues: _RefType["IssueConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          lists: _RefType["UserListConnection"];
          organization?: Maybe<_RefType["Organization"]>;
          organizations: _RefType["OrganizationConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repositoriesContributedTo: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          starredRepositories: _RefType["StarredRepositoryConnection"];
          status?: Maybe<_RefType["UserStatus"]>;
          topRepositories: _RefType["RepositoryConnection"];
          watching: _RefType["RepositoryConnection"];
        });
    Reactable:
      | (Omit<
          CommitComment,
          | "author"
          | "commit"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Discussion,
          | "answer"
          | "answerChosenBy"
          | "author"
          | "category"
          | "comments"
          | "editor"
          | "labels"
          | "poll"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          answer?: Maybe<_RefType["DiscussionComment"]>;
          answerChosenBy?: Maybe<_RefType["Actor"]>;
          author?: Maybe<_RefType["Actor"]>;
          category: _RefType["DiscussionCategory"];
          comments: _RefType["DiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          poll?: Maybe<_RefType["DiscussionPoll"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          DiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "replies"
          | "replyTo"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion?: Maybe<_RefType["Discussion"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replies: _RefType["DiscussionCommentConnection"];
          replyTo?: Maybe<_RefType["DiscussionComment"]>;
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          IssueComment,
          | "author"
          | "editor"
          | "issue"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          issue: _RefType["Issue"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        })
      | (Omit<
          PullRequestReview,
          | "author"
          | "comments"
          | "commit"
          | "editor"
          | "onBehalfOf"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["PullRequestReviewCommentConnection"];
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          onBehalfOf: _RefType["TeamConnection"];
          pullRequest: _RefType["PullRequest"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequestReviewComment,
          | "author"
          | "commit"
          | "editor"
          | "originalCommit"
          | "pullRequest"
          | "pullRequestReview"
          | "reactionGroups"
          | "reactions"
          | "replyTo"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          originalCommit?: Maybe<_RefType["Commit"]>;
          pullRequest: _RefType["PullRequest"];
          pullRequestReview?: Maybe<_RefType["PullRequestReview"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replyTo?: Maybe<_RefType["PullRequestReviewComment"]>;
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Release,
          | "author"
          | "reactionGroups"
          | "reactions"
          | "releaseAssets"
          | "repository"
          | "tag"
          | "tagCommit"
        > & {
          author?: Maybe<_RefType["User"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          releaseAssets: _RefType["ReleaseAssetConnection"];
          repository: _RefType["Repository"];
          tag?: Maybe<_RefType["Ref"]>;
          tagCommit?: Maybe<_RefType["Commit"]>;
        })
      | (Omit<
          TeamDiscussion,
          | "author"
          | "comments"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "team"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["TeamDiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          team: _RefType["Team"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          TeamDiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion: _RefType["TeamDiscussion"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        });
    RepositoryAuditEntryData:
      | (Omit<
          OrgRestoreMemberMembershipRepositoryAuditEntryData,
          "repository"
        > & { repository?: Maybe<_RefType["Repository"]> })
      | (Omit<
          PrivateRepositoryForkingDisableAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          PrivateRepositoryForkingEnableAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoAddMemberAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoAddTopicAuditEntry,
          "actor" | "organization" | "repository" | "topic" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          topic?: Maybe<_RefType["Topic"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoArchivedAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoChangeMergeSettingAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableContributorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigDisableSockpuppetDisallowedAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableCollaboratorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableContributorsOnlyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigEnableSockpuppetDisallowedAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigLockAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoConfigUnlockAnonymousGitAccessAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoCreateAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoDestroyAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoRemoveMemberAuditEntry,
          "actor" | "organization" | "repository" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoRemoveTopicAuditEntry,
          "actor" | "organization" | "repository" | "topic" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          topic?: Maybe<_RefType["Topic"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamAddRepositoryAuditEntry,
          "actor" | "organization" | "repository" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamRemoveRepositoryAuditEntry,
          "actor" | "organization" | "repository" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        });
    RepositoryDiscussionAuthor:
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          User,
          | "commitComments"
          | "contributionsCollection"
          | "enterprises"
          | "followers"
          | "following"
          | "gist"
          | "gistComments"
          | "gists"
          | "hovercard"
          | "issueComments"
          | "issues"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "lists"
          | "organization"
          | "organizations"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequests"
          | "recentProjects"
          | "repositories"
          | "repositoriesContributedTo"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "savedReplies"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "starredRepositories"
          | "status"
          | "topRepositories"
          | "watching"
        > & {
          commitComments: _RefType["CommitCommentConnection"];
          contributionsCollection: _RefType["ContributionsCollection"];
          enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
          followers: _RefType["FollowerConnection"];
          following: _RefType["FollowingConnection"];
          gist?: Maybe<_RefType["Gist"]>;
          gistComments: _RefType["GistCommentConnection"];
          gists: _RefType["GistConnection"];
          hovercard: _RefType["Hovercard"];
          issueComments: _RefType["IssueCommentConnection"];
          issues: _RefType["IssueConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          lists: _RefType["UserListConnection"];
          organization?: Maybe<_RefType["Organization"]>;
          organizations: _RefType["OrganizationConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repositoriesContributedTo: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          starredRepositories: _RefType["StarredRepositoryConnection"];
          status?: Maybe<_RefType["UserStatus"]>;
          topRepositories: _RefType["RepositoryConnection"];
          watching: _RefType["RepositoryConnection"];
        });
    RepositoryDiscussionCommentAuthor:
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          User,
          | "commitComments"
          | "contributionsCollection"
          | "enterprises"
          | "followers"
          | "following"
          | "gist"
          | "gistComments"
          | "gists"
          | "hovercard"
          | "issueComments"
          | "issues"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "lists"
          | "organization"
          | "organizations"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequests"
          | "recentProjects"
          | "repositories"
          | "repositoriesContributedTo"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "savedReplies"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "starredRepositories"
          | "status"
          | "topRepositories"
          | "watching"
        > & {
          commitComments: _RefType["CommitCommentConnection"];
          contributionsCollection: _RefType["ContributionsCollection"];
          enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
          followers: _RefType["FollowerConnection"];
          following: _RefType["FollowingConnection"];
          gist?: Maybe<_RefType["Gist"]>;
          gistComments: _RefType["GistCommentConnection"];
          gists: _RefType["GistConnection"];
          hovercard: _RefType["Hovercard"];
          issueComments: _RefType["IssueCommentConnection"];
          issues: _RefType["IssueConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          lists: _RefType["UserListConnection"];
          organization?: Maybe<_RefType["Organization"]>;
          organizations: _RefType["OrganizationConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repositoriesContributedTo: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          starredRepositories: _RefType["StarredRepositoryConnection"];
          status?: Maybe<_RefType["UserStatus"]>;
          topRepositories: _RefType["RepositoryConnection"];
          watching: _RefType["RepositoryConnection"];
        });
    RepositoryInfo: Omit<
      Repository,
      | "branchProtectionRules"
      | "collaborators"
      | "commitComments"
      | "defaultBranchRef"
      | "dependencyGraphManifests"
      | "deployments"
      | "discussion"
      | "discussionCategories"
      | "discussionCategory"
      | "discussions"
      | "environment"
      | "environments"
      | "forks"
      | "issue"
      | "issueOrPullRequest"
      | "issueTemplates"
      | "issues"
      | "label"
      | "labels"
      | "latestRelease"
      | "mergeQueue"
      | "milestone"
      | "milestones"
      | "object"
      | "owner"
      | "packages"
      | "parent"
      | "pinnedDiscussions"
      | "pinnedEnvironments"
      | "pinnedIssues"
      | "project"
      | "projectV2"
      | "projects"
      | "projectsV2"
      | "pullRequest"
      | "pullRequestTemplates"
      | "pullRequests"
      | "recentProjects"
      | "ref"
      | "release"
      | "releases"
      | "repositoryTopics"
      | "ruleset"
      | "rulesets"
      | "templateRepository"
      | "vulnerabilityAlert"
      | "vulnerabilityAlerts"
    > & {
      branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
      collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
      commitComments: _RefType["CommitCommentConnection"];
      defaultBranchRef?: Maybe<_RefType["Ref"]>;
      dependencyGraphManifests?: Maybe<
        _RefType["DependencyGraphManifestConnection"]
      >;
      deployments: _RefType["DeploymentConnection"];
      discussion?: Maybe<_RefType["Discussion"]>;
      discussionCategories: _RefType["DiscussionCategoryConnection"];
      discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
      discussions: _RefType["DiscussionConnection"];
      environment?: Maybe<_RefType["Environment"]>;
      environments: _RefType["EnvironmentConnection"];
      forks: _RefType["RepositoryConnection"];
      issue?: Maybe<_RefType["Issue"]>;
      issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
      issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
      issues: _RefType["IssueConnection"];
      label?: Maybe<_RefType["Label"]>;
      labels?: Maybe<_RefType["LabelConnection"]>;
      latestRelease?: Maybe<_RefType["Release"]>;
      mergeQueue?: Maybe<_RefType["MergeQueue"]>;
      milestone?: Maybe<_RefType["Milestone"]>;
      milestones?: Maybe<_RefType["MilestoneConnection"]>;
      object?: Maybe<_RefType["GitObject"]>;
      owner: _RefType["RepositoryOwner"];
      packages: _RefType["PackageConnection"];
      parent?: Maybe<_RefType["Repository"]>;
      pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
      pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
      pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
      project?: Maybe<_RefType["Project"]>;
      projectV2?: Maybe<_RefType["ProjectV2"]>;
      projects: _RefType["ProjectConnection"];
      projectsV2: _RefType["ProjectV2Connection"];
      pullRequest?: Maybe<_RefType["PullRequest"]>;
      pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
      pullRequests: _RefType["PullRequestConnection"];
      recentProjects: _RefType["ProjectV2Connection"];
      ref?: Maybe<_RefType["Ref"]>;
      release?: Maybe<_RefType["Release"]>;
      releases: _RefType["ReleaseConnection"];
      repositoryTopics: _RefType["RepositoryTopicConnection"];
      ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
      rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
      templateRepository?: Maybe<_RefType["Repository"]>;
      vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
      vulnerabilityAlerts?: Maybe<
        _RefType["RepositoryVulnerabilityAlertConnection"]
      >;
    };
    RepositoryNode:
      | (Omit<
          CommitComment,
          | "author"
          | "commit"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<CommitCommentThread, "comments" | "commit" | "repository"> & {
          comments: _RefType["CommitCommentConnection"];
          commit?: Maybe<_RefType["Commit"]>;
          repository: _RefType["Repository"];
        })
      | (Omit<DependabotUpdate, "error" | "pullRequest" | "repository"> & {
          error?: Maybe<_RefType["DependabotUpdateError"]>;
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          repository: _RefType["Repository"];
        })
      | (Omit<
          Discussion,
          | "answer"
          | "answerChosenBy"
          | "author"
          | "category"
          | "comments"
          | "editor"
          | "labels"
          | "poll"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          answer?: Maybe<_RefType["DiscussionComment"]>;
          answerChosenBy?: Maybe<_RefType["Actor"]>;
          author?: Maybe<_RefType["Actor"]>;
          category: _RefType["DiscussionCategory"];
          comments: _RefType["DiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          poll?: Maybe<_RefType["DiscussionPoll"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<DiscussionCategory, "repository"> & {
          repository: _RefType["Repository"];
        })
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          IssueComment,
          | "author"
          | "editor"
          | "issue"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          issue: _RefType["Issue"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<PinnedDiscussion, "discussion" | "pinnedBy" | "repository"> & {
          discussion: _RefType["Discussion"];
          pinnedBy: _RefType["Actor"];
          repository: _RefType["Repository"];
        })
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        })
      | (Omit<
          PullRequestCommitCommentThread,
          "comments" | "commit" | "pullRequest" | "repository"
        > & {
          comments: _RefType["CommitCommentConnection"];
          commit: _RefType["Commit"];
          pullRequest: _RefType["PullRequest"];
          repository: _RefType["Repository"];
        })
      | (Omit<
          PullRequestReview,
          | "author"
          | "comments"
          | "commit"
          | "editor"
          | "onBehalfOf"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["PullRequestReviewCommentConnection"];
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          onBehalfOf: _RefType["TeamConnection"];
          pullRequest: _RefType["PullRequest"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequestReviewComment,
          | "author"
          | "commit"
          | "editor"
          | "originalCommit"
          | "pullRequest"
          | "pullRequestReview"
          | "reactionGroups"
          | "reactions"
          | "replyTo"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          originalCommit?: Maybe<_RefType["Commit"]>;
          pullRequest: _RefType["PullRequest"];
          pullRequestReview?: Maybe<_RefType["PullRequestReview"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replyTo?: Maybe<_RefType["PullRequestReviewComment"]>;
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          RepositoryVulnerabilityAlert,
          "dependabotUpdate" | "dismisser" | "repository"
        > & {
          dependabotUpdate?: Maybe<_RefType["DependabotUpdate"]>;
          dismisser?: Maybe<_RefType["User"]>;
          repository: _RefType["Repository"];
        });
    RepositoryOwner:
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          User,
          | "commitComments"
          | "contributionsCollection"
          | "enterprises"
          | "followers"
          | "following"
          | "gist"
          | "gistComments"
          | "gists"
          | "hovercard"
          | "issueComments"
          | "issues"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "lists"
          | "organization"
          | "organizations"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequests"
          | "recentProjects"
          | "repositories"
          | "repositoriesContributedTo"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "savedReplies"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "starredRepositories"
          | "status"
          | "topRepositories"
          | "watching"
        > & {
          commitComments: _RefType["CommitCommentConnection"];
          contributionsCollection: _RefType["ContributionsCollection"];
          enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
          followers: _RefType["FollowerConnection"];
          following: _RefType["FollowingConnection"];
          gist?: Maybe<_RefType["Gist"]>;
          gistComments: _RefType["GistCommentConnection"];
          gists: _RefType["GistConnection"];
          hovercard: _RefType["Hovercard"];
          issueComments: _RefType["IssueCommentConnection"];
          issues: _RefType["IssueConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          lists: _RefType["UserListConnection"];
          organization?: Maybe<_RefType["Organization"]>;
          organizations: _RefType["OrganizationConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repositoriesContributedTo: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          starredRepositories: _RefType["StarredRepositoryConnection"];
          status?: Maybe<_RefType["UserStatus"]>;
          topRepositories: _RefType["RepositoryConnection"];
          watching: _RefType["RepositoryConnection"];
        });
    RequirableByPullRequest:
      | (Omit<
          CheckRun,
          | "checkSuite"
          | "deployment"
          | "pendingDeploymentRequest"
          | "repository"
        > & {
          checkSuite: _RefType["CheckSuite"];
          deployment?: Maybe<_RefType["Deployment"]>;
          pendingDeploymentRequest?: Maybe<_RefType["DeploymentRequest"]>;
          repository: _RefType["Repository"];
        })
      | (Omit<StatusContext, "commit" | "creator"> & {
          commit?: Maybe<_RefType["Commit"]>;
          creator?: Maybe<_RefType["Actor"]>;
        });
    Sponsorable:
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          User,
          | "commitComments"
          | "contributionsCollection"
          | "enterprises"
          | "followers"
          | "following"
          | "gist"
          | "gistComments"
          | "gists"
          | "hovercard"
          | "issueComments"
          | "issues"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "lists"
          | "organization"
          | "organizations"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequests"
          | "recentProjects"
          | "repositories"
          | "repositoriesContributedTo"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "savedReplies"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "starredRepositories"
          | "status"
          | "topRepositories"
          | "watching"
        > & {
          commitComments: _RefType["CommitCommentConnection"];
          contributionsCollection: _RefType["ContributionsCollection"];
          enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
          followers: _RefType["FollowerConnection"];
          following: _RefType["FollowingConnection"];
          gist?: Maybe<_RefType["Gist"]>;
          gistComments: _RefType["GistCommentConnection"];
          gists: _RefType["GistConnection"];
          hovercard: _RefType["Hovercard"];
          issueComments: _RefType["IssueCommentConnection"];
          issues: _RefType["IssueConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          lists: _RefType["UserListConnection"];
          organization?: Maybe<_RefType["Organization"]>;
          organizations: _RefType["OrganizationConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repositoriesContributedTo: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          starredRepositories: _RefType["StarredRepositoryConnection"];
          status?: Maybe<_RefType["UserStatus"]>;
          topRepositories: _RefType["RepositoryConnection"];
          watching: _RefType["RepositoryConnection"];
        });
    Starrable:
      | (Omit<Gist, "comments" | "forks" | "owner"> & {
          comments: _RefType["GistCommentConnection"];
          forks: _RefType["GistConnection"];
          owner?: Maybe<_RefType["RepositoryOwner"]>;
        })
      | (Omit<
          Repository,
          | "branchProtectionRules"
          | "collaborators"
          | "commitComments"
          | "defaultBranchRef"
          | "dependencyGraphManifests"
          | "deployments"
          | "discussion"
          | "discussionCategories"
          | "discussionCategory"
          | "discussions"
          | "environment"
          | "environments"
          | "forks"
          | "issue"
          | "issueOrPullRequest"
          | "issueTemplates"
          | "issues"
          | "label"
          | "labels"
          | "latestRelease"
          | "mergeQueue"
          | "milestone"
          | "milestones"
          | "object"
          | "owner"
          | "packages"
          | "parent"
          | "pinnedDiscussions"
          | "pinnedEnvironments"
          | "pinnedIssues"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequest"
          | "pullRequestTemplates"
          | "pullRequests"
          | "recentProjects"
          | "ref"
          | "release"
          | "releases"
          | "repositoryTopics"
          | "ruleset"
          | "rulesets"
          | "templateRepository"
          | "vulnerabilityAlert"
          | "vulnerabilityAlerts"
        > & {
          branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
          collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
          commitComments: _RefType["CommitCommentConnection"];
          defaultBranchRef?: Maybe<_RefType["Ref"]>;
          dependencyGraphManifests?: Maybe<
            _RefType["DependencyGraphManifestConnection"]
          >;
          deployments: _RefType["DeploymentConnection"];
          discussion?: Maybe<_RefType["Discussion"]>;
          discussionCategories: _RefType["DiscussionCategoryConnection"];
          discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
          discussions: _RefType["DiscussionConnection"];
          environment?: Maybe<_RefType["Environment"]>;
          environments: _RefType["EnvironmentConnection"];
          forks: _RefType["RepositoryConnection"];
          issue?: Maybe<_RefType["Issue"]>;
          issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
          issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
          issues: _RefType["IssueConnection"];
          label?: Maybe<_RefType["Label"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestRelease?: Maybe<_RefType["Release"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          milestones?: Maybe<_RefType["MilestoneConnection"]>;
          object?: Maybe<_RefType["GitObject"]>;
          owner: _RefType["RepositoryOwner"];
          packages: _RefType["PackageConnection"];
          parent?: Maybe<_RefType["Repository"]>;
          pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
          pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
          pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          ref?: Maybe<_RefType["Ref"]>;
          release?: Maybe<_RefType["Release"]>;
          releases: _RefType["ReleaseConnection"];
          repositoryTopics: _RefType["RepositoryTopicConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          templateRepository?: Maybe<_RefType["Repository"]>;
          vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
          vulnerabilityAlerts?: Maybe<
            _RefType["RepositoryVulnerabilityAlertConnection"]
          >;
        })
      | (Omit<Topic, "relatedTopics" | "repositories"> & {
          relatedTopics: Array<_RefType["Topic"]>;
          repositories: _RefType["RepositoryConnection"];
        });
    Subscribable:
      | (Omit<
          Commit,
          | "associatedPullRequests"
          | "blame"
          | "checkSuites"
          | "comments"
          | "deployments"
          | "file"
          | "history"
          | "onBehalfOf"
          | "parents"
          | "repository"
          | "signature"
          | "status"
          | "statusCheckRollup"
          | "tree"
        > & {
          associatedPullRequests?: Maybe<_RefType["PullRequestConnection"]>;
          blame: _RefType["Blame"];
          checkSuites?: Maybe<_RefType["CheckSuiteConnection"]>;
          comments: _RefType["CommitCommentConnection"];
          deployments?: Maybe<_RefType["DeploymentConnection"]>;
          file?: Maybe<_RefType["TreeEntry"]>;
          history: _RefType["CommitHistoryConnection"];
          onBehalfOf?: Maybe<_RefType["Organization"]>;
          parents: _RefType["CommitConnection"];
          repository: _RefType["Repository"];
          signature?: Maybe<_RefType["GitSignature"]>;
          status?: Maybe<_RefType["Status"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          tree: _RefType["Tree"];
        })
      | (Omit<
          Discussion,
          | "answer"
          | "answerChosenBy"
          | "author"
          | "category"
          | "comments"
          | "editor"
          | "labels"
          | "poll"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          answer?: Maybe<_RefType["DiscussionComment"]>;
          answerChosenBy?: Maybe<_RefType["Actor"]>;
          author?: Maybe<_RefType["Actor"]>;
          category: _RefType["DiscussionCategory"];
          comments: _RefType["DiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          poll?: Maybe<_RefType["DiscussionPoll"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        })
      | (Omit<
          Repository,
          | "branchProtectionRules"
          | "collaborators"
          | "commitComments"
          | "defaultBranchRef"
          | "dependencyGraphManifests"
          | "deployments"
          | "discussion"
          | "discussionCategories"
          | "discussionCategory"
          | "discussions"
          | "environment"
          | "environments"
          | "forks"
          | "issue"
          | "issueOrPullRequest"
          | "issueTemplates"
          | "issues"
          | "label"
          | "labels"
          | "latestRelease"
          | "mergeQueue"
          | "milestone"
          | "milestones"
          | "object"
          | "owner"
          | "packages"
          | "parent"
          | "pinnedDiscussions"
          | "pinnedEnvironments"
          | "pinnedIssues"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequest"
          | "pullRequestTemplates"
          | "pullRequests"
          | "recentProjects"
          | "ref"
          | "release"
          | "releases"
          | "repositoryTopics"
          | "ruleset"
          | "rulesets"
          | "templateRepository"
          | "vulnerabilityAlert"
          | "vulnerabilityAlerts"
        > & {
          branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
          collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
          commitComments: _RefType["CommitCommentConnection"];
          defaultBranchRef?: Maybe<_RefType["Ref"]>;
          dependencyGraphManifests?: Maybe<
            _RefType["DependencyGraphManifestConnection"]
          >;
          deployments: _RefType["DeploymentConnection"];
          discussion?: Maybe<_RefType["Discussion"]>;
          discussionCategories: _RefType["DiscussionCategoryConnection"];
          discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
          discussions: _RefType["DiscussionConnection"];
          environment?: Maybe<_RefType["Environment"]>;
          environments: _RefType["EnvironmentConnection"];
          forks: _RefType["RepositoryConnection"];
          issue?: Maybe<_RefType["Issue"]>;
          issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
          issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
          issues: _RefType["IssueConnection"];
          label?: Maybe<_RefType["Label"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestRelease?: Maybe<_RefType["Release"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          milestones?: Maybe<_RefType["MilestoneConnection"]>;
          object?: Maybe<_RefType["GitObject"]>;
          owner: _RefType["RepositoryOwner"];
          packages: _RefType["PackageConnection"];
          parent?: Maybe<_RefType["Repository"]>;
          pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
          pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
          pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          ref?: Maybe<_RefType["Ref"]>;
          release?: Maybe<_RefType["Release"]>;
          releases: _RefType["ReleaseConnection"];
          repositoryTopics: _RefType["RepositoryTopicConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          templateRepository?: Maybe<_RefType["Repository"]>;
          vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
          vulnerabilityAlerts?: Maybe<
            _RefType["RepositoryVulnerabilityAlertConnection"]
          >;
        })
      | (Omit<
          Team,
          | "ancestors"
          | "childTeams"
          | "discussion"
          | "discussions"
          | "invitations"
          | "memberStatuses"
          | "organization"
          | "parentTeam"
          | "projectV2"
          | "projectsV2"
          | "repositories"
        > & {
          ancestors: _RefType["TeamConnection"];
          childTeams: _RefType["TeamConnection"];
          discussion?: Maybe<_RefType["TeamDiscussion"]>;
          discussions: _RefType["TeamDiscussionConnection"];
          invitations?: Maybe<_RefType["OrganizationInvitationConnection"]>;
          memberStatuses: _RefType["UserStatusConnection"];
          organization: _RefType["Organization"];
          parentTeam?: Maybe<_RefType["Team"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          repositories: _RefType["TeamRepositoryConnection"];
        })
      | (Omit<
          TeamDiscussion,
          | "author"
          | "comments"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "team"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["TeamDiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          team: _RefType["Team"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        });
    SubscribableThread: Omit<
      Issue,
      | "author"
      | "closedByPullRequestsReferences"
      | "comments"
      | "editor"
      | "hovercard"
      | "labels"
      | "milestone"
      | "projectCards"
      | "projectItems"
      | "projectV2"
      | "projectsV2"
      | "reactionGroups"
      | "reactions"
      | "repository"
      | "timeline"
      | "timelineItems"
      | "trackedInIssues"
      | "trackedIssues"
      | "userContentEdits"
    > & {
      author?: Maybe<_RefType["Actor"]>;
      closedByPullRequestsReferences?: Maybe<_RefType["PullRequestConnection"]>;
      comments: _RefType["IssueCommentConnection"];
      editor?: Maybe<_RefType["Actor"]>;
      hovercard: _RefType["Hovercard"];
      labels?: Maybe<_RefType["LabelConnection"]>;
      milestone?: Maybe<_RefType["Milestone"]>;
      projectCards: _RefType["ProjectCardConnection"];
      projectItems: _RefType["ProjectV2ItemConnection"];
      projectV2?: Maybe<_RefType["ProjectV2"]>;
      projectsV2: _RefType["ProjectV2Connection"];
      reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
      reactions: _RefType["ReactionConnection"];
      repository: _RefType["Repository"];
      timeline: _RefType["IssueTimelineConnection"];
      timelineItems: _RefType["IssueTimelineItemsConnection"];
      trackedInIssues: _RefType["IssueConnection"];
      trackedIssues: _RefType["IssueConnection"];
      userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
    };
    TeamAuditEntryData:
      | (Omit<OrgRestoreMemberMembershipTeamAuditEntryData, "team"> & {
          team?: Maybe<_RefType["Team"]>;
        })
      | (Omit<
          TeamAddMemberAuditEntry,
          "actor" | "organization" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamAddRepositoryAuditEntry,
          "actor" | "organization" | "repository" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamChangeParentTeamAuditEntry,
          | "actor"
          | "organization"
          | "parentTeam"
          | "parentTeamWas"
          | "team"
          | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          parentTeam?: Maybe<_RefType["Team"]>;
          parentTeamWas?: Maybe<_RefType["Team"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamRemoveMemberAuditEntry,
          "actor" | "organization" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          TeamRemoveRepositoryAuditEntry,
          "actor" | "organization" | "repository" | "team" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          team?: Maybe<_RefType["Team"]>;
          user?: Maybe<_RefType["User"]>;
        });
    TopicAuditEntryData:
      | (Omit<
          RepoAddTopicAuditEntry,
          "actor" | "organization" | "repository" | "topic" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          topic?: Maybe<_RefType["Topic"]>;
          user?: Maybe<_RefType["User"]>;
        })
      | (Omit<
          RepoRemoveTopicAuditEntry,
          "actor" | "organization" | "repository" | "topic" | "user"
        > & {
          actor?: Maybe<_RefType["AuditEntryActor"]>;
          organization?: Maybe<_RefType["Organization"]>;
          repository?: Maybe<_RefType["Repository"]>;
          topic?: Maybe<_RefType["Topic"]>;
          user?: Maybe<_RefType["User"]>;
        });
    UniformResourceLocatable:
      | Bot
      | (Omit<
          CheckRun,
          | "checkSuite"
          | "deployment"
          | "pendingDeploymentRequest"
          | "repository"
        > & {
          checkSuite: _RefType["CheckSuite"];
          deployment?: Maybe<_RefType["Deployment"]>;
          pendingDeploymentRequest?: Maybe<_RefType["DeploymentRequest"]>;
          repository: _RefType["Repository"];
        })
      | (Omit<ClosedEvent, "actor" | "closable" | "closer"> & {
          actor?: Maybe<_RefType["Actor"]>;
          closable: _RefType["Closable"];
          closer?: Maybe<_RefType["Closer"]>;
        })
      | (Omit<
          Commit,
          | "associatedPullRequests"
          | "blame"
          | "checkSuites"
          | "comments"
          | "deployments"
          | "file"
          | "history"
          | "onBehalfOf"
          | "parents"
          | "repository"
          | "signature"
          | "status"
          | "statusCheckRollup"
          | "tree"
        > & {
          associatedPullRequests?: Maybe<_RefType["PullRequestConnection"]>;
          blame: _RefType["Blame"];
          checkSuites?: Maybe<_RefType["CheckSuiteConnection"]>;
          comments: _RefType["CommitCommentConnection"];
          deployments?: Maybe<_RefType["DeploymentConnection"]>;
          file?: Maybe<_RefType["TreeEntry"]>;
          history: _RefType["CommitHistoryConnection"];
          onBehalfOf?: Maybe<_RefType["Organization"]>;
          parents: _RefType["CommitConnection"];
          repository: _RefType["Repository"];
          signature?: Maybe<_RefType["GitSignature"]>;
          status?: Maybe<_RefType["Status"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          tree: _RefType["Tree"];
        })
      | (Omit<ConvertToDraftEvent, "actor" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<CrossReferencedEvent, "actor" | "source" | "target"> & {
          actor?: Maybe<_RefType["Actor"]>;
          source: _RefType["ReferencedSubject"];
          target: _RefType["ReferencedSubject"];
        })
      | (Omit<Gist, "comments" | "forks" | "owner"> & {
          comments: _RefType["GistCommentConnection"];
          forks: _RefType["GistConnection"];
          owner?: Maybe<_RefType["RepositoryOwner"]>;
        })
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<Mannequin, "claimant"> & { claimant?: Maybe<_RefType["User"]> })
      | (Omit<MergedEvent, "actor" | "commit" | "mergeRef" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          mergeRef?: Maybe<_RefType["Ref"]>;
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<
          Milestone,
          "creator" | "issues" | "pullRequests" | "repository"
        > & {
          creator?: Maybe<_RefType["Actor"]>;
          issues: _RefType["IssueConnection"];
          pullRequests: _RefType["PullRequestConnection"];
          repository: _RefType["Repository"];
        })
      | (Omit<
          Organization,
          | "auditLog"
          | "domains"
          | "enterpriseOwners"
          | "ipAllowListEntries"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "mannequins"
          | "memberStatuses"
          | "membersWithRole"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "recentProjects"
          | "repositories"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "ruleset"
          | "rulesets"
          | "samlIdentityProvider"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "team"
          | "teams"
        > & {
          auditLog: _RefType["OrganizationAuditEntryConnection"];
          domains?: Maybe<_RefType["VerifiableDomainConnection"]>;
          enterpriseOwners: _RefType["OrganizationEnterpriseOwnerConnection"];
          ipAllowListEntries: _RefType["IpAllowListEntryConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          mannequins: _RefType["MannequinConnection"];
          memberStatuses: _RefType["UserStatusConnection"];
          membersWithRole: _RefType["OrganizationMemberConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          samlIdentityProvider?: Maybe<
            _RefType["OrganizationIdentityProvider"]
          >;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          team?: Maybe<_RefType["Team"]>;
          teams: _RefType["TeamConnection"];
        })
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        })
      | (Omit<PullRequestCommit, "commit" | "pullRequest"> & {
          commit: _RefType["Commit"];
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<ReadyForReviewEvent, "actor" | "pullRequest"> & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest: _RefType["PullRequest"];
        })
      | (Omit<
          Release,
          | "author"
          | "reactionGroups"
          | "reactions"
          | "releaseAssets"
          | "repository"
          | "tag"
          | "tagCommit"
        > & {
          author?: Maybe<_RefType["User"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          releaseAssets: _RefType["ReleaseAssetConnection"];
          repository: _RefType["Repository"];
          tag?: Maybe<_RefType["Ref"]>;
          tagCommit?: Maybe<_RefType["Commit"]>;
        })
      | (Omit<
          Repository,
          | "branchProtectionRules"
          | "collaborators"
          | "commitComments"
          | "defaultBranchRef"
          | "dependencyGraphManifests"
          | "deployments"
          | "discussion"
          | "discussionCategories"
          | "discussionCategory"
          | "discussions"
          | "environment"
          | "environments"
          | "forks"
          | "issue"
          | "issueOrPullRequest"
          | "issueTemplates"
          | "issues"
          | "label"
          | "labels"
          | "latestRelease"
          | "mergeQueue"
          | "milestone"
          | "milestones"
          | "object"
          | "owner"
          | "packages"
          | "parent"
          | "pinnedDiscussions"
          | "pinnedEnvironments"
          | "pinnedIssues"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequest"
          | "pullRequestTemplates"
          | "pullRequests"
          | "recentProjects"
          | "ref"
          | "release"
          | "releases"
          | "repositoryTopics"
          | "ruleset"
          | "rulesets"
          | "templateRepository"
          | "vulnerabilityAlert"
          | "vulnerabilityAlerts"
        > & {
          branchProtectionRules: _RefType["BranchProtectionRuleConnection"];
          collaborators?: Maybe<_RefType["RepositoryCollaboratorConnection"]>;
          commitComments: _RefType["CommitCommentConnection"];
          defaultBranchRef?: Maybe<_RefType["Ref"]>;
          dependencyGraphManifests?: Maybe<
            _RefType["DependencyGraphManifestConnection"]
          >;
          deployments: _RefType["DeploymentConnection"];
          discussion?: Maybe<_RefType["Discussion"]>;
          discussionCategories: _RefType["DiscussionCategoryConnection"];
          discussionCategory?: Maybe<_RefType["DiscussionCategory"]>;
          discussions: _RefType["DiscussionConnection"];
          environment?: Maybe<_RefType["Environment"]>;
          environments: _RefType["EnvironmentConnection"];
          forks: _RefType["RepositoryConnection"];
          issue?: Maybe<_RefType["Issue"]>;
          issueOrPullRequest?: Maybe<_RefType["IssueOrPullRequest"]>;
          issueTemplates?: Maybe<Array<_RefType["IssueTemplate"]>>;
          issues: _RefType["IssueConnection"];
          label?: Maybe<_RefType["Label"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestRelease?: Maybe<_RefType["Release"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          milestones?: Maybe<_RefType["MilestoneConnection"]>;
          object?: Maybe<_RefType["GitObject"]>;
          owner: _RefType["RepositoryOwner"];
          packages: _RefType["PackageConnection"];
          parent?: Maybe<_RefType["Repository"]>;
          pinnedDiscussions: _RefType["PinnedDiscussionConnection"];
          pinnedEnvironments?: Maybe<_RefType["PinnedEnvironmentConnection"]>;
          pinnedIssues?: Maybe<_RefType["PinnedIssueConnection"]>;
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          pullRequestTemplates?: Maybe<Array<_RefType["PullRequestTemplate"]>>;
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          ref?: Maybe<_RefType["Ref"]>;
          release?: Maybe<_RefType["Release"]>;
          releases: _RefType["ReleaseConnection"];
          repositoryTopics: _RefType["RepositoryTopicConnection"];
          ruleset?: Maybe<_RefType["RepositoryRuleset"]>;
          rulesets?: Maybe<_RefType["RepositoryRulesetConnection"]>;
          templateRepository?: Maybe<_RefType["Repository"]>;
          vulnerabilityAlert?: Maybe<_RefType["RepositoryVulnerabilityAlert"]>;
          vulnerabilityAlerts?: Maybe<
            _RefType["RepositoryVulnerabilityAlertConnection"]
          >;
        })
      | (Omit<RepositoryTopic, "topic"> & { topic: _RefType["Topic"] })
      | (Omit<
          ReviewDismissedEvent,
          "actor" | "pullRequest" | "pullRequestCommit" | "review"
        > & {
          actor?: Maybe<_RefType["Actor"]>;
          pullRequest: _RefType["PullRequest"];
          pullRequestCommit?: Maybe<_RefType["PullRequestCommit"]>;
          review?: Maybe<_RefType["PullRequestReview"]>;
        })
      | (Omit<
          TeamDiscussion,
          | "author"
          | "comments"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "team"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["TeamDiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          team: _RefType["Team"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          TeamDiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion: _RefType["TeamDiscussion"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          User,
          | "commitComments"
          | "contributionsCollection"
          | "enterprises"
          | "followers"
          | "following"
          | "gist"
          | "gistComments"
          | "gists"
          | "hovercard"
          | "issueComments"
          | "issues"
          | "itemShowcase"
          | "lifetimeReceivedSponsorshipValues"
          | "lists"
          | "organization"
          | "organizations"
          | "packages"
          | "pinnableItems"
          | "pinnedItems"
          | "project"
          | "projectV2"
          | "projects"
          | "projectsV2"
          | "pullRequests"
          | "recentProjects"
          | "repositories"
          | "repositoriesContributedTo"
          | "repository"
          | "repositoryDiscussionComments"
          | "repositoryDiscussions"
          | "savedReplies"
          | "sponsoring"
          | "sponsors"
          | "sponsorsActivities"
          | "sponsorsListing"
          | "sponsorshipForViewerAsSponsor"
          | "sponsorshipForViewerAsSponsorable"
          | "sponsorshipNewsletters"
          | "sponsorshipsAsMaintainer"
          | "sponsorshipsAsSponsor"
          | "starredRepositories"
          | "status"
          | "topRepositories"
          | "watching"
        > & {
          commitComments: _RefType["CommitCommentConnection"];
          contributionsCollection: _RefType["ContributionsCollection"];
          enterprises?: Maybe<_RefType["EnterpriseConnection"]>;
          followers: _RefType["FollowerConnection"];
          following: _RefType["FollowingConnection"];
          gist?: Maybe<_RefType["Gist"]>;
          gistComments: _RefType["GistCommentConnection"];
          gists: _RefType["GistConnection"];
          hovercard: _RefType["Hovercard"];
          issueComments: _RefType["IssueCommentConnection"];
          issues: _RefType["IssueConnection"];
          itemShowcase: _RefType["ProfileItemShowcase"];
          lifetimeReceivedSponsorshipValues: _RefType["SponsorAndLifetimeValueConnection"];
          lists: _RefType["UserListConnection"];
          organization?: Maybe<_RefType["Organization"]>;
          organizations: _RefType["OrganizationConnection"];
          packages: _RefType["PackageConnection"];
          pinnableItems: _RefType["PinnableItemConnection"];
          pinnedItems: _RefType["PinnableItemConnection"];
          project?: Maybe<_RefType["Project"]>;
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projects: _RefType["ProjectConnection"];
          projectsV2: _RefType["ProjectV2Connection"];
          pullRequests: _RefType["PullRequestConnection"];
          recentProjects: _RefType["ProjectV2Connection"];
          repositories: _RefType["RepositoryConnection"];
          repositoriesContributedTo: _RefType["RepositoryConnection"];
          repository?: Maybe<_RefType["Repository"]>;
          repositoryDiscussionComments: _RefType["DiscussionCommentConnection"];
          repositoryDiscussions: _RefType["DiscussionConnection"];
          savedReplies?: Maybe<_RefType["SavedReplyConnection"]>;
          sponsoring: _RefType["SponsorConnection"];
          sponsors: _RefType["SponsorConnection"];
          sponsorsActivities: _RefType["SponsorsActivityConnection"];
          sponsorsListing?: Maybe<_RefType["SponsorsListing"]>;
          sponsorshipForViewerAsSponsor?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipForViewerAsSponsorable?: Maybe<_RefType["Sponsorship"]>;
          sponsorshipNewsletters: _RefType["SponsorshipNewsletterConnection"];
          sponsorshipsAsMaintainer: _RefType["SponsorshipConnection"];
          sponsorshipsAsSponsor: _RefType["SponsorshipConnection"];
          starredRepositories: _RefType["StarredRepositoryConnection"];
          status?: Maybe<_RefType["UserStatus"]>;
          topRepositories: _RefType["RepositoryConnection"];
          watching: _RefType["RepositoryConnection"];
        })
      | (Omit<Workflow, "runs"> & { runs: _RefType["WorkflowRunConnection"] })
      | (Omit<
          WorkflowRun,
          | "checkSuite"
          | "deploymentReviews"
          | "file"
          | "pendingDeploymentRequests"
          | "workflow"
        > & {
          checkSuite: _RefType["CheckSuite"];
          deploymentReviews: _RefType["DeploymentReviewConnection"];
          file?: Maybe<_RefType["WorkflowRunFile"]>;
          pendingDeploymentRequests: _RefType["DeploymentRequestConnection"];
          workflow: _RefType["Workflow"];
        })
      | (Omit<WorkflowRunFile, "run"> & { run: _RefType["WorkflowRun"] });
    Updatable:
      | (Omit<
          CommitComment,
          | "author"
          | "commit"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Discussion,
          | "answer"
          | "answerChosenBy"
          | "author"
          | "category"
          | "comments"
          | "editor"
          | "labels"
          | "poll"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          answer?: Maybe<_RefType["DiscussionComment"]>;
          answerChosenBy?: Maybe<_RefType["Actor"]>;
          author?: Maybe<_RefType["Actor"]>;
          category: _RefType["DiscussionCategory"];
          comments: _RefType["DiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          poll?: Maybe<_RefType["DiscussionPoll"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          DiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "replies"
          | "replyTo"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion?: Maybe<_RefType["Discussion"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replies: _RefType["DiscussionCommentConnection"];
          replyTo?: Maybe<_RefType["DiscussionComment"]>;
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          GistComment,
          "author" | "editor" | "gist" | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          gist: _RefType["Gist"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          IssueComment,
          | "author"
          | "editor"
          | "issue"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          issue: _RefType["Issue"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<Project, "creator" | "owner" | "pendingCards"> & {
          creator?: Maybe<_RefType["Actor"]>;
          owner: _RefType["ProjectOwner"];
          pendingCards: _RefType["ProjectCardConnection"];
        })
      | (Omit<
          ProjectV2,
          | "creator"
          | "field"
          | "fields"
          | "items"
          | "owner"
          | "repositories"
          | "statusUpdates"
          | "teams"
          | "view"
          | "views"
          | "workflow"
          | "workflows"
        > & {
          creator?: Maybe<_RefType["Actor"]>;
          field?: Maybe<_RefType["ProjectV2FieldConfiguration"]>;
          fields: _RefType["ProjectV2FieldConfigurationConnection"];
          items: _RefType["ProjectV2ItemConnection"];
          owner: _RefType["ProjectV2Owner"];
          repositories: _RefType["RepositoryConnection"];
          statusUpdates: _RefType["ProjectV2StatusUpdateConnection"];
          teams: _RefType["TeamConnection"];
          view?: Maybe<_RefType["ProjectV2View"]>;
          views: _RefType["ProjectV2ViewConnection"];
          workflow?: Maybe<_RefType["ProjectV2Workflow"]>;
          workflows: _RefType["ProjectV2WorkflowConnection"];
        })
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        })
      | (Omit<
          PullRequestReview,
          | "author"
          | "comments"
          | "commit"
          | "editor"
          | "onBehalfOf"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["PullRequestReviewCommentConnection"];
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          onBehalfOf: _RefType["TeamConnection"];
          pullRequest: _RefType["PullRequest"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequestReviewComment,
          | "author"
          | "commit"
          | "editor"
          | "originalCommit"
          | "pullRequest"
          | "pullRequestReview"
          | "reactionGroups"
          | "reactions"
          | "replyTo"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          originalCommit?: Maybe<_RefType["Commit"]>;
          pullRequest: _RefType["PullRequest"];
          pullRequestReview?: Maybe<_RefType["PullRequestReview"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replyTo?: Maybe<_RefType["PullRequestReviewComment"]>;
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          TeamDiscussion,
          | "author"
          | "comments"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "team"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["TeamDiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          team: _RefType["Team"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          TeamDiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion: _RefType["TeamDiscussion"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        });
    UpdatableComment:
      | (Omit<
          CommitComment,
          | "author"
          | "commit"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          DiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "replies"
          | "replyTo"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion?: Maybe<_RefType["Discussion"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replies: _RefType["DiscussionCommentConnection"];
          replyTo?: Maybe<_RefType["DiscussionComment"]>;
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          GistComment,
          "author" | "editor" | "gist" | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          gist: _RefType["Gist"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          Issue,
          | "author"
          | "closedByPullRequestsReferences"
          | "comments"
          | "editor"
          | "hovercard"
          | "labels"
          | "milestone"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "timeline"
          | "timelineItems"
          | "trackedInIssues"
          | "trackedIssues"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          closedByPullRequestsReferences?: Maybe<
            _RefType["PullRequestConnection"]
          >;
          comments: _RefType["IssueCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          timeline: _RefType["IssueTimelineConnection"];
          timelineItems: _RefType["IssueTimelineItemsConnection"];
          trackedInIssues: _RefType["IssueConnection"];
          trackedIssues: _RefType["IssueConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          IssueComment,
          | "author"
          | "editor"
          | "issue"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          editor?: Maybe<_RefType["Actor"]>;
          issue: _RefType["Issue"];
          pullRequest?: Maybe<_RefType["PullRequest"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequest,
          | "author"
          | "autoMergeRequest"
          | "baseRef"
          | "baseRepository"
          | "closingIssuesReferences"
          | "comments"
          | "commits"
          | "editor"
          | "headRef"
          | "headRepository"
          | "headRepositoryOwner"
          | "hovercard"
          | "labels"
          | "latestOpinionatedReviews"
          | "latestReviews"
          | "mergeCommit"
          | "mergeQueue"
          | "mergeQueueEntry"
          | "mergedBy"
          | "milestone"
          | "potentialMergeCommit"
          | "projectCards"
          | "projectItems"
          | "projectV2"
          | "projectsV2"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "reviewRequests"
          | "reviewThreads"
          | "reviews"
          | "statusCheckRollup"
          | "timeline"
          | "timelineItems"
          | "userContentEdits"
          | "viewerLatestReview"
          | "viewerLatestReviewRequest"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          autoMergeRequest?: Maybe<_RefType["AutoMergeRequest"]>;
          baseRef?: Maybe<_RefType["Ref"]>;
          baseRepository?: Maybe<_RefType["Repository"]>;
          closingIssuesReferences?: Maybe<_RefType["IssueConnection"]>;
          comments: _RefType["IssueCommentConnection"];
          commits: _RefType["PullRequestCommitConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          headRef?: Maybe<_RefType["Ref"]>;
          headRepository?: Maybe<_RefType["Repository"]>;
          headRepositoryOwner?: Maybe<_RefType["RepositoryOwner"]>;
          hovercard: _RefType["Hovercard"];
          labels?: Maybe<_RefType["LabelConnection"]>;
          latestOpinionatedReviews?: Maybe<
            _RefType["PullRequestReviewConnection"]
          >;
          latestReviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          mergeCommit?: Maybe<_RefType["Commit"]>;
          mergeQueue?: Maybe<_RefType["MergeQueue"]>;
          mergeQueueEntry?: Maybe<_RefType["MergeQueueEntry"]>;
          mergedBy?: Maybe<_RefType["Actor"]>;
          milestone?: Maybe<_RefType["Milestone"]>;
          potentialMergeCommit?: Maybe<_RefType["Commit"]>;
          projectCards: _RefType["ProjectCardConnection"];
          projectItems: _RefType["ProjectV2ItemConnection"];
          projectV2?: Maybe<_RefType["ProjectV2"]>;
          projectsV2: _RefType["ProjectV2Connection"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          reviewRequests?: Maybe<_RefType["ReviewRequestConnection"]>;
          reviewThreads: _RefType["PullRequestReviewThreadConnection"];
          reviews?: Maybe<_RefType["PullRequestReviewConnection"]>;
          statusCheckRollup?: Maybe<_RefType["StatusCheckRollup"]>;
          timeline: _RefType["PullRequestTimelineConnection"];
          timelineItems: _RefType["PullRequestTimelineItemsConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
          viewerLatestReview?: Maybe<_RefType["PullRequestReview"]>;
          viewerLatestReviewRequest?: Maybe<_RefType["ReviewRequest"]>;
        })
      | (Omit<
          PullRequestReview,
          | "author"
          | "comments"
          | "commit"
          | "editor"
          | "onBehalfOf"
          | "pullRequest"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["PullRequestReviewCommentConnection"];
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          onBehalfOf: _RefType["TeamConnection"];
          pullRequest: _RefType["PullRequest"];
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          PullRequestReviewComment,
          | "author"
          | "commit"
          | "editor"
          | "originalCommit"
          | "pullRequest"
          | "pullRequestReview"
          | "reactionGroups"
          | "reactions"
          | "replyTo"
          | "repository"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          commit?: Maybe<_RefType["Commit"]>;
          editor?: Maybe<_RefType["Actor"]>;
          originalCommit?: Maybe<_RefType["Commit"]>;
          pullRequest: _RefType["PullRequest"];
          pullRequestReview?: Maybe<_RefType["PullRequestReview"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replyTo?: Maybe<_RefType["PullRequestReviewComment"]>;
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          TeamDiscussion,
          | "author"
          | "comments"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "team"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          comments: _RefType["TeamDiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          team: _RefType["Team"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          TeamDiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion: _RefType["TeamDiscussion"];
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        });
    Votable:
      | (Omit<
          Discussion,
          | "answer"
          | "answerChosenBy"
          | "author"
          | "category"
          | "comments"
          | "editor"
          | "labels"
          | "poll"
          | "reactionGroups"
          | "reactions"
          | "repository"
          | "userContentEdits"
        > & {
          answer?: Maybe<_RefType["DiscussionComment"]>;
          answerChosenBy?: Maybe<_RefType["Actor"]>;
          author?: Maybe<_RefType["Actor"]>;
          category: _RefType["DiscussionCategory"];
          comments: _RefType["DiscussionCommentConnection"];
          editor?: Maybe<_RefType["Actor"]>;
          labels?: Maybe<_RefType["LabelConnection"]>;
          poll?: Maybe<_RefType["DiscussionPoll"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          repository: _RefType["Repository"];
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        })
      | (Omit<
          DiscussionComment,
          | "author"
          | "discussion"
          | "editor"
          | "reactionGroups"
          | "reactions"
          | "replies"
          | "replyTo"
          | "userContentEdits"
        > & {
          author?: Maybe<_RefType["Actor"]>;
          discussion?: Maybe<_RefType["Discussion"]>;
          editor?: Maybe<_RefType["Actor"]>;
          reactionGroups?: Maybe<Array<_RefType["ReactionGroup"]>>;
          reactions: _RefType["ReactionConnection"];
          replies: _RefType["DiscussionCommentConnection"];
          replyTo?: Maybe<_RefType["DiscussionComment"]>;
          userContentEdits?: Maybe<_RefType["UserContentEditConnection"]>;
        });
  };

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  AbortQueuedMigrationsInput: AbortQueuedMigrationsInput;
  AbortQueuedMigrationsPayload: ResolverTypeWrapper<AbortQueuedMigrationsPayload>;
  AbortRepositoryMigrationInput: AbortRepositoryMigrationInput;
  AbortRepositoryMigrationPayload: ResolverTypeWrapper<AbortRepositoryMigrationPayload>;
  AcceptEnterpriseAdministratorInvitationInput: AcceptEnterpriseAdministratorInvitationInput;
  AcceptEnterpriseAdministratorInvitationPayload: ResolverTypeWrapper<
    Omit<AcceptEnterpriseAdministratorInvitationPayload, "invitation"> & {
      invitation?: Maybe<ResolversTypes["EnterpriseAdministratorInvitation"]>;
    }
  >;
  AcceptEnterpriseMemberInvitationInput: AcceptEnterpriseMemberInvitationInput;
  AcceptEnterpriseMemberInvitationPayload: ResolverTypeWrapper<
    Omit<AcceptEnterpriseMemberInvitationPayload, "invitation"> & {
      invitation?: Maybe<ResolversTypes["EnterpriseMemberInvitation"]>;
    }
  >;
  AcceptTopicSuggestionInput: AcceptTopicSuggestionInput;
  AcceptTopicSuggestionPayload: ResolverTypeWrapper<
    Omit<AcceptTopicSuggestionPayload, "topic"> & {
      topic?: Maybe<ResolversTypes["Topic"]>;
    }
  >;
  Actor: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>["Actor"]>;
  ActorLocation: ResolverTypeWrapper<ActorLocation>;
  ActorType: ActorType;
  AddAssigneesToAssignableInput: AddAssigneesToAssignableInput;
  AddAssigneesToAssignablePayload: ResolverTypeWrapper<
    Omit<AddAssigneesToAssignablePayload, "assignable"> & {
      assignable?: Maybe<ResolversTypes["Assignable"]>;
    }
  >;
  AddCommentInput: AddCommentInput;
  AddCommentPayload: ResolverTypeWrapper<
    Omit<AddCommentPayload, "commentEdge" | "subject" | "timelineEdge"> & {
      commentEdge?: Maybe<ResolversTypes["IssueCommentEdge"]>;
      subject?: Maybe<ResolversTypes["Node"]>;
      timelineEdge?: Maybe<ResolversTypes["IssueTimelineItemEdge"]>;
    }
  >;
  AddDiscussionCommentInput: AddDiscussionCommentInput;
  AddDiscussionCommentPayload: ResolverTypeWrapper<
    Omit<AddDiscussionCommentPayload, "comment"> & {
      comment?: Maybe<ResolversTypes["DiscussionComment"]>;
    }
  >;
  AddDiscussionPollVoteInput: AddDiscussionPollVoteInput;
  AddDiscussionPollVotePayload: ResolverTypeWrapper<
    Omit<AddDiscussionPollVotePayload, "pollOption"> & {
      pollOption?: Maybe<ResolversTypes["DiscussionPollOption"]>;
    }
  >;
  AddEnterpriseOrganizationMemberInput: AddEnterpriseOrganizationMemberInput;
  AddEnterpriseOrganizationMemberPayload: ResolverTypeWrapper<
    Omit<AddEnterpriseOrganizationMemberPayload, "users"> & {
      users?: Maybe<Array<ResolversTypes["User"]>>;
    }
  >;
  AddEnterpriseSupportEntitlementInput: AddEnterpriseSupportEntitlementInput;
  AddEnterpriseSupportEntitlementPayload: ResolverTypeWrapper<AddEnterpriseSupportEntitlementPayload>;
  AddLabelsToLabelableInput: AddLabelsToLabelableInput;
  AddLabelsToLabelablePayload: ResolverTypeWrapper<
    Omit<AddLabelsToLabelablePayload, "labelable"> & {
      labelable?: Maybe<ResolversTypes["Labelable"]>;
    }
  >;
  AddProjectCardInput: AddProjectCardInput;
  AddProjectCardPayload: ResolverTypeWrapper<
    Omit<AddProjectCardPayload, "cardEdge" | "projectColumn"> & {
      cardEdge?: Maybe<ResolversTypes["ProjectCardEdge"]>;
      projectColumn?: Maybe<ResolversTypes["ProjectColumn"]>;
    }
  >;
  AddProjectColumnInput: AddProjectColumnInput;
  AddProjectColumnPayload: ResolverTypeWrapper<
    Omit<AddProjectColumnPayload, "project"> & {
      project?: Maybe<ResolversTypes["Project"]>;
    }
  >;
  AddProjectV2DraftIssueInput: AddProjectV2DraftIssueInput;
  AddProjectV2DraftIssuePayload: ResolverTypeWrapper<
    Omit<AddProjectV2DraftIssuePayload, "projectItem"> & {
      projectItem?: Maybe<ResolversTypes["ProjectV2Item"]>;
    }
  >;
  AddProjectV2ItemByIdInput: AddProjectV2ItemByIdInput;
  AddProjectV2ItemByIdPayload: ResolverTypeWrapper<
    Omit<AddProjectV2ItemByIdPayload, "item"> & {
      item?: Maybe<ResolversTypes["ProjectV2Item"]>;
    }
  >;
  AddPullRequestReviewCommentInput: AddPullRequestReviewCommentInput;
  AddPullRequestReviewCommentPayload: ResolverTypeWrapper<
    Omit<AddPullRequestReviewCommentPayload, "comment" | "commentEdge"> & {
      comment?: Maybe<ResolversTypes["PullRequestReviewComment"]>;
      commentEdge?: Maybe<ResolversTypes["PullRequestReviewCommentEdge"]>;
    }
  >;
  AddPullRequestReviewInput: AddPullRequestReviewInput;
  AddPullRequestReviewPayload: ResolverTypeWrapper<
    Omit<AddPullRequestReviewPayload, "pullRequestReview" | "reviewEdge"> & {
      pullRequestReview?: Maybe<ResolversTypes["PullRequestReview"]>;
      reviewEdge?: Maybe<ResolversTypes["PullRequestReviewEdge"]>;
    }
  >;
  AddPullRequestReviewThreadInput: AddPullRequestReviewThreadInput;
  AddPullRequestReviewThreadPayload: ResolverTypeWrapper<
    Omit<AddPullRequestReviewThreadPayload, "thread"> & {
      thread?: Maybe<ResolversTypes["PullRequestReviewThread"]>;
    }
  >;
  AddPullRequestReviewThreadReplyInput: AddPullRequestReviewThreadReplyInput;
  AddPullRequestReviewThreadReplyPayload: ResolverTypeWrapper<
    Omit<AddPullRequestReviewThreadReplyPayload, "comment"> & {
      comment?: Maybe<ResolversTypes["PullRequestReviewComment"]>;
    }
  >;
  AddReactionInput: AddReactionInput;
  AddReactionPayload: ResolverTypeWrapper<
    Omit<AddReactionPayload, "reaction" | "reactionGroups" | "subject"> & {
      reaction?: Maybe<ResolversTypes["Reaction"]>;
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      subject?: Maybe<ResolversTypes["Reactable"]>;
    }
  >;
  AddStarInput: AddStarInput;
  AddStarPayload: ResolverTypeWrapper<
    Omit<AddStarPayload, "starrable"> & {
      starrable?: Maybe<ResolversTypes["Starrable"]>;
    }
  >;
  AddUpvoteInput: AddUpvoteInput;
  AddUpvotePayload: ResolverTypeWrapper<
    Omit<AddUpvotePayload, "subject"> & {
      subject?: Maybe<ResolversTypes["Votable"]>;
    }
  >;
  AddVerifiableDomainInput: AddVerifiableDomainInput;
  AddVerifiableDomainPayload: ResolverTypeWrapper<
    Omit<AddVerifiableDomainPayload, "domain"> & {
      domain?: Maybe<ResolversTypes["VerifiableDomain"]>;
    }
  >;
  AddedToMergeQueueEvent: ResolverTypeWrapper<
    Omit<
      AddedToMergeQueueEvent,
      "actor" | "enqueuer" | "mergeQueue" | "pullRequest"
    > & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      enqueuer?: Maybe<ResolversTypes["User"]>;
      mergeQueue?: Maybe<ResolversTypes["MergeQueue"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  AddedToProjectEvent: ResolverTypeWrapper<
    Omit<AddedToProjectEvent, "actor" | "project" | "projectCard"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      project?: Maybe<ResolversTypes["Project"]>;
      projectCard?: Maybe<ResolversTypes["ProjectCard"]>;
    }
  >;
  AnnouncementBanner: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["AnnouncementBanner"]
  >;
  App: ResolverTypeWrapper<
    Omit<App, "ipAllowListEntries"> & {
      ipAllowListEntries: ResolversTypes["IpAllowListEntryConnection"];
    }
  >;
  ApproveDeploymentsInput: ApproveDeploymentsInput;
  ApproveDeploymentsPayload: ResolverTypeWrapper<
    Omit<ApproveDeploymentsPayload, "deployments"> & {
      deployments?: Maybe<Array<ResolversTypes["Deployment"]>>;
    }
  >;
  ApproveVerifiableDomainInput: ApproveVerifiableDomainInput;
  ApproveVerifiableDomainPayload: ResolverTypeWrapper<
    Omit<ApproveVerifiableDomainPayload, "domain"> & {
      domain?: Maybe<ResolversTypes["VerifiableDomain"]>;
    }
  >;
  ArchiveProjectV2ItemInput: ArchiveProjectV2ItemInput;
  ArchiveProjectV2ItemPayload: ResolverTypeWrapper<
    Omit<ArchiveProjectV2ItemPayload, "item"> & {
      item?: Maybe<ResolversTypes["ProjectV2Item"]>;
    }
  >;
  ArchiveRepositoryInput: ArchiveRepositoryInput;
  ArchiveRepositoryPayload: ResolverTypeWrapper<
    Omit<ArchiveRepositoryPayload, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  Assignable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Assignable"]
  >;
  AssignedEvent: ResolverTypeWrapper<
    Omit<AssignedEvent, "actor" | "assignable" | "assignee" | "user"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      assignable: ResolversTypes["Assignable"];
      assignee?: Maybe<ResolversTypes["Assignee"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  Assignee: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["Assignee"]
  >;
  AuditEntry: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["AuditEntry"]
  >;
  AuditEntryActor: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["AuditEntryActor"]
  >;
  AuditLogOrder: AuditLogOrder;
  AuditLogOrderField: AuditLogOrderField;
  AutoMergeDisabledEvent: ResolverTypeWrapper<
    Omit<AutoMergeDisabledEvent, "actor" | "disabler" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      disabler?: Maybe<ResolversTypes["User"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  AutoMergeEnabledEvent: ResolverTypeWrapper<
    Omit<AutoMergeEnabledEvent, "actor" | "enabler" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      enabler?: Maybe<ResolversTypes["User"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  AutoMergeRequest: ResolverTypeWrapper<
    Omit<AutoMergeRequest, "enabledBy" | "pullRequest"> & {
      enabledBy?: Maybe<ResolversTypes["Actor"]>;
      pullRequest: ResolversTypes["PullRequest"];
    }
  >;
  AutoRebaseEnabledEvent: ResolverTypeWrapper<
    Omit<AutoRebaseEnabledEvent, "actor" | "enabler" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      enabler?: Maybe<ResolversTypes["User"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  AutoSquashEnabledEvent: ResolverTypeWrapper<
    Omit<AutoSquashEnabledEvent, "actor" | "enabler" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      enabler?: Maybe<ResolversTypes["User"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  AutomaticBaseChangeFailedEvent: ResolverTypeWrapper<
    Omit<AutomaticBaseChangeFailedEvent, "actor" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest: ResolversTypes["PullRequest"];
    }
  >;
  AutomaticBaseChangeSucceededEvent: ResolverTypeWrapper<
    Omit<AutomaticBaseChangeSucceededEvent, "actor" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest: ResolversTypes["PullRequest"];
    }
  >;
  Base64String: ResolverTypeWrapper<Scalars["Base64String"]["output"]>;
  BaseRefChangedEvent: ResolverTypeWrapper<
    Omit<BaseRefChangedEvent, "actor" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest: ResolversTypes["PullRequest"];
    }
  >;
  BaseRefDeletedEvent: ResolverTypeWrapper<
    Omit<BaseRefDeletedEvent, "actor" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  BaseRefForcePushedEvent: ResolverTypeWrapper<
    Omit<
      BaseRefForcePushedEvent,
      "actor" | "afterCommit" | "beforeCommit" | "pullRequest" | "ref"
    > & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      afterCommit?: Maybe<ResolversTypes["Commit"]>;
      beforeCommit?: Maybe<ResolversTypes["Commit"]>;
      pullRequest: ResolversTypes["PullRequest"];
      ref?: Maybe<ResolversTypes["Ref"]>;
    }
  >;
  BigInt: ResolverTypeWrapper<Scalars["BigInt"]["output"]>;
  Blame: ResolverTypeWrapper<
    Omit<Blame, "ranges"> & { ranges: Array<ResolversTypes["BlameRange"]> }
  >;
  BlameRange: ResolverTypeWrapper<
    Omit<BlameRange, "commit"> & { commit: ResolversTypes["Commit"] }
  >;
  Blob: ResolverTypeWrapper<
    Omit<Blob, "repository"> & { repository: ResolversTypes["Repository"] }
  >;
  Boolean: ResolverTypeWrapper<Scalars["Boolean"]["output"]>;
  Bot: ResolverTypeWrapper<Bot>;
  BranchActorAllowanceActor: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["BranchActorAllowanceActor"]
  >;
  BranchNamePatternParameters: ResolverTypeWrapper<BranchNamePatternParameters>;
  BranchNamePatternParametersInput: BranchNamePatternParametersInput;
  BranchProtectionRule: ResolverTypeWrapper<
    Omit<
      BranchProtectionRule,
      | "bypassForcePushAllowances"
      | "bypassPullRequestAllowances"
      | "creator"
      | "pushAllowances"
      | "repository"
      | "requiredStatusChecks"
      | "reviewDismissalAllowances"
    > & {
      bypassForcePushAllowances: ResolversTypes["BypassForcePushAllowanceConnection"];
      bypassPullRequestAllowances: ResolversTypes["BypassPullRequestAllowanceConnection"];
      creator?: Maybe<ResolversTypes["Actor"]>;
      pushAllowances: ResolversTypes["PushAllowanceConnection"];
      repository?: Maybe<ResolversTypes["Repository"]>;
      requiredStatusChecks?: Maybe<
        Array<ResolversTypes["RequiredStatusCheckDescription"]>
      >;
      reviewDismissalAllowances: ResolversTypes["ReviewDismissalAllowanceConnection"];
    }
  >;
  BranchProtectionRuleConflict: ResolverTypeWrapper<
    Omit<
      BranchProtectionRuleConflict,
      "branchProtectionRule" | "conflictingBranchProtectionRule" | "ref"
    > & {
      branchProtectionRule?: Maybe<ResolversTypes["BranchProtectionRule"]>;
      conflictingBranchProtectionRule?: Maybe<
        ResolversTypes["BranchProtectionRule"]
      >;
      ref?: Maybe<ResolversTypes["Ref"]>;
    }
  >;
  BranchProtectionRuleConflictConnection: ResolverTypeWrapper<BranchProtectionRuleConflictConnection>;
  BranchProtectionRuleConflictEdge: ResolverTypeWrapper<BranchProtectionRuleConflictEdge>;
  BranchProtectionRuleConnection: ResolverTypeWrapper<
    Omit<BranchProtectionRuleConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["BranchProtectionRuleEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["BranchProtectionRule"]>>>;
    }
  >;
  BranchProtectionRuleEdge: ResolverTypeWrapper<
    Omit<BranchProtectionRuleEdge, "node"> & {
      node?: Maybe<ResolversTypes["BranchProtectionRule"]>;
    }
  >;
  BulkSponsorship: BulkSponsorship;
  BypassActor: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["BypassActor"]
  >;
  BypassForcePushAllowance: ResolverTypeWrapper<
    Omit<BypassForcePushAllowance, "actor" | "branchProtectionRule"> & {
      actor?: Maybe<ResolversTypes["BranchActorAllowanceActor"]>;
      branchProtectionRule?: Maybe<ResolversTypes["BranchProtectionRule"]>;
    }
  >;
  BypassForcePushAllowanceConnection: ResolverTypeWrapper<
    Omit<BypassForcePushAllowanceConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["BypassForcePushAllowanceEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["BypassForcePushAllowance"]>>>;
    }
  >;
  BypassForcePushAllowanceEdge: ResolverTypeWrapper<
    Omit<BypassForcePushAllowanceEdge, "node"> & {
      node?: Maybe<ResolversTypes["BypassForcePushAllowance"]>;
    }
  >;
  BypassPullRequestAllowance: ResolverTypeWrapper<
    Omit<BypassPullRequestAllowance, "actor" | "branchProtectionRule"> & {
      actor?: Maybe<ResolversTypes["BranchActorAllowanceActor"]>;
      branchProtectionRule?: Maybe<ResolversTypes["BranchProtectionRule"]>;
    }
  >;
  BypassPullRequestAllowanceConnection: ResolverTypeWrapper<
    Omit<BypassPullRequestAllowanceConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["BypassPullRequestAllowanceEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["BypassPullRequestAllowance"]>>>;
    }
  >;
  BypassPullRequestAllowanceEdge: ResolverTypeWrapper<
    Omit<BypassPullRequestAllowanceEdge, "node"> & {
      node?: Maybe<ResolversTypes["BypassPullRequestAllowance"]>;
    }
  >;
  CVSS: ResolverTypeWrapper<Cvss>;
  CWE: ResolverTypeWrapper<Cwe>;
  CWEConnection: ResolverTypeWrapper<CweConnection>;
  CWEEdge: ResolverTypeWrapper<CweEdge>;
  CancelEnterpriseAdminInvitationInput: CancelEnterpriseAdminInvitationInput;
  CancelEnterpriseAdminInvitationPayload: ResolverTypeWrapper<
    Omit<CancelEnterpriseAdminInvitationPayload, "invitation"> & {
      invitation?: Maybe<ResolversTypes["EnterpriseAdministratorInvitation"]>;
    }
  >;
  CancelEnterpriseMemberInvitationInput: CancelEnterpriseMemberInvitationInput;
  CancelEnterpriseMemberInvitationPayload: ResolverTypeWrapper<
    Omit<CancelEnterpriseMemberInvitationPayload, "invitation"> & {
      invitation?: Maybe<ResolversTypes["EnterpriseMemberInvitation"]>;
    }
  >;
  CancelSponsorshipInput: CancelSponsorshipInput;
  CancelSponsorshipPayload: ResolverTypeWrapper<
    Omit<CancelSponsorshipPayload, "sponsorsTier"> & {
      sponsorsTier?: Maybe<ResolversTypes["SponsorsTier"]>;
    }
  >;
  ChangeUserStatusInput: ChangeUserStatusInput;
  ChangeUserStatusPayload: ResolverTypeWrapper<
    Omit<ChangeUserStatusPayload, "status"> & {
      status?: Maybe<ResolversTypes["UserStatus"]>;
    }
  >;
  CheckAnnotation: ResolverTypeWrapper<CheckAnnotation>;
  CheckAnnotationConnection: ResolverTypeWrapper<CheckAnnotationConnection>;
  CheckAnnotationData: CheckAnnotationData;
  CheckAnnotationEdge: ResolverTypeWrapper<CheckAnnotationEdge>;
  CheckAnnotationLevel: CheckAnnotationLevel;
  CheckAnnotationPosition: ResolverTypeWrapper<CheckAnnotationPosition>;
  CheckAnnotationRange: CheckAnnotationRange;
  CheckAnnotationSpan: ResolverTypeWrapper<CheckAnnotationSpan>;
  CheckConclusionState: CheckConclusionState;
  CheckRun: ResolverTypeWrapper<
    Omit<
      CheckRun,
      "checkSuite" | "deployment" | "pendingDeploymentRequest" | "repository"
    > & {
      checkSuite: ResolversTypes["CheckSuite"];
      deployment?: Maybe<ResolversTypes["Deployment"]>;
      pendingDeploymentRequest?: Maybe<ResolversTypes["DeploymentRequest"]>;
      repository: ResolversTypes["Repository"];
    }
  >;
  CheckRunAction: CheckRunAction;
  CheckRunConnection: ResolverTypeWrapper<
    Omit<CheckRunConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["CheckRunEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["CheckRun"]>>>;
    }
  >;
  CheckRunEdge: ResolverTypeWrapper<
    Omit<CheckRunEdge, "node"> & { node?: Maybe<ResolversTypes["CheckRun"]> }
  >;
  CheckRunFilter: CheckRunFilter;
  CheckRunOutput: CheckRunOutput;
  CheckRunOutputImage: CheckRunOutputImage;
  CheckRunState: CheckRunState;
  CheckRunStateCount: ResolverTypeWrapper<CheckRunStateCount>;
  CheckRunType: CheckRunType;
  CheckStatusState: CheckStatusState;
  CheckStep: ResolverTypeWrapper<CheckStep>;
  CheckStepConnection: ResolverTypeWrapper<CheckStepConnection>;
  CheckStepEdge: ResolverTypeWrapper<CheckStepEdge>;
  CheckSuite: ResolverTypeWrapper<
    Omit<
      CheckSuite,
      | "app"
      | "branch"
      | "checkRuns"
      | "commit"
      | "creator"
      | "matchingPullRequests"
      | "push"
      | "repository"
      | "workflowRun"
    > & {
      app?: Maybe<ResolversTypes["App"]>;
      branch?: Maybe<ResolversTypes["Ref"]>;
      checkRuns?: Maybe<ResolversTypes["CheckRunConnection"]>;
      commit: ResolversTypes["Commit"];
      creator?: Maybe<ResolversTypes["User"]>;
      matchingPullRequests?: Maybe<ResolversTypes["PullRequestConnection"]>;
      push?: Maybe<ResolversTypes["Push"]>;
      repository: ResolversTypes["Repository"];
      workflowRun?: Maybe<ResolversTypes["WorkflowRun"]>;
    }
  >;
  CheckSuiteAutoTriggerPreference: CheckSuiteAutoTriggerPreference;
  CheckSuiteConnection: ResolverTypeWrapper<
    Omit<CheckSuiteConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["CheckSuiteEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["CheckSuite"]>>>;
    }
  >;
  CheckSuiteEdge: ResolverTypeWrapper<
    Omit<CheckSuiteEdge, "node"> & {
      node?: Maybe<ResolversTypes["CheckSuite"]>;
    }
  >;
  CheckSuiteFilter: CheckSuiteFilter;
  Claimable: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["Claimable"]
  >;
  ClearLabelsFromLabelableInput: ClearLabelsFromLabelableInput;
  ClearLabelsFromLabelablePayload: ResolverTypeWrapper<
    Omit<ClearLabelsFromLabelablePayload, "labelable"> & {
      labelable?: Maybe<ResolversTypes["Labelable"]>;
    }
  >;
  ClearProjectV2ItemFieldValueInput: ClearProjectV2ItemFieldValueInput;
  ClearProjectV2ItemFieldValuePayload: ResolverTypeWrapper<
    Omit<ClearProjectV2ItemFieldValuePayload, "projectV2Item"> & {
      projectV2Item?: Maybe<ResolversTypes["ProjectV2Item"]>;
    }
  >;
  CloneProjectInput: CloneProjectInput;
  CloneProjectPayload: ResolverTypeWrapper<
    Omit<CloneProjectPayload, "project"> & {
      project?: Maybe<ResolversTypes["Project"]>;
    }
  >;
  CloneTemplateRepositoryInput: CloneTemplateRepositoryInput;
  CloneTemplateRepositoryPayload: ResolverTypeWrapper<
    Omit<CloneTemplateRepositoryPayload, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  Closable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Closable"]
  >;
  CloseDiscussionInput: CloseDiscussionInput;
  CloseDiscussionPayload: ResolverTypeWrapper<
    Omit<CloseDiscussionPayload, "discussion"> & {
      discussion?: Maybe<ResolversTypes["Discussion"]>;
    }
  >;
  CloseIssueInput: CloseIssueInput;
  CloseIssuePayload: ResolverTypeWrapper<
    Omit<CloseIssuePayload, "issue"> & {
      issue?: Maybe<ResolversTypes["Issue"]>;
    }
  >;
  ClosePullRequestInput: ClosePullRequestInput;
  ClosePullRequestPayload: ResolverTypeWrapper<
    Omit<ClosePullRequestPayload, "pullRequest"> & {
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  ClosedEvent: ResolverTypeWrapper<
    Omit<ClosedEvent, "actor" | "closable" | "closer"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      closable: ResolversTypes["Closable"];
      closer?: Maybe<ResolversTypes["Closer"]>;
    }
  >;
  Closer: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>["Closer"]>;
  CodeOfConduct: ResolverTypeWrapper<CodeOfConduct>;
  CodeScanningParameters: ResolverTypeWrapper<CodeScanningParameters>;
  CodeScanningParametersInput: CodeScanningParametersInput;
  CodeScanningTool: ResolverTypeWrapper<CodeScanningTool>;
  CodeScanningToolInput: CodeScanningToolInput;
  CollaboratorAffiliation: CollaboratorAffiliation;
  Comment: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Comment"]
  >;
  CommentAuthorAssociation: CommentAuthorAssociation;
  CommentCannotUpdateReason: CommentCannotUpdateReason;
  CommentDeletedEvent: ResolverTypeWrapper<
    Omit<CommentDeletedEvent, "actor" | "deletedCommentAuthor"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      deletedCommentAuthor?: Maybe<ResolversTypes["Actor"]>;
    }
  >;
  Commit: ResolverTypeWrapper<
    Omit<
      Commit,
      | "associatedPullRequests"
      | "blame"
      | "checkSuites"
      | "comments"
      | "deployments"
      | "file"
      | "history"
      | "onBehalfOf"
      | "parents"
      | "repository"
      | "signature"
      | "status"
      | "statusCheckRollup"
      | "tree"
    > & {
      associatedPullRequests?: Maybe<ResolversTypes["PullRequestConnection"]>;
      blame: ResolversTypes["Blame"];
      checkSuites?: Maybe<ResolversTypes["CheckSuiteConnection"]>;
      comments: ResolversTypes["CommitCommentConnection"];
      deployments?: Maybe<ResolversTypes["DeploymentConnection"]>;
      file?: Maybe<ResolversTypes["TreeEntry"]>;
      history: ResolversTypes["CommitHistoryConnection"];
      onBehalfOf?: Maybe<ResolversTypes["Organization"]>;
      parents: ResolversTypes["CommitConnection"];
      repository: ResolversTypes["Repository"];
      signature?: Maybe<ResolversTypes["GitSignature"]>;
      status?: Maybe<ResolversTypes["Status"]>;
      statusCheckRollup?: Maybe<ResolversTypes["StatusCheckRollup"]>;
      tree: ResolversTypes["Tree"];
    }
  >;
  CommitAuthor: CommitAuthor;
  CommitAuthorEmailPatternParameters: ResolverTypeWrapper<CommitAuthorEmailPatternParameters>;
  CommitAuthorEmailPatternParametersInput: CommitAuthorEmailPatternParametersInput;
  CommitComment: ResolverTypeWrapper<
    Omit<
      CommitComment,
      | "author"
      | "commit"
      | "editor"
      | "reactionGroups"
      | "reactions"
      | "repository"
      | "userContentEdits"
    > & {
      author?: Maybe<ResolversTypes["Actor"]>;
      commit?: Maybe<ResolversTypes["Commit"]>;
      editor?: Maybe<ResolversTypes["Actor"]>;
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      reactions: ResolversTypes["ReactionConnection"];
      repository: ResolversTypes["Repository"];
      userContentEdits?: Maybe<ResolversTypes["UserContentEditConnection"]>;
    }
  >;
  CommitCommentConnection: ResolverTypeWrapper<
    Omit<CommitCommentConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["CommitCommentEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["CommitComment"]>>>;
    }
  >;
  CommitCommentEdge: ResolverTypeWrapper<
    Omit<CommitCommentEdge, "node"> & {
      node?: Maybe<ResolversTypes["CommitComment"]>;
    }
  >;
  CommitCommentThread: ResolverTypeWrapper<
    Omit<CommitCommentThread, "comments" | "commit" | "repository"> & {
      comments: ResolversTypes["CommitCommentConnection"];
      commit?: Maybe<ResolversTypes["Commit"]>;
      repository: ResolversTypes["Repository"];
    }
  >;
  CommitConnection: ResolverTypeWrapper<
    Omit<CommitConnection, "nodes"> & {
      nodes?: Maybe<Array<Maybe<ResolversTypes["Commit"]>>>;
    }
  >;
  CommitContributionOrder: CommitContributionOrder;
  CommitContributionOrderField: CommitContributionOrderField;
  CommitContributionsByRepository: ResolverTypeWrapper<
    Omit<CommitContributionsByRepository, "contributions" | "repository"> & {
      contributions: ResolversTypes["CreatedCommitContributionConnection"];
      repository: ResolversTypes["Repository"];
    }
  >;
  CommitEdge: ResolverTypeWrapper<
    Omit<CommitEdge, "node"> & { node?: Maybe<ResolversTypes["Commit"]> }
  >;
  CommitHistoryConnection: ResolverTypeWrapper<
    Omit<CommitHistoryConnection, "nodes"> & {
      nodes?: Maybe<Array<Maybe<ResolversTypes["Commit"]>>>;
    }
  >;
  CommitMessage: CommitMessage;
  CommitMessagePatternParameters: ResolverTypeWrapper<CommitMessagePatternParameters>;
  CommitMessagePatternParametersInput: CommitMessagePatternParametersInput;
  CommittableBranch: CommittableBranch;
  CommitterEmailPatternParameters: ResolverTypeWrapper<CommitterEmailPatternParameters>;
  CommitterEmailPatternParametersInput: CommitterEmailPatternParametersInput;
  Comparison: ResolverTypeWrapper<
    Omit<Comparison, "baseTarget" | "headTarget"> & {
      baseTarget: ResolversTypes["GitObject"];
      headTarget: ResolversTypes["GitObject"];
    }
  >;
  ComparisonCommitConnection: ResolverTypeWrapper<
    Omit<ComparisonCommitConnection, "nodes"> & {
      nodes?: Maybe<Array<Maybe<ResolversTypes["Commit"]>>>;
    }
  >;
  ComparisonStatus: ComparisonStatus;
  ConnectedEvent: ResolverTypeWrapper<
    Omit<ConnectedEvent, "actor" | "source" | "subject"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      source: ResolversTypes["ReferencedSubject"];
      subject: ResolversTypes["ReferencedSubject"];
    }
  >;
  ContributingGuidelines: ResolverTypeWrapper<ContributingGuidelines>;
  Contribution: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Contribution"]
  >;
  ContributionCalendar: ResolverTypeWrapper<ContributionCalendar>;
  ContributionCalendarDay: ResolverTypeWrapper<ContributionCalendarDay>;
  ContributionCalendarMonth: ResolverTypeWrapper<ContributionCalendarMonth>;
  ContributionCalendarWeek: ResolverTypeWrapper<ContributionCalendarWeek>;
  ContributionLevel: ContributionLevel;
  ContributionOrder: ContributionOrder;
  ContributionsCollection: ResolverTypeWrapper<
    Omit<
      ContributionsCollection,
      | "commitContributionsByRepository"
      | "firstIssueContribution"
      | "firstPullRequestContribution"
      | "firstRepositoryContribution"
      | "issueContributions"
      | "issueContributionsByRepository"
      | "joinedGitHubContribution"
      | "mostRecentCollectionWithActivity"
      | "mostRecentCollectionWithoutActivity"
      | "popularIssueContribution"
      | "popularPullRequestContribution"
      | "pullRequestContributions"
      | "pullRequestContributionsByRepository"
      | "pullRequestReviewContributions"
      | "pullRequestReviewContributionsByRepository"
      | "repositoryContributions"
      | "user"
    > & {
      commitContributionsByRepository: Array<
        ResolversTypes["CommitContributionsByRepository"]
      >;
      firstIssueContribution?: Maybe<
        ResolversTypes["CreatedIssueOrRestrictedContribution"]
      >;
      firstPullRequestContribution?: Maybe<
        ResolversTypes["CreatedPullRequestOrRestrictedContribution"]
      >;
      firstRepositoryContribution?: Maybe<
        ResolversTypes["CreatedRepositoryOrRestrictedContribution"]
      >;
      issueContributions: ResolversTypes["CreatedIssueContributionConnection"];
      issueContributionsByRepository: Array<
        ResolversTypes["IssueContributionsByRepository"]
      >;
      joinedGitHubContribution?: Maybe<
        ResolversTypes["JoinedGitHubContribution"]
      >;
      mostRecentCollectionWithActivity?: Maybe<
        ResolversTypes["ContributionsCollection"]
      >;
      mostRecentCollectionWithoutActivity?: Maybe<
        ResolversTypes["ContributionsCollection"]
      >;
      popularIssueContribution?: Maybe<
        ResolversTypes["CreatedIssueContribution"]
      >;
      popularPullRequestContribution?: Maybe<
        ResolversTypes["CreatedPullRequestContribution"]
      >;
      pullRequestContributions: ResolversTypes["CreatedPullRequestContributionConnection"];
      pullRequestContributionsByRepository: Array<
        ResolversTypes["PullRequestContributionsByRepository"]
      >;
      pullRequestReviewContributions: ResolversTypes["CreatedPullRequestReviewContributionConnection"];
      pullRequestReviewContributionsByRepository: Array<
        ResolversTypes["PullRequestReviewContributionsByRepository"]
      >;
      repositoryContributions: ResolversTypes["CreatedRepositoryContributionConnection"];
      user: ResolversTypes["User"];
    }
  >;
  ConvertProjectCardNoteToIssueInput: ConvertProjectCardNoteToIssueInput;
  ConvertProjectCardNoteToIssuePayload: ResolverTypeWrapper<
    Omit<ConvertProjectCardNoteToIssuePayload, "projectCard"> & {
      projectCard?: Maybe<ResolversTypes["ProjectCard"]>;
    }
  >;
  ConvertProjectV2DraftIssueItemToIssueInput: ConvertProjectV2DraftIssueItemToIssueInput;
  ConvertProjectV2DraftIssueItemToIssuePayload: ResolverTypeWrapper<
    Omit<ConvertProjectV2DraftIssueItemToIssuePayload, "item"> & {
      item?: Maybe<ResolversTypes["ProjectV2Item"]>;
    }
  >;
  ConvertPullRequestToDraftInput: ConvertPullRequestToDraftInput;
  ConvertPullRequestToDraftPayload: ResolverTypeWrapper<
    Omit<ConvertPullRequestToDraftPayload, "pullRequest"> & {
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  ConvertToDraftEvent: ResolverTypeWrapper<
    Omit<ConvertToDraftEvent, "actor" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest: ResolversTypes["PullRequest"];
    }
  >;
  ConvertedNoteToIssueEvent: ResolverTypeWrapper<
    Omit<ConvertedNoteToIssueEvent, "actor" | "project" | "projectCard"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      project?: Maybe<ResolversTypes["Project"]>;
      projectCard?: Maybe<ResolversTypes["ProjectCard"]>;
    }
  >;
  ConvertedToDiscussionEvent: ResolverTypeWrapper<
    Omit<ConvertedToDiscussionEvent, "actor" | "discussion"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      discussion?: Maybe<ResolversTypes["Discussion"]>;
    }
  >;
  CopilotEndpoints: ResolverTypeWrapper<CopilotEndpoints>;
  CopyProjectV2Input: CopyProjectV2Input;
  CopyProjectV2Payload: ResolverTypeWrapper<
    Omit<CopyProjectV2Payload, "projectV2"> & {
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
    }
  >;
  CreateAttributionInvitationInput: CreateAttributionInvitationInput;
  CreateAttributionInvitationPayload: ResolverTypeWrapper<
    Omit<CreateAttributionInvitationPayload, "owner" | "source" | "target"> & {
      owner?: Maybe<ResolversTypes["Organization"]>;
      source?: Maybe<ResolversTypes["Claimable"]>;
      target?: Maybe<ResolversTypes["Claimable"]>;
    }
  >;
  CreateBranchProtectionRuleInput: CreateBranchProtectionRuleInput;
  CreateBranchProtectionRulePayload: ResolverTypeWrapper<
    Omit<CreateBranchProtectionRulePayload, "branchProtectionRule"> & {
      branchProtectionRule?: Maybe<ResolversTypes["BranchProtectionRule"]>;
    }
  >;
  CreateCheckRunInput: CreateCheckRunInput;
  CreateCheckRunPayload: ResolverTypeWrapper<
    Omit<CreateCheckRunPayload, "checkRun"> & {
      checkRun?: Maybe<ResolversTypes["CheckRun"]>;
    }
  >;
  CreateCheckSuiteInput: CreateCheckSuiteInput;
  CreateCheckSuitePayload: ResolverTypeWrapper<
    Omit<CreateCheckSuitePayload, "checkSuite"> & {
      checkSuite?: Maybe<ResolversTypes["CheckSuite"]>;
    }
  >;
  CreateCommitOnBranchInput: CreateCommitOnBranchInput;
  CreateCommitOnBranchPayload: ResolverTypeWrapper<
    Omit<CreateCommitOnBranchPayload, "commit" | "ref"> & {
      commit?: Maybe<ResolversTypes["Commit"]>;
      ref?: Maybe<ResolversTypes["Ref"]>;
    }
  >;
  CreateDeploymentInput: CreateDeploymentInput;
  CreateDeploymentPayload: ResolverTypeWrapper<
    Omit<CreateDeploymentPayload, "deployment"> & {
      deployment?: Maybe<ResolversTypes["Deployment"]>;
    }
  >;
  CreateDeploymentStatusInput: CreateDeploymentStatusInput;
  CreateDeploymentStatusPayload: ResolverTypeWrapper<
    Omit<CreateDeploymentStatusPayload, "deploymentStatus"> & {
      deploymentStatus?: Maybe<ResolversTypes["DeploymentStatus"]>;
    }
  >;
  CreateDiscussionInput: CreateDiscussionInput;
  CreateDiscussionPayload: ResolverTypeWrapper<
    Omit<CreateDiscussionPayload, "discussion"> & {
      discussion?: Maybe<ResolversTypes["Discussion"]>;
    }
  >;
  CreateEnterpriseOrganizationInput: CreateEnterpriseOrganizationInput;
  CreateEnterpriseOrganizationPayload: ResolverTypeWrapper<
    Omit<CreateEnterpriseOrganizationPayload, "enterprise" | "organization"> & {
      enterprise?: Maybe<ResolversTypes["Enterprise"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
    }
  >;
  CreateEnvironmentInput: CreateEnvironmentInput;
  CreateEnvironmentPayload: ResolverTypeWrapper<
    Omit<CreateEnvironmentPayload, "environment"> & {
      environment?: Maybe<ResolversTypes["Environment"]>;
    }
  >;
  CreateIpAllowListEntryInput: CreateIpAllowListEntryInput;
  CreateIpAllowListEntryPayload: ResolverTypeWrapper<
    Omit<CreateIpAllowListEntryPayload, "ipAllowListEntry"> & {
      ipAllowListEntry?: Maybe<ResolversTypes["IpAllowListEntry"]>;
    }
  >;
  CreateIssueInput: CreateIssueInput;
  CreateIssuePayload: ResolverTypeWrapper<
    Omit<CreateIssuePayload, "issue"> & {
      issue?: Maybe<ResolversTypes["Issue"]>;
    }
  >;
  CreateLabelInput: CreateLabelInput;
  CreateLabelPayload: ResolverTypeWrapper<
    Omit<CreateLabelPayload, "label"> & {
      label?: Maybe<ResolversTypes["Label"]>;
    }
  >;
  CreateLinkedBranchInput: CreateLinkedBranchInput;
  CreateLinkedBranchPayload: ResolverTypeWrapper<
    Omit<CreateLinkedBranchPayload, "issue"> & {
      issue?: Maybe<ResolversTypes["Issue"]>;
    }
  >;
  CreateMigrationSourceInput: CreateMigrationSourceInput;
  CreateMigrationSourcePayload: ResolverTypeWrapper<CreateMigrationSourcePayload>;
  CreateProjectInput: CreateProjectInput;
  CreateProjectPayload: ResolverTypeWrapper<
    Omit<CreateProjectPayload, "project"> & {
      project?: Maybe<ResolversTypes["Project"]>;
    }
  >;
  CreateProjectV2FieldInput: CreateProjectV2FieldInput;
  CreateProjectV2FieldPayload: ResolverTypeWrapper<
    Omit<CreateProjectV2FieldPayload, "projectV2Field"> & {
      projectV2Field?: Maybe<ResolversTypes["ProjectV2FieldConfiguration"]>;
    }
  >;
  CreateProjectV2Input: CreateProjectV2Input;
  CreateProjectV2Payload: ResolverTypeWrapper<
    Omit<CreateProjectV2Payload, "projectV2"> & {
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
    }
  >;
  CreateProjectV2StatusUpdateInput: CreateProjectV2StatusUpdateInput;
  CreateProjectV2StatusUpdatePayload: ResolverTypeWrapper<
    Omit<CreateProjectV2StatusUpdatePayload, "statusUpdate"> & {
      statusUpdate?: Maybe<ResolversTypes["ProjectV2StatusUpdate"]>;
    }
  >;
  CreatePullRequestInput: CreatePullRequestInput;
  CreatePullRequestPayload: ResolverTypeWrapper<
    Omit<CreatePullRequestPayload, "pullRequest"> & {
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  CreateRefInput: CreateRefInput;
  CreateRefPayload: ResolverTypeWrapper<
    Omit<CreateRefPayload, "ref"> & { ref?: Maybe<ResolversTypes["Ref"]> }
  >;
  CreateRepositoryInput: CreateRepositoryInput;
  CreateRepositoryPayload: ResolverTypeWrapper<
    Omit<CreateRepositoryPayload, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  CreateRepositoryRulesetInput: CreateRepositoryRulesetInput;
  CreateRepositoryRulesetPayload: ResolverTypeWrapper<
    Omit<CreateRepositoryRulesetPayload, "ruleset"> & {
      ruleset?: Maybe<ResolversTypes["RepositoryRuleset"]>;
    }
  >;
  CreateSponsorsListingInput: CreateSponsorsListingInput;
  CreateSponsorsListingPayload: ResolverTypeWrapper<
    Omit<CreateSponsorsListingPayload, "sponsorsListing"> & {
      sponsorsListing?: Maybe<ResolversTypes["SponsorsListing"]>;
    }
  >;
  CreateSponsorsTierInput: CreateSponsorsTierInput;
  CreateSponsorsTierPayload: ResolverTypeWrapper<
    Omit<CreateSponsorsTierPayload, "sponsorsTier"> & {
      sponsorsTier?: Maybe<ResolversTypes["SponsorsTier"]>;
    }
  >;
  CreateSponsorshipInput: CreateSponsorshipInput;
  CreateSponsorshipPayload: ResolverTypeWrapper<
    Omit<CreateSponsorshipPayload, "sponsorship"> & {
      sponsorship?: Maybe<ResolversTypes["Sponsorship"]>;
    }
  >;
  CreateSponsorshipsInput: CreateSponsorshipsInput;
  CreateSponsorshipsPayload: ResolverTypeWrapper<
    Omit<CreateSponsorshipsPayload, "sponsorables"> & {
      sponsorables?: Maybe<Array<ResolversTypes["Sponsorable"]>>;
    }
  >;
  CreateTeamDiscussionCommentInput: CreateTeamDiscussionCommentInput;
  CreateTeamDiscussionCommentPayload: ResolverTypeWrapper<
    Omit<CreateTeamDiscussionCommentPayload, "teamDiscussionComment"> & {
      teamDiscussionComment?: Maybe<ResolversTypes["TeamDiscussionComment"]>;
    }
  >;
  CreateTeamDiscussionInput: CreateTeamDiscussionInput;
  CreateTeamDiscussionPayload: ResolverTypeWrapper<
    Omit<CreateTeamDiscussionPayload, "teamDiscussion"> & {
      teamDiscussion?: Maybe<ResolversTypes["TeamDiscussion"]>;
    }
  >;
  CreateUserListInput: CreateUserListInput;
  CreateUserListPayload: ResolverTypeWrapper<
    Omit<CreateUserListPayload, "list" | "viewer"> & {
      list?: Maybe<ResolversTypes["UserList"]>;
      viewer?: Maybe<ResolversTypes["User"]>;
    }
  >;
  CreatedCommitContribution: ResolverTypeWrapper<
    Omit<CreatedCommitContribution, "repository" | "user"> & {
      repository: ResolversTypes["Repository"];
      user: ResolversTypes["User"];
    }
  >;
  CreatedCommitContributionConnection: ResolverTypeWrapper<
    Omit<CreatedCommitContributionConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["CreatedCommitContributionEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["CreatedCommitContribution"]>>>;
    }
  >;
  CreatedCommitContributionEdge: ResolverTypeWrapper<
    Omit<CreatedCommitContributionEdge, "node"> & {
      node?: Maybe<ResolversTypes["CreatedCommitContribution"]>;
    }
  >;
  CreatedIssueContribution: ResolverTypeWrapper<
    Omit<CreatedIssueContribution, "issue" | "user"> & {
      issue: ResolversTypes["Issue"];
      user: ResolversTypes["User"];
    }
  >;
  CreatedIssueContributionConnection: ResolverTypeWrapper<
    Omit<CreatedIssueContributionConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["CreatedIssueContributionEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["CreatedIssueContribution"]>>>;
    }
  >;
  CreatedIssueContributionEdge: ResolverTypeWrapper<
    Omit<CreatedIssueContributionEdge, "node"> & {
      node?: Maybe<ResolversTypes["CreatedIssueContribution"]>;
    }
  >;
  CreatedIssueOrRestrictedContribution: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["CreatedIssueOrRestrictedContribution"]
  >;
  CreatedPullRequestContribution: ResolverTypeWrapper<
    Omit<CreatedPullRequestContribution, "pullRequest" | "user"> & {
      pullRequest: ResolversTypes["PullRequest"];
      user: ResolversTypes["User"];
    }
  >;
  CreatedPullRequestContributionConnection: ResolverTypeWrapper<
    Omit<CreatedPullRequestContributionConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["CreatedPullRequestContributionEdge"]>>
      >;
      nodes?: Maybe<
        Array<Maybe<ResolversTypes["CreatedPullRequestContribution"]>>
      >;
    }
  >;
  CreatedPullRequestContributionEdge: ResolverTypeWrapper<
    Omit<CreatedPullRequestContributionEdge, "node"> & {
      node?: Maybe<ResolversTypes["CreatedPullRequestContribution"]>;
    }
  >;
  CreatedPullRequestOrRestrictedContribution: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["CreatedPullRequestOrRestrictedContribution"]
  >;
  CreatedPullRequestReviewContribution: ResolverTypeWrapper<
    Omit<
      CreatedPullRequestReviewContribution,
      "pullRequest" | "pullRequestReview" | "repository" | "user"
    > & {
      pullRequest: ResolversTypes["PullRequest"];
      pullRequestReview: ResolversTypes["PullRequestReview"];
      repository: ResolversTypes["Repository"];
      user: ResolversTypes["User"];
    }
  >;
  CreatedPullRequestReviewContributionConnection: ResolverTypeWrapper<
    Omit<CreatedPullRequestReviewContributionConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["CreatedPullRequestReviewContributionEdge"]>>
      >;
      nodes?: Maybe<
        Array<Maybe<ResolversTypes["CreatedPullRequestReviewContribution"]>>
      >;
    }
  >;
  CreatedPullRequestReviewContributionEdge: ResolverTypeWrapper<
    Omit<CreatedPullRequestReviewContributionEdge, "node"> & {
      node?: Maybe<ResolversTypes["CreatedPullRequestReviewContribution"]>;
    }
  >;
  CreatedRepositoryContribution: ResolverTypeWrapper<
    Omit<CreatedRepositoryContribution, "repository" | "user"> & {
      repository: ResolversTypes["Repository"];
      user: ResolversTypes["User"];
    }
  >;
  CreatedRepositoryContributionConnection: ResolverTypeWrapper<
    Omit<CreatedRepositoryContributionConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["CreatedRepositoryContributionEdge"]>>
      >;
      nodes?: Maybe<
        Array<Maybe<ResolversTypes["CreatedRepositoryContribution"]>>
      >;
    }
  >;
  CreatedRepositoryContributionEdge: ResolverTypeWrapper<
    Omit<CreatedRepositoryContributionEdge, "node"> & {
      node?: Maybe<ResolversTypes["CreatedRepositoryContribution"]>;
    }
  >;
  CreatedRepositoryOrRestrictedContribution: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["CreatedRepositoryOrRestrictedContribution"]
  >;
  CrossReferencedEvent: ResolverTypeWrapper<
    Omit<CrossReferencedEvent, "actor" | "source" | "target"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      source: ResolversTypes["ReferencedSubject"];
      target: ResolversTypes["ReferencedSubject"];
    }
  >;
  Date: ResolverTypeWrapper<Scalars["Date"]["output"]>;
  DateTime: ResolverTypeWrapper<Scalars["DateTime"]["output"]>;
  DeclineTopicSuggestionInput: DeclineTopicSuggestionInput;
  DeclineTopicSuggestionPayload: ResolverTypeWrapper<
    Omit<DeclineTopicSuggestionPayload, "topic"> & {
      topic?: Maybe<ResolversTypes["Topic"]>;
    }
  >;
  DefaultRepositoryPermissionField: DefaultRepositoryPermissionField;
  Deletable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Deletable"]
  >;
  DeleteBranchProtectionRuleInput: DeleteBranchProtectionRuleInput;
  DeleteBranchProtectionRulePayload: ResolverTypeWrapper<DeleteBranchProtectionRulePayload>;
  DeleteDeploymentInput: DeleteDeploymentInput;
  DeleteDeploymentPayload: ResolverTypeWrapper<DeleteDeploymentPayload>;
  DeleteDiscussionCommentInput: DeleteDiscussionCommentInput;
  DeleteDiscussionCommentPayload: ResolverTypeWrapper<
    Omit<DeleteDiscussionCommentPayload, "comment"> & {
      comment?: Maybe<ResolversTypes["DiscussionComment"]>;
    }
  >;
  DeleteDiscussionInput: DeleteDiscussionInput;
  DeleteDiscussionPayload: ResolverTypeWrapper<
    Omit<DeleteDiscussionPayload, "discussion"> & {
      discussion?: Maybe<ResolversTypes["Discussion"]>;
    }
  >;
  DeleteEnvironmentInput: DeleteEnvironmentInput;
  DeleteEnvironmentPayload: ResolverTypeWrapper<DeleteEnvironmentPayload>;
  DeleteIpAllowListEntryInput: DeleteIpAllowListEntryInput;
  DeleteIpAllowListEntryPayload: ResolverTypeWrapper<
    Omit<DeleteIpAllowListEntryPayload, "ipAllowListEntry"> & {
      ipAllowListEntry?: Maybe<ResolversTypes["IpAllowListEntry"]>;
    }
  >;
  DeleteIssueCommentInput: DeleteIssueCommentInput;
  DeleteIssueCommentPayload: ResolverTypeWrapper<DeleteIssueCommentPayload>;
  DeleteIssueInput: DeleteIssueInput;
  DeleteIssuePayload: ResolverTypeWrapper<
    Omit<DeleteIssuePayload, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  DeleteLabelInput: DeleteLabelInput;
  DeleteLabelPayload: ResolverTypeWrapper<DeleteLabelPayload>;
  DeleteLinkedBranchInput: DeleteLinkedBranchInput;
  DeleteLinkedBranchPayload: ResolverTypeWrapper<
    Omit<DeleteLinkedBranchPayload, "issue"> & {
      issue?: Maybe<ResolversTypes["Issue"]>;
    }
  >;
  DeletePackageVersionInput: DeletePackageVersionInput;
  DeletePackageVersionPayload: ResolverTypeWrapper<DeletePackageVersionPayload>;
  DeleteProjectCardInput: DeleteProjectCardInput;
  DeleteProjectCardPayload: ResolverTypeWrapper<
    Omit<DeleteProjectCardPayload, "column"> & {
      column?: Maybe<ResolversTypes["ProjectColumn"]>;
    }
  >;
  DeleteProjectColumnInput: DeleteProjectColumnInput;
  DeleteProjectColumnPayload: ResolverTypeWrapper<
    Omit<DeleteProjectColumnPayload, "project"> & {
      project?: Maybe<ResolversTypes["Project"]>;
    }
  >;
  DeleteProjectInput: DeleteProjectInput;
  DeleteProjectPayload: ResolverTypeWrapper<
    Omit<DeleteProjectPayload, "owner"> & {
      owner?: Maybe<ResolversTypes["ProjectOwner"]>;
    }
  >;
  DeleteProjectV2FieldInput: DeleteProjectV2FieldInput;
  DeleteProjectV2FieldPayload: ResolverTypeWrapper<
    Omit<DeleteProjectV2FieldPayload, "projectV2Field"> & {
      projectV2Field?: Maybe<ResolversTypes["ProjectV2FieldConfiguration"]>;
    }
  >;
  DeleteProjectV2Input: DeleteProjectV2Input;
  DeleteProjectV2ItemInput: DeleteProjectV2ItemInput;
  DeleteProjectV2ItemPayload: ResolverTypeWrapper<DeleteProjectV2ItemPayload>;
  DeleteProjectV2Payload: ResolverTypeWrapper<
    Omit<DeleteProjectV2Payload, "projectV2"> & {
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
    }
  >;
  DeleteProjectV2StatusUpdateInput: DeleteProjectV2StatusUpdateInput;
  DeleteProjectV2StatusUpdatePayload: ResolverTypeWrapper<
    Omit<DeleteProjectV2StatusUpdatePayload, "projectV2"> & {
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
    }
  >;
  DeleteProjectV2WorkflowInput: DeleteProjectV2WorkflowInput;
  DeleteProjectV2WorkflowPayload: ResolverTypeWrapper<
    Omit<DeleteProjectV2WorkflowPayload, "projectV2"> & {
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
    }
  >;
  DeletePullRequestReviewCommentInput: DeletePullRequestReviewCommentInput;
  DeletePullRequestReviewCommentPayload: ResolverTypeWrapper<
    Omit<
      DeletePullRequestReviewCommentPayload,
      "pullRequestReview" | "pullRequestReviewComment"
    > & {
      pullRequestReview?: Maybe<ResolversTypes["PullRequestReview"]>;
      pullRequestReviewComment?: Maybe<
        ResolversTypes["PullRequestReviewComment"]
      >;
    }
  >;
  DeletePullRequestReviewInput: DeletePullRequestReviewInput;
  DeletePullRequestReviewPayload: ResolverTypeWrapper<
    Omit<DeletePullRequestReviewPayload, "pullRequestReview"> & {
      pullRequestReview?: Maybe<ResolversTypes["PullRequestReview"]>;
    }
  >;
  DeleteRefInput: DeleteRefInput;
  DeleteRefPayload: ResolverTypeWrapper<DeleteRefPayload>;
  DeleteRepositoryRulesetInput: DeleteRepositoryRulesetInput;
  DeleteRepositoryRulesetPayload: ResolverTypeWrapper<DeleteRepositoryRulesetPayload>;
  DeleteTeamDiscussionCommentInput: DeleteTeamDiscussionCommentInput;
  DeleteTeamDiscussionCommentPayload: ResolverTypeWrapper<DeleteTeamDiscussionCommentPayload>;
  DeleteTeamDiscussionInput: DeleteTeamDiscussionInput;
  DeleteTeamDiscussionPayload: ResolverTypeWrapper<DeleteTeamDiscussionPayload>;
  DeleteUserListInput: DeleteUserListInput;
  DeleteUserListPayload: ResolverTypeWrapper<
    Omit<DeleteUserListPayload, "user"> & {
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  DeleteVerifiableDomainInput: DeleteVerifiableDomainInput;
  DeleteVerifiableDomainPayload: ResolverTypeWrapper<
    Omit<DeleteVerifiableDomainPayload, "owner"> & {
      owner?: Maybe<ResolversTypes["VerifiableDomainOwner"]>;
    }
  >;
  DemilestonedEvent: ResolverTypeWrapper<
    Omit<DemilestonedEvent, "actor" | "subject"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      subject: ResolversTypes["MilestoneItem"];
    }
  >;
  DependabotUpdate: ResolverTypeWrapper<
    Omit<DependabotUpdate, "error" | "pullRequest" | "repository"> & {
      error?: Maybe<ResolversTypes["DependabotUpdateError"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
      repository: ResolversTypes["Repository"];
    }
  >;
  DependabotUpdateError: ResolverTypeWrapper<DependabotUpdateError>;
  DependencyGraphDependency: ResolverTypeWrapper<
    Omit<DependencyGraphDependency, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  DependencyGraphDependencyConnection: ResolverTypeWrapper<
    Omit<DependencyGraphDependencyConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["DependencyGraphDependencyEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["DependencyGraphDependency"]>>>;
    }
  >;
  DependencyGraphDependencyEdge: ResolverTypeWrapper<
    Omit<DependencyGraphDependencyEdge, "node"> & {
      node?: Maybe<ResolversTypes["DependencyGraphDependency"]>;
    }
  >;
  DependencyGraphEcosystem: DependencyGraphEcosystem;
  DependencyGraphManifest: ResolverTypeWrapper<
    Omit<DependencyGraphManifest, "dependencies" | "repository"> & {
      dependencies?: Maybe<
        ResolversTypes["DependencyGraphDependencyConnection"]
      >;
      repository: ResolversTypes["Repository"];
    }
  >;
  DependencyGraphManifestConnection: ResolverTypeWrapper<
    Omit<DependencyGraphManifestConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["DependencyGraphManifestEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["DependencyGraphManifest"]>>>;
    }
  >;
  DependencyGraphManifestEdge: ResolverTypeWrapper<
    Omit<DependencyGraphManifestEdge, "node"> & {
      node?: Maybe<ResolversTypes["DependencyGraphManifest"]>;
    }
  >;
  DeployKey: ResolverTypeWrapper<DeployKey>;
  DeployKeyConnection: ResolverTypeWrapper<DeployKeyConnection>;
  DeployKeyEdge: ResolverTypeWrapper<DeployKeyEdge>;
  DeployedEvent: ResolverTypeWrapper<
    Omit<DeployedEvent, "actor" | "deployment" | "pullRequest" | "ref"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      deployment: ResolversTypes["Deployment"];
      pullRequest: ResolversTypes["PullRequest"];
      ref?: Maybe<ResolversTypes["Ref"]>;
    }
  >;
  Deployment: ResolverTypeWrapper<
    Omit<
      Deployment,
      "commit" | "creator" | "latestStatus" | "ref" | "repository" | "statuses"
    > & {
      commit?: Maybe<ResolversTypes["Commit"]>;
      creator: ResolversTypes["Actor"];
      latestStatus?: Maybe<ResolversTypes["DeploymentStatus"]>;
      ref?: Maybe<ResolversTypes["Ref"]>;
      repository: ResolversTypes["Repository"];
      statuses?: Maybe<ResolversTypes["DeploymentStatusConnection"]>;
    }
  >;
  DeploymentConnection: ResolverTypeWrapper<
    Omit<DeploymentConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["DeploymentEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Deployment"]>>>;
    }
  >;
  DeploymentEdge: ResolverTypeWrapper<
    Omit<DeploymentEdge, "node"> & {
      node?: Maybe<ResolversTypes["Deployment"]>;
    }
  >;
  DeploymentEnvironmentChangedEvent: ResolverTypeWrapper<
    Omit<
      DeploymentEnvironmentChangedEvent,
      "actor" | "deploymentStatus" | "pullRequest"
    > & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      deploymentStatus: ResolversTypes["DeploymentStatus"];
      pullRequest: ResolversTypes["PullRequest"];
    }
  >;
  DeploymentOrder: DeploymentOrder;
  DeploymentOrderField: DeploymentOrderField;
  DeploymentProtectionRule: ResolverTypeWrapper<
    Omit<DeploymentProtectionRule, "reviewers"> & {
      reviewers: ResolversTypes["DeploymentReviewerConnection"];
    }
  >;
  DeploymentProtectionRuleConnection: ResolverTypeWrapper<
    Omit<DeploymentProtectionRuleConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["DeploymentProtectionRuleEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["DeploymentProtectionRule"]>>>;
    }
  >;
  DeploymentProtectionRuleEdge: ResolverTypeWrapper<
    Omit<DeploymentProtectionRuleEdge, "node"> & {
      node?: Maybe<ResolversTypes["DeploymentProtectionRule"]>;
    }
  >;
  DeploymentProtectionRuleType: DeploymentProtectionRuleType;
  DeploymentRequest: ResolverTypeWrapper<
    Omit<DeploymentRequest, "environment" | "reviewers"> & {
      environment: ResolversTypes["Environment"];
      reviewers: ResolversTypes["DeploymentReviewerConnection"];
    }
  >;
  DeploymentRequestConnection: ResolverTypeWrapper<
    Omit<DeploymentRequestConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["DeploymentRequestEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["DeploymentRequest"]>>>;
    }
  >;
  DeploymentRequestEdge: ResolverTypeWrapper<
    Omit<DeploymentRequestEdge, "node"> & {
      node?: Maybe<ResolversTypes["DeploymentRequest"]>;
    }
  >;
  DeploymentReview: ResolverTypeWrapper<
    Omit<DeploymentReview, "environments" | "user"> & {
      environments: ResolversTypes["EnvironmentConnection"];
      user: ResolversTypes["User"];
    }
  >;
  DeploymentReviewConnection: ResolverTypeWrapper<
    Omit<DeploymentReviewConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["DeploymentReviewEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["DeploymentReview"]>>>;
    }
  >;
  DeploymentReviewEdge: ResolverTypeWrapper<
    Omit<DeploymentReviewEdge, "node"> & {
      node?: Maybe<ResolversTypes["DeploymentReview"]>;
    }
  >;
  DeploymentReviewState: DeploymentReviewState;
  DeploymentReviewer: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["DeploymentReviewer"]
  >;
  DeploymentReviewerConnection: ResolverTypeWrapper<
    Omit<DeploymentReviewerConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["DeploymentReviewerEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["DeploymentReviewer"]>>>;
    }
  >;
  DeploymentReviewerEdge: ResolverTypeWrapper<
    Omit<DeploymentReviewerEdge, "node"> & {
      node?: Maybe<ResolversTypes["DeploymentReviewer"]>;
    }
  >;
  DeploymentState: DeploymentState;
  DeploymentStatus: ResolverTypeWrapper<
    Omit<DeploymentStatus, "creator" | "deployment"> & {
      creator: ResolversTypes["Actor"];
      deployment: ResolversTypes["Deployment"];
    }
  >;
  DeploymentStatusConnection: ResolverTypeWrapper<
    Omit<DeploymentStatusConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["DeploymentStatusEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["DeploymentStatus"]>>>;
    }
  >;
  DeploymentStatusEdge: ResolverTypeWrapper<
    Omit<DeploymentStatusEdge, "node"> & {
      node?: Maybe<ResolversTypes["DeploymentStatus"]>;
    }
  >;
  DeploymentStatusState: DeploymentStatusState;
  DequeuePullRequestInput: DequeuePullRequestInput;
  DequeuePullRequestPayload: ResolverTypeWrapper<
    Omit<DequeuePullRequestPayload, "mergeQueueEntry"> & {
      mergeQueueEntry?: Maybe<ResolversTypes["MergeQueueEntry"]>;
    }
  >;
  DiffSide: DiffSide;
  DisablePullRequestAutoMergeInput: DisablePullRequestAutoMergeInput;
  DisablePullRequestAutoMergePayload: ResolverTypeWrapper<
    Omit<DisablePullRequestAutoMergePayload, "actor" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  DisconnectedEvent: ResolverTypeWrapper<
    Omit<DisconnectedEvent, "actor" | "source" | "subject"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      source: ResolversTypes["ReferencedSubject"];
      subject: ResolversTypes["ReferencedSubject"];
    }
  >;
  Discussion: ResolverTypeWrapper<
    Omit<
      Discussion,
      | "answer"
      | "answerChosenBy"
      | "author"
      | "category"
      | "comments"
      | "editor"
      | "labels"
      | "poll"
      | "reactionGroups"
      | "reactions"
      | "repository"
      | "userContentEdits"
    > & {
      answer?: Maybe<ResolversTypes["DiscussionComment"]>;
      answerChosenBy?: Maybe<ResolversTypes["Actor"]>;
      author?: Maybe<ResolversTypes["Actor"]>;
      category: ResolversTypes["DiscussionCategory"];
      comments: ResolversTypes["DiscussionCommentConnection"];
      editor?: Maybe<ResolversTypes["Actor"]>;
      labels?: Maybe<ResolversTypes["LabelConnection"]>;
      poll?: Maybe<ResolversTypes["DiscussionPoll"]>;
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      reactions: ResolversTypes["ReactionConnection"];
      repository: ResolversTypes["Repository"];
      userContentEdits?: Maybe<ResolversTypes["UserContentEditConnection"]>;
    }
  >;
  DiscussionCategory: ResolverTypeWrapper<
    Omit<DiscussionCategory, "repository"> & {
      repository: ResolversTypes["Repository"];
    }
  >;
  DiscussionCategoryConnection: ResolverTypeWrapper<
    Omit<DiscussionCategoryConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["DiscussionCategoryEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["DiscussionCategory"]>>>;
    }
  >;
  DiscussionCategoryEdge: ResolverTypeWrapper<
    Omit<DiscussionCategoryEdge, "node"> & {
      node?: Maybe<ResolversTypes["DiscussionCategory"]>;
    }
  >;
  DiscussionCloseReason: DiscussionCloseReason;
  DiscussionComment: ResolverTypeWrapper<
    Omit<
      DiscussionComment,
      | "author"
      | "discussion"
      | "editor"
      | "reactionGroups"
      | "reactions"
      | "replies"
      | "replyTo"
      | "userContentEdits"
    > & {
      author?: Maybe<ResolversTypes["Actor"]>;
      discussion?: Maybe<ResolversTypes["Discussion"]>;
      editor?: Maybe<ResolversTypes["Actor"]>;
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      reactions: ResolversTypes["ReactionConnection"];
      replies: ResolversTypes["DiscussionCommentConnection"];
      replyTo?: Maybe<ResolversTypes["DiscussionComment"]>;
      userContentEdits?: Maybe<ResolversTypes["UserContentEditConnection"]>;
    }
  >;
  DiscussionCommentConnection: ResolverTypeWrapper<
    Omit<DiscussionCommentConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["DiscussionCommentEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["DiscussionComment"]>>>;
    }
  >;
  DiscussionCommentEdge: ResolverTypeWrapper<
    Omit<DiscussionCommentEdge, "node"> & {
      node?: Maybe<ResolversTypes["DiscussionComment"]>;
    }
  >;
  DiscussionConnection: ResolverTypeWrapper<
    Omit<DiscussionConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["DiscussionEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Discussion"]>>>;
    }
  >;
  DiscussionEdge: ResolverTypeWrapper<
    Omit<DiscussionEdge, "node"> & {
      node?: Maybe<ResolversTypes["Discussion"]>;
    }
  >;
  DiscussionOrder: DiscussionOrder;
  DiscussionOrderField: DiscussionOrderField;
  DiscussionPoll: ResolverTypeWrapper<
    Omit<DiscussionPoll, "discussion" | "options"> & {
      discussion?: Maybe<ResolversTypes["Discussion"]>;
      options?: Maybe<ResolversTypes["DiscussionPollOptionConnection"]>;
    }
  >;
  DiscussionPollOption: ResolverTypeWrapper<
    Omit<DiscussionPollOption, "poll"> & {
      poll?: Maybe<ResolversTypes["DiscussionPoll"]>;
    }
  >;
  DiscussionPollOptionConnection: ResolverTypeWrapper<
    Omit<DiscussionPollOptionConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["DiscussionPollOptionEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["DiscussionPollOption"]>>>;
    }
  >;
  DiscussionPollOptionEdge: ResolverTypeWrapper<
    Omit<DiscussionPollOptionEdge, "node"> & {
      node?: Maybe<ResolversTypes["DiscussionPollOption"]>;
    }
  >;
  DiscussionPollOptionOrder: DiscussionPollOptionOrder;
  DiscussionPollOptionOrderField: DiscussionPollOptionOrderField;
  DiscussionState: DiscussionState;
  DiscussionStateReason: DiscussionStateReason;
  DismissPullRequestReviewInput: DismissPullRequestReviewInput;
  DismissPullRequestReviewPayload: ResolverTypeWrapper<
    Omit<DismissPullRequestReviewPayload, "pullRequestReview"> & {
      pullRequestReview?: Maybe<ResolversTypes["PullRequestReview"]>;
    }
  >;
  DismissReason: DismissReason;
  DismissRepositoryVulnerabilityAlertInput: DismissRepositoryVulnerabilityAlertInput;
  DismissRepositoryVulnerabilityAlertPayload: ResolverTypeWrapper<
    Omit<
      DismissRepositoryVulnerabilityAlertPayload,
      "repositoryVulnerabilityAlert"
    > & {
      repositoryVulnerabilityAlert?: Maybe<
        ResolversTypes["RepositoryVulnerabilityAlert"]
      >;
    }
  >;
  DraftIssue: ResolverTypeWrapper<
    Omit<DraftIssue, "creator" | "projectV2Items" | "projectsV2"> & {
      creator?: Maybe<ResolversTypes["Actor"]>;
      projectV2Items: ResolversTypes["ProjectV2ItemConnection"];
      projectsV2: ResolversTypes["ProjectV2Connection"];
    }
  >;
  DraftPullRequestReviewComment: DraftPullRequestReviewComment;
  DraftPullRequestReviewThread: DraftPullRequestReviewThread;
  EnablePullRequestAutoMergeInput: EnablePullRequestAutoMergeInput;
  EnablePullRequestAutoMergePayload: ResolverTypeWrapper<
    Omit<EnablePullRequestAutoMergePayload, "actor" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  EnqueuePullRequestInput: EnqueuePullRequestInput;
  EnqueuePullRequestPayload: ResolverTypeWrapper<
    Omit<EnqueuePullRequestPayload, "mergeQueueEntry"> & {
      mergeQueueEntry?: Maybe<ResolversTypes["MergeQueueEntry"]>;
    }
  >;
  Enterprise: ResolverTypeWrapper<
    Omit<
      Enterprise,
      "billingInfo" | "members" | "organizations" | "ownerInfo"
    > & {
      billingInfo?: Maybe<ResolversTypes["EnterpriseBillingInfo"]>;
      members: ResolversTypes["EnterpriseMemberConnection"];
      organizations: ResolversTypes["OrganizationConnection"];
      ownerInfo?: Maybe<ResolversTypes["EnterpriseOwnerInfo"]>;
    }
  >;
  EnterpriseAdministratorConnection: ResolverTypeWrapper<
    Omit<EnterpriseAdministratorConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["EnterpriseAdministratorEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["User"]>>>;
    }
  >;
  EnterpriseAdministratorEdge: ResolverTypeWrapper<
    Omit<EnterpriseAdministratorEdge, "node"> & {
      node?: Maybe<ResolversTypes["User"]>;
    }
  >;
  EnterpriseAdministratorInvitation: ResolverTypeWrapper<
    Omit<
      EnterpriseAdministratorInvitation,
      "enterprise" | "invitee" | "inviter"
    > & {
      enterprise: ResolversTypes["Enterprise"];
      invitee?: Maybe<ResolversTypes["User"]>;
      inviter?: Maybe<ResolversTypes["User"]>;
    }
  >;
  EnterpriseAdministratorInvitationConnection: ResolverTypeWrapper<
    Omit<EnterpriseAdministratorInvitationConnection, "nodes"> & {
      nodes?: Maybe<
        Array<Maybe<ResolversTypes["EnterpriseAdministratorInvitation"]>>
      >;
    }
  >;
  EnterpriseAdministratorInvitationEdge: ResolverTypeWrapper<
    Omit<EnterpriseAdministratorInvitationEdge, "node"> & {
      node?: Maybe<ResolversTypes["EnterpriseAdministratorInvitation"]>;
    }
  >;
  EnterpriseAdministratorInvitationOrder: EnterpriseAdministratorInvitationOrder;
  EnterpriseAdministratorInvitationOrderField: EnterpriseAdministratorInvitationOrderField;
  EnterpriseAdministratorRole: EnterpriseAdministratorRole;
  EnterpriseAllowPrivateRepositoryForkingPolicyValue: EnterpriseAllowPrivateRepositoryForkingPolicyValue;
  EnterpriseAuditEntryData: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["EnterpriseAuditEntryData"]
  >;
  EnterpriseBillingInfo: ResolverTypeWrapper<EnterpriseBillingInfo>;
  EnterpriseConnection: ResolverTypeWrapper<
    Omit<EnterpriseConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["EnterpriseEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Enterprise"]>>>;
    }
  >;
  EnterpriseDefaultRepositoryPermissionSettingValue: EnterpriseDefaultRepositoryPermissionSettingValue;
  EnterpriseEdge: ResolverTypeWrapper<
    Omit<EnterpriseEdge, "node"> & {
      node?: Maybe<ResolversTypes["Enterprise"]>;
    }
  >;
  EnterpriseEnabledDisabledSettingValue: EnterpriseEnabledDisabledSettingValue;
  EnterpriseEnabledSettingValue: EnterpriseEnabledSettingValue;
  EnterpriseFailedInvitationConnection: ResolverTypeWrapper<
    Omit<EnterpriseFailedInvitationConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["EnterpriseFailedInvitationEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["OrganizationInvitation"]>>>;
    }
  >;
  EnterpriseFailedInvitationEdge: ResolverTypeWrapper<
    Omit<EnterpriseFailedInvitationEdge, "node"> & {
      node?: Maybe<ResolversTypes["OrganizationInvitation"]>;
    }
  >;
  EnterpriseIdentityProvider: ResolverTypeWrapper<
    Omit<EnterpriseIdentityProvider, "enterprise" | "externalIdentities"> & {
      enterprise?: Maybe<ResolversTypes["Enterprise"]>;
      externalIdentities: ResolversTypes["ExternalIdentityConnection"];
    }
  >;
  EnterpriseMember: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["EnterpriseMember"]
  >;
  EnterpriseMemberConnection: ResolverTypeWrapper<
    Omit<EnterpriseMemberConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["EnterpriseMemberEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["EnterpriseMember"]>>>;
    }
  >;
  EnterpriseMemberEdge: ResolverTypeWrapper<
    Omit<EnterpriseMemberEdge, "node"> & {
      node?: Maybe<ResolversTypes["EnterpriseMember"]>;
    }
  >;
  EnterpriseMemberInvitation: ResolverTypeWrapper<
    Omit<EnterpriseMemberInvitation, "enterprise" | "invitee" | "inviter"> & {
      enterprise: ResolversTypes["Enterprise"];
      invitee?: Maybe<ResolversTypes["User"]>;
      inviter?: Maybe<ResolversTypes["User"]>;
    }
  >;
  EnterpriseMemberInvitationConnection: ResolverTypeWrapper<
    Omit<EnterpriseMemberInvitationConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["EnterpriseMemberInvitationEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["EnterpriseMemberInvitation"]>>>;
    }
  >;
  EnterpriseMemberInvitationEdge: ResolverTypeWrapper<
    Omit<EnterpriseMemberInvitationEdge, "node"> & {
      node?: Maybe<ResolversTypes["EnterpriseMemberInvitation"]>;
    }
  >;
  EnterpriseMemberInvitationOrder: EnterpriseMemberInvitationOrder;
  EnterpriseMemberInvitationOrderField: EnterpriseMemberInvitationOrderField;
  EnterpriseMemberOrder: EnterpriseMemberOrder;
  EnterpriseMemberOrderField: EnterpriseMemberOrderField;
  EnterpriseMembersCanCreateRepositoriesSettingValue: EnterpriseMembersCanCreateRepositoriesSettingValue;
  EnterpriseMembersCanMakePurchasesSettingValue: EnterpriseMembersCanMakePurchasesSettingValue;
  EnterpriseMembershipType: EnterpriseMembershipType;
  EnterpriseOrder: EnterpriseOrder;
  EnterpriseOrderField: EnterpriseOrderField;
  EnterpriseOrganizationMembershipConnection: ResolverTypeWrapper<
    Omit<EnterpriseOrganizationMembershipConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["EnterpriseOrganizationMembershipEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Organization"]>>>;
    }
  >;
  EnterpriseOrganizationMembershipEdge: ResolverTypeWrapper<
    Omit<EnterpriseOrganizationMembershipEdge, "node"> & {
      node?: Maybe<ResolversTypes["Organization"]>;
    }
  >;
  EnterpriseOutsideCollaboratorConnection: ResolverTypeWrapper<
    Omit<EnterpriseOutsideCollaboratorConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["EnterpriseOutsideCollaboratorEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["User"]>>>;
    }
  >;
  EnterpriseOutsideCollaboratorEdge: ResolverTypeWrapper<
    Omit<EnterpriseOutsideCollaboratorEdge, "node"> & {
      node?: Maybe<ResolversTypes["User"]>;
    }
  >;
  EnterpriseOwnerInfo: ResolverTypeWrapper<
    Omit<
      EnterpriseOwnerInfo,
      | "admins"
      | "allowPrivateRepositoryForkingSettingOrganizations"
      | "defaultRepositoryPermissionSettingOrganizations"
      | "domains"
      | "enterpriseServerInstallations"
      | "failedInvitations"
      | "ipAllowListEntries"
      | "membersCanChangeRepositoryVisibilitySettingOrganizations"
      | "membersCanCreateRepositoriesSettingOrganizations"
      | "membersCanDeleteIssuesSettingOrganizations"
      | "membersCanDeleteRepositoriesSettingOrganizations"
      | "membersCanInviteCollaboratorsSettingOrganizations"
      | "membersCanUpdateProtectedBranchesSettingOrganizations"
      | "membersCanViewDependencyInsightsSettingOrganizations"
      | "oidcProvider"
      | "organizationProjectsSettingOrganizations"
      | "outsideCollaborators"
      | "pendingCollaboratorInvitations"
      | "pendingMemberInvitations"
      | "pendingUnaffiliatedMemberInvitations"
      | "repositoryProjectsSettingOrganizations"
      | "samlIdentityProvider"
      | "samlIdentityProviderSettingOrganizations"
      | "supportEntitlements"
      | "teamDiscussionsSettingOrganizations"
      | "twoFactorRequiredSettingOrganizations"
    > & {
      admins: ResolversTypes["EnterpriseAdministratorConnection"];
      allowPrivateRepositoryForkingSettingOrganizations: ResolversTypes["OrganizationConnection"];
      defaultRepositoryPermissionSettingOrganizations: ResolversTypes["OrganizationConnection"];
      domains: ResolversTypes["VerifiableDomainConnection"];
      enterpriseServerInstallations: ResolversTypes["EnterpriseServerInstallationConnection"];
      failedInvitations: ResolversTypes["EnterpriseFailedInvitationConnection"];
      ipAllowListEntries: ResolversTypes["IpAllowListEntryConnection"];
      membersCanChangeRepositoryVisibilitySettingOrganizations: ResolversTypes["OrganizationConnection"];
      membersCanCreateRepositoriesSettingOrganizations: ResolversTypes["OrganizationConnection"];
      membersCanDeleteIssuesSettingOrganizations: ResolversTypes["OrganizationConnection"];
      membersCanDeleteRepositoriesSettingOrganizations: ResolversTypes["OrganizationConnection"];
      membersCanInviteCollaboratorsSettingOrganizations: ResolversTypes["OrganizationConnection"];
      membersCanUpdateProtectedBranchesSettingOrganizations: ResolversTypes["OrganizationConnection"];
      membersCanViewDependencyInsightsSettingOrganizations: ResolversTypes["OrganizationConnection"];
      oidcProvider?: Maybe<ResolversTypes["OIDCProvider"]>;
      organizationProjectsSettingOrganizations: ResolversTypes["OrganizationConnection"];
      outsideCollaborators: ResolversTypes["EnterpriseOutsideCollaboratorConnection"];
      pendingCollaboratorInvitations: ResolversTypes["RepositoryInvitationConnection"];
      pendingMemberInvitations: ResolversTypes["EnterprisePendingMemberInvitationConnection"];
      pendingUnaffiliatedMemberInvitations: ResolversTypes["EnterpriseMemberInvitationConnection"];
      repositoryProjectsSettingOrganizations: ResolversTypes["OrganizationConnection"];
      samlIdentityProvider?: Maybe<
        ResolversTypes["EnterpriseIdentityProvider"]
      >;
      samlIdentityProviderSettingOrganizations: ResolversTypes["OrganizationConnection"];
      supportEntitlements: ResolversTypes["EnterpriseMemberConnection"];
      teamDiscussionsSettingOrganizations: ResolversTypes["OrganizationConnection"];
      twoFactorRequiredSettingOrganizations: ResolversTypes["OrganizationConnection"];
    }
  >;
  EnterprisePendingMemberInvitationConnection: ResolverTypeWrapper<
    Omit<EnterprisePendingMemberInvitationConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["EnterprisePendingMemberInvitationEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["OrganizationInvitation"]>>>;
    }
  >;
  EnterprisePendingMemberInvitationEdge: ResolverTypeWrapper<
    Omit<EnterprisePendingMemberInvitationEdge, "node"> & {
      node?: Maybe<ResolversTypes["OrganizationInvitation"]>;
    }
  >;
  EnterpriseRepositoryInfo: ResolverTypeWrapper<EnterpriseRepositoryInfo>;
  EnterpriseRepositoryInfoConnection: ResolverTypeWrapper<EnterpriseRepositoryInfoConnection>;
  EnterpriseRepositoryInfoEdge: ResolverTypeWrapper<EnterpriseRepositoryInfoEdge>;
  EnterpriseServerInstallation: ResolverTypeWrapper<
    Omit<EnterpriseServerInstallation, "userAccountsUploads"> & {
      userAccountsUploads: ResolversTypes["EnterpriseServerUserAccountsUploadConnection"];
    }
  >;
  EnterpriseServerInstallationConnection: ResolverTypeWrapper<
    Omit<EnterpriseServerInstallationConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["EnterpriseServerInstallationEdge"]>>
      >;
      nodes?: Maybe<
        Array<Maybe<ResolversTypes["EnterpriseServerInstallation"]>>
      >;
    }
  >;
  EnterpriseServerInstallationEdge: ResolverTypeWrapper<
    Omit<EnterpriseServerInstallationEdge, "node"> & {
      node?: Maybe<ResolversTypes["EnterpriseServerInstallation"]>;
    }
  >;
  EnterpriseServerInstallationMembershipConnection: ResolverTypeWrapper<
    Omit<
      EnterpriseServerInstallationMembershipConnection,
      "edges" | "nodes"
    > & {
      edges?: Maybe<
        Array<
          Maybe<ResolversTypes["EnterpriseServerInstallationMembershipEdge"]>
        >
      >;
      nodes?: Maybe<
        Array<Maybe<ResolversTypes["EnterpriseServerInstallation"]>>
      >;
    }
  >;
  EnterpriseServerInstallationMembershipEdge: ResolverTypeWrapper<
    Omit<EnterpriseServerInstallationMembershipEdge, "node"> & {
      node?: Maybe<ResolversTypes["EnterpriseServerInstallation"]>;
    }
  >;
  EnterpriseServerInstallationOrder: EnterpriseServerInstallationOrder;
  EnterpriseServerInstallationOrderField: EnterpriseServerInstallationOrderField;
  EnterpriseServerUserAccount: ResolverTypeWrapper<
    Omit<EnterpriseServerUserAccount, "enterpriseServerInstallation"> & {
      enterpriseServerInstallation: ResolversTypes["EnterpriseServerInstallation"];
    }
  >;
  EnterpriseServerUserAccountConnection: ResolverTypeWrapper<EnterpriseServerUserAccountConnection>;
  EnterpriseServerUserAccountEdge: ResolverTypeWrapper<EnterpriseServerUserAccountEdge>;
  EnterpriseServerUserAccountEmail: ResolverTypeWrapper<EnterpriseServerUserAccountEmail>;
  EnterpriseServerUserAccountEmailConnection: ResolverTypeWrapper<EnterpriseServerUserAccountEmailConnection>;
  EnterpriseServerUserAccountEmailEdge: ResolverTypeWrapper<EnterpriseServerUserAccountEmailEdge>;
  EnterpriseServerUserAccountEmailOrder: EnterpriseServerUserAccountEmailOrder;
  EnterpriseServerUserAccountEmailOrderField: EnterpriseServerUserAccountEmailOrderField;
  EnterpriseServerUserAccountOrder: EnterpriseServerUserAccountOrder;
  EnterpriseServerUserAccountOrderField: EnterpriseServerUserAccountOrderField;
  EnterpriseServerUserAccountsUpload: ResolverTypeWrapper<
    Omit<
      EnterpriseServerUserAccountsUpload,
      "enterprise" | "enterpriseServerInstallation"
    > & {
      enterprise: ResolversTypes["Enterprise"];
      enterpriseServerInstallation: ResolversTypes["EnterpriseServerInstallation"];
    }
  >;
  EnterpriseServerUserAccountsUploadConnection: ResolverTypeWrapper<
    Omit<EnterpriseServerUserAccountsUploadConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["EnterpriseServerUserAccountsUploadEdge"]>>
      >;
      nodes?: Maybe<
        Array<Maybe<ResolversTypes["EnterpriseServerUserAccountsUpload"]>>
      >;
    }
  >;
  EnterpriseServerUserAccountsUploadEdge: ResolverTypeWrapper<
    Omit<EnterpriseServerUserAccountsUploadEdge, "node"> & {
      node?: Maybe<ResolversTypes["EnterpriseServerUserAccountsUpload"]>;
    }
  >;
  EnterpriseServerUserAccountsUploadOrder: EnterpriseServerUserAccountsUploadOrder;
  EnterpriseServerUserAccountsUploadOrderField: EnterpriseServerUserAccountsUploadOrderField;
  EnterpriseServerUserAccountsUploadSyncState: EnterpriseServerUserAccountsUploadSyncState;
  EnterpriseUserAccount: ResolverTypeWrapper<
    Omit<
      EnterpriseUserAccount,
      "enterprise" | "enterpriseInstallations" | "organizations" | "user"
    > & {
      enterprise: ResolversTypes["Enterprise"];
      enterpriseInstallations: ResolversTypes["EnterpriseServerInstallationMembershipConnection"];
      organizations: ResolversTypes["EnterpriseOrganizationMembershipConnection"];
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  EnterpriseUserAccountMembershipRole: EnterpriseUserAccountMembershipRole;
  EnterpriseUserDeployment: EnterpriseUserDeployment;
  Environment: ResolverTypeWrapper<
    Omit<Environment, "latestCompletedDeployment" | "protectionRules"> & {
      latestCompletedDeployment?: Maybe<ResolversTypes["Deployment"]>;
      protectionRules: ResolversTypes["DeploymentProtectionRuleConnection"];
    }
  >;
  EnvironmentConnection: ResolverTypeWrapper<
    Omit<EnvironmentConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["EnvironmentEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Environment"]>>>;
    }
  >;
  EnvironmentEdge: ResolverTypeWrapper<
    Omit<EnvironmentEdge, "node"> & {
      node?: Maybe<ResolversTypes["Environment"]>;
    }
  >;
  EnvironmentOrderField: EnvironmentOrderField;
  EnvironmentPinnedFilterField: EnvironmentPinnedFilterField;
  Environments: Environments;
  ExternalIdentity: ResolverTypeWrapper<
    Omit<ExternalIdentity, "organizationInvitation" | "user"> & {
      organizationInvitation?: Maybe<ResolversTypes["OrganizationInvitation"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  ExternalIdentityAttribute: ResolverTypeWrapper<ExternalIdentityAttribute>;
  ExternalIdentityConnection: ResolverTypeWrapper<
    Omit<ExternalIdentityConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ExternalIdentityEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ExternalIdentity"]>>>;
    }
  >;
  ExternalIdentityEdge: ResolverTypeWrapper<
    Omit<ExternalIdentityEdge, "node"> & {
      node?: Maybe<ResolversTypes["ExternalIdentity"]>;
    }
  >;
  ExternalIdentitySamlAttributes: ResolverTypeWrapper<ExternalIdentitySamlAttributes>;
  ExternalIdentityScimAttributes: ResolverTypeWrapper<ExternalIdentityScimAttributes>;
  FileAddition: FileAddition;
  FileChanges: FileChanges;
  FileDeletion: FileDeletion;
  FileExtensionRestrictionParameters: ResolverTypeWrapper<FileExtensionRestrictionParameters>;
  FileExtensionRestrictionParametersInput: FileExtensionRestrictionParametersInput;
  FilePathRestrictionParameters: ResolverTypeWrapper<FilePathRestrictionParameters>;
  FilePathRestrictionParametersInput: FilePathRestrictionParametersInput;
  FileViewedState: FileViewedState;
  Float: ResolverTypeWrapper<Scalars["Float"]["output"]>;
  FollowOrganizationInput: FollowOrganizationInput;
  FollowOrganizationPayload: ResolverTypeWrapper<
    Omit<FollowOrganizationPayload, "organization"> & {
      organization?: Maybe<ResolversTypes["Organization"]>;
    }
  >;
  FollowUserInput: FollowUserInput;
  FollowUserPayload: ResolverTypeWrapper<
    Omit<FollowUserPayload, "user"> & { user?: Maybe<ResolversTypes["User"]> }
  >;
  FollowerConnection: ResolverTypeWrapper<
    Omit<FollowerConnection, "nodes"> & {
      nodes?: Maybe<Array<Maybe<ResolversTypes["User"]>>>;
    }
  >;
  FollowingConnection: ResolverTypeWrapper<
    Omit<FollowingConnection, "nodes"> & {
      nodes?: Maybe<Array<Maybe<ResolversTypes["User"]>>>;
    }
  >;
  FundingLink: ResolverTypeWrapper<FundingLink>;
  FundingPlatform: FundingPlatform;
  GenericHovercardContext: ResolverTypeWrapper<GenericHovercardContext>;
  Gist: ResolverTypeWrapper<
    Omit<Gist, "comments" | "forks" | "owner"> & {
      comments: ResolversTypes["GistCommentConnection"];
      forks: ResolversTypes["GistConnection"];
      owner?: Maybe<ResolversTypes["RepositoryOwner"]>;
    }
  >;
  GistComment: ResolverTypeWrapper<
    Omit<GistComment, "author" | "editor" | "gist" | "userContentEdits"> & {
      author?: Maybe<ResolversTypes["Actor"]>;
      editor?: Maybe<ResolversTypes["Actor"]>;
      gist: ResolversTypes["Gist"];
      userContentEdits?: Maybe<ResolversTypes["UserContentEditConnection"]>;
    }
  >;
  GistCommentConnection: ResolverTypeWrapper<
    Omit<GistCommentConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["GistCommentEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["GistComment"]>>>;
    }
  >;
  GistCommentEdge: ResolverTypeWrapper<
    Omit<GistCommentEdge, "node"> & {
      node?: Maybe<ResolversTypes["GistComment"]>;
    }
  >;
  GistConnection: ResolverTypeWrapper<
    Omit<GistConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["GistEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Gist"]>>>;
    }
  >;
  GistEdge: ResolverTypeWrapper<
    Omit<GistEdge, "node"> & { node?: Maybe<ResolversTypes["Gist"]> }
  >;
  GistFile: ResolverTypeWrapper<GistFile>;
  GistOrder: GistOrder;
  GistOrderField: GistOrderField;
  GistPrivacy: GistPrivacy;
  GitActor: ResolverTypeWrapper<
    Omit<GitActor, "user"> & { user?: Maybe<ResolversTypes["User"]> }
  >;
  GitActorConnection: ResolverTypeWrapper<GitActorConnection>;
  GitActorEdge: ResolverTypeWrapper<GitActorEdge>;
  GitHubMetadata: ResolverTypeWrapper<GitHubMetadata>;
  GitObject: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["GitObject"]
  >;
  GitObjectID: ResolverTypeWrapper<Scalars["GitObjectID"]["output"]>;
  GitRefname: ResolverTypeWrapper<Scalars["GitRefname"]["output"]>;
  GitSSHRemote: ResolverTypeWrapper<Scalars["GitSSHRemote"]["output"]>;
  GitSignature: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["GitSignature"]
  >;
  GitSignatureState: GitSignatureState;
  GitTimestamp: ResolverTypeWrapper<Scalars["GitTimestamp"]["output"]>;
  GpgSignature: ResolverTypeWrapper<
    Omit<GpgSignature, "signer"> & { signer?: Maybe<ResolversTypes["User"]> }
  >;
  GrantEnterpriseOrganizationsMigratorRoleInput: GrantEnterpriseOrganizationsMigratorRoleInput;
  GrantEnterpriseOrganizationsMigratorRolePayload: ResolverTypeWrapper<
    Omit<GrantEnterpriseOrganizationsMigratorRolePayload, "organizations"> & {
      organizations?: Maybe<ResolversTypes["OrganizationConnection"]>;
    }
  >;
  GrantMigratorRoleInput: GrantMigratorRoleInput;
  GrantMigratorRolePayload: ResolverTypeWrapper<GrantMigratorRolePayload>;
  HTML: ResolverTypeWrapper<Scalars["HTML"]["output"]>;
  HeadRefDeletedEvent: ResolverTypeWrapper<
    Omit<HeadRefDeletedEvent, "actor" | "headRef" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      headRef?: Maybe<ResolversTypes["Ref"]>;
      pullRequest: ResolversTypes["PullRequest"];
    }
  >;
  HeadRefForcePushedEvent: ResolverTypeWrapper<
    Omit<
      HeadRefForcePushedEvent,
      "actor" | "afterCommit" | "beforeCommit" | "pullRequest" | "ref"
    > & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      afterCommit?: Maybe<ResolversTypes["Commit"]>;
      beforeCommit?: Maybe<ResolversTypes["Commit"]>;
      pullRequest: ResolversTypes["PullRequest"];
      ref?: Maybe<ResolversTypes["Ref"]>;
    }
  >;
  HeadRefRestoredEvent: ResolverTypeWrapper<
    Omit<HeadRefRestoredEvent, "actor" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest: ResolversTypes["PullRequest"];
    }
  >;
  Hovercard: ResolverTypeWrapper<
    Omit<Hovercard, "contexts"> & {
      contexts: Array<ResolversTypes["HovercardContext"]>;
    }
  >;
  HovercardContext: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["HovercardContext"]
  >;
  ID: ResolverTypeWrapper<Scalars["ID"]["output"]>;
  IdentityProviderConfigurationState: IdentityProviderConfigurationState;
  ImportProjectInput: ImportProjectInput;
  ImportProjectPayload: ResolverTypeWrapper<
    Omit<ImportProjectPayload, "project"> & {
      project?: Maybe<ResolversTypes["Project"]>;
    }
  >;
  Int: ResolverTypeWrapper<Scalars["Int"]["output"]>;
  InviteEnterpriseAdminInput: InviteEnterpriseAdminInput;
  InviteEnterpriseAdminPayload: ResolverTypeWrapper<
    Omit<InviteEnterpriseAdminPayload, "invitation"> & {
      invitation?: Maybe<ResolversTypes["EnterpriseAdministratorInvitation"]>;
    }
  >;
  InviteEnterpriseMemberInput: InviteEnterpriseMemberInput;
  InviteEnterpriseMemberPayload: ResolverTypeWrapper<
    Omit<InviteEnterpriseMemberPayload, "invitation"> & {
      invitation?: Maybe<ResolversTypes["EnterpriseMemberInvitation"]>;
    }
  >;
  IpAllowListEnabledSettingValue: IpAllowListEnabledSettingValue;
  IpAllowListEntry: ResolverTypeWrapper<
    Omit<IpAllowListEntry, "owner"> & {
      owner: ResolversTypes["IpAllowListOwner"];
    }
  >;
  IpAllowListEntryConnection: ResolverTypeWrapper<
    Omit<IpAllowListEntryConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["IpAllowListEntryEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["IpAllowListEntry"]>>>;
    }
  >;
  IpAllowListEntryEdge: ResolverTypeWrapper<
    Omit<IpAllowListEntryEdge, "node"> & {
      node?: Maybe<ResolversTypes["IpAllowListEntry"]>;
    }
  >;
  IpAllowListEntryOrder: IpAllowListEntryOrder;
  IpAllowListEntryOrderField: IpAllowListEntryOrderField;
  IpAllowListForInstalledAppsEnabledSettingValue: IpAllowListForInstalledAppsEnabledSettingValue;
  IpAllowListOwner: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["IpAllowListOwner"]
  >;
  Issue: ResolverTypeWrapper<
    Omit<
      Issue,
      | "author"
      | "closedByPullRequestsReferences"
      | "comments"
      | "editor"
      | "hovercard"
      | "labels"
      | "milestone"
      | "projectCards"
      | "projectItems"
      | "projectV2"
      | "projectsV2"
      | "reactionGroups"
      | "reactions"
      | "repository"
      | "timeline"
      | "timelineItems"
      | "trackedInIssues"
      | "trackedIssues"
      | "userContentEdits"
    > & {
      author?: Maybe<ResolversTypes["Actor"]>;
      closedByPullRequestsReferences?: Maybe<
        ResolversTypes["PullRequestConnection"]
      >;
      comments: ResolversTypes["IssueCommentConnection"];
      editor?: Maybe<ResolversTypes["Actor"]>;
      hovercard: ResolversTypes["Hovercard"];
      labels?: Maybe<ResolversTypes["LabelConnection"]>;
      milestone?: Maybe<ResolversTypes["Milestone"]>;
      projectCards: ResolversTypes["ProjectCardConnection"];
      projectItems: ResolversTypes["ProjectV2ItemConnection"];
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
      projectsV2: ResolversTypes["ProjectV2Connection"];
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      reactions: ResolversTypes["ReactionConnection"];
      repository: ResolversTypes["Repository"];
      timeline: ResolversTypes["IssueTimelineConnection"];
      timelineItems: ResolversTypes["IssueTimelineItemsConnection"];
      trackedInIssues: ResolversTypes["IssueConnection"];
      trackedIssues: ResolversTypes["IssueConnection"];
      userContentEdits?: Maybe<ResolversTypes["UserContentEditConnection"]>;
    }
  >;
  IssueClosedStateReason: IssueClosedStateReason;
  IssueComment: ResolverTypeWrapper<
    Omit<
      IssueComment,
      | "author"
      | "editor"
      | "issue"
      | "pullRequest"
      | "reactionGroups"
      | "reactions"
      | "repository"
      | "userContentEdits"
    > & {
      author?: Maybe<ResolversTypes["Actor"]>;
      editor?: Maybe<ResolversTypes["Actor"]>;
      issue: ResolversTypes["Issue"];
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      reactions: ResolversTypes["ReactionConnection"];
      repository: ResolversTypes["Repository"];
      userContentEdits?: Maybe<ResolversTypes["UserContentEditConnection"]>;
    }
  >;
  IssueCommentConnection: ResolverTypeWrapper<
    Omit<IssueCommentConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["IssueCommentEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["IssueComment"]>>>;
    }
  >;
  IssueCommentEdge: ResolverTypeWrapper<
    Omit<IssueCommentEdge, "node"> & {
      node?: Maybe<ResolversTypes["IssueComment"]>;
    }
  >;
  IssueCommentOrder: IssueCommentOrder;
  IssueCommentOrderField: IssueCommentOrderField;
  IssueConnection: ResolverTypeWrapper<
    Omit<IssueConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["IssueEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Issue"]>>>;
    }
  >;
  IssueContributionsByRepository: ResolverTypeWrapper<
    Omit<IssueContributionsByRepository, "contributions" | "repository"> & {
      contributions: ResolversTypes["CreatedIssueContributionConnection"];
      repository: ResolversTypes["Repository"];
    }
  >;
  IssueEdge: ResolverTypeWrapper<
    Omit<IssueEdge, "node"> & { node?: Maybe<ResolversTypes["Issue"]> }
  >;
  IssueFilters: IssueFilters;
  IssueOrPullRequest: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["IssueOrPullRequest"]
  >;
  IssueOrder: IssueOrder;
  IssueOrderField: IssueOrderField;
  IssueState: IssueState;
  IssueStateReason: IssueStateReason;
  IssueTemplate: ResolverTypeWrapper<
    Omit<IssueTemplate, "labels"> & {
      labels?: Maybe<ResolversTypes["LabelConnection"]>;
    }
  >;
  IssueTimelineConnection: ResolverTypeWrapper<
    Omit<IssueTimelineConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["IssueTimelineItemEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["IssueTimelineItem"]>>>;
    }
  >;
  IssueTimelineItem: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["IssueTimelineItem"]
  >;
  IssueTimelineItemEdge: ResolverTypeWrapper<
    Omit<IssueTimelineItemEdge, "node"> & {
      node?: Maybe<ResolversTypes["IssueTimelineItem"]>;
    }
  >;
  IssueTimelineItems: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["IssueTimelineItems"]
  >;
  IssueTimelineItemsConnection: ResolverTypeWrapper<
    Omit<IssueTimelineItemsConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["IssueTimelineItemsEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["IssueTimelineItems"]>>>;
    }
  >;
  IssueTimelineItemsEdge: ResolverTypeWrapper<
    Omit<IssueTimelineItemsEdge, "node"> & {
      node?: Maybe<ResolversTypes["IssueTimelineItems"]>;
    }
  >;
  IssueTimelineItemsItemType: IssueTimelineItemsItemType;
  JoinedGitHubContribution: ResolverTypeWrapper<
    Omit<JoinedGitHubContribution, "user"> & { user: ResolversTypes["User"] }
  >;
  Label: ResolverTypeWrapper<
    Omit<Label, "issues" | "pullRequests" | "repository"> & {
      issues: ResolversTypes["IssueConnection"];
      pullRequests: ResolversTypes["PullRequestConnection"];
      repository: ResolversTypes["Repository"];
    }
  >;
  LabelConnection: ResolverTypeWrapper<
    Omit<LabelConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["LabelEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Label"]>>>;
    }
  >;
  LabelEdge: ResolverTypeWrapper<
    Omit<LabelEdge, "node"> & { node?: Maybe<ResolversTypes["Label"]> }
  >;
  LabelOrder: LabelOrder;
  LabelOrderField: LabelOrderField;
  Labelable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Labelable"]
  >;
  LabeledEvent: ResolverTypeWrapper<
    Omit<LabeledEvent, "actor" | "label" | "labelable"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      label: ResolversTypes["Label"];
      labelable: ResolversTypes["Labelable"];
    }
  >;
  Language: ResolverTypeWrapper<Language>;
  LanguageConnection: ResolverTypeWrapper<LanguageConnection>;
  LanguageEdge: ResolverTypeWrapper<LanguageEdge>;
  LanguageOrder: LanguageOrder;
  LanguageOrderField: LanguageOrderField;
  License: ResolverTypeWrapper<License>;
  LicenseRule: ResolverTypeWrapper<LicenseRule>;
  LinkProjectV2ToRepositoryInput: LinkProjectV2ToRepositoryInput;
  LinkProjectV2ToRepositoryPayload: ResolverTypeWrapper<
    Omit<LinkProjectV2ToRepositoryPayload, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  LinkProjectV2ToTeamInput: LinkProjectV2ToTeamInput;
  LinkProjectV2ToTeamPayload: ResolverTypeWrapper<
    Omit<LinkProjectV2ToTeamPayload, "team"> & {
      team?: Maybe<ResolversTypes["Team"]>;
    }
  >;
  LinkRepositoryToProjectInput: LinkRepositoryToProjectInput;
  LinkRepositoryToProjectPayload: ResolverTypeWrapper<
    Omit<LinkRepositoryToProjectPayload, "project" | "repository"> & {
      project?: Maybe<ResolversTypes["Project"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  LinkedBranch: ResolverTypeWrapper<
    Omit<LinkedBranch, "ref"> & { ref?: Maybe<ResolversTypes["Ref"]> }
  >;
  LinkedBranchConnection: ResolverTypeWrapper<LinkedBranchConnection>;
  LinkedBranchEdge: ResolverTypeWrapper<LinkedBranchEdge>;
  LockLockableInput: LockLockableInput;
  LockLockablePayload: ResolverTypeWrapper<
    Omit<LockLockablePayload, "actor" | "lockedRecord"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      lockedRecord?: Maybe<ResolversTypes["Lockable"]>;
    }
  >;
  LockReason: LockReason;
  Lockable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Lockable"]
  >;
  LockedEvent: ResolverTypeWrapper<
    Omit<LockedEvent, "actor" | "lockable"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      lockable: ResolversTypes["Lockable"];
    }
  >;
  Mannequin: ResolverTypeWrapper<
    Omit<Mannequin, "claimant"> & { claimant?: Maybe<ResolversTypes["User"]> }
  >;
  MannequinConnection: ResolverTypeWrapper<
    Omit<MannequinConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["MannequinEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Mannequin"]>>>;
    }
  >;
  MannequinEdge: ResolverTypeWrapper<
    Omit<MannequinEdge, "node"> & { node?: Maybe<ResolversTypes["Mannequin"]> }
  >;
  MannequinOrder: MannequinOrder;
  MannequinOrderField: MannequinOrderField;
  MarkDiscussionCommentAsAnswerInput: MarkDiscussionCommentAsAnswerInput;
  MarkDiscussionCommentAsAnswerPayload: ResolverTypeWrapper<
    Omit<MarkDiscussionCommentAsAnswerPayload, "discussion"> & {
      discussion?: Maybe<ResolversTypes["Discussion"]>;
    }
  >;
  MarkFileAsViewedInput: MarkFileAsViewedInput;
  MarkFileAsViewedPayload: ResolverTypeWrapper<
    Omit<MarkFileAsViewedPayload, "pullRequest"> & {
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  MarkNotificationAsDoneInput: MarkNotificationAsDoneInput;
  MarkNotificationAsDonePayload: ResolverTypeWrapper<
    Omit<MarkNotificationAsDonePayload, "viewer"> & {
      viewer?: Maybe<ResolversTypes["User"]>;
    }
  >;
  MarkProjectV2AsTemplateInput: MarkProjectV2AsTemplateInput;
  MarkProjectV2AsTemplatePayload: ResolverTypeWrapper<
    Omit<MarkProjectV2AsTemplatePayload, "projectV2"> & {
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
    }
  >;
  MarkPullRequestReadyForReviewInput: MarkPullRequestReadyForReviewInput;
  MarkPullRequestReadyForReviewPayload: ResolverTypeWrapper<
    Omit<MarkPullRequestReadyForReviewPayload, "pullRequest"> & {
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  MarkedAsDuplicateEvent: ResolverTypeWrapper<
    Omit<MarkedAsDuplicateEvent, "actor" | "canonical" | "duplicate"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      canonical?: Maybe<ResolversTypes["IssueOrPullRequest"]>;
      duplicate?: Maybe<ResolversTypes["IssueOrPullRequest"]>;
    }
  >;
  MarketplaceCategory: ResolverTypeWrapper<MarketplaceCategory>;
  MarketplaceListing: ResolverTypeWrapper<
    Omit<MarketplaceListing, "app"> & { app?: Maybe<ResolversTypes["App"]> }
  >;
  MarketplaceListingConnection: ResolverTypeWrapper<
    Omit<MarketplaceListingConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["MarketplaceListingEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["MarketplaceListing"]>>>;
    }
  >;
  MarketplaceListingEdge: ResolverTypeWrapper<
    Omit<MarketplaceListingEdge, "node"> & {
      node?: Maybe<ResolversTypes["MarketplaceListing"]>;
    }
  >;
  MaxFilePathLengthParameters: ResolverTypeWrapper<MaxFilePathLengthParameters>;
  MaxFilePathLengthParametersInput: MaxFilePathLengthParametersInput;
  MaxFileSizeParameters: ResolverTypeWrapper<MaxFileSizeParameters>;
  MaxFileSizeParametersInput: MaxFileSizeParametersInput;
  MemberFeatureRequestNotification: ResolverTypeWrapper<MemberFeatureRequestNotification>;
  MemberStatusable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["MemberStatusable"]
  >;
  MembersCanDeleteReposClearAuditEntry: ResolverTypeWrapper<
    Omit<
      MembersCanDeleteReposClearAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  MembersCanDeleteReposDisableAuditEntry: ResolverTypeWrapper<
    Omit<
      MembersCanDeleteReposDisableAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  MembersCanDeleteReposEnableAuditEntry: ResolverTypeWrapper<
    Omit<
      MembersCanDeleteReposEnableAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  MentionedEvent: ResolverTypeWrapper<
    Omit<MentionedEvent, "actor"> & { actor?: Maybe<ResolversTypes["Actor"]> }
  >;
  MergeBranchInput: MergeBranchInput;
  MergeBranchPayload: ResolverTypeWrapper<
    Omit<MergeBranchPayload, "mergeCommit"> & {
      mergeCommit?: Maybe<ResolversTypes["Commit"]>;
    }
  >;
  MergeCommitMessage: MergeCommitMessage;
  MergeCommitTitle: MergeCommitTitle;
  MergePullRequestInput: MergePullRequestInput;
  MergePullRequestPayload: ResolverTypeWrapper<
    Omit<MergePullRequestPayload, "actor" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  MergeQueue: ResolverTypeWrapper<
    Omit<MergeQueue, "configuration" | "entries" | "repository"> & {
      configuration?: Maybe<ResolversTypes["MergeQueueConfiguration"]>;
      entries?: Maybe<ResolversTypes["MergeQueueEntryConnection"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  MergeQueueConfiguration: ResolverTypeWrapper<MergeQueueConfiguration>;
  MergeQueueEntry: ResolverTypeWrapper<
    Omit<
      MergeQueueEntry,
      "baseCommit" | "enqueuer" | "headCommit" | "mergeQueue" | "pullRequest"
    > & {
      baseCommit?: Maybe<ResolversTypes["Commit"]>;
      enqueuer: ResolversTypes["Actor"];
      headCommit?: Maybe<ResolversTypes["Commit"]>;
      mergeQueue?: Maybe<ResolversTypes["MergeQueue"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  MergeQueueEntryConnection: ResolverTypeWrapper<
    Omit<MergeQueueEntryConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["MergeQueueEntryEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["MergeQueueEntry"]>>>;
    }
  >;
  MergeQueueEntryEdge: ResolverTypeWrapper<
    Omit<MergeQueueEntryEdge, "node"> & {
      node?: Maybe<ResolversTypes["MergeQueueEntry"]>;
    }
  >;
  MergeQueueEntryState: MergeQueueEntryState;
  MergeQueueGroupingStrategy: MergeQueueGroupingStrategy;
  MergeQueueMergeMethod: MergeQueueMergeMethod;
  MergeQueueMergingStrategy: MergeQueueMergingStrategy;
  MergeQueueParameters: ResolverTypeWrapper<MergeQueueParameters>;
  MergeQueueParametersInput: MergeQueueParametersInput;
  MergeStateStatus: MergeStateStatus;
  MergeableState: MergeableState;
  MergedEvent: ResolverTypeWrapper<
    Omit<MergedEvent, "actor" | "commit" | "mergeRef" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      commit?: Maybe<ResolversTypes["Commit"]>;
      mergeRef?: Maybe<ResolversTypes["Ref"]>;
      pullRequest: ResolversTypes["PullRequest"];
    }
  >;
  Migration: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Migration"]
  >;
  MigrationSource: ResolverTypeWrapper<MigrationSource>;
  MigrationSourceType: MigrationSourceType;
  MigrationState: MigrationState;
  Milestone: ResolverTypeWrapper<
    Omit<Milestone, "creator" | "issues" | "pullRequests" | "repository"> & {
      creator?: Maybe<ResolversTypes["Actor"]>;
      issues: ResolversTypes["IssueConnection"];
      pullRequests: ResolversTypes["PullRequestConnection"];
      repository: ResolversTypes["Repository"];
    }
  >;
  MilestoneConnection: ResolverTypeWrapper<
    Omit<MilestoneConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["MilestoneEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Milestone"]>>>;
    }
  >;
  MilestoneEdge: ResolverTypeWrapper<
    Omit<MilestoneEdge, "node"> & { node?: Maybe<ResolversTypes["Milestone"]> }
  >;
  MilestoneItem: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["MilestoneItem"]
  >;
  MilestoneOrder: MilestoneOrder;
  MilestoneOrderField: MilestoneOrderField;
  MilestoneState: MilestoneState;
  MilestonedEvent: ResolverTypeWrapper<
    Omit<MilestonedEvent, "actor" | "subject"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      subject: ResolversTypes["MilestoneItem"];
    }
  >;
  Minimizable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Minimizable"]
  >;
  MinimizeCommentInput: MinimizeCommentInput;
  MinimizeCommentPayload: ResolverTypeWrapper<
    Omit<MinimizeCommentPayload, "minimizedComment"> & {
      minimizedComment?: Maybe<ResolversTypes["Minimizable"]>;
    }
  >;
  MoveProjectCardInput: MoveProjectCardInput;
  MoveProjectCardPayload: ResolverTypeWrapper<
    Omit<MoveProjectCardPayload, "cardEdge"> & {
      cardEdge?: Maybe<ResolversTypes["ProjectCardEdge"]>;
    }
  >;
  MoveProjectColumnInput: MoveProjectColumnInput;
  MoveProjectColumnPayload: ResolverTypeWrapper<MoveProjectColumnPayload>;
  MovedColumnsInProjectEvent: ResolverTypeWrapper<
    Omit<MovedColumnsInProjectEvent, "actor" | "project" | "projectCard"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      project?: Maybe<ResolversTypes["Project"]>;
      projectCard?: Maybe<ResolversTypes["ProjectCard"]>;
    }
  >;
  Mutation: ResolverTypeWrapper<{}>;
  Node: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>["Node"]>;
  NotificationRestrictionSettingValue: NotificationRestrictionSettingValue;
  OIDCProvider: ResolverTypeWrapper<
    Omit<OidcProvider, "enterprise" | "externalIdentities"> & {
      enterprise?: Maybe<ResolversTypes["Enterprise"]>;
      externalIdentities: ResolversTypes["ExternalIdentityConnection"];
    }
  >;
  OIDCProviderType: OidcProviderType;
  OauthApplicationAuditEntryData: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["OauthApplicationAuditEntryData"]
  >;
  OauthApplicationCreateAuditEntry: ResolverTypeWrapper<
    Omit<
      OauthApplicationCreateAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OauthApplicationCreateAuditEntryState: OauthApplicationCreateAuditEntryState;
  OperationType: OperationType;
  OrderDirection: OrderDirection;
  OrgAddBillingManagerAuditEntry: ResolverTypeWrapper<
    Omit<OrgAddBillingManagerAuditEntry, "actor" | "organization" | "user"> & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgAddMemberAuditEntry: ResolverTypeWrapper<
    Omit<OrgAddMemberAuditEntry, "actor" | "organization" | "user"> & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgAddMemberAuditEntryPermission: OrgAddMemberAuditEntryPermission;
  OrgBlockUserAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgBlockUserAuditEntry,
      "actor" | "blockedUser" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      blockedUser?: Maybe<ResolversTypes["User"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgConfigDisableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgConfigDisableCollaboratorsOnlyAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgConfigEnableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgConfigEnableCollaboratorsOnlyAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgCreateAuditEntry: ResolverTypeWrapper<
    Omit<OrgCreateAuditEntry, "actor" | "organization" | "user"> & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgCreateAuditEntryBillingPlan: OrgCreateAuditEntryBillingPlan;
  OrgDisableOauthAppRestrictionsAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgDisableOauthAppRestrictionsAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgDisableSamlAuditEntry: ResolverTypeWrapper<
    Omit<OrgDisableSamlAuditEntry, "actor" | "organization" | "user"> & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgDisableTwoFactorRequirementAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgDisableTwoFactorRequirementAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgEnableOauthAppRestrictionsAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgEnableOauthAppRestrictionsAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgEnableSamlAuditEntry: ResolverTypeWrapper<
    Omit<OrgEnableSamlAuditEntry, "actor" | "organization" | "user"> & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgEnableTwoFactorRequirementAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgEnableTwoFactorRequirementAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgEnterpriseOwnerOrder: OrgEnterpriseOwnerOrder;
  OrgEnterpriseOwnerOrderField: OrgEnterpriseOwnerOrderField;
  OrgInviteMemberAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgInviteMemberAuditEntry,
      "actor" | "organization" | "organizationInvitation" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      organizationInvitation?: Maybe<ResolversTypes["OrganizationInvitation"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgInviteToBusinessAuditEntry: ResolverTypeWrapper<
    Omit<OrgInviteToBusinessAuditEntry, "actor" | "organization" | "user"> & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgOauthAppAccessApprovedAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgOauthAppAccessApprovedAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgOauthAppAccessBlockedAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgOauthAppAccessBlockedAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgOauthAppAccessDeniedAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgOauthAppAccessDeniedAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgOauthAppAccessRequestedAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgOauthAppAccessRequestedAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgOauthAppAccessUnblockedAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgOauthAppAccessUnblockedAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgRemoveBillingManagerAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgRemoveBillingManagerAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgRemoveBillingManagerAuditEntryReason: OrgRemoveBillingManagerAuditEntryReason;
  OrgRemoveMemberAuditEntry: ResolverTypeWrapper<
    Omit<OrgRemoveMemberAuditEntry, "actor" | "organization" | "user"> & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgRemoveMemberAuditEntryMembershipType: OrgRemoveMemberAuditEntryMembershipType;
  OrgRemoveMemberAuditEntryReason: OrgRemoveMemberAuditEntryReason;
  OrgRemoveOutsideCollaboratorAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgRemoveOutsideCollaboratorAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgRemoveOutsideCollaboratorAuditEntryMembershipType: OrgRemoveOutsideCollaboratorAuditEntryMembershipType;
  OrgRemoveOutsideCollaboratorAuditEntryReason: OrgRemoveOutsideCollaboratorAuditEntryReason;
  OrgRestoreMemberAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgRestoreMemberAuditEntry,
      "actor" | "organization" | "restoredMemberships" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      restoredMemberships?: Maybe<
        Array<ResolversTypes["OrgRestoreMemberAuditEntryMembership"]>
      >;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgRestoreMemberAuditEntryMembership: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["OrgRestoreMemberAuditEntryMembership"]
  >;
  OrgRestoreMemberMembershipOrganizationAuditEntryData: ResolverTypeWrapper<
    Omit<
      OrgRestoreMemberMembershipOrganizationAuditEntryData,
      "organization"
    > & { organization?: Maybe<ResolversTypes["Organization"]> }
  >;
  OrgRestoreMemberMembershipRepositoryAuditEntryData: ResolverTypeWrapper<
    Omit<OrgRestoreMemberMembershipRepositoryAuditEntryData, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  OrgRestoreMemberMembershipTeamAuditEntryData: ResolverTypeWrapper<
    Omit<OrgRestoreMemberMembershipTeamAuditEntryData, "team"> & {
      team?: Maybe<ResolversTypes["Team"]>;
    }
  >;
  OrgUnblockUserAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgUnblockUserAuditEntry,
      "actor" | "blockedUser" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      blockedUser?: Maybe<ResolversTypes["User"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgUpdateDefaultRepositoryPermissionAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgUpdateDefaultRepositoryPermissionAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgUpdateDefaultRepositoryPermissionAuditEntryPermission: OrgUpdateDefaultRepositoryPermissionAuditEntryPermission;
  OrgUpdateMemberAuditEntry: ResolverTypeWrapper<
    Omit<OrgUpdateMemberAuditEntry, "actor" | "organization" | "user"> & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgUpdateMemberAuditEntryPermission: OrgUpdateMemberAuditEntryPermission;
  OrgUpdateMemberRepositoryCreationPermissionAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgUpdateMemberRepositoryCreationPermissionAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility: OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility;
  OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: ResolverTypeWrapper<
    Omit<
      OrgUpdateMemberRepositoryInvitationPermissionAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  Organization: ResolverTypeWrapper<
    Omit<
      Organization,
      | "auditLog"
      | "domains"
      | "enterpriseOwners"
      | "ipAllowListEntries"
      | "itemShowcase"
      | "lifetimeReceivedSponsorshipValues"
      | "mannequins"
      | "memberStatuses"
      | "membersWithRole"
      | "packages"
      | "pinnableItems"
      | "pinnedItems"
      | "project"
      | "projectV2"
      | "projects"
      | "projectsV2"
      | "recentProjects"
      | "repositories"
      | "repository"
      | "repositoryDiscussionComments"
      | "repositoryDiscussions"
      | "ruleset"
      | "rulesets"
      | "samlIdentityProvider"
      | "sponsoring"
      | "sponsors"
      | "sponsorsActivities"
      | "sponsorsListing"
      | "sponsorshipForViewerAsSponsor"
      | "sponsorshipForViewerAsSponsorable"
      | "sponsorshipNewsletters"
      | "sponsorshipsAsMaintainer"
      | "sponsorshipsAsSponsor"
      | "team"
      | "teams"
    > & {
      auditLog: ResolversTypes["OrganizationAuditEntryConnection"];
      domains?: Maybe<ResolversTypes["VerifiableDomainConnection"]>;
      enterpriseOwners: ResolversTypes["OrganizationEnterpriseOwnerConnection"];
      ipAllowListEntries: ResolversTypes["IpAllowListEntryConnection"];
      itemShowcase: ResolversTypes["ProfileItemShowcase"];
      lifetimeReceivedSponsorshipValues: ResolversTypes["SponsorAndLifetimeValueConnection"];
      mannequins: ResolversTypes["MannequinConnection"];
      memberStatuses: ResolversTypes["UserStatusConnection"];
      membersWithRole: ResolversTypes["OrganizationMemberConnection"];
      packages: ResolversTypes["PackageConnection"];
      pinnableItems: ResolversTypes["PinnableItemConnection"];
      pinnedItems: ResolversTypes["PinnableItemConnection"];
      project?: Maybe<ResolversTypes["Project"]>;
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
      projects: ResolversTypes["ProjectConnection"];
      projectsV2: ResolversTypes["ProjectV2Connection"];
      recentProjects: ResolversTypes["ProjectV2Connection"];
      repositories: ResolversTypes["RepositoryConnection"];
      repository?: Maybe<ResolversTypes["Repository"]>;
      repositoryDiscussionComments: ResolversTypes["DiscussionCommentConnection"];
      repositoryDiscussions: ResolversTypes["DiscussionConnection"];
      ruleset?: Maybe<ResolversTypes["RepositoryRuleset"]>;
      rulesets?: Maybe<ResolversTypes["RepositoryRulesetConnection"]>;
      samlIdentityProvider?: Maybe<
        ResolversTypes["OrganizationIdentityProvider"]
      >;
      sponsoring: ResolversTypes["SponsorConnection"];
      sponsors: ResolversTypes["SponsorConnection"];
      sponsorsActivities: ResolversTypes["SponsorsActivityConnection"];
      sponsorsListing?: Maybe<ResolversTypes["SponsorsListing"]>;
      sponsorshipForViewerAsSponsor?: Maybe<ResolversTypes["Sponsorship"]>;
      sponsorshipForViewerAsSponsorable?: Maybe<ResolversTypes["Sponsorship"]>;
      sponsorshipNewsletters: ResolversTypes["SponsorshipNewsletterConnection"];
      sponsorshipsAsMaintainer: ResolversTypes["SponsorshipConnection"];
      sponsorshipsAsSponsor: ResolversTypes["SponsorshipConnection"];
      team?: Maybe<ResolversTypes["Team"]>;
      teams: ResolversTypes["TeamConnection"];
    }
  >;
  OrganizationAuditEntry: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["OrganizationAuditEntry"]
  >;
  OrganizationAuditEntryConnection: ResolverTypeWrapper<
    Omit<OrganizationAuditEntryConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["OrganizationAuditEntryEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["OrganizationAuditEntry"]>>>;
    }
  >;
  OrganizationAuditEntryData: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["OrganizationAuditEntryData"]
  >;
  OrganizationAuditEntryEdge: ResolverTypeWrapper<
    Omit<OrganizationAuditEntryEdge, "node"> & {
      node?: Maybe<ResolversTypes["OrganizationAuditEntry"]>;
    }
  >;
  OrganizationConnection: ResolverTypeWrapper<
    Omit<OrganizationConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["OrganizationEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Organization"]>>>;
    }
  >;
  OrganizationEdge: ResolverTypeWrapper<
    Omit<OrganizationEdge, "node"> & {
      node?: Maybe<ResolversTypes["Organization"]>;
    }
  >;
  OrganizationEnterpriseOwnerConnection: ResolverTypeWrapper<
    Omit<OrganizationEnterpriseOwnerConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["OrganizationEnterpriseOwnerEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["User"]>>>;
    }
  >;
  OrganizationEnterpriseOwnerEdge: ResolverTypeWrapper<
    Omit<OrganizationEnterpriseOwnerEdge, "node"> & {
      node?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrganizationIdentityProvider: ResolverTypeWrapper<
    Omit<
      OrganizationIdentityProvider,
      "externalIdentities" | "organization"
    > & {
      externalIdentities: ResolversTypes["ExternalIdentityConnection"];
      organization?: Maybe<ResolversTypes["Organization"]>;
    }
  >;
  OrganizationInvitation: ResolverTypeWrapper<
    Omit<
      OrganizationInvitation,
      "invitee" | "inviter" | "inviterActor" | "organization"
    > & {
      invitee?: Maybe<ResolversTypes["User"]>;
      inviter: ResolversTypes["User"];
      inviterActor?: Maybe<ResolversTypes["User"]>;
      organization: ResolversTypes["Organization"];
    }
  >;
  OrganizationInvitationConnection: ResolverTypeWrapper<
    Omit<OrganizationInvitationConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["OrganizationInvitationEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["OrganizationInvitation"]>>>;
    }
  >;
  OrganizationInvitationEdge: ResolverTypeWrapper<
    Omit<OrganizationInvitationEdge, "node"> & {
      node?: Maybe<ResolversTypes["OrganizationInvitation"]>;
    }
  >;
  OrganizationInvitationRole: OrganizationInvitationRole;
  OrganizationInvitationSource: OrganizationInvitationSource;
  OrganizationInvitationType: OrganizationInvitationType;
  OrganizationMemberConnection: ResolverTypeWrapper<
    Omit<OrganizationMemberConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["OrganizationMemberEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["User"]>>>;
    }
  >;
  OrganizationMemberEdge: ResolverTypeWrapper<
    Omit<OrganizationMemberEdge, "node"> & {
      node?: Maybe<ResolversTypes["User"]>;
    }
  >;
  OrganizationMemberRole: OrganizationMemberRole;
  OrganizationMembersCanCreateRepositoriesSettingValue: OrganizationMembersCanCreateRepositoriesSettingValue;
  OrganizationMigration: ResolverTypeWrapper<OrganizationMigration>;
  OrganizationMigrationState: OrganizationMigrationState;
  OrganizationOrUser: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["OrganizationOrUser"]
  >;
  OrganizationOrder: OrganizationOrder;
  OrganizationOrderField: OrganizationOrderField;
  OrganizationTeamsHovercardContext: ResolverTypeWrapper<
    Omit<OrganizationTeamsHovercardContext, "relevantTeams"> & {
      relevantTeams: ResolversTypes["TeamConnection"];
    }
  >;
  OrganizationsHovercardContext: ResolverTypeWrapper<
    Omit<OrganizationsHovercardContext, "relevantOrganizations"> & {
      relevantOrganizations: ResolversTypes["OrganizationConnection"];
    }
  >;
  Package: ResolverTypeWrapper<
    Omit<Package, "latestVersion" | "repository" | "version" | "versions"> & {
      latestVersion?: Maybe<ResolversTypes["PackageVersion"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      version?: Maybe<ResolversTypes["PackageVersion"]>;
      versions: ResolversTypes["PackageVersionConnection"];
    }
  >;
  PackageConnection: ResolverTypeWrapper<
    Omit<PackageConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["PackageEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Package"]>>>;
    }
  >;
  PackageEdge: ResolverTypeWrapper<
    Omit<PackageEdge, "node"> & { node?: Maybe<ResolversTypes["Package"]> }
  >;
  PackageFile: ResolverTypeWrapper<
    Omit<PackageFile, "packageVersion"> & {
      packageVersion?: Maybe<ResolversTypes["PackageVersion"]>;
    }
  >;
  PackageFileConnection: ResolverTypeWrapper<PackageFileConnection>;
  PackageFileEdge: ResolverTypeWrapper<PackageFileEdge>;
  PackageFileOrder: PackageFileOrder;
  PackageFileOrderField: PackageFileOrderField;
  PackageOrder: PackageOrder;
  PackageOrderField: PackageOrderField;
  PackageOwner: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["PackageOwner"]
  >;
  PackageStatistics: ResolverTypeWrapper<PackageStatistics>;
  PackageTag: ResolverTypeWrapper<
    Omit<PackageTag, "version"> & {
      version?: Maybe<ResolversTypes["PackageVersion"]>;
    }
  >;
  PackageType: PackageType;
  PackageVersion: ResolverTypeWrapper<
    Omit<PackageVersion, "package" | "release"> & {
      package?: Maybe<ResolversTypes["Package"]>;
      release?: Maybe<ResolversTypes["Release"]>;
    }
  >;
  PackageVersionConnection: ResolverTypeWrapper<
    Omit<PackageVersionConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["PackageVersionEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PackageVersion"]>>>;
    }
  >;
  PackageVersionEdge: ResolverTypeWrapper<
    Omit<PackageVersionEdge, "node"> & {
      node?: Maybe<ResolversTypes["PackageVersion"]>;
    }
  >;
  PackageVersionOrder: PackageVersionOrder;
  PackageVersionOrderField: PackageVersionOrderField;
  PackageVersionStatistics: ResolverTypeWrapper<PackageVersionStatistics>;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  PatchStatus: PatchStatus;
  PermissionGranter: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["PermissionGranter"]
  >;
  PermissionSource: ResolverTypeWrapper<
    Omit<PermissionSource, "organization" | "source"> & {
      organization: ResolversTypes["Organization"];
      source: ResolversTypes["PermissionGranter"];
    }
  >;
  PinEnvironmentInput: PinEnvironmentInput;
  PinEnvironmentPayload: ResolverTypeWrapper<
    Omit<PinEnvironmentPayload, "environment" | "pinnedEnvironment"> & {
      environment?: Maybe<ResolversTypes["Environment"]>;
      pinnedEnvironment?: Maybe<ResolversTypes["PinnedEnvironment"]>;
    }
  >;
  PinIssueInput: PinIssueInput;
  PinIssuePayload: ResolverTypeWrapper<
    Omit<PinIssuePayload, "issue"> & { issue?: Maybe<ResolversTypes["Issue"]> }
  >;
  PinnableItem: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["PinnableItem"]
  >;
  PinnableItemConnection: ResolverTypeWrapper<
    Omit<PinnableItemConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["PinnableItemEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PinnableItem"]>>>;
    }
  >;
  PinnableItemEdge: ResolverTypeWrapper<
    Omit<PinnableItemEdge, "node"> & {
      node?: Maybe<ResolversTypes["PinnableItem"]>;
    }
  >;
  PinnableItemType: PinnableItemType;
  PinnedDiscussion: ResolverTypeWrapper<
    Omit<PinnedDiscussion, "discussion" | "pinnedBy" | "repository"> & {
      discussion: ResolversTypes["Discussion"];
      pinnedBy: ResolversTypes["Actor"];
      repository: ResolversTypes["Repository"];
    }
  >;
  PinnedDiscussionConnection: ResolverTypeWrapper<
    Omit<PinnedDiscussionConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["PinnedDiscussionEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PinnedDiscussion"]>>>;
    }
  >;
  PinnedDiscussionEdge: ResolverTypeWrapper<
    Omit<PinnedDiscussionEdge, "node"> & {
      node?: Maybe<ResolversTypes["PinnedDiscussion"]>;
    }
  >;
  PinnedDiscussionGradient: PinnedDiscussionGradient;
  PinnedDiscussionPattern: PinnedDiscussionPattern;
  PinnedEnvironment: ResolverTypeWrapper<
    Omit<PinnedEnvironment, "environment" | "repository"> & {
      environment: ResolversTypes["Environment"];
      repository: ResolversTypes["Repository"];
    }
  >;
  PinnedEnvironmentConnection: ResolverTypeWrapper<
    Omit<PinnedEnvironmentConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["PinnedEnvironmentEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PinnedEnvironment"]>>>;
    }
  >;
  PinnedEnvironmentEdge: ResolverTypeWrapper<
    Omit<PinnedEnvironmentEdge, "node"> & {
      node?: Maybe<ResolversTypes["PinnedEnvironment"]>;
    }
  >;
  PinnedEnvironmentOrder: PinnedEnvironmentOrder;
  PinnedEnvironmentOrderField: PinnedEnvironmentOrderField;
  PinnedEvent: ResolverTypeWrapper<
    Omit<PinnedEvent, "actor" | "issue"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      issue: ResolversTypes["Issue"];
    }
  >;
  PinnedIssue: ResolverTypeWrapper<
    Omit<PinnedIssue, "issue" | "pinnedBy" | "repository"> & {
      issue: ResolversTypes["Issue"];
      pinnedBy: ResolversTypes["Actor"];
      repository: ResolversTypes["Repository"];
    }
  >;
  PinnedIssueConnection: ResolverTypeWrapper<
    Omit<PinnedIssueConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["PinnedIssueEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PinnedIssue"]>>>;
    }
  >;
  PinnedIssueEdge: ResolverTypeWrapper<
    Omit<PinnedIssueEdge, "node"> & {
      node?: Maybe<ResolversTypes["PinnedIssue"]>;
    }
  >;
  PreciseDateTime: ResolverTypeWrapper<Scalars["PreciseDateTime"]["output"]>;
  PrivateRepositoryForkingDisableAuditEntry: ResolverTypeWrapper<
    Omit<
      PrivateRepositoryForkingDisableAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  PrivateRepositoryForkingEnableAuditEntry: ResolverTypeWrapper<
    Omit<
      PrivateRepositoryForkingEnableAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  ProfileItemShowcase: ResolverTypeWrapper<
    Omit<ProfileItemShowcase, "items"> & {
      items: ResolversTypes["PinnableItemConnection"];
    }
  >;
  ProfileOwner: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["ProfileOwner"]
  >;
  Project: ResolverTypeWrapper<
    Omit<Project, "creator" | "owner" | "pendingCards"> & {
      creator?: Maybe<ResolversTypes["Actor"]>;
      owner: ResolversTypes["ProjectOwner"];
      pendingCards: ResolversTypes["ProjectCardConnection"];
    }
  >;
  ProjectCard: ResolverTypeWrapper<
    Omit<ProjectCard, "column" | "content" | "creator" | "project"> & {
      column?: Maybe<ResolversTypes["ProjectColumn"]>;
      content?: Maybe<ResolversTypes["ProjectCardItem"]>;
      creator?: Maybe<ResolversTypes["Actor"]>;
      project: ResolversTypes["Project"];
    }
  >;
  ProjectCardArchivedState: ProjectCardArchivedState;
  ProjectCardConnection: ResolverTypeWrapper<
    Omit<ProjectCardConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ProjectCardEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ProjectCard"]>>>;
    }
  >;
  ProjectCardEdge: ResolverTypeWrapper<
    Omit<ProjectCardEdge, "node"> & {
      node?: Maybe<ResolversTypes["ProjectCard"]>;
    }
  >;
  ProjectCardImport: ProjectCardImport;
  ProjectCardItem: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["ProjectCardItem"]
  >;
  ProjectCardState: ProjectCardState;
  ProjectColumn: ResolverTypeWrapper<
    Omit<ProjectColumn, "cards" | "project"> & {
      cards: ResolversTypes["ProjectCardConnection"];
      project: ResolversTypes["Project"];
    }
  >;
  ProjectColumnConnection: ResolverTypeWrapper<
    Omit<ProjectColumnConnection, "nodes"> & {
      nodes?: Maybe<Array<Maybe<ResolversTypes["ProjectColumn"]>>>;
    }
  >;
  ProjectColumnEdge: ResolverTypeWrapper<
    Omit<ProjectColumnEdge, "node"> & {
      node?: Maybe<ResolversTypes["ProjectColumn"]>;
    }
  >;
  ProjectColumnImport: ProjectColumnImport;
  ProjectColumnPurpose: ProjectColumnPurpose;
  ProjectConnection: ResolverTypeWrapper<
    Omit<ProjectConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ProjectEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Project"]>>>;
    }
  >;
  ProjectEdge: ResolverTypeWrapper<
    Omit<ProjectEdge, "node"> & { node?: Maybe<ResolversTypes["Project"]> }
  >;
  ProjectOrder: ProjectOrder;
  ProjectOrderField: ProjectOrderField;
  ProjectOwner: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["ProjectOwner"]
  >;
  ProjectProgress: ResolverTypeWrapper<ProjectProgress>;
  ProjectState: ProjectState;
  ProjectTemplate: ProjectTemplate;
  ProjectV2: ResolverTypeWrapper<
    Omit<
      ProjectV2,
      | "creator"
      | "field"
      | "fields"
      | "items"
      | "owner"
      | "repositories"
      | "statusUpdates"
      | "teams"
      | "view"
      | "views"
      | "workflow"
      | "workflows"
    > & {
      creator?: Maybe<ResolversTypes["Actor"]>;
      field?: Maybe<ResolversTypes["ProjectV2FieldConfiguration"]>;
      fields: ResolversTypes["ProjectV2FieldConfigurationConnection"];
      items: ResolversTypes["ProjectV2ItemConnection"];
      owner: ResolversTypes["ProjectV2Owner"];
      repositories: ResolversTypes["RepositoryConnection"];
      statusUpdates: ResolversTypes["ProjectV2StatusUpdateConnection"];
      teams: ResolversTypes["TeamConnection"];
      view?: Maybe<ResolversTypes["ProjectV2View"]>;
      views: ResolversTypes["ProjectV2ViewConnection"];
      workflow?: Maybe<ResolversTypes["ProjectV2Workflow"]>;
      workflows: ResolversTypes["ProjectV2WorkflowConnection"];
    }
  >;
  ProjectV2Actor: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["ProjectV2Actor"]
  >;
  ProjectV2ActorConnection: ResolverTypeWrapper<
    Omit<ProjectV2ActorConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ProjectV2ActorEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ProjectV2Actor"]>>>;
    }
  >;
  ProjectV2ActorEdge: ResolverTypeWrapper<
    Omit<ProjectV2ActorEdge, "node"> & {
      node?: Maybe<ResolversTypes["ProjectV2Actor"]>;
    }
  >;
  ProjectV2Collaborator: ProjectV2Collaborator;
  ProjectV2Connection: ResolverTypeWrapper<
    Omit<ProjectV2Connection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ProjectV2Edge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ProjectV2"]>>>;
    }
  >;
  ProjectV2CustomFieldType: ProjectV2CustomFieldType;
  ProjectV2Edge: ResolverTypeWrapper<
    Omit<ProjectV2Edge, "node"> & { node?: Maybe<ResolversTypes["ProjectV2"]> }
  >;
  ProjectV2Field: ResolverTypeWrapper<
    Omit<ProjectV2Field, "project"> & { project: ResolversTypes["ProjectV2"] }
  >;
  ProjectV2FieldCommon: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["ProjectV2FieldCommon"]
  >;
  ProjectV2FieldConfiguration: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["ProjectV2FieldConfiguration"]
  >;
  ProjectV2FieldConfigurationConnection: ResolverTypeWrapper<
    Omit<ProjectV2FieldConfigurationConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["ProjectV2FieldConfigurationEdge"]>>
      >;
      nodes?: Maybe<
        Array<Maybe<ResolversTypes["ProjectV2FieldConfiguration"]>>
      >;
    }
  >;
  ProjectV2FieldConfigurationEdge: ResolverTypeWrapper<
    Omit<ProjectV2FieldConfigurationEdge, "node"> & {
      node?: Maybe<ResolversTypes["ProjectV2FieldConfiguration"]>;
    }
  >;
  ProjectV2FieldConnection: ResolverTypeWrapper<
    Omit<ProjectV2FieldConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ProjectV2FieldEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ProjectV2Field"]>>>;
    }
  >;
  ProjectV2FieldEdge: ResolverTypeWrapper<
    Omit<ProjectV2FieldEdge, "node"> & {
      node?: Maybe<ResolversTypes["ProjectV2Field"]>;
    }
  >;
  ProjectV2FieldOrder: ProjectV2FieldOrder;
  ProjectV2FieldOrderField: ProjectV2FieldOrderField;
  ProjectV2FieldType: ProjectV2FieldType;
  ProjectV2FieldValue: ProjectV2FieldValue;
  ProjectV2Filters: ProjectV2Filters;
  ProjectV2Item: ResolverTypeWrapper<
    Omit<
      ProjectV2Item,
      "content" | "creator" | "fieldValueByName" | "fieldValues" | "project"
    > & {
      content?: Maybe<ResolversTypes["ProjectV2ItemContent"]>;
      creator?: Maybe<ResolversTypes["Actor"]>;
      fieldValueByName?: Maybe<ResolversTypes["ProjectV2ItemFieldValue"]>;
      fieldValues: ResolversTypes["ProjectV2ItemFieldValueConnection"];
      project: ResolversTypes["ProjectV2"];
    }
  >;
  ProjectV2ItemConnection: ResolverTypeWrapper<
    Omit<ProjectV2ItemConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ProjectV2ItemEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ProjectV2Item"]>>>;
    }
  >;
  ProjectV2ItemContent: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["ProjectV2ItemContent"]
  >;
  ProjectV2ItemEdge: ResolverTypeWrapper<
    Omit<ProjectV2ItemEdge, "node"> & {
      node?: Maybe<ResolversTypes["ProjectV2Item"]>;
    }
  >;
  ProjectV2ItemFieldDateValue: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldDateValue, "creator" | "field" | "item"> & {
      creator?: Maybe<ResolversTypes["Actor"]>;
      field: ResolversTypes["ProjectV2FieldConfiguration"];
      item: ResolversTypes["ProjectV2Item"];
    }
  >;
  ProjectV2ItemFieldIterationValue: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldIterationValue, "creator" | "field" | "item"> & {
      creator?: Maybe<ResolversTypes["Actor"]>;
      field: ResolversTypes["ProjectV2FieldConfiguration"];
      item: ResolversTypes["ProjectV2Item"];
    }
  >;
  ProjectV2ItemFieldLabelValue: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldLabelValue, "field" | "labels"> & {
      field: ResolversTypes["ProjectV2FieldConfiguration"];
      labels?: Maybe<ResolversTypes["LabelConnection"]>;
    }
  >;
  ProjectV2ItemFieldMilestoneValue: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldMilestoneValue, "field" | "milestone"> & {
      field: ResolversTypes["ProjectV2FieldConfiguration"];
      milestone?: Maybe<ResolversTypes["Milestone"]>;
    }
  >;
  ProjectV2ItemFieldNumberValue: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldNumberValue, "creator" | "field" | "item"> & {
      creator?: Maybe<ResolversTypes["Actor"]>;
      field: ResolversTypes["ProjectV2FieldConfiguration"];
      item: ResolversTypes["ProjectV2Item"];
    }
  >;
  ProjectV2ItemFieldPullRequestValue: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldPullRequestValue, "field" | "pullRequests"> & {
      field: ResolversTypes["ProjectV2FieldConfiguration"];
      pullRequests?: Maybe<ResolversTypes["PullRequestConnection"]>;
    }
  >;
  ProjectV2ItemFieldRepositoryValue: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldRepositoryValue, "field" | "repository"> & {
      field: ResolversTypes["ProjectV2FieldConfiguration"];
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  ProjectV2ItemFieldReviewerValue: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldReviewerValue, "field" | "reviewers"> & {
      field: ResolversTypes["ProjectV2FieldConfiguration"];
      reviewers?: Maybe<ResolversTypes["RequestedReviewerConnection"]>;
    }
  >;
  ProjectV2ItemFieldSingleSelectValue: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldSingleSelectValue, "creator" | "field" | "item"> & {
      creator?: Maybe<ResolversTypes["Actor"]>;
      field: ResolversTypes["ProjectV2FieldConfiguration"];
      item: ResolversTypes["ProjectV2Item"];
    }
  >;
  ProjectV2ItemFieldTextValue: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldTextValue, "creator" | "field" | "item"> & {
      creator?: Maybe<ResolversTypes["Actor"]>;
      field: ResolversTypes["ProjectV2FieldConfiguration"];
      item: ResolversTypes["ProjectV2Item"];
    }
  >;
  ProjectV2ItemFieldUserValue: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldUserValue, "field"> & {
      field: ResolversTypes["ProjectV2FieldConfiguration"];
    }
  >;
  ProjectV2ItemFieldValue: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["ProjectV2ItemFieldValue"]
  >;
  ProjectV2ItemFieldValueCommon: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["ProjectV2ItemFieldValueCommon"]
  >;
  ProjectV2ItemFieldValueConnection: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldValueConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["ProjectV2ItemFieldValueEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ProjectV2ItemFieldValue"]>>>;
    }
  >;
  ProjectV2ItemFieldValueEdge: ResolverTypeWrapper<
    Omit<ProjectV2ItemFieldValueEdge, "node"> & {
      node?: Maybe<ResolversTypes["ProjectV2ItemFieldValue"]>;
    }
  >;
  ProjectV2ItemFieldValueOrder: ProjectV2ItemFieldValueOrder;
  ProjectV2ItemFieldValueOrderField: ProjectV2ItemFieldValueOrderField;
  ProjectV2ItemOrder: ProjectV2ItemOrder;
  ProjectV2ItemOrderField: ProjectV2ItemOrderField;
  ProjectV2ItemType: ProjectV2ItemType;
  ProjectV2IterationField: ResolverTypeWrapper<
    Omit<ProjectV2IterationField, "project"> & {
      project: ResolversTypes["ProjectV2"];
    }
  >;
  ProjectV2IterationFieldConfiguration: ResolverTypeWrapper<ProjectV2IterationFieldConfiguration>;
  ProjectV2IterationFieldIteration: ResolverTypeWrapper<ProjectV2IterationFieldIteration>;
  ProjectV2Order: ProjectV2Order;
  ProjectV2OrderField: ProjectV2OrderField;
  ProjectV2Owner: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["ProjectV2Owner"]
  >;
  ProjectV2PermissionLevel: ProjectV2PermissionLevel;
  ProjectV2Recent: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["ProjectV2Recent"]
  >;
  ProjectV2Roles: ProjectV2Roles;
  ProjectV2SingleSelectField: ResolverTypeWrapper<
    Omit<ProjectV2SingleSelectField, "project"> & {
      project: ResolversTypes["ProjectV2"];
    }
  >;
  ProjectV2SingleSelectFieldOption: ResolverTypeWrapper<ProjectV2SingleSelectFieldOption>;
  ProjectV2SingleSelectFieldOptionColor: ProjectV2SingleSelectFieldOptionColor;
  ProjectV2SingleSelectFieldOptionInput: ProjectV2SingleSelectFieldOptionInput;
  ProjectV2SortBy: ResolverTypeWrapper<
    Omit<ProjectV2SortBy, "field"> & { field: ResolversTypes["ProjectV2Field"] }
  >;
  ProjectV2SortByConnection: ResolverTypeWrapper<
    Omit<ProjectV2SortByConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ProjectV2SortByEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ProjectV2SortBy"]>>>;
    }
  >;
  ProjectV2SortByEdge: ResolverTypeWrapper<
    Omit<ProjectV2SortByEdge, "node"> & {
      node?: Maybe<ResolversTypes["ProjectV2SortBy"]>;
    }
  >;
  ProjectV2SortByField: ResolverTypeWrapper<
    Omit<ProjectV2SortByField, "field"> & {
      field: ResolversTypes["ProjectV2FieldConfiguration"];
    }
  >;
  ProjectV2SortByFieldConnection: ResolverTypeWrapper<
    Omit<ProjectV2SortByFieldConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ProjectV2SortByFieldEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ProjectV2SortByField"]>>>;
    }
  >;
  ProjectV2SortByFieldEdge: ResolverTypeWrapper<
    Omit<ProjectV2SortByFieldEdge, "node"> & {
      node?: Maybe<ResolversTypes["ProjectV2SortByField"]>;
    }
  >;
  ProjectV2State: ProjectV2State;
  ProjectV2StatusOrder: ProjectV2StatusOrder;
  ProjectV2StatusUpdate: ResolverTypeWrapper<
    Omit<ProjectV2StatusUpdate, "creator" | "project"> & {
      creator?: Maybe<ResolversTypes["Actor"]>;
      project: ResolversTypes["ProjectV2"];
    }
  >;
  ProjectV2StatusUpdateConnection: ResolverTypeWrapper<
    Omit<ProjectV2StatusUpdateConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ProjectV2StatusUpdateEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ProjectV2StatusUpdate"]>>>;
    }
  >;
  ProjectV2StatusUpdateEdge: ResolverTypeWrapper<
    Omit<ProjectV2StatusUpdateEdge, "node"> & {
      node?: Maybe<ResolversTypes["ProjectV2StatusUpdate"]>;
    }
  >;
  ProjectV2StatusUpdateOrderField: ProjectV2StatusUpdateOrderField;
  ProjectV2StatusUpdateStatus: ProjectV2StatusUpdateStatus;
  ProjectV2View: ResolverTypeWrapper<
    Omit<
      ProjectV2View,
      | "fields"
      | "groupBy"
      | "groupByFields"
      | "project"
      | "sortBy"
      | "sortByFields"
      | "verticalGroupBy"
      | "verticalGroupByFields"
      | "visibleFields"
    > & {
      fields?: Maybe<ResolversTypes["ProjectV2FieldConfigurationConnection"]>;
      groupBy?: Maybe<ResolversTypes["ProjectV2FieldConnection"]>;
      groupByFields?: Maybe<
        ResolversTypes["ProjectV2FieldConfigurationConnection"]
      >;
      project: ResolversTypes["ProjectV2"];
      sortBy?: Maybe<ResolversTypes["ProjectV2SortByConnection"]>;
      sortByFields?: Maybe<ResolversTypes["ProjectV2SortByFieldConnection"]>;
      verticalGroupBy?: Maybe<ResolversTypes["ProjectV2FieldConnection"]>;
      verticalGroupByFields?: Maybe<
        ResolversTypes["ProjectV2FieldConfigurationConnection"]
      >;
      visibleFields?: Maybe<ResolversTypes["ProjectV2FieldConnection"]>;
    }
  >;
  ProjectV2ViewConnection: ResolverTypeWrapper<
    Omit<ProjectV2ViewConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ProjectV2ViewEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ProjectV2View"]>>>;
    }
  >;
  ProjectV2ViewEdge: ResolverTypeWrapper<
    Omit<ProjectV2ViewEdge, "node"> & {
      node?: Maybe<ResolversTypes["ProjectV2View"]>;
    }
  >;
  ProjectV2ViewLayout: ProjectV2ViewLayout;
  ProjectV2ViewOrder: ProjectV2ViewOrder;
  ProjectV2ViewOrderField: ProjectV2ViewOrderField;
  ProjectV2Workflow: ResolverTypeWrapper<
    Omit<ProjectV2Workflow, "project"> & {
      project: ResolversTypes["ProjectV2"];
    }
  >;
  ProjectV2WorkflowConnection: ResolverTypeWrapper<
    Omit<ProjectV2WorkflowConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ProjectV2WorkflowEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ProjectV2Workflow"]>>>;
    }
  >;
  ProjectV2WorkflowEdge: ResolverTypeWrapper<
    Omit<ProjectV2WorkflowEdge, "node"> & {
      node?: Maybe<ResolversTypes["ProjectV2Workflow"]>;
    }
  >;
  ProjectV2WorkflowOrder: ProjectV2WorkflowOrder;
  ProjectV2WorkflowsOrderField: ProjectV2WorkflowsOrderField;
  PropertyTargetDefinition: ResolverTypeWrapper<PropertyTargetDefinition>;
  PropertyTargetDefinitionInput: PropertyTargetDefinitionInput;
  PublicKey: ResolverTypeWrapper<PublicKey>;
  PublicKeyConnection: ResolverTypeWrapper<PublicKeyConnection>;
  PublicKeyEdge: ResolverTypeWrapper<PublicKeyEdge>;
  PublishSponsorsTierInput: PublishSponsorsTierInput;
  PublishSponsorsTierPayload: ResolverTypeWrapper<
    Omit<PublishSponsorsTierPayload, "sponsorsTier"> & {
      sponsorsTier?: Maybe<ResolversTypes["SponsorsTier"]>;
    }
  >;
  PullRequest: ResolverTypeWrapper<
    Omit<
      PullRequest,
      | "author"
      | "autoMergeRequest"
      | "baseRef"
      | "baseRepository"
      | "closingIssuesReferences"
      | "comments"
      | "commits"
      | "editor"
      | "headRef"
      | "headRepository"
      | "headRepositoryOwner"
      | "hovercard"
      | "labels"
      | "latestOpinionatedReviews"
      | "latestReviews"
      | "mergeCommit"
      | "mergeQueue"
      | "mergeQueueEntry"
      | "mergedBy"
      | "milestone"
      | "potentialMergeCommit"
      | "projectCards"
      | "projectItems"
      | "projectV2"
      | "projectsV2"
      | "reactionGroups"
      | "reactions"
      | "repository"
      | "reviewRequests"
      | "reviewThreads"
      | "reviews"
      | "statusCheckRollup"
      | "timeline"
      | "timelineItems"
      | "userContentEdits"
      | "viewerLatestReview"
      | "viewerLatestReviewRequest"
    > & {
      author?: Maybe<ResolversTypes["Actor"]>;
      autoMergeRequest?: Maybe<ResolversTypes["AutoMergeRequest"]>;
      baseRef?: Maybe<ResolversTypes["Ref"]>;
      baseRepository?: Maybe<ResolversTypes["Repository"]>;
      closingIssuesReferences?: Maybe<ResolversTypes["IssueConnection"]>;
      comments: ResolversTypes["IssueCommentConnection"];
      commits: ResolversTypes["PullRequestCommitConnection"];
      editor?: Maybe<ResolversTypes["Actor"]>;
      headRef?: Maybe<ResolversTypes["Ref"]>;
      headRepository?: Maybe<ResolversTypes["Repository"]>;
      headRepositoryOwner?: Maybe<ResolversTypes["RepositoryOwner"]>;
      hovercard: ResolversTypes["Hovercard"];
      labels?: Maybe<ResolversTypes["LabelConnection"]>;
      latestOpinionatedReviews?: Maybe<
        ResolversTypes["PullRequestReviewConnection"]
      >;
      latestReviews?: Maybe<ResolversTypes["PullRequestReviewConnection"]>;
      mergeCommit?: Maybe<ResolversTypes["Commit"]>;
      mergeQueue?: Maybe<ResolversTypes["MergeQueue"]>;
      mergeQueueEntry?: Maybe<ResolversTypes["MergeQueueEntry"]>;
      mergedBy?: Maybe<ResolversTypes["Actor"]>;
      milestone?: Maybe<ResolversTypes["Milestone"]>;
      potentialMergeCommit?: Maybe<ResolversTypes["Commit"]>;
      projectCards: ResolversTypes["ProjectCardConnection"];
      projectItems: ResolversTypes["ProjectV2ItemConnection"];
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
      projectsV2: ResolversTypes["ProjectV2Connection"];
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      reactions: ResolversTypes["ReactionConnection"];
      repository: ResolversTypes["Repository"];
      reviewRequests?: Maybe<ResolversTypes["ReviewRequestConnection"]>;
      reviewThreads: ResolversTypes["PullRequestReviewThreadConnection"];
      reviews?: Maybe<ResolversTypes["PullRequestReviewConnection"]>;
      statusCheckRollup?: Maybe<ResolversTypes["StatusCheckRollup"]>;
      timeline: ResolversTypes["PullRequestTimelineConnection"];
      timelineItems: ResolversTypes["PullRequestTimelineItemsConnection"];
      userContentEdits?: Maybe<ResolversTypes["UserContentEditConnection"]>;
      viewerLatestReview?: Maybe<ResolversTypes["PullRequestReview"]>;
      viewerLatestReviewRequest?: Maybe<ResolversTypes["ReviewRequest"]>;
    }
  >;
  PullRequestBranchUpdateMethod: PullRequestBranchUpdateMethod;
  PullRequestChangedFile: ResolverTypeWrapper<PullRequestChangedFile>;
  PullRequestChangedFileConnection: ResolverTypeWrapper<PullRequestChangedFileConnection>;
  PullRequestChangedFileEdge: ResolverTypeWrapper<PullRequestChangedFileEdge>;
  PullRequestCommit: ResolverTypeWrapper<
    Omit<PullRequestCommit, "commit" | "pullRequest"> & {
      commit: ResolversTypes["Commit"];
      pullRequest: ResolversTypes["PullRequest"];
    }
  >;
  PullRequestCommitCommentThread: ResolverTypeWrapper<
    Omit<
      PullRequestCommitCommentThread,
      "comments" | "commit" | "pullRequest" | "repository"
    > & {
      comments: ResolversTypes["CommitCommentConnection"];
      commit: ResolversTypes["Commit"];
      pullRequest: ResolversTypes["PullRequest"];
      repository: ResolversTypes["Repository"];
    }
  >;
  PullRequestCommitConnection: ResolverTypeWrapper<
    Omit<PullRequestCommitConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["PullRequestCommitEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PullRequestCommit"]>>>;
    }
  >;
  PullRequestCommitEdge: ResolverTypeWrapper<
    Omit<PullRequestCommitEdge, "node"> & {
      node?: Maybe<ResolversTypes["PullRequestCommit"]>;
    }
  >;
  PullRequestConnection: ResolverTypeWrapper<
    Omit<PullRequestConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["PullRequestEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PullRequest"]>>>;
    }
  >;
  PullRequestContributionsByRepository: ResolverTypeWrapper<
    Omit<
      PullRequestContributionsByRepository,
      "contributions" | "repository"
    > & {
      contributions: ResolversTypes["CreatedPullRequestContributionConnection"];
      repository: ResolversTypes["Repository"];
    }
  >;
  PullRequestEdge: ResolverTypeWrapper<
    Omit<PullRequestEdge, "node"> & {
      node?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  PullRequestMergeMethod: PullRequestMergeMethod;
  PullRequestOrder: PullRequestOrder;
  PullRequestOrderField: PullRequestOrderField;
  PullRequestParameters: ResolverTypeWrapper<PullRequestParameters>;
  PullRequestParametersInput: PullRequestParametersInput;
  PullRequestReview: ResolverTypeWrapper<
    Omit<
      PullRequestReview,
      | "author"
      | "comments"
      | "commit"
      | "editor"
      | "onBehalfOf"
      | "pullRequest"
      | "reactionGroups"
      | "reactions"
      | "repository"
      | "userContentEdits"
    > & {
      author?: Maybe<ResolversTypes["Actor"]>;
      comments: ResolversTypes["PullRequestReviewCommentConnection"];
      commit?: Maybe<ResolversTypes["Commit"]>;
      editor?: Maybe<ResolversTypes["Actor"]>;
      onBehalfOf: ResolversTypes["TeamConnection"];
      pullRequest: ResolversTypes["PullRequest"];
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      reactions: ResolversTypes["ReactionConnection"];
      repository: ResolversTypes["Repository"];
      userContentEdits?: Maybe<ResolversTypes["UserContentEditConnection"]>;
    }
  >;
  PullRequestReviewComment: ResolverTypeWrapper<
    Omit<
      PullRequestReviewComment,
      | "author"
      | "commit"
      | "editor"
      | "originalCommit"
      | "pullRequest"
      | "pullRequestReview"
      | "reactionGroups"
      | "reactions"
      | "replyTo"
      | "repository"
      | "userContentEdits"
    > & {
      author?: Maybe<ResolversTypes["Actor"]>;
      commit?: Maybe<ResolversTypes["Commit"]>;
      editor?: Maybe<ResolversTypes["Actor"]>;
      originalCommit?: Maybe<ResolversTypes["Commit"]>;
      pullRequest: ResolversTypes["PullRequest"];
      pullRequestReview?: Maybe<ResolversTypes["PullRequestReview"]>;
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      reactions: ResolversTypes["ReactionConnection"];
      replyTo?: Maybe<ResolversTypes["PullRequestReviewComment"]>;
      repository: ResolversTypes["Repository"];
      userContentEdits?: Maybe<ResolversTypes["UserContentEditConnection"]>;
    }
  >;
  PullRequestReviewCommentConnection: ResolverTypeWrapper<
    Omit<PullRequestReviewCommentConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["PullRequestReviewCommentEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PullRequestReviewComment"]>>>;
    }
  >;
  PullRequestReviewCommentEdge: ResolverTypeWrapper<
    Omit<PullRequestReviewCommentEdge, "node"> & {
      node?: Maybe<ResolversTypes["PullRequestReviewComment"]>;
    }
  >;
  PullRequestReviewCommentState: PullRequestReviewCommentState;
  PullRequestReviewConnection: ResolverTypeWrapper<
    Omit<PullRequestReviewConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["PullRequestReviewEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PullRequestReview"]>>>;
    }
  >;
  PullRequestReviewContributionsByRepository: ResolverTypeWrapper<
    Omit<
      PullRequestReviewContributionsByRepository,
      "contributions" | "repository"
    > & {
      contributions: ResolversTypes["CreatedPullRequestReviewContributionConnection"];
      repository: ResolversTypes["Repository"];
    }
  >;
  PullRequestReviewDecision: PullRequestReviewDecision;
  PullRequestReviewEdge: ResolverTypeWrapper<
    Omit<PullRequestReviewEdge, "node"> & {
      node?: Maybe<ResolversTypes["PullRequestReview"]>;
    }
  >;
  PullRequestReviewEvent: PullRequestReviewEvent;
  PullRequestReviewState: PullRequestReviewState;
  PullRequestReviewThread: ResolverTypeWrapper<
    Omit<
      PullRequestReviewThread,
      "comments" | "pullRequest" | "repository" | "resolvedBy"
    > & {
      comments: ResolversTypes["PullRequestReviewCommentConnection"];
      pullRequest: ResolversTypes["PullRequest"];
      repository: ResolversTypes["Repository"];
      resolvedBy?: Maybe<ResolversTypes["User"]>;
    }
  >;
  PullRequestReviewThreadConnection: ResolverTypeWrapper<
    Omit<PullRequestReviewThreadConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["PullRequestReviewThreadEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PullRequestReviewThread"]>>>;
    }
  >;
  PullRequestReviewThreadEdge: ResolverTypeWrapper<
    Omit<PullRequestReviewThreadEdge, "node"> & {
      node?: Maybe<ResolversTypes["PullRequestReviewThread"]>;
    }
  >;
  PullRequestReviewThreadSubjectType: PullRequestReviewThreadSubjectType;
  PullRequestRevisionMarker: ResolverTypeWrapper<
    Omit<PullRequestRevisionMarker, "lastSeenCommit" | "pullRequest"> & {
      lastSeenCommit: ResolversTypes["Commit"];
      pullRequest: ResolversTypes["PullRequest"];
    }
  >;
  PullRequestState: PullRequestState;
  PullRequestTemplate: ResolverTypeWrapper<
    Omit<PullRequestTemplate, "repository"> & {
      repository: ResolversTypes["Repository"];
    }
  >;
  PullRequestThread: ResolverTypeWrapper<
    Omit<
      PullRequestThread,
      "comments" | "pullRequest" | "repository" | "resolvedBy"
    > & {
      comments: ResolversTypes["PullRequestReviewCommentConnection"];
      pullRequest: ResolversTypes["PullRequest"];
      repository: ResolversTypes["Repository"];
      resolvedBy?: Maybe<ResolversTypes["User"]>;
    }
  >;
  PullRequestTimelineConnection: ResolverTypeWrapper<
    Omit<PullRequestTimelineConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["PullRequestTimelineItemEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PullRequestTimelineItem"]>>>;
    }
  >;
  PullRequestTimelineItem: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["PullRequestTimelineItem"]
  >;
  PullRequestTimelineItemEdge: ResolverTypeWrapper<
    Omit<PullRequestTimelineItemEdge, "node"> & {
      node?: Maybe<ResolversTypes["PullRequestTimelineItem"]>;
    }
  >;
  PullRequestTimelineItems: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["PullRequestTimelineItems"]
  >;
  PullRequestTimelineItemsConnection: ResolverTypeWrapper<
    Omit<PullRequestTimelineItemsConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["PullRequestTimelineItemsEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PullRequestTimelineItems"]>>>;
    }
  >;
  PullRequestTimelineItemsEdge: ResolverTypeWrapper<
    Omit<PullRequestTimelineItemsEdge, "node"> & {
      node?: Maybe<ResolversTypes["PullRequestTimelineItems"]>;
    }
  >;
  PullRequestTimelineItemsItemType: PullRequestTimelineItemsItemType;
  PullRequestUpdateState: PullRequestUpdateState;
  Push: ResolverTypeWrapper<
    Omit<Push, "pusher" | "repository"> & {
      pusher: ResolversTypes["Actor"];
      repository: ResolversTypes["Repository"];
    }
  >;
  PushAllowance: ResolverTypeWrapper<
    Omit<PushAllowance, "actor" | "branchProtectionRule"> & {
      actor?: Maybe<ResolversTypes["PushAllowanceActor"]>;
      branchProtectionRule?: Maybe<ResolversTypes["BranchProtectionRule"]>;
    }
  >;
  PushAllowanceActor: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["PushAllowanceActor"]
  >;
  PushAllowanceConnection: ResolverTypeWrapper<
    Omit<PushAllowanceConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["PushAllowanceEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["PushAllowance"]>>>;
    }
  >;
  PushAllowanceEdge: ResolverTypeWrapper<
    Omit<PushAllowanceEdge, "node"> & {
      node?: Maybe<ResolversTypes["PushAllowance"]>;
    }
  >;
  Query: ResolverTypeWrapper<{}>;
  RateLimit: ResolverTypeWrapper<RateLimit>;
  Reactable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Reactable"]
  >;
  ReactingUserConnection: ResolverTypeWrapper<
    Omit<ReactingUserConnection, "nodes"> & {
      nodes?: Maybe<Array<Maybe<ResolversTypes["User"]>>>;
    }
  >;
  ReactingUserEdge: ResolverTypeWrapper<
    Omit<ReactingUserEdge, "node"> & { node: ResolversTypes["User"] }
  >;
  Reaction: ResolverTypeWrapper<
    Omit<Reaction, "reactable" | "user"> & {
      reactable: ResolversTypes["Reactable"];
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  ReactionConnection: ResolverTypeWrapper<
    Omit<ReactionConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ReactionEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Reaction"]>>>;
    }
  >;
  ReactionContent: ReactionContent;
  ReactionEdge: ResolverTypeWrapper<
    Omit<ReactionEdge, "node"> & { node?: Maybe<ResolversTypes["Reaction"]> }
  >;
  ReactionGroup: ResolverTypeWrapper<
    Omit<ReactionGroup, "reactors" | "subject"> & {
      reactors: ResolversTypes["ReactorConnection"];
      subject: ResolversTypes["Reactable"];
    }
  >;
  ReactionOrder: ReactionOrder;
  ReactionOrderField: ReactionOrderField;
  Reactor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>["Reactor"]>;
  ReactorConnection: ResolverTypeWrapper<
    Omit<ReactorConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ReactorEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Reactor"]>>>;
    }
  >;
  ReactorEdge: ResolverTypeWrapper<
    Omit<ReactorEdge, "node"> & { node: ResolversTypes["Reactor"] }
  >;
  ReadyForReviewEvent: ResolverTypeWrapper<
    Omit<ReadyForReviewEvent, "actor" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest: ResolversTypes["PullRequest"];
    }
  >;
  Ref: ResolverTypeWrapper<
    Omit<
      Ref,
      | "associatedPullRequests"
      | "branchProtectionRule"
      | "compare"
      | "repository"
      | "rules"
      | "target"
    > & {
      associatedPullRequests: ResolversTypes["PullRequestConnection"];
      branchProtectionRule?: Maybe<ResolversTypes["BranchProtectionRule"]>;
      compare?: Maybe<ResolversTypes["Comparison"]>;
      repository: ResolversTypes["Repository"];
      rules?: Maybe<ResolversTypes["RepositoryRuleConnection"]>;
      target?: Maybe<ResolversTypes["GitObject"]>;
    }
  >;
  RefConnection: ResolverTypeWrapper<
    Omit<RefConnection, "nodes"> & {
      nodes?: Maybe<Array<Maybe<ResolversTypes["Ref"]>>>;
    }
  >;
  RefEdge: ResolverTypeWrapper<
    Omit<RefEdge, "node"> & { node?: Maybe<ResolversTypes["Ref"]> }
  >;
  RefNameConditionTarget: ResolverTypeWrapper<RefNameConditionTarget>;
  RefNameConditionTargetInput: RefNameConditionTargetInput;
  RefOrder: RefOrder;
  RefOrderField: RefOrderField;
  RefUpdate: RefUpdate;
  RefUpdateRule: ResolverTypeWrapper<RefUpdateRule>;
  ReferencedEvent: ResolverTypeWrapper<
    Omit<
      ReferencedEvent,
      "actor" | "commit" | "commitRepository" | "subject"
    > & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      commit?: Maybe<ResolversTypes["Commit"]>;
      commitRepository: ResolversTypes["Repository"];
      subject: ResolversTypes["ReferencedSubject"];
    }
  >;
  ReferencedSubject: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["ReferencedSubject"]
  >;
  RegenerateEnterpriseIdentityProviderRecoveryCodesInput: RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: ResolverTypeWrapper<
    Omit<
      RegenerateEnterpriseIdentityProviderRecoveryCodesPayload,
      "identityProvider"
    > & {
      identityProvider?: Maybe<ResolversTypes["EnterpriseIdentityProvider"]>;
    }
  >;
  RegenerateVerifiableDomainTokenInput: RegenerateVerifiableDomainTokenInput;
  RegenerateVerifiableDomainTokenPayload: ResolverTypeWrapper<RegenerateVerifiableDomainTokenPayload>;
  RejectDeploymentsInput: RejectDeploymentsInput;
  RejectDeploymentsPayload: ResolverTypeWrapper<
    Omit<RejectDeploymentsPayload, "deployments"> & {
      deployments?: Maybe<Array<ResolversTypes["Deployment"]>>;
    }
  >;
  Release: ResolverTypeWrapper<
    Omit<
      Release,
      | "author"
      | "reactionGroups"
      | "reactions"
      | "releaseAssets"
      | "repository"
      | "tag"
      | "tagCommit"
    > & {
      author?: Maybe<ResolversTypes["User"]>;
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      reactions: ResolversTypes["ReactionConnection"];
      releaseAssets: ResolversTypes["ReleaseAssetConnection"];
      repository: ResolversTypes["Repository"];
      tag?: Maybe<ResolversTypes["Ref"]>;
      tagCommit?: Maybe<ResolversTypes["Commit"]>;
    }
  >;
  ReleaseAsset: ResolverTypeWrapper<
    Omit<ReleaseAsset, "release" | "uploadedBy"> & {
      release?: Maybe<ResolversTypes["Release"]>;
      uploadedBy: ResolversTypes["User"];
    }
  >;
  ReleaseAssetConnection: ResolverTypeWrapper<
    Omit<ReleaseAssetConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ReleaseAssetEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ReleaseAsset"]>>>;
    }
  >;
  ReleaseAssetEdge: ResolverTypeWrapper<
    Omit<ReleaseAssetEdge, "node"> & {
      node?: Maybe<ResolversTypes["ReleaseAsset"]>;
    }
  >;
  ReleaseConnection: ResolverTypeWrapper<
    Omit<ReleaseConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ReleaseEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Release"]>>>;
    }
  >;
  ReleaseEdge: ResolverTypeWrapper<
    Omit<ReleaseEdge, "node"> & { node?: Maybe<ResolversTypes["Release"]> }
  >;
  ReleaseOrder: ReleaseOrder;
  ReleaseOrderField: ReleaseOrderField;
  RemoveAssigneesFromAssignableInput: RemoveAssigneesFromAssignableInput;
  RemoveAssigneesFromAssignablePayload: ResolverTypeWrapper<
    Omit<RemoveAssigneesFromAssignablePayload, "assignable"> & {
      assignable?: Maybe<ResolversTypes["Assignable"]>;
    }
  >;
  RemoveEnterpriseAdminInput: RemoveEnterpriseAdminInput;
  RemoveEnterpriseAdminPayload: ResolverTypeWrapper<
    Omit<RemoveEnterpriseAdminPayload, "admin" | "enterprise" | "viewer"> & {
      admin?: Maybe<ResolversTypes["User"]>;
      enterprise?: Maybe<ResolversTypes["Enterprise"]>;
      viewer?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RemoveEnterpriseIdentityProviderInput: RemoveEnterpriseIdentityProviderInput;
  RemoveEnterpriseIdentityProviderPayload: ResolverTypeWrapper<
    Omit<RemoveEnterpriseIdentityProviderPayload, "identityProvider"> & {
      identityProvider?: Maybe<ResolversTypes["EnterpriseIdentityProvider"]>;
    }
  >;
  RemoveEnterpriseMemberInput: RemoveEnterpriseMemberInput;
  RemoveEnterpriseMemberPayload: ResolverTypeWrapper<
    Omit<RemoveEnterpriseMemberPayload, "enterprise" | "user" | "viewer"> & {
      enterprise?: Maybe<ResolversTypes["Enterprise"]>;
      user?: Maybe<ResolversTypes["User"]>;
      viewer?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RemoveEnterpriseOrganizationInput: RemoveEnterpriseOrganizationInput;
  RemoveEnterpriseOrganizationPayload: ResolverTypeWrapper<
    Omit<
      RemoveEnterpriseOrganizationPayload,
      "enterprise" | "organization" | "viewer"
    > & {
      enterprise?: Maybe<ResolversTypes["Enterprise"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      viewer?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RemoveEnterpriseSupportEntitlementInput: RemoveEnterpriseSupportEntitlementInput;
  RemoveEnterpriseSupportEntitlementPayload: ResolverTypeWrapper<RemoveEnterpriseSupportEntitlementPayload>;
  RemoveLabelsFromLabelableInput: RemoveLabelsFromLabelableInput;
  RemoveLabelsFromLabelablePayload: ResolverTypeWrapper<
    Omit<RemoveLabelsFromLabelablePayload, "labelable"> & {
      labelable?: Maybe<ResolversTypes["Labelable"]>;
    }
  >;
  RemoveOutsideCollaboratorInput: RemoveOutsideCollaboratorInput;
  RemoveOutsideCollaboratorPayload: ResolverTypeWrapper<
    Omit<RemoveOutsideCollaboratorPayload, "removedUser"> & {
      removedUser?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RemoveReactionInput: RemoveReactionInput;
  RemoveReactionPayload: ResolverTypeWrapper<
    Omit<RemoveReactionPayload, "reaction" | "reactionGroups" | "subject"> & {
      reaction?: Maybe<ResolversTypes["Reaction"]>;
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      subject?: Maybe<ResolversTypes["Reactable"]>;
    }
  >;
  RemoveStarInput: RemoveStarInput;
  RemoveStarPayload: ResolverTypeWrapper<
    Omit<RemoveStarPayload, "starrable"> & {
      starrable?: Maybe<ResolversTypes["Starrable"]>;
    }
  >;
  RemoveUpvoteInput: RemoveUpvoteInput;
  RemoveUpvotePayload: ResolverTypeWrapper<
    Omit<RemoveUpvotePayload, "subject"> & {
      subject?: Maybe<ResolversTypes["Votable"]>;
    }
  >;
  RemovedFromMergeQueueEvent: ResolverTypeWrapper<
    Omit<
      RemovedFromMergeQueueEvent,
      "actor" | "beforeCommit" | "enqueuer" | "mergeQueue" | "pullRequest"
    > & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      beforeCommit?: Maybe<ResolversTypes["Commit"]>;
      enqueuer?: Maybe<ResolversTypes["User"]>;
      mergeQueue?: Maybe<ResolversTypes["MergeQueue"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  RemovedFromProjectEvent: ResolverTypeWrapper<
    Omit<RemovedFromProjectEvent, "actor" | "project"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      project?: Maybe<ResolversTypes["Project"]>;
    }
  >;
  RenamedTitleEvent: ResolverTypeWrapper<
    Omit<RenamedTitleEvent, "actor" | "subject"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      subject: ResolversTypes["RenamedTitleSubject"];
    }
  >;
  RenamedTitleSubject: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["RenamedTitleSubject"]
  >;
  ReopenDiscussionInput: ReopenDiscussionInput;
  ReopenDiscussionPayload: ResolverTypeWrapper<
    Omit<ReopenDiscussionPayload, "discussion"> & {
      discussion?: Maybe<ResolversTypes["Discussion"]>;
    }
  >;
  ReopenIssueInput: ReopenIssueInput;
  ReopenIssuePayload: ResolverTypeWrapper<
    Omit<ReopenIssuePayload, "issue"> & {
      issue?: Maybe<ResolversTypes["Issue"]>;
    }
  >;
  ReopenPullRequestInput: ReopenPullRequestInput;
  ReopenPullRequestPayload: ResolverTypeWrapper<
    Omit<ReopenPullRequestPayload, "pullRequest"> & {
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  ReopenedEvent: ResolverTypeWrapper<
    Omit<ReopenedEvent, "actor" | "closable"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      closable: ResolversTypes["Closable"];
    }
  >;
  ReorderEnvironmentInput: ReorderEnvironmentInput;
  ReorderEnvironmentPayload: ResolverTypeWrapper<
    Omit<ReorderEnvironmentPayload, "environment"> & {
      environment?: Maybe<ResolversTypes["Environment"]>;
    }
  >;
  RepoAccessAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoAccessAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoAccessAuditEntryVisibility: RepoAccessAuditEntryVisibility;
  RepoAddMemberAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoAddMemberAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoAddMemberAuditEntryVisibility: RepoAddMemberAuditEntryVisibility;
  RepoAddTopicAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoAddTopicAuditEntry,
      "actor" | "organization" | "repository" | "topic" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      topic?: Maybe<ResolversTypes["Topic"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoArchivedAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoArchivedAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoArchivedAuditEntryVisibility: RepoArchivedAuditEntryVisibility;
  RepoChangeMergeSettingAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoChangeMergeSettingAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoChangeMergeSettingAuditEntryMergeType: RepoChangeMergeSettingAuditEntryMergeType;
  RepoConfigDisableAnonymousGitAccessAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoConfigDisableAnonymousGitAccessAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoConfigDisableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoConfigDisableCollaboratorsOnlyAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoConfigDisableContributorsOnlyAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoConfigDisableContributorsOnlyAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoConfigDisableSockpuppetDisallowedAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoConfigDisableSockpuppetDisallowedAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoConfigEnableAnonymousGitAccessAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoConfigEnableAnonymousGitAccessAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoConfigEnableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoConfigEnableCollaboratorsOnlyAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoConfigEnableContributorsOnlyAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoConfigEnableContributorsOnlyAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoConfigEnableSockpuppetDisallowedAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoConfigEnableSockpuppetDisallowedAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoConfigLockAnonymousGitAccessAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoConfigLockAnonymousGitAccessAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoConfigUnlockAnonymousGitAccessAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoConfigUnlockAnonymousGitAccessAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoCreateAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoCreateAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoCreateAuditEntryVisibility: RepoCreateAuditEntryVisibility;
  RepoDestroyAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoDestroyAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoDestroyAuditEntryVisibility: RepoDestroyAuditEntryVisibility;
  RepoRemoveMemberAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoRemoveMemberAuditEntry,
      "actor" | "organization" | "repository" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepoRemoveMemberAuditEntryVisibility: RepoRemoveMemberAuditEntryVisibility;
  RepoRemoveTopicAuditEntry: ResolverTypeWrapper<
    Omit<
      RepoRemoveTopicAuditEntry,
      "actor" | "organization" | "repository" | "topic" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      topic?: Maybe<ResolversTypes["Topic"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  ReportedContentClassifiers: ReportedContentClassifiers;
  Repository: ResolverTypeWrapper<
    Omit<
      Repository,
      | "branchProtectionRules"
      | "collaborators"
      | "commitComments"
      | "defaultBranchRef"
      | "dependencyGraphManifests"
      | "deployments"
      | "discussion"
      | "discussionCategories"
      | "discussionCategory"
      | "discussions"
      | "environment"
      | "environments"
      | "forks"
      | "issue"
      | "issueOrPullRequest"
      | "issueTemplates"
      | "issues"
      | "label"
      | "labels"
      | "latestRelease"
      | "mergeQueue"
      | "milestone"
      | "milestones"
      | "object"
      | "owner"
      | "packages"
      | "parent"
      | "pinnedDiscussions"
      | "pinnedEnvironments"
      | "pinnedIssues"
      | "project"
      | "projectV2"
      | "projects"
      | "projectsV2"
      | "pullRequest"
      | "pullRequestTemplates"
      | "pullRequests"
      | "recentProjects"
      | "ref"
      | "release"
      | "releases"
      | "repositoryTopics"
      | "ruleset"
      | "rulesets"
      | "templateRepository"
      | "vulnerabilityAlert"
      | "vulnerabilityAlerts"
    > & {
      branchProtectionRules: ResolversTypes["BranchProtectionRuleConnection"];
      collaborators?: Maybe<ResolversTypes["RepositoryCollaboratorConnection"]>;
      commitComments: ResolversTypes["CommitCommentConnection"];
      defaultBranchRef?: Maybe<ResolversTypes["Ref"]>;
      dependencyGraphManifests?: Maybe<
        ResolversTypes["DependencyGraphManifestConnection"]
      >;
      deployments: ResolversTypes["DeploymentConnection"];
      discussion?: Maybe<ResolversTypes["Discussion"]>;
      discussionCategories: ResolversTypes["DiscussionCategoryConnection"];
      discussionCategory?: Maybe<ResolversTypes["DiscussionCategory"]>;
      discussions: ResolversTypes["DiscussionConnection"];
      environment?: Maybe<ResolversTypes["Environment"]>;
      environments: ResolversTypes["EnvironmentConnection"];
      forks: ResolversTypes["RepositoryConnection"];
      issue?: Maybe<ResolversTypes["Issue"]>;
      issueOrPullRequest?: Maybe<ResolversTypes["IssueOrPullRequest"]>;
      issueTemplates?: Maybe<Array<ResolversTypes["IssueTemplate"]>>;
      issues: ResolversTypes["IssueConnection"];
      label?: Maybe<ResolversTypes["Label"]>;
      labels?: Maybe<ResolversTypes["LabelConnection"]>;
      latestRelease?: Maybe<ResolversTypes["Release"]>;
      mergeQueue?: Maybe<ResolversTypes["MergeQueue"]>;
      milestone?: Maybe<ResolversTypes["Milestone"]>;
      milestones?: Maybe<ResolversTypes["MilestoneConnection"]>;
      object?: Maybe<ResolversTypes["GitObject"]>;
      owner: ResolversTypes["RepositoryOwner"];
      packages: ResolversTypes["PackageConnection"];
      parent?: Maybe<ResolversTypes["Repository"]>;
      pinnedDiscussions: ResolversTypes["PinnedDiscussionConnection"];
      pinnedEnvironments?: Maybe<ResolversTypes["PinnedEnvironmentConnection"]>;
      pinnedIssues?: Maybe<ResolversTypes["PinnedIssueConnection"]>;
      project?: Maybe<ResolversTypes["Project"]>;
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
      projects: ResolversTypes["ProjectConnection"];
      projectsV2: ResolversTypes["ProjectV2Connection"];
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
      pullRequestTemplates?: Maybe<
        Array<ResolversTypes["PullRequestTemplate"]>
      >;
      pullRequests: ResolversTypes["PullRequestConnection"];
      recentProjects: ResolversTypes["ProjectV2Connection"];
      ref?: Maybe<ResolversTypes["Ref"]>;
      release?: Maybe<ResolversTypes["Release"]>;
      releases: ResolversTypes["ReleaseConnection"];
      repositoryTopics: ResolversTypes["RepositoryTopicConnection"];
      ruleset?: Maybe<ResolversTypes["RepositoryRuleset"]>;
      rulesets?: Maybe<ResolversTypes["RepositoryRulesetConnection"]>;
      templateRepository?: Maybe<ResolversTypes["Repository"]>;
      vulnerabilityAlert?: Maybe<
        ResolversTypes["RepositoryVulnerabilityAlert"]
      >;
      vulnerabilityAlerts?: Maybe<
        ResolversTypes["RepositoryVulnerabilityAlertConnection"]
      >;
    }
  >;
  RepositoryAffiliation: RepositoryAffiliation;
  RepositoryAuditEntryData: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["RepositoryAuditEntryData"]
  >;
  RepositoryCodeowners: ResolverTypeWrapper<RepositoryCodeowners>;
  RepositoryCodeownersError: ResolverTypeWrapper<RepositoryCodeownersError>;
  RepositoryCollaboratorConnection: ResolverTypeWrapper<
    Omit<RepositoryCollaboratorConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["RepositoryCollaboratorEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["User"]>>>;
    }
  >;
  RepositoryCollaboratorEdge: ResolverTypeWrapper<
    Omit<RepositoryCollaboratorEdge, "node" | "permissionSources"> & {
      node: ResolversTypes["User"];
      permissionSources?: Maybe<Array<ResolversTypes["PermissionSource"]>>;
    }
  >;
  RepositoryConnection: ResolverTypeWrapper<
    Omit<RepositoryConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["RepositoryEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Repository"]>>>;
    }
  >;
  RepositoryContactLink: ResolverTypeWrapper<RepositoryContactLink>;
  RepositoryContributionType: RepositoryContributionType;
  RepositoryDiscussionAuthor: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["RepositoryDiscussionAuthor"]
  >;
  RepositoryDiscussionCommentAuthor: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["RepositoryDiscussionCommentAuthor"]
  >;
  RepositoryEdge: ResolverTypeWrapper<
    Omit<RepositoryEdge, "node"> & {
      node?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  RepositoryIdConditionTarget: ResolverTypeWrapper<RepositoryIdConditionTarget>;
  RepositoryIdConditionTargetInput: RepositoryIdConditionTargetInput;
  RepositoryInfo: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["RepositoryInfo"]
  >;
  RepositoryInteractionAbility: ResolverTypeWrapper<RepositoryInteractionAbility>;
  RepositoryInteractionLimit: RepositoryInteractionLimit;
  RepositoryInteractionLimitExpiry: RepositoryInteractionLimitExpiry;
  RepositoryInteractionLimitOrigin: RepositoryInteractionLimitOrigin;
  RepositoryInvitation: ResolverTypeWrapper<
    Omit<RepositoryInvitation, "invitee" | "inviter" | "repository"> & {
      invitee?: Maybe<ResolversTypes["User"]>;
      inviter: ResolversTypes["User"];
      repository?: Maybe<ResolversTypes["RepositoryInfo"]>;
    }
  >;
  RepositoryInvitationConnection: ResolverTypeWrapper<
    Omit<RepositoryInvitationConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["RepositoryInvitationEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["RepositoryInvitation"]>>>;
    }
  >;
  RepositoryInvitationEdge: ResolverTypeWrapper<
    Omit<RepositoryInvitationEdge, "node"> & {
      node?: Maybe<ResolversTypes["RepositoryInvitation"]>;
    }
  >;
  RepositoryInvitationOrder: RepositoryInvitationOrder;
  RepositoryInvitationOrderField: RepositoryInvitationOrderField;
  RepositoryLockReason: RepositoryLockReason;
  RepositoryMigration: ResolverTypeWrapper<RepositoryMigration>;
  RepositoryMigrationConnection: ResolverTypeWrapper<RepositoryMigrationConnection>;
  RepositoryMigrationEdge: ResolverTypeWrapper<RepositoryMigrationEdge>;
  RepositoryMigrationOrder: RepositoryMigrationOrder;
  RepositoryMigrationOrderDirection: RepositoryMigrationOrderDirection;
  RepositoryMigrationOrderField: RepositoryMigrationOrderField;
  RepositoryNameConditionTarget: ResolverTypeWrapper<RepositoryNameConditionTarget>;
  RepositoryNameConditionTargetInput: RepositoryNameConditionTargetInput;
  RepositoryNode: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["RepositoryNode"]
  >;
  RepositoryOrder: RepositoryOrder;
  RepositoryOrderField: RepositoryOrderField;
  RepositoryOwner: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["RepositoryOwner"]
  >;
  RepositoryPermission: RepositoryPermission;
  RepositoryPlanFeatures: ResolverTypeWrapper<RepositoryPlanFeatures>;
  RepositoryPrivacy: RepositoryPrivacy;
  RepositoryPropertyConditionTarget: ResolverTypeWrapper<RepositoryPropertyConditionTarget>;
  RepositoryPropertyConditionTargetInput: RepositoryPropertyConditionTargetInput;
  RepositoryRule: ResolverTypeWrapper<
    Omit<RepositoryRule, "parameters" | "repositoryRuleset"> & {
      parameters?: Maybe<ResolversTypes["RuleParameters"]>;
      repositoryRuleset?: Maybe<ResolversTypes["RepositoryRuleset"]>;
    }
  >;
  RepositoryRuleConditions: ResolverTypeWrapper<RepositoryRuleConditions>;
  RepositoryRuleConditionsInput: RepositoryRuleConditionsInput;
  RepositoryRuleConnection: ResolverTypeWrapper<
    Omit<RepositoryRuleConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["RepositoryRuleEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["RepositoryRule"]>>>;
    }
  >;
  RepositoryRuleEdge: ResolverTypeWrapper<
    Omit<RepositoryRuleEdge, "node"> & {
      node?: Maybe<ResolversTypes["RepositoryRule"]>;
    }
  >;
  RepositoryRuleInput: RepositoryRuleInput;
  RepositoryRuleOrder: RepositoryRuleOrder;
  RepositoryRuleOrderField: RepositoryRuleOrderField;
  RepositoryRuleType: RepositoryRuleType;
  RepositoryRuleset: ResolverTypeWrapper<
    Omit<RepositoryRuleset, "bypassActors" | "rules" | "source"> & {
      bypassActors?: Maybe<
        ResolversTypes["RepositoryRulesetBypassActorConnection"]
      >;
      rules?: Maybe<ResolversTypes["RepositoryRuleConnection"]>;
      source: ResolversTypes["RuleSource"];
    }
  >;
  RepositoryRulesetBypassActor: ResolverTypeWrapper<
    Omit<RepositoryRulesetBypassActor, "actor" | "repositoryRuleset"> & {
      actor?: Maybe<ResolversTypes["BypassActor"]>;
      repositoryRuleset?: Maybe<ResolversTypes["RepositoryRuleset"]>;
    }
  >;
  RepositoryRulesetBypassActorBypassMode: RepositoryRulesetBypassActorBypassMode;
  RepositoryRulesetBypassActorConnection: ResolverTypeWrapper<
    Omit<RepositoryRulesetBypassActorConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["RepositoryRulesetBypassActorEdge"]>>
      >;
      nodes?: Maybe<
        Array<Maybe<ResolversTypes["RepositoryRulesetBypassActor"]>>
      >;
    }
  >;
  RepositoryRulesetBypassActorEdge: ResolverTypeWrapper<
    Omit<RepositoryRulesetBypassActorEdge, "node"> & {
      node?: Maybe<ResolversTypes["RepositoryRulesetBypassActor"]>;
    }
  >;
  RepositoryRulesetBypassActorInput: RepositoryRulesetBypassActorInput;
  RepositoryRulesetConnection: ResolverTypeWrapper<
    Omit<RepositoryRulesetConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["RepositoryRulesetEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["RepositoryRuleset"]>>>;
    }
  >;
  RepositoryRulesetEdge: ResolverTypeWrapper<
    Omit<RepositoryRulesetEdge, "node"> & {
      node?: Maybe<ResolversTypes["RepositoryRuleset"]>;
    }
  >;
  RepositoryRulesetTarget: RepositoryRulesetTarget;
  RepositoryTopic: ResolverTypeWrapper<
    Omit<RepositoryTopic, "topic"> & { topic: ResolversTypes["Topic"] }
  >;
  RepositoryTopicConnection: ResolverTypeWrapper<
    Omit<RepositoryTopicConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["RepositoryTopicEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["RepositoryTopic"]>>>;
    }
  >;
  RepositoryTopicEdge: ResolverTypeWrapper<
    Omit<RepositoryTopicEdge, "node"> & {
      node?: Maybe<ResolversTypes["RepositoryTopic"]>;
    }
  >;
  RepositoryVisibility: RepositoryVisibility;
  RepositoryVisibilityChangeDisableAuditEntry: ResolverTypeWrapper<
    Omit<
      RepositoryVisibilityChangeDisableAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepositoryVisibilityChangeEnableAuditEntry: ResolverTypeWrapper<
    Omit<
      RepositoryVisibilityChangeEnableAuditEntry,
      "actor" | "organization" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  RepositoryVulnerabilityAlert: ResolverTypeWrapper<
    Omit<
      RepositoryVulnerabilityAlert,
      "dependabotUpdate" | "dismisser" | "repository"
    > & {
      dependabotUpdate?: Maybe<ResolversTypes["DependabotUpdate"]>;
      dismisser?: Maybe<ResolversTypes["User"]>;
      repository: ResolversTypes["Repository"];
    }
  >;
  RepositoryVulnerabilityAlertConnection: ResolverTypeWrapper<
    Omit<RepositoryVulnerabilityAlertConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["RepositoryVulnerabilityAlertEdge"]>>
      >;
      nodes?: Maybe<
        Array<Maybe<ResolversTypes["RepositoryVulnerabilityAlert"]>>
      >;
    }
  >;
  RepositoryVulnerabilityAlertDependencyScope: RepositoryVulnerabilityAlertDependencyScope;
  RepositoryVulnerabilityAlertEdge: ResolverTypeWrapper<
    Omit<RepositoryVulnerabilityAlertEdge, "node"> & {
      node?: Maybe<ResolversTypes["RepositoryVulnerabilityAlert"]>;
    }
  >;
  RepositoryVulnerabilityAlertState: RepositoryVulnerabilityAlertState;
  RequestReviewsInput: RequestReviewsInput;
  RequestReviewsPayload: ResolverTypeWrapper<
    Omit<RequestReviewsPayload, "actor" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  RequestableCheckStatusState: RequestableCheckStatusState;
  RequestedReviewer: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["RequestedReviewer"]
  >;
  RequestedReviewerConnection: ResolverTypeWrapper<
    Omit<RequestedReviewerConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["RequestedReviewerEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["RequestedReviewer"]>>>;
    }
  >;
  RequestedReviewerEdge: ResolverTypeWrapper<
    Omit<RequestedReviewerEdge, "node"> & {
      node?: Maybe<ResolversTypes["RequestedReviewer"]>;
    }
  >;
  RequirableByPullRequest: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["RequirableByPullRequest"]
  >;
  RequiredDeploymentsParameters: ResolverTypeWrapper<RequiredDeploymentsParameters>;
  RequiredDeploymentsParametersInput: RequiredDeploymentsParametersInput;
  RequiredStatusCheckDescription: ResolverTypeWrapper<
    Omit<RequiredStatusCheckDescription, "app"> & {
      app?: Maybe<ResolversTypes["App"]>;
    }
  >;
  RequiredStatusCheckInput: RequiredStatusCheckInput;
  RequiredStatusChecksParameters: ResolverTypeWrapper<RequiredStatusChecksParameters>;
  RequiredStatusChecksParametersInput: RequiredStatusChecksParametersInput;
  RerequestCheckSuiteInput: RerequestCheckSuiteInput;
  RerequestCheckSuitePayload: ResolverTypeWrapper<
    Omit<RerequestCheckSuitePayload, "checkSuite"> & {
      checkSuite?: Maybe<ResolversTypes["CheckSuite"]>;
    }
  >;
  ResolveReviewThreadInput: ResolveReviewThreadInput;
  ResolveReviewThreadPayload: ResolverTypeWrapper<
    Omit<ResolveReviewThreadPayload, "thread"> & {
      thread?: Maybe<ResolversTypes["PullRequestReviewThread"]>;
    }
  >;
  RestrictedContribution: ResolverTypeWrapper<
    Omit<RestrictedContribution, "user"> & { user: ResolversTypes["User"] }
  >;
  RetireSponsorsTierInput: RetireSponsorsTierInput;
  RetireSponsorsTierPayload: ResolverTypeWrapper<
    Omit<RetireSponsorsTierPayload, "sponsorsTier"> & {
      sponsorsTier?: Maybe<ResolversTypes["SponsorsTier"]>;
    }
  >;
  RevertPullRequestInput: RevertPullRequestInput;
  RevertPullRequestPayload: ResolverTypeWrapper<
    Omit<RevertPullRequestPayload, "pullRequest" | "revertPullRequest"> & {
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
      revertPullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  ReviewDismissalAllowance: ResolverTypeWrapper<
    Omit<ReviewDismissalAllowance, "actor" | "branchProtectionRule"> & {
      actor?: Maybe<ResolversTypes["ReviewDismissalAllowanceActor"]>;
      branchProtectionRule?: Maybe<ResolversTypes["BranchProtectionRule"]>;
    }
  >;
  ReviewDismissalAllowanceActor: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["ReviewDismissalAllowanceActor"]
  >;
  ReviewDismissalAllowanceConnection: ResolverTypeWrapper<
    Omit<ReviewDismissalAllowanceConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["ReviewDismissalAllowanceEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ReviewDismissalAllowance"]>>>;
    }
  >;
  ReviewDismissalAllowanceEdge: ResolverTypeWrapper<
    Omit<ReviewDismissalAllowanceEdge, "node"> & {
      node?: Maybe<ResolversTypes["ReviewDismissalAllowance"]>;
    }
  >;
  ReviewDismissedEvent: ResolverTypeWrapper<
    Omit<
      ReviewDismissedEvent,
      "actor" | "pullRequest" | "pullRequestCommit" | "review"
    > & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest: ResolversTypes["PullRequest"];
      pullRequestCommit?: Maybe<ResolversTypes["PullRequestCommit"]>;
      review?: Maybe<ResolversTypes["PullRequestReview"]>;
    }
  >;
  ReviewRequest: ResolverTypeWrapper<
    Omit<ReviewRequest, "pullRequest" | "requestedReviewer"> & {
      pullRequest: ResolversTypes["PullRequest"];
      requestedReviewer?: Maybe<ResolversTypes["RequestedReviewer"]>;
    }
  >;
  ReviewRequestConnection: ResolverTypeWrapper<
    Omit<ReviewRequestConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["ReviewRequestEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["ReviewRequest"]>>>;
    }
  >;
  ReviewRequestEdge: ResolverTypeWrapper<
    Omit<ReviewRequestEdge, "node"> & {
      node?: Maybe<ResolversTypes["ReviewRequest"]>;
    }
  >;
  ReviewRequestRemovedEvent: ResolverTypeWrapper<
    Omit<
      ReviewRequestRemovedEvent,
      "actor" | "pullRequest" | "requestedReviewer"
    > & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest: ResolversTypes["PullRequest"];
      requestedReviewer?: Maybe<ResolversTypes["RequestedReviewer"]>;
    }
  >;
  ReviewRequestedEvent: ResolverTypeWrapper<
    Omit<
      ReviewRequestedEvent,
      "actor" | "pullRequest" | "requestedReviewer"
    > & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest: ResolversTypes["PullRequest"];
      requestedReviewer?: Maybe<ResolversTypes["RequestedReviewer"]>;
    }
  >;
  ReviewStatusHovercardContext: ResolverTypeWrapper<ReviewStatusHovercardContext>;
  RevokeEnterpriseOrganizationsMigratorRoleInput: RevokeEnterpriseOrganizationsMigratorRoleInput;
  RevokeEnterpriseOrganizationsMigratorRolePayload: ResolverTypeWrapper<
    Omit<RevokeEnterpriseOrganizationsMigratorRolePayload, "organizations"> & {
      organizations?: Maybe<ResolversTypes["OrganizationConnection"]>;
    }
  >;
  RevokeMigratorRoleInput: RevokeMigratorRoleInput;
  RevokeMigratorRolePayload: ResolverTypeWrapper<RevokeMigratorRolePayload>;
  RoleInOrganization: RoleInOrganization;
  RuleEnforcement: RuleEnforcement;
  RuleParameters: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["RuleParameters"]
  >;
  RuleParametersInput: RuleParametersInput;
  RuleSource: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["RuleSource"]
  >;
  SamlDigestAlgorithm: SamlDigestAlgorithm;
  SamlSignatureAlgorithm: SamlSignatureAlgorithm;
  SavedReply: ResolverTypeWrapper<
    Omit<SavedReply, "user"> & { user?: Maybe<ResolversTypes["Actor"]> }
  >;
  SavedReplyConnection: ResolverTypeWrapper<
    Omit<SavedReplyConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["SavedReplyEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["SavedReply"]>>>;
    }
  >;
  SavedReplyEdge: ResolverTypeWrapper<
    Omit<SavedReplyEdge, "node"> & {
      node?: Maybe<ResolversTypes["SavedReply"]>;
    }
  >;
  SavedReplyOrder: SavedReplyOrder;
  SavedReplyOrderField: SavedReplyOrderField;
  SearchResultItem: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["SearchResultItem"]
  >;
  SearchResultItemConnection: ResolverTypeWrapper<
    Omit<SearchResultItemConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["SearchResultItemEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["SearchResultItem"]>>>;
    }
  >;
  SearchResultItemEdge: ResolverTypeWrapper<
    Omit<SearchResultItemEdge, "node"> & {
      node?: Maybe<ResolversTypes["SearchResultItem"]>;
    }
  >;
  SearchType: SearchType;
  SecurityAdvisory: ResolverTypeWrapper<SecurityAdvisory>;
  SecurityAdvisoryClassification: SecurityAdvisoryClassification;
  SecurityAdvisoryConnection: ResolverTypeWrapper<SecurityAdvisoryConnection>;
  SecurityAdvisoryEcosystem: SecurityAdvisoryEcosystem;
  SecurityAdvisoryEdge: ResolverTypeWrapper<SecurityAdvisoryEdge>;
  SecurityAdvisoryIdentifier: ResolverTypeWrapper<SecurityAdvisoryIdentifier>;
  SecurityAdvisoryIdentifierFilter: SecurityAdvisoryIdentifierFilter;
  SecurityAdvisoryIdentifierType: SecurityAdvisoryIdentifierType;
  SecurityAdvisoryOrder: SecurityAdvisoryOrder;
  SecurityAdvisoryOrderField: SecurityAdvisoryOrderField;
  SecurityAdvisoryPackage: ResolverTypeWrapper<SecurityAdvisoryPackage>;
  SecurityAdvisoryPackageVersion: ResolverTypeWrapper<SecurityAdvisoryPackageVersion>;
  SecurityAdvisoryReference: ResolverTypeWrapper<SecurityAdvisoryReference>;
  SecurityAdvisorySeverity: SecurityAdvisorySeverity;
  SecurityVulnerability: ResolverTypeWrapper<SecurityVulnerability>;
  SecurityVulnerabilityConnection: ResolverTypeWrapper<SecurityVulnerabilityConnection>;
  SecurityVulnerabilityEdge: ResolverTypeWrapper<SecurityVulnerabilityEdge>;
  SecurityVulnerabilityOrder: SecurityVulnerabilityOrder;
  SecurityVulnerabilityOrderField: SecurityVulnerabilityOrderField;
  SetEnterpriseIdentityProviderInput: SetEnterpriseIdentityProviderInput;
  SetEnterpriseIdentityProviderPayload: ResolverTypeWrapper<
    Omit<SetEnterpriseIdentityProviderPayload, "identityProvider"> & {
      identityProvider?: Maybe<ResolversTypes["EnterpriseIdentityProvider"]>;
    }
  >;
  SetOrganizationInteractionLimitInput: SetOrganizationInteractionLimitInput;
  SetOrganizationInteractionLimitPayload: ResolverTypeWrapper<
    Omit<SetOrganizationInteractionLimitPayload, "organization"> & {
      organization?: Maybe<ResolversTypes["Organization"]>;
    }
  >;
  SetRepositoryInteractionLimitInput: SetRepositoryInteractionLimitInput;
  SetRepositoryInteractionLimitPayload: ResolverTypeWrapper<
    Omit<SetRepositoryInteractionLimitPayload, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  SetUserInteractionLimitInput: SetUserInteractionLimitInput;
  SetUserInteractionLimitPayload: ResolverTypeWrapper<
    Omit<SetUserInteractionLimitPayload, "user"> & {
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  SmimeSignature: ResolverTypeWrapper<
    Omit<SmimeSignature, "signer"> & { signer?: Maybe<ResolversTypes["User"]> }
  >;
  SocialAccount: ResolverTypeWrapper<SocialAccount>;
  SocialAccountConnection: ResolverTypeWrapper<SocialAccountConnection>;
  SocialAccountEdge: ResolverTypeWrapper<SocialAccountEdge>;
  SocialAccountProvider: SocialAccountProvider;
  Sponsor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>["Sponsor"]>;
  SponsorAndLifetimeValue: ResolverTypeWrapper<
    Omit<SponsorAndLifetimeValue, "sponsor" | "sponsorable"> & {
      sponsor: ResolversTypes["Sponsorable"];
      sponsorable: ResolversTypes["Sponsorable"];
    }
  >;
  SponsorAndLifetimeValueConnection: ResolverTypeWrapper<
    Omit<SponsorAndLifetimeValueConnection, "edges" | "nodes"> & {
      edges?: Maybe<
        Array<Maybe<ResolversTypes["SponsorAndLifetimeValueEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["SponsorAndLifetimeValue"]>>>;
    }
  >;
  SponsorAndLifetimeValueEdge: ResolverTypeWrapper<
    Omit<SponsorAndLifetimeValueEdge, "node"> & {
      node?: Maybe<ResolversTypes["SponsorAndLifetimeValue"]>;
    }
  >;
  SponsorAndLifetimeValueOrder: SponsorAndLifetimeValueOrder;
  SponsorAndLifetimeValueOrderField: SponsorAndLifetimeValueOrderField;
  SponsorConnection: ResolverTypeWrapper<
    Omit<SponsorConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["SponsorEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Sponsor"]>>>;
    }
  >;
  SponsorEdge: ResolverTypeWrapper<
    Omit<SponsorEdge, "node"> & { node?: Maybe<ResolversTypes["Sponsor"]> }
  >;
  SponsorOrder: SponsorOrder;
  SponsorOrderField: SponsorOrderField;
  Sponsorable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Sponsorable"]
  >;
  SponsorableItem: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["SponsorableItem"]
  >;
  SponsorableItemConnection: ResolverTypeWrapper<
    Omit<SponsorableItemConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["SponsorableItemEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["SponsorableItem"]>>>;
    }
  >;
  SponsorableItemEdge: ResolverTypeWrapper<
    Omit<SponsorableItemEdge, "node"> & {
      node?: Maybe<ResolversTypes["SponsorableItem"]>;
    }
  >;
  SponsorableOrder: SponsorableOrder;
  SponsorableOrderField: SponsorableOrderField;
  SponsorsActivity: ResolverTypeWrapper<
    Omit<
      SponsorsActivity,
      "previousSponsorsTier" | "sponsor" | "sponsorable" | "sponsorsTier"
    > & {
      previousSponsorsTier?: Maybe<ResolversTypes["SponsorsTier"]>;
      sponsor?: Maybe<ResolversTypes["Sponsor"]>;
      sponsorable: ResolversTypes["Sponsorable"];
      sponsorsTier?: Maybe<ResolversTypes["SponsorsTier"]>;
    }
  >;
  SponsorsActivityAction: SponsorsActivityAction;
  SponsorsActivityConnection: ResolverTypeWrapper<
    Omit<SponsorsActivityConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["SponsorsActivityEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["SponsorsActivity"]>>>;
    }
  >;
  SponsorsActivityEdge: ResolverTypeWrapper<
    Omit<SponsorsActivityEdge, "node"> & {
      node?: Maybe<ResolversTypes["SponsorsActivity"]>;
    }
  >;
  SponsorsActivityOrder: SponsorsActivityOrder;
  SponsorsActivityOrderField: SponsorsActivityOrderField;
  SponsorsActivityPeriod: SponsorsActivityPeriod;
  SponsorsCountryOrRegionCode: SponsorsCountryOrRegionCode;
  SponsorsGoal: ResolverTypeWrapper<SponsorsGoal>;
  SponsorsGoalKind: SponsorsGoalKind;
  SponsorsListing: ResolverTypeWrapper<
    Omit<
      SponsorsListing,
      "activeGoal" | "featuredItems" | "fiscalHost" | "sponsorable" | "tiers"
    > & {
      activeGoal?: Maybe<ResolversTypes["SponsorsGoal"]>;
      featuredItems: Array<ResolversTypes["SponsorsListingFeaturedItem"]>;
      fiscalHost?: Maybe<ResolversTypes["Organization"]>;
      sponsorable: ResolversTypes["Sponsorable"];
      tiers?: Maybe<ResolversTypes["SponsorsTierConnection"]>;
    }
  >;
  SponsorsListingFeatureableItem: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["SponsorsListingFeatureableItem"]
  >;
  SponsorsListingFeaturedItem: ResolverTypeWrapper<
    Omit<SponsorsListingFeaturedItem, "featureable" | "sponsorsListing"> & {
      featureable: ResolversTypes["SponsorsListingFeatureableItem"];
      sponsorsListing: ResolversTypes["SponsorsListing"];
    }
  >;
  SponsorsListingFeaturedItemFeatureableType: SponsorsListingFeaturedItemFeatureableType;
  SponsorsTier: ResolverTypeWrapper<
    Omit<
      SponsorsTier,
      "adminInfo" | "closestLesserValueTier" | "sponsorsListing"
    > & {
      adminInfo?: Maybe<ResolversTypes["SponsorsTierAdminInfo"]>;
      closestLesserValueTier?: Maybe<ResolversTypes["SponsorsTier"]>;
      sponsorsListing: ResolversTypes["SponsorsListing"];
    }
  >;
  SponsorsTierAdminInfo: ResolverTypeWrapper<
    Omit<SponsorsTierAdminInfo, "sponsorships"> & {
      sponsorships: ResolversTypes["SponsorshipConnection"];
    }
  >;
  SponsorsTierConnection: ResolverTypeWrapper<
    Omit<SponsorsTierConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["SponsorsTierEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["SponsorsTier"]>>>;
    }
  >;
  SponsorsTierEdge: ResolverTypeWrapper<
    Omit<SponsorsTierEdge, "node"> & {
      node?: Maybe<ResolversTypes["SponsorsTier"]>;
    }
  >;
  SponsorsTierOrder: SponsorsTierOrder;
  SponsorsTierOrderField: SponsorsTierOrderField;
  Sponsorship: ResolverTypeWrapper<
    Omit<
      Sponsorship,
      "maintainer" | "sponsor" | "sponsorEntity" | "sponsorable" | "tier"
    > & {
      maintainer: ResolversTypes["User"];
      sponsor?: Maybe<ResolversTypes["User"]>;
      sponsorEntity?: Maybe<ResolversTypes["Sponsor"]>;
      sponsorable: ResolversTypes["Sponsorable"];
      tier?: Maybe<ResolversTypes["SponsorsTier"]>;
    }
  >;
  SponsorshipConnection: ResolverTypeWrapper<
    Omit<SponsorshipConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["SponsorshipEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Sponsorship"]>>>;
    }
  >;
  SponsorshipEdge: ResolverTypeWrapper<
    Omit<SponsorshipEdge, "node"> & {
      node?: Maybe<ResolversTypes["Sponsorship"]>;
    }
  >;
  SponsorshipNewsletter: ResolverTypeWrapper<
    Omit<SponsorshipNewsletter, "author" | "sponsorable"> & {
      author?: Maybe<ResolversTypes["User"]>;
      sponsorable: ResolversTypes["Sponsorable"];
    }
  >;
  SponsorshipNewsletterConnection: ResolverTypeWrapper<
    Omit<SponsorshipNewsletterConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["SponsorshipNewsletterEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["SponsorshipNewsletter"]>>>;
    }
  >;
  SponsorshipNewsletterEdge: ResolverTypeWrapper<
    Omit<SponsorshipNewsletterEdge, "node"> & {
      node?: Maybe<ResolversTypes["SponsorshipNewsletter"]>;
    }
  >;
  SponsorshipNewsletterOrder: SponsorshipNewsletterOrder;
  SponsorshipNewsletterOrderField: SponsorshipNewsletterOrderField;
  SponsorshipOrder: SponsorshipOrder;
  SponsorshipOrderField: SponsorshipOrderField;
  SponsorshipPaymentSource: SponsorshipPaymentSource;
  SponsorshipPrivacy: SponsorshipPrivacy;
  SquashMergeCommitMessage: SquashMergeCommitMessage;
  SquashMergeCommitTitle: SquashMergeCommitTitle;
  SshSignature: ResolverTypeWrapper<
    Omit<SshSignature, "signer"> & { signer?: Maybe<ResolversTypes["User"]> }
  >;
  StarOrder: StarOrder;
  StarOrderField: StarOrderField;
  StargazerConnection: ResolverTypeWrapper<
    Omit<StargazerConnection, "nodes"> & {
      nodes?: Maybe<Array<Maybe<ResolversTypes["User"]>>>;
    }
  >;
  StargazerEdge: ResolverTypeWrapper<
    Omit<StargazerEdge, "node"> & { node: ResolversTypes["User"] }
  >;
  Starrable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Starrable"]
  >;
  StarredRepositoryConnection: ResolverTypeWrapper<
    Omit<StarredRepositoryConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["StarredRepositoryEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Repository"]>>>;
    }
  >;
  StarredRepositoryEdge: ResolverTypeWrapper<
    Omit<StarredRepositoryEdge, "node"> & { node: ResolversTypes["Repository"] }
  >;
  StartOrganizationMigrationInput: StartOrganizationMigrationInput;
  StartOrganizationMigrationPayload: ResolverTypeWrapper<StartOrganizationMigrationPayload>;
  StartRepositoryMigrationInput: StartRepositoryMigrationInput;
  StartRepositoryMigrationPayload: ResolverTypeWrapper<StartRepositoryMigrationPayload>;
  Status: ResolverTypeWrapper<
    Omit<Status, "combinedContexts" | "commit" | "context" | "contexts"> & {
      combinedContexts: ResolversTypes["StatusCheckRollupContextConnection"];
      commit?: Maybe<ResolversTypes["Commit"]>;
      context?: Maybe<ResolversTypes["StatusContext"]>;
      contexts: Array<ResolversTypes["StatusContext"]>;
    }
  >;
  StatusCheckConfiguration: ResolverTypeWrapper<StatusCheckConfiguration>;
  StatusCheckConfigurationInput: StatusCheckConfigurationInput;
  StatusCheckRollup: ResolverTypeWrapper<
    Omit<StatusCheckRollup, "commit" | "contexts"> & {
      commit?: Maybe<ResolversTypes["Commit"]>;
      contexts: ResolversTypes["StatusCheckRollupContextConnection"];
    }
  >;
  StatusCheckRollupContext: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["StatusCheckRollupContext"]
  >;
  StatusCheckRollupContextConnection: ResolverTypeWrapper<
    Omit<
      StatusCheckRollupContextConnection,
      "checkRunCountsByState" | "edges" | "nodes"
    > & {
      checkRunCountsByState?: Maybe<
        Array<ResolversTypes["CheckRunStateCount"]>
      >;
      edges?: Maybe<
        Array<Maybe<ResolversTypes["StatusCheckRollupContextEdge"]>>
      >;
      nodes?: Maybe<Array<Maybe<ResolversTypes["StatusCheckRollupContext"]>>>;
    }
  >;
  StatusCheckRollupContextEdge: ResolverTypeWrapper<
    Omit<StatusCheckRollupContextEdge, "node"> & {
      node?: Maybe<ResolversTypes["StatusCheckRollupContext"]>;
    }
  >;
  StatusContext: ResolverTypeWrapper<
    Omit<StatusContext, "commit" | "creator"> & {
      commit?: Maybe<ResolversTypes["Commit"]>;
      creator?: Maybe<ResolversTypes["Actor"]>;
    }
  >;
  StatusContextStateCount: ResolverTypeWrapper<StatusContextStateCount>;
  StatusState: StatusState;
  String: ResolverTypeWrapper<Scalars["String"]["output"]>;
  StripeConnectAccount: ResolverTypeWrapper<
    Omit<StripeConnectAccount, "sponsorsListing"> & {
      sponsorsListing: ResolversTypes["SponsorsListing"];
    }
  >;
  SubmitPullRequestReviewInput: SubmitPullRequestReviewInput;
  SubmitPullRequestReviewPayload: ResolverTypeWrapper<
    Omit<SubmitPullRequestReviewPayload, "pullRequestReview"> & {
      pullRequestReview?: Maybe<ResolversTypes["PullRequestReview"]>;
    }
  >;
  Submodule: ResolverTypeWrapper<Submodule>;
  SubmoduleConnection: ResolverTypeWrapper<SubmoduleConnection>;
  SubmoduleEdge: ResolverTypeWrapper<SubmoduleEdge>;
  Subscribable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Subscribable"]
  >;
  SubscribableThread: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["SubscribableThread"]
  >;
  SubscribedEvent: ResolverTypeWrapper<
    Omit<SubscribedEvent, "actor" | "subscribable"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      subscribable: ResolversTypes["Subscribable"];
    }
  >;
  SubscriptionState: SubscriptionState;
  SuggestedReviewer: ResolverTypeWrapper<
    Omit<SuggestedReviewer, "reviewer"> & { reviewer: ResolversTypes["User"] }
  >;
  Tag: ResolverTypeWrapper<
    Omit<Tag, "repository" | "target"> & {
      repository: ResolversTypes["Repository"];
      target: ResolversTypes["GitObject"];
    }
  >;
  TagNamePatternParameters: ResolverTypeWrapper<TagNamePatternParameters>;
  TagNamePatternParametersInput: TagNamePatternParametersInput;
  Team: ResolverTypeWrapper<
    Omit<
      Team,
      | "ancestors"
      | "childTeams"
      | "discussion"
      | "discussions"
      | "invitations"
      | "memberStatuses"
      | "organization"
      | "parentTeam"
      | "projectV2"
      | "projectsV2"
      | "repositories"
    > & {
      ancestors: ResolversTypes["TeamConnection"];
      childTeams: ResolversTypes["TeamConnection"];
      discussion?: Maybe<ResolversTypes["TeamDiscussion"]>;
      discussions: ResolversTypes["TeamDiscussionConnection"];
      invitations?: Maybe<ResolversTypes["OrganizationInvitationConnection"]>;
      memberStatuses: ResolversTypes["UserStatusConnection"];
      organization: ResolversTypes["Organization"];
      parentTeam?: Maybe<ResolversTypes["Team"]>;
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
      projectsV2: ResolversTypes["ProjectV2Connection"];
      repositories: ResolversTypes["TeamRepositoryConnection"];
    }
  >;
  TeamAddMemberAuditEntry: ResolverTypeWrapper<
    Omit<
      TeamAddMemberAuditEntry,
      "actor" | "organization" | "team" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      team?: Maybe<ResolversTypes["Team"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  TeamAddRepositoryAuditEntry: ResolverTypeWrapper<
    Omit<
      TeamAddRepositoryAuditEntry,
      "actor" | "organization" | "repository" | "team" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      team?: Maybe<ResolversTypes["Team"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  TeamAuditEntryData: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["TeamAuditEntryData"]
  >;
  TeamChangeParentTeamAuditEntry: ResolverTypeWrapper<
    Omit<
      TeamChangeParentTeamAuditEntry,
      | "actor"
      | "organization"
      | "parentTeam"
      | "parentTeamWas"
      | "team"
      | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      parentTeam?: Maybe<ResolversTypes["Team"]>;
      parentTeamWas?: Maybe<ResolversTypes["Team"]>;
      team?: Maybe<ResolversTypes["Team"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  TeamConnection: ResolverTypeWrapper<
    Omit<TeamConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["TeamEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Team"]>>>;
    }
  >;
  TeamDiscussion: ResolverTypeWrapper<
    Omit<
      TeamDiscussion,
      | "author"
      | "comments"
      | "editor"
      | "reactionGroups"
      | "reactions"
      | "team"
      | "userContentEdits"
    > & {
      author?: Maybe<ResolversTypes["Actor"]>;
      comments: ResolversTypes["TeamDiscussionCommentConnection"];
      editor?: Maybe<ResolversTypes["Actor"]>;
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      reactions: ResolversTypes["ReactionConnection"];
      team: ResolversTypes["Team"];
      userContentEdits?: Maybe<ResolversTypes["UserContentEditConnection"]>;
    }
  >;
  TeamDiscussionComment: ResolverTypeWrapper<
    Omit<
      TeamDiscussionComment,
      | "author"
      | "discussion"
      | "editor"
      | "reactionGroups"
      | "reactions"
      | "userContentEdits"
    > & {
      author?: Maybe<ResolversTypes["Actor"]>;
      discussion: ResolversTypes["TeamDiscussion"];
      editor?: Maybe<ResolversTypes["Actor"]>;
      reactionGroups?: Maybe<Array<ResolversTypes["ReactionGroup"]>>;
      reactions: ResolversTypes["ReactionConnection"];
      userContentEdits?: Maybe<ResolversTypes["UserContentEditConnection"]>;
    }
  >;
  TeamDiscussionCommentConnection: ResolverTypeWrapper<
    Omit<TeamDiscussionCommentConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["TeamDiscussionCommentEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["TeamDiscussionComment"]>>>;
    }
  >;
  TeamDiscussionCommentEdge: ResolverTypeWrapper<
    Omit<TeamDiscussionCommentEdge, "node"> & {
      node?: Maybe<ResolversTypes["TeamDiscussionComment"]>;
    }
  >;
  TeamDiscussionCommentOrder: TeamDiscussionCommentOrder;
  TeamDiscussionCommentOrderField: TeamDiscussionCommentOrderField;
  TeamDiscussionConnection: ResolverTypeWrapper<
    Omit<TeamDiscussionConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["TeamDiscussionEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["TeamDiscussion"]>>>;
    }
  >;
  TeamDiscussionEdge: ResolverTypeWrapper<
    Omit<TeamDiscussionEdge, "node"> & {
      node?: Maybe<ResolversTypes["TeamDiscussion"]>;
    }
  >;
  TeamDiscussionOrder: TeamDiscussionOrder;
  TeamDiscussionOrderField: TeamDiscussionOrderField;
  TeamEdge: ResolverTypeWrapper<
    Omit<TeamEdge, "node"> & { node?: Maybe<ResolversTypes["Team"]> }
  >;
  TeamMemberConnection: ResolverTypeWrapper<
    Omit<TeamMemberConnection, "nodes"> & {
      nodes?: Maybe<Array<Maybe<ResolversTypes["User"]>>>;
    }
  >;
  TeamMemberEdge: ResolverTypeWrapper<
    Omit<TeamMemberEdge, "node"> & { node: ResolversTypes["User"] }
  >;
  TeamMemberOrder: TeamMemberOrder;
  TeamMemberOrderField: TeamMemberOrderField;
  TeamMemberRole: TeamMemberRole;
  TeamMembershipType: TeamMembershipType;
  TeamNotificationSetting: TeamNotificationSetting;
  TeamOrder: TeamOrder;
  TeamOrderField: TeamOrderField;
  TeamPrivacy: TeamPrivacy;
  TeamRemoveMemberAuditEntry: ResolverTypeWrapper<
    Omit<
      TeamRemoveMemberAuditEntry,
      "actor" | "organization" | "team" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      team?: Maybe<ResolversTypes["Team"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  TeamRemoveRepositoryAuditEntry: ResolverTypeWrapper<
    Omit<
      TeamRemoveRepositoryAuditEntry,
      "actor" | "organization" | "repository" | "team" | "user"
    > & {
      actor?: Maybe<ResolversTypes["AuditEntryActor"]>;
      organization?: Maybe<ResolversTypes["Organization"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
      team?: Maybe<ResolversTypes["Team"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  TeamRepositoryConnection: ResolverTypeWrapper<
    Omit<TeamRepositoryConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["TeamRepositoryEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["Repository"]>>>;
    }
  >;
  TeamRepositoryEdge: ResolverTypeWrapper<
    Omit<TeamRepositoryEdge, "node"> & { node: ResolversTypes["Repository"] }
  >;
  TeamRepositoryOrder: TeamRepositoryOrder;
  TeamRepositoryOrderField: TeamRepositoryOrderField;
  TeamReviewAssignmentAlgorithm: TeamReviewAssignmentAlgorithm;
  TeamRole: TeamRole;
  TextMatch: ResolverTypeWrapper<TextMatch>;
  TextMatchHighlight: ResolverTypeWrapper<TextMatchHighlight>;
  ThreadSubscriptionFormAction: ThreadSubscriptionFormAction;
  ThreadSubscriptionState: ThreadSubscriptionState;
  Topic: ResolverTypeWrapper<
    Omit<Topic, "relatedTopics" | "repositories"> & {
      relatedTopics: Array<ResolversTypes["Topic"]>;
      repositories: ResolversTypes["RepositoryConnection"];
    }
  >;
  TopicAuditEntryData: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["TopicAuditEntryData"]
  >;
  TopicSuggestionDeclineReason: TopicSuggestionDeclineReason;
  TrackedIssueStates: TrackedIssueStates;
  TransferEnterpriseOrganizationInput: TransferEnterpriseOrganizationInput;
  TransferEnterpriseOrganizationPayload: ResolverTypeWrapper<
    Omit<TransferEnterpriseOrganizationPayload, "organization"> & {
      organization?: Maybe<ResolversTypes["Organization"]>;
    }
  >;
  TransferIssueInput: TransferIssueInput;
  TransferIssuePayload: ResolverTypeWrapper<
    Omit<TransferIssuePayload, "issue"> & {
      issue?: Maybe<ResolversTypes["Issue"]>;
    }
  >;
  TransferredEvent: ResolverTypeWrapper<
    Omit<TransferredEvent, "actor" | "fromRepository" | "issue"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      fromRepository?: Maybe<ResolversTypes["Repository"]>;
      issue: ResolversTypes["Issue"];
    }
  >;
  Tree: ResolverTypeWrapper<
    Omit<Tree, "entries" | "repository"> & {
      entries?: Maybe<Array<ResolversTypes["TreeEntry"]>>;
      repository: ResolversTypes["Repository"];
    }
  >;
  TreeEntry: ResolverTypeWrapper<
    Omit<TreeEntry, "object" | "repository"> & {
      object?: Maybe<ResolversTypes["GitObject"]>;
      repository: ResolversTypes["Repository"];
    }
  >;
  URI: ResolverTypeWrapper<Scalars["URI"]["output"]>;
  UnarchiveProjectV2ItemInput: UnarchiveProjectV2ItemInput;
  UnarchiveProjectV2ItemPayload: ResolverTypeWrapper<
    Omit<UnarchiveProjectV2ItemPayload, "item"> & {
      item?: Maybe<ResolversTypes["ProjectV2Item"]>;
    }
  >;
  UnarchiveRepositoryInput: UnarchiveRepositoryInput;
  UnarchiveRepositoryPayload: ResolverTypeWrapper<
    Omit<UnarchiveRepositoryPayload, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  UnassignedEvent: ResolverTypeWrapper<
    Omit<UnassignedEvent, "actor" | "assignable" | "assignee" | "user"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      assignable: ResolversTypes["Assignable"];
      assignee?: Maybe<ResolversTypes["Assignee"]>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  UnfollowOrganizationInput: UnfollowOrganizationInput;
  UnfollowOrganizationPayload: ResolverTypeWrapper<
    Omit<UnfollowOrganizationPayload, "organization"> & {
      organization?: Maybe<ResolversTypes["Organization"]>;
    }
  >;
  UnfollowUserInput: UnfollowUserInput;
  UnfollowUserPayload: ResolverTypeWrapper<
    Omit<UnfollowUserPayload, "user"> & { user?: Maybe<ResolversTypes["User"]> }
  >;
  UniformResourceLocatable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["UniformResourceLocatable"]
  >;
  UnknownSignature: ResolverTypeWrapper<
    Omit<UnknownSignature, "signer"> & {
      signer?: Maybe<ResolversTypes["User"]>;
    }
  >;
  UnlabeledEvent: ResolverTypeWrapper<
    Omit<UnlabeledEvent, "actor" | "label" | "labelable"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      label: ResolversTypes["Label"];
      labelable: ResolversTypes["Labelable"];
    }
  >;
  UnlinkProjectV2FromRepositoryInput: UnlinkProjectV2FromRepositoryInput;
  UnlinkProjectV2FromRepositoryPayload: ResolverTypeWrapper<
    Omit<UnlinkProjectV2FromRepositoryPayload, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  UnlinkProjectV2FromTeamInput: UnlinkProjectV2FromTeamInput;
  UnlinkProjectV2FromTeamPayload: ResolverTypeWrapper<
    Omit<UnlinkProjectV2FromTeamPayload, "team"> & {
      team?: Maybe<ResolversTypes["Team"]>;
    }
  >;
  UnlinkRepositoryFromProjectInput: UnlinkRepositoryFromProjectInput;
  UnlinkRepositoryFromProjectPayload: ResolverTypeWrapper<
    Omit<UnlinkRepositoryFromProjectPayload, "project" | "repository"> & {
      project?: Maybe<ResolversTypes["Project"]>;
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  UnlockLockableInput: UnlockLockableInput;
  UnlockLockablePayload: ResolverTypeWrapper<
    Omit<UnlockLockablePayload, "actor" | "unlockedRecord"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      unlockedRecord?: Maybe<ResolversTypes["Lockable"]>;
    }
  >;
  UnlockedEvent: ResolverTypeWrapper<
    Omit<UnlockedEvent, "actor" | "lockable"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      lockable: ResolversTypes["Lockable"];
    }
  >;
  UnmarkDiscussionCommentAsAnswerInput: UnmarkDiscussionCommentAsAnswerInput;
  UnmarkDiscussionCommentAsAnswerPayload: ResolverTypeWrapper<
    Omit<UnmarkDiscussionCommentAsAnswerPayload, "discussion"> & {
      discussion?: Maybe<ResolversTypes["Discussion"]>;
    }
  >;
  UnmarkFileAsViewedInput: UnmarkFileAsViewedInput;
  UnmarkFileAsViewedPayload: ResolverTypeWrapper<
    Omit<UnmarkFileAsViewedPayload, "pullRequest"> & {
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  UnmarkIssueAsDuplicateInput: UnmarkIssueAsDuplicateInput;
  UnmarkIssueAsDuplicatePayload: ResolverTypeWrapper<
    Omit<UnmarkIssueAsDuplicatePayload, "duplicate"> & {
      duplicate?: Maybe<ResolversTypes["IssueOrPullRequest"]>;
    }
  >;
  UnmarkProjectV2AsTemplateInput: UnmarkProjectV2AsTemplateInput;
  UnmarkProjectV2AsTemplatePayload: ResolverTypeWrapper<
    Omit<UnmarkProjectV2AsTemplatePayload, "projectV2"> & {
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
    }
  >;
  UnmarkedAsDuplicateEvent: ResolverTypeWrapper<
    Omit<UnmarkedAsDuplicateEvent, "actor" | "canonical" | "duplicate"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      canonical?: Maybe<ResolversTypes["IssueOrPullRequest"]>;
      duplicate?: Maybe<ResolversTypes["IssueOrPullRequest"]>;
    }
  >;
  UnminimizeCommentInput: UnminimizeCommentInput;
  UnminimizeCommentPayload: ResolverTypeWrapper<
    Omit<UnminimizeCommentPayload, "unminimizedComment"> & {
      unminimizedComment?: Maybe<ResolversTypes["Minimizable"]>;
    }
  >;
  UnpinIssueInput: UnpinIssueInput;
  UnpinIssuePayload: ResolverTypeWrapper<
    Omit<UnpinIssuePayload, "issue"> & {
      issue?: Maybe<ResolversTypes["Issue"]>;
    }
  >;
  UnpinnedEvent: ResolverTypeWrapper<
    Omit<UnpinnedEvent, "actor" | "issue"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      issue: ResolversTypes["Issue"];
    }
  >;
  UnresolveReviewThreadInput: UnresolveReviewThreadInput;
  UnresolveReviewThreadPayload: ResolverTypeWrapper<
    Omit<UnresolveReviewThreadPayload, "thread"> & {
      thread?: Maybe<ResolversTypes["PullRequestReviewThread"]>;
    }
  >;
  UnsubscribeFromNotificationsInput: UnsubscribeFromNotificationsInput;
  UnsubscribeFromNotificationsPayload: ResolverTypeWrapper<UnsubscribeFromNotificationsPayload>;
  UnsubscribedEvent: ResolverTypeWrapper<
    Omit<UnsubscribedEvent, "actor" | "subscribable"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      subscribable: ResolversTypes["Subscribable"];
    }
  >;
  Updatable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Updatable"]
  >;
  UpdatableComment: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["UpdatableComment"]
  >;
  UpdateBranchProtectionRuleInput: UpdateBranchProtectionRuleInput;
  UpdateBranchProtectionRulePayload: ResolverTypeWrapper<
    Omit<UpdateBranchProtectionRulePayload, "branchProtectionRule"> & {
      branchProtectionRule?: Maybe<ResolversTypes["BranchProtectionRule"]>;
    }
  >;
  UpdateCheckRunInput: UpdateCheckRunInput;
  UpdateCheckRunPayload: ResolverTypeWrapper<
    Omit<UpdateCheckRunPayload, "checkRun"> & {
      checkRun?: Maybe<ResolversTypes["CheckRun"]>;
    }
  >;
  UpdateCheckSuitePreferencesInput: UpdateCheckSuitePreferencesInput;
  UpdateCheckSuitePreferencesPayload: ResolverTypeWrapper<
    Omit<UpdateCheckSuitePreferencesPayload, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  UpdateDiscussionCommentInput: UpdateDiscussionCommentInput;
  UpdateDiscussionCommentPayload: ResolverTypeWrapper<
    Omit<UpdateDiscussionCommentPayload, "comment"> & {
      comment?: Maybe<ResolversTypes["DiscussionComment"]>;
    }
  >;
  UpdateDiscussionInput: UpdateDiscussionInput;
  UpdateDiscussionPayload: ResolverTypeWrapper<
    Omit<UpdateDiscussionPayload, "discussion"> & {
      discussion?: Maybe<ResolversTypes["Discussion"]>;
    }
  >;
  UpdateEnterpriseAdministratorRoleInput: UpdateEnterpriseAdministratorRoleInput;
  UpdateEnterpriseAdministratorRolePayload: ResolverTypeWrapper<UpdateEnterpriseAdministratorRolePayload>;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: ResolverTypeWrapper<
    Omit<
      UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload,
      "enterprise"
    > & { enterprise?: Maybe<ResolversTypes["Enterprise"]> }
  >;
  UpdateEnterpriseDefaultRepositoryPermissionSettingInput: UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: ResolverTypeWrapper<
    Omit<
      UpdateEnterpriseDefaultRepositoryPermissionSettingPayload,
      "enterprise"
    > & { enterprise?: Maybe<ResolversTypes["Enterprise"]> }
  >;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: ResolverTypeWrapper<
    Omit<
      UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload,
      "enterprise"
    > & { enterprise?: Maybe<ResolversTypes["Enterprise"]> }
  >;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: ResolverTypeWrapper<
    Omit<
      UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload,
      "enterprise"
    > & { enterprise?: Maybe<ResolversTypes["Enterprise"]> }
  >;
  UpdateEnterpriseMembersCanDeleteIssuesSettingInput: UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
  UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: ResolverTypeWrapper<
    Omit<UpdateEnterpriseMembersCanDeleteIssuesSettingPayload, "enterprise"> & {
      enterprise?: Maybe<ResolversTypes["Enterprise"]>;
    }
  >;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: ResolverTypeWrapper<
    Omit<
      UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload,
      "enterprise"
    > & { enterprise?: Maybe<ResolversTypes["Enterprise"]> }
  >;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: ResolverTypeWrapper<
    Omit<
      UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload,
      "enterprise"
    > & { enterprise?: Maybe<ResolversTypes["Enterprise"]> }
  >;
  UpdateEnterpriseMembersCanMakePurchasesSettingInput: UpdateEnterpriseMembersCanMakePurchasesSettingInput;
  UpdateEnterpriseMembersCanMakePurchasesSettingPayload: ResolverTypeWrapper<
    Omit<
      UpdateEnterpriseMembersCanMakePurchasesSettingPayload,
      "enterprise"
    > & { enterprise?: Maybe<ResolversTypes["Enterprise"]> }
  >;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: ResolverTypeWrapper<
    Omit<
      UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload,
      "enterprise"
    > & { enterprise?: Maybe<ResolversTypes["Enterprise"]> }
  >;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: ResolverTypeWrapper<
    Omit<
      UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload,
      "enterprise"
    > & { enterprise?: Maybe<ResolversTypes["Enterprise"]> }
  >;
  UpdateEnterpriseOrganizationProjectsSettingInput: UpdateEnterpriseOrganizationProjectsSettingInput;
  UpdateEnterpriseOrganizationProjectsSettingPayload: ResolverTypeWrapper<
    Omit<UpdateEnterpriseOrganizationProjectsSettingPayload, "enterprise"> & {
      enterprise?: Maybe<ResolversTypes["Enterprise"]>;
    }
  >;
  UpdateEnterpriseOwnerOrganizationRoleInput: UpdateEnterpriseOwnerOrganizationRoleInput;
  UpdateEnterpriseOwnerOrganizationRolePayload: ResolverTypeWrapper<UpdateEnterpriseOwnerOrganizationRolePayload>;
  UpdateEnterpriseProfileInput: UpdateEnterpriseProfileInput;
  UpdateEnterpriseProfilePayload: ResolverTypeWrapper<
    Omit<UpdateEnterpriseProfilePayload, "enterprise"> & {
      enterprise?: Maybe<ResolversTypes["Enterprise"]>;
    }
  >;
  UpdateEnterpriseRepositoryProjectsSettingInput: UpdateEnterpriseRepositoryProjectsSettingInput;
  UpdateEnterpriseRepositoryProjectsSettingPayload: ResolverTypeWrapper<
    Omit<UpdateEnterpriseRepositoryProjectsSettingPayload, "enterprise"> & {
      enterprise?: Maybe<ResolversTypes["Enterprise"]>;
    }
  >;
  UpdateEnterpriseTeamDiscussionsSettingInput: UpdateEnterpriseTeamDiscussionsSettingInput;
  UpdateEnterpriseTeamDiscussionsSettingPayload: ResolverTypeWrapper<
    Omit<UpdateEnterpriseTeamDiscussionsSettingPayload, "enterprise"> & {
      enterprise?: Maybe<ResolversTypes["Enterprise"]>;
    }
  >;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: ResolverTypeWrapper<
    Omit<
      UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload,
      "enterprise"
    > & { enterprise?: Maybe<ResolversTypes["Enterprise"]> }
  >;
  UpdateEnvironmentInput: UpdateEnvironmentInput;
  UpdateEnvironmentPayload: ResolverTypeWrapper<
    Omit<UpdateEnvironmentPayload, "environment"> & {
      environment?: Maybe<ResolversTypes["Environment"]>;
    }
  >;
  UpdateIpAllowListEnabledSettingInput: UpdateIpAllowListEnabledSettingInput;
  UpdateIpAllowListEnabledSettingPayload: ResolverTypeWrapper<
    Omit<UpdateIpAllowListEnabledSettingPayload, "owner"> & {
      owner?: Maybe<ResolversTypes["IpAllowListOwner"]>;
    }
  >;
  UpdateIpAllowListEntryInput: UpdateIpAllowListEntryInput;
  UpdateIpAllowListEntryPayload: ResolverTypeWrapper<
    Omit<UpdateIpAllowListEntryPayload, "ipAllowListEntry"> & {
      ipAllowListEntry?: Maybe<ResolversTypes["IpAllowListEntry"]>;
    }
  >;
  UpdateIpAllowListForInstalledAppsEnabledSettingInput: UpdateIpAllowListForInstalledAppsEnabledSettingInput;
  UpdateIpAllowListForInstalledAppsEnabledSettingPayload: ResolverTypeWrapper<
    Omit<UpdateIpAllowListForInstalledAppsEnabledSettingPayload, "owner"> & {
      owner?: Maybe<ResolversTypes["IpAllowListOwner"]>;
    }
  >;
  UpdateIssueCommentInput: UpdateIssueCommentInput;
  UpdateIssueCommentPayload: ResolverTypeWrapper<
    Omit<UpdateIssueCommentPayload, "issueComment"> & {
      issueComment?: Maybe<ResolversTypes["IssueComment"]>;
    }
  >;
  UpdateIssueInput: UpdateIssueInput;
  UpdateIssuePayload: ResolverTypeWrapper<
    Omit<UpdateIssuePayload, "actor" | "issue"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      issue?: Maybe<ResolversTypes["Issue"]>;
    }
  >;
  UpdateLabelInput: UpdateLabelInput;
  UpdateLabelPayload: ResolverTypeWrapper<
    Omit<UpdateLabelPayload, "label"> & {
      label?: Maybe<ResolversTypes["Label"]>;
    }
  >;
  UpdateNotificationRestrictionSettingInput: UpdateNotificationRestrictionSettingInput;
  UpdateNotificationRestrictionSettingPayload: ResolverTypeWrapper<
    Omit<UpdateNotificationRestrictionSettingPayload, "owner"> & {
      owner?: Maybe<ResolversTypes["VerifiableDomainOwner"]>;
    }
  >;
  UpdateOrganizationAllowPrivateRepositoryForkingSettingInput: UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
  UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload: ResolverTypeWrapper<
    Omit<
      UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload,
      "organization"
    > & { organization?: Maybe<ResolversTypes["Organization"]> }
  >;
  UpdateOrganizationWebCommitSignoffSettingInput: UpdateOrganizationWebCommitSignoffSettingInput;
  UpdateOrganizationWebCommitSignoffSettingPayload: ResolverTypeWrapper<
    Omit<UpdateOrganizationWebCommitSignoffSettingPayload, "organization"> & {
      organization?: Maybe<ResolversTypes["Organization"]>;
    }
  >;
  UpdateParameters: ResolverTypeWrapper<UpdateParameters>;
  UpdateParametersInput: UpdateParametersInput;
  UpdatePatreonSponsorabilityInput: UpdatePatreonSponsorabilityInput;
  UpdatePatreonSponsorabilityPayload: ResolverTypeWrapper<
    Omit<UpdatePatreonSponsorabilityPayload, "sponsorsListing"> & {
      sponsorsListing?: Maybe<ResolversTypes["SponsorsListing"]>;
    }
  >;
  UpdateProjectCardInput: UpdateProjectCardInput;
  UpdateProjectCardPayload: ResolverTypeWrapper<
    Omit<UpdateProjectCardPayload, "projectCard"> & {
      projectCard?: Maybe<ResolversTypes["ProjectCard"]>;
    }
  >;
  UpdateProjectColumnInput: UpdateProjectColumnInput;
  UpdateProjectColumnPayload: ResolverTypeWrapper<
    Omit<UpdateProjectColumnPayload, "projectColumn"> & {
      projectColumn?: Maybe<ResolversTypes["ProjectColumn"]>;
    }
  >;
  UpdateProjectInput: UpdateProjectInput;
  UpdateProjectPayload: ResolverTypeWrapper<
    Omit<UpdateProjectPayload, "project"> & {
      project?: Maybe<ResolversTypes["Project"]>;
    }
  >;
  UpdateProjectV2CollaboratorsInput: UpdateProjectV2CollaboratorsInput;
  UpdateProjectV2CollaboratorsPayload: ResolverTypeWrapper<
    Omit<UpdateProjectV2CollaboratorsPayload, "collaborators"> & {
      collaborators?: Maybe<ResolversTypes["ProjectV2ActorConnection"]>;
    }
  >;
  UpdateProjectV2DraftIssueInput: UpdateProjectV2DraftIssueInput;
  UpdateProjectV2DraftIssuePayload: ResolverTypeWrapper<
    Omit<UpdateProjectV2DraftIssuePayload, "draftIssue"> & {
      draftIssue?: Maybe<ResolversTypes["DraftIssue"]>;
    }
  >;
  UpdateProjectV2Input: UpdateProjectV2Input;
  UpdateProjectV2ItemFieldValueInput: UpdateProjectV2ItemFieldValueInput;
  UpdateProjectV2ItemFieldValuePayload: ResolverTypeWrapper<
    Omit<UpdateProjectV2ItemFieldValuePayload, "projectV2Item"> & {
      projectV2Item?: Maybe<ResolversTypes["ProjectV2Item"]>;
    }
  >;
  UpdateProjectV2ItemPositionInput: UpdateProjectV2ItemPositionInput;
  UpdateProjectV2ItemPositionPayload: ResolverTypeWrapper<
    Omit<UpdateProjectV2ItemPositionPayload, "items"> & {
      items?: Maybe<ResolversTypes["ProjectV2ItemConnection"]>;
    }
  >;
  UpdateProjectV2Payload: ResolverTypeWrapper<
    Omit<UpdateProjectV2Payload, "projectV2"> & {
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
    }
  >;
  UpdateProjectV2StatusUpdateInput: UpdateProjectV2StatusUpdateInput;
  UpdateProjectV2StatusUpdatePayload: ResolverTypeWrapper<
    Omit<UpdateProjectV2StatusUpdatePayload, "statusUpdate"> & {
      statusUpdate?: Maybe<ResolversTypes["ProjectV2StatusUpdate"]>;
    }
  >;
  UpdatePullRequestBranchInput: UpdatePullRequestBranchInput;
  UpdatePullRequestBranchPayload: ResolverTypeWrapper<
    Omit<UpdatePullRequestBranchPayload, "pullRequest"> & {
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  UpdatePullRequestInput: UpdatePullRequestInput;
  UpdatePullRequestPayload: ResolverTypeWrapper<
    Omit<UpdatePullRequestPayload, "actor" | "pullRequest"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      pullRequest?: Maybe<ResolversTypes["PullRequest"]>;
    }
  >;
  UpdatePullRequestReviewCommentInput: UpdatePullRequestReviewCommentInput;
  UpdatePullRequestReviewCommentPayload: ResolverTypeWrapper<
    Omit<UpdatePullRequestReviewCommentPayload, "pullRequestReviewComment"> & {
      pullRequestReviewComment?: Maybe<
        ResolversTypes["PullRequestReviewComment"]
      >;
    }
  >;
  UpdatePullRequestReviewInput: UpdatePullRequestReviewInput;
  UpdatePullRequestReviewPayload: ResolverTypeWrapper<
    Omit<UpdatePullRequestReviewPayload, "pullRequestReview"> & {
      pullRequestReview?: Maybe<ResolversTypes["PullRequestReview"]>;
    }
  >;
  UpdateRefInput: UpdateRefInput;
  UpdateRefPayload: ResolverTypeWrapper<
    Omit<UpdateRefPayload, "ref"> & { ref?: Maybe<ResolversTypes["Ref"]> }
  >;
  UpdateRefsInput: UpdateRefsInput;
  UpdateRefsPayload: ResolverTypeWrapper<UpdateRefsPayload>;
  UpdateRepositoryInput: UpdateRepositoryInput;
  UpdateRepositoryPayload: ResolverTypeWrapper<
    Omit<UpdateRepositoryPayload, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  UpdateRepositoryRulesetInput: UpdateRepositoryRulesetInput;
  UpdateRepositoryRulesetPayload: ResolverTypeWrapper<
    Omit<UpdateRepositoryRulesetPayload, "ruleset"> & {
      ruleset?: Maybe<ResolversTypes["RepositoryRuleset"]>;
    }
  >;
  UpdateRepositoryWebCommitSignoffSettingInput: UpdateRepositoryWebCommitSignoffSettingInput;
  UpdateRepositoryWebCommitSignoffSettingPayload: ResolverTypeWrapper<
    Omit<UpdateRepositoryWebCommitSignoffSettingPayload, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  UpdateSponsorshipPreferencesInput: UpdateSponsorshipPreferencesInput;
  UpdateSponsorshipPreferencesPayload: ResolverTypeWrapper<
    Omit<UpdateSponsorshipPreferencesPayload, "sponsorship"> & {
      sponsorship?: Maybe<ResolversTypes["Sponsorship"]>;
    }
  >;
  UpdateSubscriptionInput: UpdateSubscriptionInput;
  UpdateSubscriptionPayload: ResolverTypeWrapper<
    Omit<UpdateSubscriptionPayload, "subscribable"> & {
      subscribable?: Maybe<ResolversTypes["Subscribable"]>;
    }
  >;
  UpdateTeamDiscussionCommentInput: UpdateTeamDiscussionCommentInput;
  UpdateTeamDiscussionCommentPayload: ResolverTypeWrapper<
    Omit<UpdateTeamDiscussionCommentPayload, "teamDiscussionComment"> & {
      teamDiscussionComment?: Maybe<ResolversTypes["TeamDiscussionComment"]>;
    }
  >;
  UpdateTeamDiscussionInput: UpdateTeamDiscussionInput;
  UpdateTeamDiscussionPayload: ResolverTypeWrapper<
    Omit<UpdateTeamDiscussionPayload, "teamDiscussion"> & {
      teamDiscussion?: Maybe<ResolversTypes["TeamDiscussion"]>;
    }
  >;
  UpdateTeamReviewAssignmentInput: UpdateTeamReviewAssignmentInput;
  UpdateTeamReviewAssignmentPayload: ResolverTypeWrapper<
    Omit<UpdateTeamReviewAssignmentPayload, "team"> & {
      team?: Maybe<ResolversTypes["Team"]>;
    }
  >;
  UpdateTeamsRepositoryInput: UpdateTeamsRepositoryInput;
  UpdateTeamsRepositoryPayload: ResolverTypeWrapper<
    Omit<UpdateTeamsRepositoryPayload, "repository" | "teams"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
      teams?: Maybe<Array<ResolversTypes["Team"]>>;
    }
  >;
  UpdateTopicsInput: UpdateTopicsInput;
  UpdateTopicsPayload: ResolverTypeWrapper<
    Omit<UpdateTopicsPayload, "repository"> & {
      repository?: Maybe<ResolversTypes["Repository"]>;
    }
  >;
  UpdateUserListInput: UpdateUserListInput;
  UpdateUserListPayload: ResolverTypeWrapper<
    Omit<UpdateUserListPayload, "list"> & {
      list?: Maybe<ResolversTypes["UserList"]>;
    }
  >;
  UpdateUserListsForItemInput: UpdateUserListsForItemInput;
  UpdateUserListsForItemPayload: ResolverTypeWrapper<
    Omit<UpdateUserListsForItemPayload, "item" | "lists" | "user"> & {
      item?: Maybe<ResolversTypes["UserListItems"]>;
      lists?: Maybe<Array<ResolversTypes["UserList"]>>;
      user?: Maybe<ResolversTypes["User"]>;
    }
  >;
  User: ResolverTypeWrapper<
    Omit<
      User,
      | "commitComments"
      | "contributionsCollection"
      | "enterprises"
      | "followers"
      | "following"
      | "gist"
      | "gistComments"
      | "gists"
      | "hovercard"
      | "issueComments"
      | "issues"
      | "itemShowcase"
      | "lifetimeReceivedSponsorshipValues"
      | "lists"
      | "organization"
      | "organizations"
      | "packages"
      | "pinnableItems"
      | "pinnedItems"
      | "project"
      | "projectV2"
      | "projects"
      | "projectsV2"
      | "pullRequests"
      | "recentProjects"
      | "repositories"
      | "repositoriesContributedTo"
      | "repository"
      | "repositoryDiscussionComments"
      | "repositoryDiscussions"
      | "savedReplies"
      | "sponsoring"
      | "sponsors"
      | "sponsorsActivities"
      | "sponsorsListing"
      | "sponsorshipForViewerAsSponsor"
      | "sponsorshipForViewerAsSponsorable"
      | "sponsorshipNewsletters"
      | "sponsorshipsAsMaintainer"
      | "sponsorshipsAsSponsor"
      | "starredRepositories"
      | "status"
      | "topRepositories"
      | "watching"
    > & {
      commitComments: ResolversTypes["CommitCommentConnection"];
      contributionsCollection: ResolversTypes["ContributionsCollection"];
      enterprises?: Maybe<ResolversTypes["EnterpriseConnection"]>;
      followers: ResolversTypes["FollowerConnection"];
      following: ResolversTypes["FollowingConnection"];
      gist?: Maybe<ResolversTypes["Gist"]>;
      gistComments: ResolversTypes["GistCommentConnection"];
      gists: ResolversTypes["GistConnection"];
      hovercard: ResolversTypes["Hovercard"];
      issueComments: ResolversTypes["IssueCommentConnection"];
      issues: ResolversTypes["IssueConnection"];
      itemShowcase: ResolversTypes["ProfileItemShowcase"];
      lifetimeReceivedSponsorshipValues: ResolversTypes["SponsorAndLifetimeValueConnection"];
      lists: ResolversTypes["UserListConnection"];
      organization?: Maybe<ResolversTypes["Organization"]>;
      organizations: ResolversTypes["OrganizationConnection"];
      packages: ResolversTypes["PackageConnection"];
      pinnableItems: ResolversTypes["PinnableItemConnection"];
      pinnedItems: ResolversTypes["PinnableItemConnection"];
      project?: Maybe<ResolversTypes["Project"]>;
      projectV2?: Maybe<ResolversTypes["ProjectV2"]>;
      projects: ResolversTypes["ProjectConnection"];
      projectsV2: ResolversTypes["ProjectV2Connection"];
      pullRequests: ResolversTypes["PullRequestConnection"];
      recentProjects: ResolversTypes["ProjectV2Connection"];
      repositories: ResolversTypes["RepositoryConnection"];
      repositoriesContributedTo: ResolversTypes["RepositoryConnection"];
      repository?: Maybe<ResolversTypes["Repository"]>;
      repositoryDiscussionComments: ResolversTypes["DiscussionCommentConnection"];
      repositoryDiscussions: ResolversTypes["DiscussionConnection"];
      savedReplies?: Maybe<ResolversTypes["SavedReplyConnection"]>;
      sponsoring: ResolversTypes["SponsorConnection"];
      sponsors: ResolversTypes["SponsorConnection"];
      sponsorsActivities: ResolversTypes["SponsorsActivityConnection"];
      sponsorsListing?: Maybe<ResolversTypes["SponsorsListing"]>;
      sponsorshipForViewerAsSponsor?: Maybe<ResolversTypes["Sponsorship"]>;
      sponsorshipForViewerAsSponsorable?: Maybe<ResolversTypes["Sponsorship"]>;
      sponsorshipNewsletters: ResolversTypes["SponsorshipNewsletterConnection"];
      sponsorshipsAsMaintainer: ResolversTypes["SponsorshipConnection"];
      sponsorshipsAsSponsor: ResolversTypes["SponsorshipConnection"];
      starredRepositories: ResolversTypes["StarredRepositoryConnection"];
      status?: Maybe<ResolversTypes["UserStatus"]>;
      topRepositories: ResolversTypes["RepositoryConnection"];
      watching: ResolversTypes["RepositoryConnection"];
    }
  >;
  UserBlockDuration: UserBlockDuration;
  UserBlockedEvent: ResolverTypeWrapper<
    Omit<UserBlockedEvent, "actor" | "subject"> & {
      actor?: Maybe<ResolversTypes["Actor"]>;
      subject?: Maybe<ResolversTypes["User"]>;
    }
  >;
  UserConnection: ResolverTypeWrapper<
    Omit<UserConnection, "nodes"> & {
      nodes?: Maybe<Array<Maybe<ResolversTypes["User"]>>>;
    }
  >;
  UserContentEdit: ResolverTypeWrapper<
    Omit<UserContentEdit, "deletedBy" | "editor"> & {
      deletedBy?: Maybe<ResolversTypes["Actor"]>;
      editor?: Maybe<ResolversTypes["Actor"]>;
    }
  >;
  UserContentEditConnection: ResolverTypeWrapper<
    Omit<UserContentEditConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["UserContentEditEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["UserContentEdit"]>>>;
    }
  >;
  UserContentEditEdge: ResolverTypeWrapper<
    Omit<UserContentEditEdge, "node"> & {
      node?: Maybe<ResolversTypes["UserContentEdit"]>;
    }
  >;
  UserEdge: ResolverTypeWrapper<
    Omit<UserEdge, "node"> & { node?: Maybe<ResolversTypes["User"]> }
  >;
  UserEmailMetadata: ResolverTypeWrapper<UserEmailMetadata>;
  UserList: ResolverTypeWrapper<
    Omit<UserList, "items" | "user"> & {
      items: ResolversTypes["UserListItemsConnection"];
      user: ResolversTypes["User"];
    }
  >;
  UserListConnection: ResolverTypeWrapper<
    Omit<UserListConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["UserListEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["UserList"]>>>;
    }
  >;
  UserListEdge: ResolverTypeWrapper<
    Omit<UserListEdge, "node"> & { node?: Maybe<ResolversTypes["UserList"]> }
  >;
  UserListItems: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["UserListItems"]
  >;
  UserListItemsConnection: ResolverTypeWrapper<
    Omit<UserListItemsConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["UserListItemsEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["UserListItems"]>>>;
    }
  >;
  UserListItemsEdge: ResolverTypeWrapper<
    Omit<UserListItemsEdge, "node"> & {
      node?: Maybe<ResolversTypes["UserListItems"]>;
    }
  >;
  UserListSuggestion: ResolverTypeWrapper<UserListSuggestion>;
  UserStatus: ResolverTypeWrapper<
    Omit<UserStatus, "organization" | "user"> & {
      organization?: Maybe<ResolversTypes["Organization"]>;
      user: ResolversTypes["User"];
    }
  >;
  UserStatusConnection: ResolverTypeWrapper<
    Omit<UserStatusConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["UserStatusEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["UserStatus"]>>>;
    }
  >;
  UserStatusEdge: ResolverTypeWrapper<
    Omit<UserStatusEdge, "node"> & {
      node?: Maybe<ResolversTypes["UserStatus"]>;
    }
  >;
  UserStatusOrder: UserStatusOrder;
  UserStatusOrderField: UserStatusOrderField;
  VerifiableDomain: ResolverTypeWrapper<
    Omit<VerifiableDomain, "owner"> & {
      owner: ResolversTypes["VerifiableDomainOwner"];
    }
  >;
  VerifiableDomainConnection: ResolverTypeWrapper<
    Omit<VerifiableDomainConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["VerifiableDomainEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["VerifiableDomain"]>>>;
    }
  >;
  VerifiableDomainEdge: ResolverTypeWrapper<
    Omit<VerifiableDomainEdge, "node"> & {
      node?: Maybe<ResolversTypes["VerifiableDomain"]>;
    }
  >;
  VerifiableDomainOrder: VerifiableDomainOrder;
  VerifiableDomainOrderField: VerifiableDomainOrderField;
  VerifiableDomainOwner: ResolverTypeWrapper<
    ResolversUnionTypes<ResolversTypes>["VerifiableDomainOwner"]
  >;
  VerifyVerifiableDomainInput: VerifyVerifiableDomainInput;
  VerifyVerifiableDomainPayload: ResolverTypeWrapper<
    Omit<VerifyVerifiableDomainPayload, "domain"> & {
      domain?: Maybe<ResolversTypes["VerifiableDomain"]>;
    }
  >;
  ViewerHovercardContext: ResolverTypeWrapper<
    Omit<ViewerHovercardContext, "viewer"> & { viewer: ResolversTypes["User"] }
  >;
  Votable: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>["Votable"]
  >;
  Workflow: ResolverTypeWrapper<
    Omit<Workflow, "runs"> & { runs: ResolversTypes["WorkflowRunConnection"] }
  >;
  WorkflowFileReference: ResolverTypeWrapper<WorkflowFileReference>;
  WorkflowFileReferenceInput: WorkflowFileReferenceInput;
  WorkflowRun: ResolverTypeWrapper<
    Omit<
      WorkflowRun,
      | "checkSuite"
      | "deploymentReviews"
      | "file"
      | "pendingDeploymentRequests"
      | "workflow"
    > & {
      checkSuite: ResolversTypes["CheckSuite"];
      deploymentReviews: ResolversTypes["DeploymentReviewConnection"];
      file?: Maybe<ResolversTypes["WorkflowRunFile"]>;
      pendingDeploymentRequests: ResolversTypes["DeploymentRequestConnection"];
      workflow: ResolversTypes["Workflow"];
    }
  >;
  WorkflowRunConnection: ResolverTypeWrapper<
    Omit<WorkflowRunConnection, "edges" | "nodes"> & {
      edges?: Maybe<Array<Maybe<ResolversTypes["WorkflowRunEdge"]>>>;
      nodes?: Maybe<Array<Maybe<ResolversTypes["WorkflowRun"]>>>;
    }
  >;
  WorkflowRunEdge: ResolverTypeWrapper<
    Omit<WorkflowRunEdge, "node"> & {
      node?: Maybe<ResolversTypes["WorkflowRun"]>;
    }
  >;
  WorkflowRunFile: ResolverTypeWrapper<
    Omit<WorkflowRunFile, "run"> & { run: ResolversTypes["WorkflowRun"] }
  >;
  WorkflowRunOrder: WorkflowRunOrder;
  WorkflowRunOrderField: WorkflowRunOrderField;
  WorkflowState: WorkflowState;
  WorkflowsParameters: ResolverTypeWrapper<WorkflowsParameters>;
  WorkflowsParametersInput: WorkflowsParametersInput;
  X509Certificate: ResolverTypeWrapper<Scalars["X509Certificate"]["output"]>;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  AbortQueuedMigrationsInput: AbortQueuedMigrationsInput;
  AbortQueuedMigrationsPayload: AbortQueuedMigrationsPayload;
  AbortRepositoryMigrationInput: AbortRepositoryMigrationInput;
  AbortRepositoryMigrationPayload: AbortRepositoryMigrationPayload;
  AcceptEnterpriseAdministratorInvitationInput: AcceptEnterpriseAdministratorInvitationInput;
  AcceptEnterpriseAdministratorInvitationPayload: Omit<
    AcceptEnterpriseAdministratorInvitationPayload,
    "invitation"
  > & {
    invitation?: Maybe<
      ResolversParentTypes["EnterpriseAdministratorInvitation"]
    >;
  };
  AcceptEnterpriseMemberInvitationInput: AcceptEnterpriseMemberInvitationInput;
  AcceptEnterpriseMemberInvitationPayload: Omit<
    AcceptEnterpriseMemberInvitationPayload,
    "invitation"
  > & {
    invitation?: Maybe<ResolversParentTypes["EnterpriseMemberInvitation"]>;
  };
  AcceptTopicSuggestionInput: AcceptTopicSuggestionInput;
  AcceptTopicSuggestionPayload: Omit<AcceptTopicSuggestionPayload, "topic"> & {
    topic?: Maybe<ResolversParentTypes["Topic"]>;
  };
  Actor: ResolversInterfaceTypes<ResolversParentTypes>["Actor"];
  ActorLocation: ActorLocation;
  AddAssigneesToAssignableInput: AddAssigneesToAssignableInput;
  AddAssigneesToAssignablePayload: Omit<
    AddAssigneesToAssignablePayload,
    "assignable"
  > & { assignable?: Maybe<ResolversParentTypes["Assignable"]> };
  AddCommentInput: AddCommentInput;
  AddCommentPayload: Omit<
    AddCommentPayload,
    "commentEdge" | "subject" | "timelineEdge"
  > & {
    commentEdge?: Maybe<ResolversParentTypes["IssueCommentEdge"]>;
    subject?: Maybe<ResolversParentTypes["Node"]>;
    timelineEdge?: Maybe<ResolversParentTypes["IssueTimelineItemEdge"]>;
  };
  AddDiscussionCommentInput: AddDiscussionCommentInput;
  AddDiscussionCommentPayload: Omit<AddDiscussionCommentPayload, "comment"> & {
    comment?: Maybe<ResolversParentTypes["DiscussionComment"]>;
  };
  AddDiscussionPollVoteInput: AddDiscussionPollVoteInput;
  AddDiscussionPollVotePayload: Omit<
    AddDiscussionPollVotePayload,
    "pollOption"
  > & { pollOption?: Maybe<ResolversParentTypes["DiscussionPollOption"]> };
  AddEnterpriseOrganizationMemberInput: AddEnterpriseOrganizationMemberInput;
  AddEnterpriseOrganizationMemberPayload: Omit<
    AddEnterpriseOrganizationMemberPayload,
    "users"
  > & { users?: Maybe<Array<ResolversParentTypes["User"]>> };
  AddEnterpriseSupportEntitlementInput: AddEnterpriseSupportEntitlementInput;
  AddEnterpriseSupportEntitlementPayload: AddEnterpriseSupportEntitlementPayload;
  AddLabelsToLabelableInput: AddLabelsToLabelableInput;
  AddLabelsToLabelablePayload: Omit<
    AddLabelsToLabelablePayload,
    "labelable"
  > & { labelable?: Maybe<ResolversParentTypes["Labelable"]> };
  AddProjectCardInput: AddProjectCardInput;
  AddProjectCardPayload: Omit<
    AddProjectCardPayload,
    "cardEdge" | "projectColumn"
  > & {
    cardEdge?: Maybe<ResolversParentTypes["ProjectCardEdge"]>;
    projectColumn?: Maybe<ResolversParentTypes["ProjectColumn"]>;
  };
  AddProjectColumnInput: AddProjectColumnInput;
  AddProjectColumnPayload: Omit<AddProjectColumnPayload, "project"> & {
    project?: Maybe<ResolversParentTypes["Project"]>;
  };
  AddProjectV2DraftIssueInput: AddProjectV2DraftIssueInput;
  AddProjectV2DraftIssuePayload: Omit<
    AddProjectV2DraftIssuePayload,
    "projectItem"
  > & { projectItem?: Maybe<ResolversParentTypes["ProjectV2Item"]> };
  AddProjectV2ItemByIdInput: AddProjectV2ItemByIdInput;
  AddProjectV2ItemByIdPayload: Omit<AddProjectV2ItemByIdPayload, "item"> & {
    item?: Maybe<ResolversParentTypes["ProjectV2Item"]>;
  };
  AddPullRequestReviewCommentInput: AddPullRequestReviewCommentInput;
  AddPullRequestReviewCommentPayload: Omit<
    AddPullRequestReviewCommentPayload,
    "comment" | "commentEdge"
  > & {
    comment?: Maybe<ResolversParentTypes["PullRequestReviewComment"]>;
    commentEdge?: Maybe<ResolversParentTypes["PullRequestReviewCommentEdge"]>;
  };
  AddPullRequestReviewInput: AddPullRequestReviewInput;
  AddPullRequestReviewPayload: Omit<
    AddPullRequestReviewPayload,
    "pullRequestReview" | "reviewEdge"
  > & {
    pullRequestReview?: Maybe<ResolversParentTypes["PullRequestReview"]>;
    reviewEdge?: Maybe<ResolversParentTypes["PullRequestReviewEdge"]>;
  };
  AddPullRequestReviewThreadInput: AddPullRequestReviewThreadInput;
  AddPullRequestReviewThreadPayload: Omit<
    AddPullRequestReviewThreadPayload,
    "thread"
  > & { thread?: Maybe<ResolversParentTypes["PullRequestReviewThread"]> };
  AddPullRequestReviewThreadReplyInput: AddPullRequestReviewThreadReplyInput;
  AddPullRequestReviewThreadReplyPayload: Omit<
    AddPullRequestReviewThreadReplyPayload,
    "comment"
  > & { comment?: Maybe<ResolversParentTypes["PullRequestReviewComment"]> };
  AddReactionInput: AddReactionInput;
  AddReactionPayload: Omit<
    AddReactionPayload,
    "reaction" | "reactionGroups" | "subject"
  > & {
    reaction?: Maybe<ResolversParentTypes["Reaction"]>;
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    subject?: Maybe<ResolversParentTypes["Reactable"]>;
  };
  AddStarInput: AddStarInput;
  AddStarPayload: Omit<AddStarPayload, "starrable"> & {
    starrable?: Maybe<ResolversParentTypes["Starrable"]>;
  };
  AddUpvoteInput: AddUpvoteInput;
  AddUpvotePayload: Omit<AddUpvotePayload, "subject"> & {
    subject?: Maybe<ResolversParentTypes["Votable"]>;
  };
  AddVerifiableDomainInput: AddVerifiableDomainInput;
  AddVerifiableDomainPayload: Omit<AddVerifiableDomainPayload, "domain"> & {
    domain?: Maybe<ResolversParentTypes["VerifiableDomain"]>;
  };
  AddedToMergeQueueEvent: Omit<
    AddedToMergeQueueEvent,
    "actor" | "enqueuer" | "mergeQueue" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    enqueuer?: Maybe<ResolversParentTypes["User"]>;
    mergeQueue?: Maybe<ResolversParentTypes["MergeQueue"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  AddedToProjectEvent: Omit<
    AddedToProjectEvent,
    "actor" | "project" | "projectCard"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    project?: Maybe<ResolversParentTypes["Project"]>;
    projectCard?: Maybe<ResolversParentTypes["ProjectCard"]>;
  };
  AnnouncementBanner: ResolversInterfaceTypes<ResolversParentTypes>["AnnouncementBanner"];
  App: Omit<App, "ipAllowListEntries"> & {
    ipAllowListEntries: ResolversParentTypes["IpAllowListEntryConnection"];
  };
  ApproveDeploymentsInput: ApproveDeploymentsInput;
  ApproveDeploymentsPayload: Omit<ApproveDeploymentsPayload, "deployments"> & {
    deployments?: Maybe<Array<ResolversParentTypes["Deployment"]>>;
  };
  ApproveVerifiableDomainInput: ApproveVerifiableDomainInput;
  ApproveVerifiableDomainPayload: Omit<
    ApproveVerifiableDomainPayload,
    "domain"
  > & { domain?: Maybe<ResolversParentTypes["VerifiableDomain"]> };
  ArchiveProjectV2ItemInput: ArchiveProjectV2ItemInput;
  ArchiveProjectV2ItemPayload: Omit<ArchiveProjectV2ItemPayload, "item"> & {
    item?: Maybe<ResolversParentTypes["ProjectV2Item"]>;
  };
  ArchiveRepositoryInput: ArchiveRepositoryInput;
  ArchiveRepositoryPayload: Omit<ArchiveRepositoryPayload, "repository"> & {
    repository?: Maybe<ResolversParentTypes["Repository"]>;
  };
  Assignable: ResolversInterfaceTypes<ResolversParentTypes>["Assignable"];
  AssignedEvent: Omit<
    AssignedEvent,
    "actor" | "assignable" | "assignee" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    assignable: ResolversParentTypes["Assignable"];
    assignee?: Maybe<ResolversParentTypes["Assignee"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  Assignee: ResolversUnionTypes<ResolversParentTypes>["Assignee"];
  AuditEntry: ResolversInterfaceTypes<ResolversParentTypes>["AuditEntry"];
  AuditEntryActor: ResolversUnionTypes<ResolversParentTypes>["AuditEntryActor"];
  AuditLogOrder: AuditLogOrder;
  AutoMergeDisabledEvent: Omit<
    AutoMergeDisabledEvent,
    "actor" | "disabler" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    disabler?: Maybe<ResolversParentTypes["User"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  AutoMergeEnabledEvent: Omit<
    AutoMergeEnabledEvent,
    "actor" | "enabler" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    enabler?: Maybe<ResolversParentTypes["User"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  AutoMergeRequest: Omit<AutoMergeRequest, "enabledBy" | "pullRequest"> & {
    enabledBy?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
  };
  AutoRebaseEnabledEvent: Omit<
    AutoRebaseEnabledEvent,
    "actor" | "enabler" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    enabler?: Maybe<ResolversParentTypes["User"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  AutoSquashEnabledEvent: Omit<
    AutoSquashEnabledEvent,
    "actor" | "enabler" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    enabler?: Maybe<ResolversParentTypes["User"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  AutomaticBaseChangeFailedEvent: Omit<
    AutomaticBaseChangeFailedEvent,
    "actor" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
  };
  AutomaticBaseChangeSucceededEvent: Omit<
    AutomaticBaseChangeSucceededEvent,
    "actor" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
  };
  Base64String: Scalars["Base64String"]["output"];
  BaseRefChangedEvent: Omit<BaseRefChangedEvent, "actor" | "pullRequest"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
  };
  BaseRefDeletedEvent: Omit<BaseRefDeletedEvent, "actor" | "pullRequest"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  BaseRefForcePushedEvent: Omit<
    BaseRefForcePushedEvent,
    "actor" | "afterCommit" | "beforeCommit" | "pullRequest" | "ref"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    afterCommit?: Maybe<ResolversParentTypes["Commit"]>;
    beforeCommit?: Maybe<ResolversParentTypes["Commit"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
    ref?: Maybe<ResolversParentTypes["Ref"]>;
  };
  BigInt: Scalars["BigInt"]["output"];
  Blame: Omit<Blame, "ranges"> & {
    ranges: Array<ResolversParentTypes["BlameRange"]>;
  };
  BlameRange: Omit<BlameRange, "commit"> & {
    commit: ResolversParentTypes["Commit"];
  };
  Blob: Omit<Blob, "repository"> & {
    repository: ResolversParentTypes["Repository"];
  };
  Boolean: Scalars["Boolean"]["output"];
  Bot: Bot;
  BranchActorAllowanceActor: ResolversUnionTypes<ResolversParentTypes>["BranchActorAllowanceActor"];
  BranchNamePatternParameters: BranchNamePatternParameters;
  BranchNamePatternParametersInput: BranchNamePatternParametersInput;
  BranchProtectionRule: Omit<
    BranchProtectionRule,
    | "bypassForcePushAllowances"
    | "bypassPullRequestAllowances"
    | "creator"
    | "pushAllowances"
    | "repository"
    | "requiredStatusChecks"
    | "reviewDismissalAllowances"
  > & {
    bypassForcePushAllowances: ResolversParentTypes["BypassForcePushAllowanceConnection"];
    bypassPullRequestAllowances: ResolversParentTypes["BypassPullRequestAllowanceConnection"];
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    pushAllowances: ResolversParentTypes["PushAllowanceConnection"];
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    requiredStatusChecks?: Maybe<
      Array<ResolversParentTypes["RequiredStatusCheckDescription"]>
    >;
    reviewDismissalAllowances: ResolversParentTypes["ReviewDismissalAllowanceConnection"];
  };
  BranchProtectionRuleConflict: Omit<
    BranchProtectionRuleConflict,
    "branchProtectionRule" | "conflictingBranchProtectionRule" | "ref"
  > & {
    branchProtectionRule?: Maybe<ResolversParentTypes["BranchProtectionRule"]>;
    conflictingBranchProtectionRule?: Maybe<
      ResolversParentTypes["BranchProtectionRule"]
    >;
    ref?: Maybe<ResolversParentTypes["Ref"]>;
  };
  BranchProtectionRuleConflictConnection: BranchProtectionRuleConflictConnection;
  BranchProtectionRuleConflictEdge: BranchProtectionRuleConflictEdge;
  BranchProtectionRuleConnection: Omit<
    BranchProtectionRuleConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["BranchProtectionRuleEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["BranchProtectionRule"]>>>;
  };
  BranchProtectionRuleEdge: Omit<BranchProtectionRuleEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["BranchProtectionRule"]>;
  };
  BulkSponsorship: BulkSponsorship;
  BypassActor: ResolversUnionTypes<ResolversParentTypes>["BypassActor"];
  BypassForcePushAllowance: Omit<
    BypassForcePushAllowance,
    "actor" | "branchProtectionRule"
  > & {
    actor?: Maybe<ResolversParentTypes["BranchActorAllowanceActor"]>;
    branchProtectionRule?: Maybe<ResolversParentTypes["BranchProtectionRule"]>;
  };
  BypassForcePushAllowanceConnection: Omit<
    BypassForcePushAllowanceConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["BypassForcePushAllowanceEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["BypassForcePushAllowance"]>>
    >;
  };
  BypassForcePushAllowanceEdge: Omit<BypassForcePushAllowanceEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["BypassForcePushAllowance"]>;
  };
  BypassPullRequestAllowance: Omit<
    BypassPullRequestAllowance,
    "actor" | "branchProtectionRule"
  > & {
    actor?: Maybe<ResolversParentTypes["BranchActorAllowanceActor"]>;
    branchProtectionRule?: Maybe<ResolversParentTypes["BranchProtectionRule"]>;
  };
  BypassPullRequestAllowanceConnection: Omit<
    BypassPullRequestAllowanceConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["BypassPullRequestAllowanceEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["BypassPullRequestAllowance"]>>
    >;
  };
  BypassPullRequestAllowanceEdge: Omit<
    BypassPullRequestAllowanceEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["BypassPullRequestAllowance"]> };
  CVSS: Cvss;
  CWE: Cwe;
  CWEConnection: CweConnection;
  CWEEdge: CweEdge;
  CancelEnterpriseAdminInvitationInput: CancelEnterpriseAdminInvitationInput;
  CancelEnterpriseAdminInvitationPayload: Omit<
    CancelEnterpriseAdminInvitationPayload,
    "invitation"
  > & {
    invitation?: Maybe<
      ResolversParentTypes["EnterpriseAdministratorInvitation"]
    >;
  };
  CancelEnterpriseMemberInvitationInput: CancelEnterpriseMemberInvitationInput;
  CancelEnterpriseMemberInvitationPayload: Omit<
    CancelEnterpriseMemberInvitationPayload,
    "invitation"
  > & {
    invitation?: Maybe<ResolversParentTypes["EnterpriseMemberInvitation"]>;
  };
  CancelSponsorshipInput: CancelSponsorshipInput;
  CancelSponsorshipPayload: Omit<CancelSponsorshipPayload, "sponsorsTier"> & {
    sponsorsTier?: Maybe<ResolversParentTypes["SponsorsTier"]>;
  };
  ChangeUserStatusInput: ChangeUserStatusInput;
  ChangeUserStatusPayload: Omit<ChangeUserStatusPayload, "status"> & {
    status?: Maybe<ResolversParentTypes["UserStatus"]>;
  };
  CheckAnnotation: CheckAnnotation;
  CheckAnnotationConnection: CheckAnnotationConnection;
  CheckAnnotationData: CheckAnnotationData;
  CheckAnnotationEdge: CheckAnnotationEdge;
  CheckAnnotationPosition: CheckAnnotationPosition;
  CheckAnnotationRange: CheckAnnotationRange;
  CheckAnnotationSpan: CheckAnnotationSpan;
  CheckRun: Omit<
    CheckRun,
    "checkSuite" | "deployment" | "pendingDeploymentRequest" | "repository"
  > & {
    checkSuite: ResolversParentTypes["CheckSuite"];
    deployment?: Maybe<ResolversParentTypes["Deployment"]>;
    pendingDeploymentRequest?: Maybe<ResolversParentTypes["DeploymentRequest"]>;
    repository: ResolversParentTypes["Repository"];
  };
  CheckRunAction: CheckRunAction;
  CheckRunConnection: Omit<CheckRunConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["CheckRunEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["CheckRun"]>>>;
  };
  CheckRunEdge: Omit<CheckRunEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["CheckRun"]>;
  };
  CheckRunFilter: CheckRunFilter;
  CheckRunOutput: CheckRunOutput;
  CheckRunOutputImage: CheckRunOutputImage;
  CheckRunStateCount: CheckRunStateCount;
  CheckStep: CheckStep;
  CheckStepConnection: CheckStepConnection;
  CheckStepEdge: CheckStepEdge;
  CheckSuite: Omit<
    CheckSuite,
    | "app"
    | "branch"
    | "checkRuns"
    | "commit"
    | "creator"
    | "matchingPullRequests"
    | "push"
    | "repository"
    | "workflowRun"
  > & {
    app?: Maybe<ResolversParentTypes["App"]>;
    branch?: Maybe<ResolversParentTypes["Ref"]>;
    checkRuns?: Maybe<ResolversParentTypes["CheckRunConnection"]>;
    commit: ResolversParentTypes["Commit"];
    creator?: Maybe<ResolversParentTypes["User"]>;
    matchingPullRequests?: Maybe<ResolversParentTypes["PullRequestConnection"]>;
    push?: Maybe<ResolversParentTypes["Push"]>;
    repository: ResolversParentTypes["Repository"];
    workflowRun?: Maybe<ResolversParentTypes["WorkflowRun"]>;
  };
  CheckSuiteAutoTriggerPreference: CheckSuiteAutoTriggerPreference;
  CheckSuiteConnection: Omit<CheckSuiteConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["CheckSuiteEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["CheckSuite"]>>>;
  };
  CheckSuiteEdge: Omit<CheckSuiteEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["CheckSuite"]>;
  };
  CheckSuiteFilter: CheckSuiteFilter;
  Claimable: ResolversUnionTypes<ResolversParentTypes>["Claimable"];
  ClearLabelsFromLabelableInput: ClearLabelsFromLabelableInput;
  ClearLabelsFromLabelablePayload: Omit<
    ClearLabelsFromLabelablePayload,
    "labelable"
  > & { labelable?: Maybe<ResolversParentTypes["Labelable"]> };
  ClearProjectV2ItemFieldValueInput: ClearProjectV2ItemFieldValueInput;
  ClearProjectV2ItemFieldValuePayload: Omit<
    ClearProjectV2ItemFieldValuePayload,
    "projectV2Item"
  > & { projectV2Item?: Maybe<ResolversParentTypes["ProjectV2Item"]> };
  CloneProjectInput: CloneProjectInput;
  CloneProjectPayload: Omit<CloneProjectPayload, "project"> & {
    project?: Maybe<ResolversParentTypes["Project"]>;
  };
  CloneTemplateRepositoryInput: CloneTemplateRepositoryInput;
  CloneTemplateRepositoryPayload: Omit<
    CloneTemplateRepositoryPayload,
    "repository"
  > & { repository?: Maybe<ResolversParentTypes["Repository"]> };
  Closable: ResolversInterfaceTypes<ResolversParentTypes>["Closable"];
  CloseDiscussionInput: CloseDiscussionInput;
  CloseDiscussionPayload: Omit<CloseDiscussionPayload, "discussion"> & {
    discussion?: Maybe<ResolversParentTypes["Discussion"]>;
  };
  CloseIssueInput: CloseIssueInput;
  CloseIssuePayload: Omit<CloseIssuePayload, "issue"> & {
    issue?: Maybe<ResolversParentTypes["Issue"]>;
  };
  ClosePullRequestInput: ClosePullRequestInput;
  ClosePullRequestPayload: Omit<ClosePullRequestPayload, "pullRequest"> & {
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  ClosedEvent: Omit<ClosedEvent, "actor" | "closable" | "closer"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    closable: ResolversParentTypes["Closable"];
    closer?: Maybe<ResolversParentTypes["Closer"]>;
  };
  Closer: ResolversUnionTypes<ResolversParentTypes>["Closer"];
  CodeOfConduct: CodeOfConduct;
  CodeScanningParameters: CodeScanningParameters;
  CodeScanningParametersInput: CodeScanningParametersInput;
  CodeScanningTool: CodeScanningTool;
  CodeScanningToolInput: CodeScanningToolInput;
  Comment: ResolversInterfaceTypes<ResolversParentTypes>["Comment"];
  CommentDeletedEvent: Omit<
    CommentDeletedEvent,
    "actor" | "deletedCommentAuthor"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    deletedCommentAuthor?: Maybe<ResolversParentTypes["Actor"]>;
  };
  Commit: Omit<
    Commit,
    | "associatedPullRequests"
    | "blame"
    | "checkSuites"
    | "comments"
    | "deployments"
    | "file"
    | "history"
    | "onBehalfOf"
    | "parents"
    | "repository"
    | "signature"
    | "status"
    | "statusCheckRollup"
    | "tree"
  > & {
    associatedPullRequests?: Maybe<
      ResolversParentTypes["PullRequestConnection"]
    >;
    blame: ResolversParentTypes["Blame"];
    checkSuites?: Maybe<ResolversParentTypes["CheckSuiteConnection"]>;
    comments: ResolversParentTypes["CommitCommentConnection"];
    deployments?: Maybe<ResolversParentTypes["DeploymentConnection"]>;
    file?: Maybe<ResolversParentTypes["TreeEntry"]>;
    history: ResolversParentTypes["CommitHistoryConnection"];
    onBehalfOf?: Maybe<ResolversParentTypes["Organization"]>;
    parents: ResolversParentTypes["CommitConnection"];
    repository: ResolversParentTypes["Repository"];
    signature?: Maybe<ResolversParentTypes["GitSignature"]>;
    status?: Maybe<ResolversParentTypes["Status"]>;
    statusCheckRollup?: Maybe<ResolversParentTypes["StatusCheckRollup"]>;
    tree: ResolversParentTypes["Tree"];
  };
  CommitAuthor: CommitAuthor;
  CommitAuthorEmailPatternParameters: CommitAuthorEmailPatternParameters;
  CommitAuthorEmailPatternParametersInput: CommitAuthorEmailPatternParametersInput;
  CommitComment: Omit<
    CommitComment,
    | "author"
    | "commit"
    | "editor"
    | "reactionGroups"
    | "reactions"
    | "repository"
    | "userContentEdits"
  > & {
    author?: Maybe<ResolversParentTypes["Actor"]>;
    commit?: Maybe<ResolversParentTypes["Commit"]>;
    editor?: Maybe<ResolversParentTypes["Actor"]>;
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    reactions: ResolversParentTypes["ReactionConnection"];
    repository: ResolversParentTypes["Repository"];
    userContentEdits?: Maybe<ResolversParentTypes["UserContentEditConnection"]>;
  };
  CommitCommentConnection: Omit<CommitCommentConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["CommitCommentEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["CommitComment"]>>>;
  };
  CommitCommentEdge: Omit<CommitCommentEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["CommitComment"]>;
  };
  CommitCommentThread: Omit<
    CommitCommentThread,
    "comments" | "commit" | "repository"
  > & {
    comments: ResolversParentTypes["CommitCommentConnection"];
    commit?: Maybe<ResolversParentTypes["Commit"]>;
    repository: ResolversParentTypes["Repository"];
  };
  CommitConnection: Omit<CommitConnection, "nodes"> & {
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Commit"]>>>;
  };
  CommitContributionOrder: CommitContributionOrder;
  CommitContributionsByRepository: Omit<
    CommitContributionsByRepository,
    "contributions" | "repository"
  > & {
    contributions: ResolversParentTypes["CreatedCommitContributionConnection"];
    repository: ResolversParentTypes["Repository"];
  };
  CommitEdge: Omit<CommitEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Commit"]>;
  };
  CommitHistoryConnection: Omit<CommitHistoryConnection, "nodes"> & {
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Commit"]>>>;
  };
  CommitMessage: CommitMessage;
  CommitMessagePatternParameters: CommitMessagePatternParameters;
  CommitMessagePatternParametersInput: CommitMessagePatternParametersInput;
  CommittableBranch: CommittableBranch;
  CommitterEmailPatternParameters: CommitterEmailPatternParameters;
  CommitterEmailPatternParametersInput: CommitterEmailPatternParametersInput;
  Comparison: Omit<Comparison, "baseTarget" | "headTarget"> & {
    baseTarget: ResolversParentTypes["GitObject"];
    headTarget: ResolversParentTypes["GitObject"];
  };
  ComparisonCommitConnection: Omit<ComparisonCommitConnection, "nodes"> & {
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Commit"]>>>;
  };
  ConnectedEvent: Omit<ConnectedEvent, "actor" | "source" | "subject"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    source: ResolversParentTypes["ReferencedSubject"];
    subject: ResolversParentTypes["ReferencedSubject"];
  };
  ContributingGuidelines: ContributingGuidelines;
  Contribution: ResolversInterfaceTypes<ResolversParentTypes>["Contribution"];
  ContributionCalendar: ContributionCalendar;
  ContributionCalendarDay: ContributionCalendarDay;
  ContributionCalendarMonth: ContributionCalendarMonth;
  ContributionCalendarWeek: ContributionCalendarWeek;
  ContributionOrder: ContributionOrder;
  ContributionsCollection: Omit<
    ContributionsCollection,
    | "commitContributionsByRepository"
    | "firstIssueContribution"
    | "firstPullRequestContribution"
    | "firstRepositoryContribution"
    | "issueContributions"
    | "issueContributionsByRepository"
    | "joinedGitHubContribution"
    | "mostRecentCollectionWithActivity"
    | "mostRecentCollectionWithoutActivity"
    | "popularIssueContribution"
    | "popularPullRequestContribution"
    | "pullRequestContributions"
    | "pullRequestContributionsByRepository"
    | "pullRequestReviewContributions"
    | "pullRequestReviewContributionsByRepository"
    | "repositoryContributions"
    | "user"
  > & {
    commitContributionsByRepository: Array<
      ResolversParentTypes["CommitContributionsByRepository"]
    >;
    firstIssueContribution?: Maybe<
      ResolversParentTypes["CreatedIssueOrRestrictedContribution"]
    >;
    firstPullRequestContribution?: Maybe<
      ResolversParentTypes["CreatedPullRequestOrRestrictedContribution"]
    >;
    firstRepositoryContribution?: Maybe<
      ResolversParentTypes["CreatedRepositoryOrRestrictedContribution"]
    >;
    issueContributions: ResolversParentTypes["CreatedIssueContributionConnection"];
    issueContributionsByRepository: Array<
      ResolversParentTypes["IssueContributionsByRepository"]
    >;
    joinedGitHubContribution?: Maybe<
      ResolversParentTypes["JoinedGitHubContribution"]
    >;
    mostRecentCollectionWithActivity?: Maybe<
      ResolversParentTypes["ContributionsCollection"]
    >;
    mostRecentCollectionWithoutActivity?: Maybe<
      ResolversParentTypes["ContributionsCollection"]
    >;
    popularIssueContribution?: Maybe<
      ResolversParentTypes["CreatedIssueContribution"]
    >;
    popularPullRequestContribution?: Maybe<
      ResolversParentTypes["CreatedPullRequestContribution"]
    >;
    pullRequestContributions: ResolversParentTypes["CreatedPullRequestContributionConnection"];
    pullRequestContributionsByRepository: Array<
      ResolversParentTypes["PullRequestContributionsByRepository"]
    >;
    pullRequestReviewContributions: ResolversParentTypes["CreatedPullRequestReviewContributionConnection"];
    pullRequestReviewContributionsByRepository: Array<
      ResolversParentTypes["PullRequestReviewContributionsByRepository"]
    >;
    repositoryContributions: ResolversParentTypes["CreatedRepositoryContributionConnection"];
    user: ResolversParentTypes["User"];
  };
  ConvertProjectCardNoteToIssueInput: ConvertProjectCardNoteToIssueInput;
  ConvertProjectCardNoteToIssuePayload: Omit<
    ConvertProjectCardNoteToIssuePayload,
    "projectCard"
  > & { projectCard?: Maybe<ResolversParentTypes["ProjectCard"]> };
  ConvertProjectV2DraftIssueItemToIssueInput: ConvertProjectV2DraftIssueItemToIssueInput;
  ConvertProjectV2DraftIssueItemToIssuePayload: Omit<
    ConvertProjectV2DraftIssueItemToIssuePayload,
    "item"
  > & { item?: Maybe<ResolversParentTypes["ProjectV2Item"]> };
  ConvertPullRequestToDraftInput: ConvertPullRequestToDraftInput;
  ConvertPullRequestToDraftPayload: Omit<
    ConvertPullRequestToDraftPayload,
    "pullRequest"
  > & { pullRequest?: Maybe<ResolversParentTypes["PullRequest"]> };
  ConvertToDraftEvent: Omit<ConvertToDraftEvent, "actor" | "pullRequest"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
  };
  ConvertedNoteToIssueEvent: Omit<
    ConvertedNoteToIssueEvent,
    "actor" | "project" | "projectCard"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    project?: Maybe<ResolversParentTypes["Project"]>;
    projectCard?: Maybe<ResolversParentTypes["ProjectCard"]>;
  };
  ConvertedToDiscussionEvent: Omit<
    ConvertedToDiscussionEvent,
    "actor" | "discussion"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    discussion?: Maybe<ResolversParentTypes["Discussion"]>;
  };
  CopilotEndpoints: CopilotEndpoints;
  CopyProjectV2Input: CopyProjectV2Input;
  CopyProjectV2Payload: Omit<CopyProjectV2Payload, "projectV2"> & {
    projectV2?: Maybe<ResolversParentTypes["ProjectV2"]>;
  };
  CreateAttributionInvitationInput: CreateAttributionInvitationInput;
  CreateAttributionInvitationPayload: Omit<
    CreateAttributionInvitationPayload,
    "owner" | "source" | "target"
  > & {
    owner?: Maybe<ResolversParentTypes["Organization"]>;
    source?: Maybe<ResolversParentTypes["Claimable"]>;
    target?: Maybe<ResolversParentTypes["Claimable"]>;
  };
  CreateBranchProtectionRuleInput: CreateBranchProtectionRuleInput;
  CreateBranchProtectionRulePayload: Omit<
    CreateBranchProtectionRulePayload,
    "branchProtectionRule"
  > & {
    branchProtectionRule?: Maybe<ResolversParentTypes["BranchProtectionRule"]>;
  };
  CreateCheckRunInput: CreateCheckRunInput;
  CreateCheckRunPayload: Omit<CreateCheckRunPayload, "checkRun"> & {
    checkRun?: Maybe<ResolversParentTypes["CheckRun"]>;
  };
  CreateCheckSuiteInput: CreateCheckSuiteInput;
  CreateCheckSuitePayload: Omit<CreateCheckSuitePayload, "checkSuite"> & {
    checkSuite?: Maybe<ResolversParentTypes["CheckSuite"]>;
  };
  CreateCommitOnBranchInput: CreateCommitOnBranchInput;
  CreateCommitOnBranchPayload: Omit<
    CreateCommitOnBranchPayload,
    "commit" | "ref"
  > & {
    commit?: Maybe<ResolversParentTypes["Commit"]>;
    ref?: Maybe<ResolversParentTypes["Ref"]>;
  };
  CreateDeploymentInput: CreateDeploymentInput;
  CreateDeploymentPayload: Omit<CreateDeploymentPayload, "deployment"> & {
    deployment?: Maybe<ResolversParentTypes["Deployment"]>;
  };
  CreateDeploymentStatusInput: CreateDeploymentStatusInput;
  CreateDeploymentStatusPayload: Omit<
    CreateDeploymentStatusPayload,
    "deploymentStatus"
  > & { deploymentStatus?: Maybe<ResolversParentTypes["DeploymentStatus"]> };
  CreateDiscussionInput: CreateDiscussionInput;
  CreateDiscussionPayload: Omit<CreateDiscussionPayload, "discussion"> & {
    discussion?: Maybe<ResolversParentTypes["Discussion"]>;
  };
  CreateEnterpriseOrganizationInput: CreateEnterpriseOrganizationInput;
  CreateEnterpriseOrganizationPayload: Omit<
    CreateEnterpriseOrganizationPayload,
    "enterprise" | "organization"
  > & {
    enterprise?: Maybe<ResolversParentTypes["Enterprise"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
  };
  CreateEnvironmentInput: CreateEnvironmentInput;
  CreateEnvironmentPayload: Omit<CreateEnvironmentPayload, "environment"> & {
    environment?: Maybe<ResolversParentTypes["Environment"]>;
  };
  CreateIpAllowListEntryInput: CreateIpAllowListEntryInput;
  CreateIpAllowListEntryPayload: Omit<
    CreateIpAllowListEntryPayload,
    "ipAllowListEntry"
  > & { ipAllowListEntry?: Maybe<ResolversParentTypes["IpAllowListEntry"]> };
  CreateIssueInput: CreateIssueInput;
  CreateIssuePayload: Omit<CreateIssuePayload, "issue"> & {
    issue?: Maybe<ResolversParentTypes["Issue"]>;
  };
  CreateLabelInput: CreateLabelInput;
  CreateLabelPayload: Omit<CreateLabelPayload, "label"> & {
    label?: Maybe<ResolversParentTypes["Label"]>;
  };
  CreateLinkedBranchInput: CreateLinkedBranchInput;
  CreateLinkedBranchPayload: Omit<CreateLinkedBranchPayload, "issue"> & {
    issue?: Maybe<ResolversParentTypes["Issue"]>;
  };
  CreateMigrationSourceInput: CreateMigrationSourceInput;
  CreateMigrationSourcePayload: CreateMigrationSourcePayload;
  CreateProjectInput: CreateProjectInput;
  CreateProjectPayload: Omit<CreateProjectPayload, "project"> & {
    project?: Maybe<ResolversParentTypes["Project"]>;
  };
  CreateProjectV2FieldInput: CreateProjectV2FieldInput;
  CreateProjectV2FieldPayload: Omit<
    CreateProjectV2FieldPayload,
    "projectV2Field"
  > & {
    projectV2Field?: Maybe<ResolversParentTypes["ProjectV2FieldConfiguration"]>;
  };
  CreateProjectV2Input: CreateProjectV2Input;
  CreateProjectV2Payload: Omit<CreateProjectV2Payload, "projectV2"> & {
    projectV2?: Maybe<ResolversParentTypes["ProjectV2"]>;
  };
  CreateProjectV2StatusUpdateInput: CreateProjectV2StatusUpdateInput;
  CreateProjectV2StatusUpdatePayload: Omit<
    CreateProjectV2StatusUpdatePayload,
    "statusUpdate"
  > & { statusUpdate?: Maybe<ResolversParentTypes["ProjectV2StatusUpdate"]> };
  CreatePullRequestInput: CreatePullRequestInput;
  CreatePullRequestPayload: Omit<CreatePullRequestPayload, "pullRequest"> & {
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  CreateRefInput: CreateRefInput;
  CreateRefPayload: Omit<CreateRefPayload, "ref"> & {
    ref?: Maybe<ResolversParentTypes["Ref"]>;
  };
  CreateRepositoryInput: CreateRepositoryInput;
  CreateRepositoryPayload: Omit<CreateRepositoryPayload, "repository"> & {
    repository?: Maybe<ResolversParentTypes["Repository"]>;
  };
  CreateRepositoryRulesetInput: CreateRepositoryRulesetInput;
  CreateRepositoryRulesetPayload: Omit<
    CreateRepositoryRulesetPayload,
    "ruleset"
  > & { ruleset?: Maybe<ResolversParentTypes["RepositoryRuleset"]> };
  CreateSponsorsListingInput: CreateSponsorsListingInput;
  CreateSponsorsListingPayload: Omit<
    CreateSponsorsListingPayload,
    "sponsorsListing"
  > & { sponsorsListing?: Maybe<ResolversParentTypes["SponsorsListing"]> };
  CreateSponsorsTierInput: CreateSponsorsTierInput;
  CreateSponsorsTierPayload: Omit<CreateSponsorsTierPayload, "sponsorsTier"> & {
    sponsorsTier?: Maybe<ResolversParentTypes["SponsorsTier"]>;
  };
  CreateSponsorshipInput: CreateSponsorshipInput;
  CreateSponsorshipPayload: Omit<CreateSponsorshipPayload, "sponsorship"> & {
    sponsorship?: Maybe<ResolversParentTypes["Sponsorship"]>;
  };
  CreateSponsorshipsInput: CreateSponsorshipsInput;
  CreateSponsorshipsPayload: Omit<CreateSponsorshipsPayload, "sponsorables"> & {
    sponsorables?: Maybe<Array<ResolversParentTypes["Sponsorable"]>>;
  };
  CreateTeamDiscussionCommentInput: CreateTeamDiscussionCommentInput;
  CreateTeamDiscussionCommentPayload: Omit<
    CreateTeamDiscussionCommentPayload,
    "teamDiscussionComment"
  > & {
    teamDiscussionComment?: Maybe<
      ResolversParentTypes["TeamDiscussionComment"]
    >;
  };
  CreateTeamDiscussionInput: CreateTeamDiscussionInput;
  CreateTeamDiscussionPayload: Omit<
    CreateTeamDiscussionPayload,
    "teamDiscussion"
  > & { teamDiscussion?: Maybe<ResolversParentTypes["TeamDiscussion"]> };
  CreateUserListInput: CreateUserListInput;
  CreateUserListPayload: Omit<CreateUserListPayload, "list" | "viewer"> & {
    list?: Maybe<ResolversParentTypes["UserList"]>;
    viewer?: Maybe<ResolversParentTypes["User"]>;
  };
  CreatedCommitContribution: Omit<
    CreatedCommitContribution,
    "repository" | "user"
  > & {
    repository: ResolversParentTypes["Repository"];
    user: ResolversParentTypes["User"];
  };
  CreatedCommitContributionConnection: Omit<
    CreatedCommitContributionConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["CreatedCommitContributionEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["CreatedCommitContribution"]>>
    >;
  };
  CreatedCommitContributionEdge: Omit<CreatedCommitContributionEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["CreatedCommitContribution"]>;
  };
  CreatedIssueContribution: Omit<CreatedIssueContribution, "issue" | "user"> & {
    issue: ResolversParentTypes["Issue"];
    user: ResolversParentTypes["User"];
  };
  CreatedIssueContributionConnection: Omit<
    CreatedIssueContributionConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["CreatedIssueContributionEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["CreatedIssueContribution"]>>
    >;
  };
  CreatedIssueContributionEdge: Omit<CreatedIssueContributionEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["CreatedIssueContribution"]>;
  };
  CreatedIssueOrRestrictedContribution: ResolversUnionTypes<ResolversParentTypes>["CreatedIssueOrRestrictedContribution"];
  CreatedPullRequestContribution: Omit<
    CreatedPullRequestContribution,
    "pullRequest" | "user"
  > & {
    pullRequest: ResolversParentTypes["PullRequest"];
    user: ResolversParentTypes["User"];
  };
  CreatedPullRequestContributionConnection: Omit<
    CreatedPullRequestContributionConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["CreatedPullRequestContributionEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["CreatedPullRequestContribution"]>>
    >;
  };
  CreatedPullRequestContributionEdge: Omit<
    CreatedPullRequestContributionEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["CreatedPullRequestContribution"]> };
  CreatedPullRequestOrRestrictedContribution: ResolversUnionTypes<ResolversParentTypes>["CreatedPullRequestOrRestrictedContribution"];
  CreatedPullRequestReviewContribution: Omit<
    CreatedPullRequestReviewContribution,
    "pullRequest" | "pullRequestReview" | "repository" | "user"
  > & {
    pullRequest: ResolversParentTypes["PullRequest"];
    pullRequestReview: ResolversParentTypes["PullRequestReview"];
    repository: ResolversParentTypes["Repository"];
    user: ResolversParentTypes["User"];
  };
  CreatedPullRequestReviewContributionConnection: Omit<
    CreatedPullRequestReviewContributionConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<
        Maybe<ResolversParentTypes["CreatedPullRequestReviewContributionEdge"]>
      >
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["CreatedPullRequestReviewContribution"]>>
    >;
  };
  CreatedPullRequestReviewContributionEdge: Omit<
    CreatedPullRequestReviewContributionEdge,
    "node"
  > & {
    node?: Maybe<ResolversParentTypes["CreatedPullRequestReviewContribution"]>;
  };
  CreatedRepositoryContribution: Omit<
    CreatedRepositoryContribution,
    "repository" | "user"
  > & {
    repository: ResolversParentTypes["Repository"];
    user: ResolversParentTypes["User"];
  };
  CreatedRepositoryContributionConnection: Omit<
    CreatedRepositoryContributionConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["CreatedRepositoryContributionEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["CreatedRepositoryContribution"]>>
    >;
  };
  CreatedRepositoryContributionEdge: Omit<
    CreatedRepositoryContributionEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["CreatedRepositoryContribution"]> };
  CreatedRepositoryOrRestrictedContribution: ResolversUnionTypes<ResolversParentTypes>["CreatedRepositoryOrRestrictedContribution"];
  CrossReferencedEvent: Omit<
    CrossReferencedEvent,
    "actor" | "source" | "target"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    source: ResolversParentTypes["ReferencedSubject"];
    target: ResolversParentTypes["ReferencedSubject"];
  };
  Date: Scalars["Date"]["output"];
  DateTime: Scalars["DateTime"]["output"];
  DeclineTopicSuggestionInput: DeclineTopicSuggestionInput;
  DeclineTopicSuggestionPayload: Omit<
    DeclineTopicSuggestionPayload,
    "topic"
  > & { topic?: Maybe<ResolversParentTypes["Topic"]> };
  Deletable: ResolversInterfaceTypes<ResolversParentTypes>["Deletable"];
  DeleteBranchProtectionRuleInput: DeleteBranchProtectionRuleInput;
  DeleteBranchProtectionRulePayload: DeleteBranchProtectionRulePayload;
  DeleteDeploymentInput: DeleteDeploymentInput;
  DeleteDeploymentPayload: DeleteDeploymentPayload;
  DeleteDiscussionCommentInput: DeleteDiscussionCommentInput;
  DeleteDiscussionCommentPayload: Omit<
    DeleteDiscussionCommentPayload,
    "comment"
  > & { comment?: Maybe<ResolversParentTypes["DiscussionComment"]> };
  DeleteDiscussionInput: DeleteDiscussionInput;
  DeleteDiscussionPayload: Omit<DeleteDiscussionPayload, "discussion"> & {
    discussion?: Maybe<ResolversParentTypes["Discussion"]>;
  };
  DeleteEnvironmentInput: DeleteEnvironmentInput;
  DeleteEnvironmentPayload: DeleteEnvironmentPayload;
  DeleteIpAllowListEntryInput: DeleteIpAllowListEntryInput;
  DeleteIpAllowListEntryPayload: Omit<
    DeleteIpAllowListEntryPayload,
    "ipAllowListEntry"
  > & { ipAllowListEntry?: Maybe<ResolversParentTypes["IpAllowListEntry"]> };
  DeleteIssueCommentInput: DeleteIssueCommentInput;
  DeleteIssueCommentPayload: DeleteIssueCommentPayload;
  DeleteIssueInput: DeleteIssueInput;
  DeleteIssuePayload: Omit<DeleteIssuePayload, "repository"> & {
    repository?: Maybe<ResolversParentTypes["Repository"]>;
  };
  DeleteLabelInput: DeleteLabelInput;
  DeleteLabelPayload: DeleteLabelPayload;
  DeleteLinkedBranchInput: DeleteLinkedBranchInput;
  DeleteLinkedBranchPayload: Omit<DeleteLinkedBranchPayload, "issue"> & {
    issue?: Maybe<ResolversParentTypes["Issue"]>;
  };
  DeletePackageVersionInput: DeletePackageVersionInput;
  DeletePackageVersionPayload: DeletePackageVersionPayload;
  DeleteProjectCardInput: DeleteProjectCardInput;
  DeleteProjectCardPayload: Omit<DeleteProjectCardPayload, "column"> & {
    column?: Maybe<ResolversParentTypes["ProjectColumn"]>;
  };
  DeleteProjectColumnInput: DeleteProjectColumnInput;
  DeleteProjectColumnPayload: Omit<DeleteProjectColumnPayload, "project"> & {
    project?: Maybe<ResolversParentTypes["Project"]>;
  };
  DeleteProjectInput: DeleteProjectInput;
  DeleteProjectPayload: Omit<DeleteProjectPayload, "owner"> & {
    owner?: Maybe<ResolversParentTypes["ProjectOwner"]>;
  };
  DeleteProjectV2FieldInput: DeleteProjectV2FieldInput;
  DeleteProjectV2FieldPayload: Omit<
    DeleteProjectV2FieldPayload,
    "projectV2Field"
  > & {
    projectV2Field?: Maybe<ResolversParentTypes["ProjectV2FieldConfiguration"]>;
  };
  DeleteProjectV2Input: DeleteProjectV2Input;
  DeleteProjectV2ItemInput: DeleteProjectV2ItemInput;
  DeleteProjectV2ItemPayload: DeleteProjectV2ItemPayload;
  DeleteProjectV2Payload: Omit<DeleteProjectV2Payload, "projectV2"> & {
    projectV2?: Maybe<ResolversParentTypes["ProjectV2"]>;
  };
  DeleteProjectV2StatusUpdateInput: DeleteProjectV2StatusUpdateInput;
  DeleteProjectV2StatusUpdatePayload: Omit<
    DeleteProjectV2StatusUpdatePayload,
    "projectV2"
  > & { projectV2?: Maybe<ResolversParentTypes["ProjectV2"]> };
  DeleteProjectV2WorkflowInput: DeleteProjectV2WorkflowInput;
  DeleteProjectV2WorkflowPayload: Omit<
    DeleteProjectV2WorkflowPayload,
    "projectV2"
  > & { projectV2?: Maybe<ResolversParentTypes["ProjectV2"]> };
  DeletePullRequestReviewCommentInput: DeletePullRequestReviewCommentInput;
  DeletePullRequestReviewCommentPayload: Omit<
    DeletePullRequestReviewCommentPayload,
    "pullRequestReview" | "pullRequestReviewComment"
  > & {
    pullRequestReview?: Maybe<ResolversParentTypes["PullRequestReview"]>;
    pullRequestReviewComment?: Maybe<
      ResolversParentTypes["PullRequestReviewComment"]
    >;
  };
  DeletePullRequestReviewInput: DeletePullRequestReviewInput;
  DeletePullRequestReviewPayload: Omit<
    DeletePullRequestReviewPayload,
    "pullRequestReview"
  > & { pullRequestReview?: Maybe<ResolversParentTypes["PullRequestReview"]> };
  DeleteRefInput: DeleteRefInput;
  DeleteRefPayload: DeleteRefPayload;
  DeleteRepositoryRulesetInput: DeleteRepositoryRulesetInput;
  DeleteRepositoryRulesetPayload: DeleteRepositoryRulesetPayload;
  DeleteTeamDiscussionCommentInput: DeleteTeamDiscussionCommentInput;
  DeleteTeamDiscussionCommentPayload: DeleteTeamDiscussionCommentPayload;
  DeleteTeamDiscussionInput: DeleteTeamDiscussionInput;
  DeleteTeamDiscussionPayload: DeleteTeamDiscussionPayload;
  DeleteUserListInput: DeleteUserListInput;
  DeleteUserListPayload: Omit<DeleteUserListPayload, "user"> & {
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  DeleteVerifiableDomainInput: DeleteVerifiableDomainInput;
  DeleteVerifiableDomainPayload: Omit<
    DeleteVerifiableDomainPayload,
    "owner"
  > & { owner?: Maybe<ResolversParentTypes["VerifiableDomainOwner"]> };
  DemilestonedEvent: Omit<DemilestonedEvent, "actor" | "subject"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    subject: ResolversParentTypes["MilestoneItem"];
  };
  DependabotUpdate: Omit<
    DependabotUpdate,
    "error" | "pullRequest" | "repository"
  > & {
    error?: Maybe<ResolversParentTypes["DependabotUpdateError"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
    repository: ResolversParentTypes["Repository"];
  };
  DependabotUpdateError: DependabotUpdateError;
  DependencyGraphDependency: Omit<DependencyGraphDependency, "repository"> & {
    repository?: Maybe<ResolversParentTypes["Repository"]>;
  };
  DependencyGraphDependencyConnection: Omit<
    DependencyGraphDependencyConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["DependencyGraphDependencyEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["DependencyGraphDependency"]>>
    >;
  };
  DependencyGraphDependencyEdge: Omit<DependencyGraphDependencyEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["DependencyGraphDependency"]>;
  };
  DependencyGraphManifest: Omit<
    DependencyGraphManifest,
    "dependencies" | "repository"
  > & {
    dependencies?: Maybe<
      ResolversParentTypes["DependencyGraphDependencyConnection"]
    >;
    repository: ResolversParentTypes["Repository"];
  };
  DependencyGraphManifestConnection: Omit<
    DependencyGraphManifestConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["DependencyGraphManifestEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["DependencyGraphManifest"]>>
    >;
  };
  DependencyGraphManifestEdge: Omit<DependencyGraphManifestEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["DependencyGraphManifest"]>;
  };
  DeployKey: DeployKey;
  DeployKeyConnection: DeployKeyConnection;
  DeployKeyEdge: DeployKeyEdge;
  DeployedEvent: Omit<
    DeployedEvent,
    "actor" | "deployment" | "pullRequest" | "ref"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    deployment: ResolversParentTypes["Deployment"];
    pullRequest: ResolversParentTypes["PullRequest"];
    ref?: Maybe<ResolversParentTypes["Ref"]>;
  };
  Deployment: Omit<
    Deployment,
    "commit" | "creator" | "latestStatus" | "ref" | "repository" | "statuses"
  > & {
    commit?: Maybe<ResolversParentTypes["Commit"]>;
    creator: ResolversParentTypes["Actor"];
    latestStatus?: Maybe<ResolversParentTypes["DeploymentStatus"]>;
    ref?: Maybe<ResolversParentTypes["Ref"]>;
    repository: ResolversParentTypes["Repository"];
    statuses?: Maybe<ResolversParentTypes["DeploymentStatusConnection"]>;
  };
  DeploymentConnection: Omit<DeploymentConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["DeploymentEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Deployment"]>>>;
  };
  DeploymentEdge: Omit<DeploymentEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Deployment"]>;
  };
  DeploymentEnvironmentChangedEvent: Omit<
    DeploymentEnvironmentChangedEvent,
    "actor" | "deploymentStatus" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    deploymentStatus: ResolversParentTypes["DeploymentStatus"];
    pullRequest: ResolversParentTypes["PullRequest"];
  };
  DeploymentOrder: DeploymentOrder;
  DeploymentProtectionRule: Omit<DeploymentProtectionRule, "reviewers"> & {
    reviewers: ResolversParentTypes["DeploymentReviewerConnection"];
  };
  DeploymentProtectionRuleConnection: Omit<
    DeploymentProtectionRuleConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["DeploymentProtectionRuleEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["DeploymentProtectionRule"]>>
    >;
  };
  DeploymentProtectionRuleEdge: Omit<DeploymentProtectionRuleEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["DeploymentProtectionRule"]>;
  };
  DeploymentRequest: Omit<DeploymentRequest, "environment" | "reviewers"> & {
    environment: ResolversParentTypes["Environment"];
    reviewers: ResolversParentTypes["DeploymentReviewerConnection"];
  };
  DeploymentRequestConnection: Omit<
    DeploymentRequestConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["DeploymentRequestEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["DeploymentRequest"]>>>;
  };
  DeploymentRequestEdge: Omit<DeploymentRequestEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["DeploymentRequest"]>;
  };
  DeploymentReview: Omit<DeploymentReview, "environments" | "user"> & {
    environments: ResolversParentTypes["EnvironmentConnection"];
    user: ResolversParentTypes["User"];
  };
  DeploymentReviewConnection: Omit<
    DeploymentReviewConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["DeploymentReviewEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["DeploymentReview"]>>>;
  };
  DeploymentReviewEdge: Omit<DeploymentReviewEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["DeploymentReview"]>;
  };
  DeploymentReviewer: ResolversUnionTypes<ResolversParentTypes>["DeploymentReviewer"];
  DeploymentReviewerConnection: Omit<
    DeploymentReviewerConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["DeploymentReviewerEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["DeploymentReviewer"]>>>;
  };
  DeploymentReviewerEdge: Omit<DeploymentReviewerEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["DeploymentReviewer"]>;
  };
  DeploymentStatus: Omit<DeploymentStatus, "creator" | "deployment"> & {
    creator: ResolversParentTypes["Actor"];
    deployment: ResolversParentTypes["Deployment"];
  };
  DeploymentStatusConnection: Omit<
    DeploymentStatusConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["DeploymentStatusEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["DeploymentStatus"]>>>;
  };
  DeploymentStatusEdge: Omit<DeploymentStatusEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["DeploymentStatus"]>;
  };
  DequeuePullRequestInput: DequeuePullRequestInput;
  DequeuePullRequestPayload: Omit<
    DequeuePullRequestPayload,
    "mergeQueueEntry"
  > & { mergeQueueEntry?: Maybe<ResolversParentTypes["MergeQueueEntry"]> };
  DisablePullRequestAutoMergeInput: DisablePullRequestAutoMergeInput;
  DisablePullRequestAutoMergePayload: Omit<
    DisablePullRequestAutoMergePayload,
    "actor" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  DisconnectedEvent: Omit<DisconnectedEvent, "actor" | "source" | "subject"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    source: ResolversParentTypes["ReferencedSubject"];
    subject: ResolversParentTypes["ReferencedSubject"];
  };
  Discussion: Omit<
    Discussion,
    | "answer"
    | "answerChosenBy"
    | "author"
    | "category"
    | "comments"
    | "editor"
    | "labels"
    | "poll"
    | "reactionGroups"
    | "reactions"
    | "repository"
    | "userContentEdits"
  > & {
    answer?: Maybe<ResolversParentTypes["DiscussionComment"]>;
    answerChosenBy?: Maybe<ResolversParentTypes["Actor"]>;
    author?: Maybe<ResolversParentTypes["Actor"]>;
    category: ResolversParentTypes["DiscussionCategory"];
    comments: ResolversParentTypes["DiscussionCommentConnection"];
    editor?: Maybe<ResolversParentTypes["Actor"]>;
    labels?: Maybe<ResolversParentTypes["LabelConnection"]>;
    poll?: Maybe<ResolversParentTypes["DiscussionPoll"]>;
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    reactions: ResolversParentTypes["ReactionConnection"];
    repository: ResolversParentTypes["Repository"];
    userContentEdits?: Maybe<ResolversParentTypes["UserContentEditConnection"]>;
  };
  DiscussionCategory: Omit<DiscussionCategory, "repository"> & {
    repository: ResolversParentTypes["Repository"];
  };
  DiscussionCategoryConnection: Omit<
    DiscussionCategoryConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["DiscussionCategoryEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["DiscussionCategory"]>>>;
  };
  DiscussionCategoryEdge: Omit<DiscussionCategoryEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["DiscussionCategory"]>;
  };
  DiscussionComment: Omit<
    DiscussionComment,
    | "author"
    | "discussion"
    | "editor"
    | "reactionGroups"
    | "reactions"
    | "replies"
    | "replyTo"
    | "userContentEdits"
  > & {
    author?: Maybe<ResolversParentTypes["Actor"]>;
    discussion?: Maybe<ResolversParentTypes["Discussion"]>;
    editor?: Maybe<ResolversParentTypes["Actor"]>;
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    reactions: ResolversParentTypes["ReactionConnection"];
    replies: ResolversParentTypes["DiscussionCommentConnection"];
    replyTo?: Maybe<ResolversParentTypes["DiscussionComment"]>;
    userContentEdits?: Maybe<ResolversParentTypes["UserContentEditConnection"]>;
  };
  DiscussionCommentConnection: Omit<
    DiscussionCommentConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["DiscussionCommentEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["DiscussionComment"]>>>;
  };
  DiscussionCommentEdge: Omit<DiscussionCommentEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["DiscussionComment"]>;
  };
  DiscussionConnection: Omit<DiscussionConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["DiscussionEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Discussion"]>>>;
  };
  DiscussionEdge: Omit<DiscussionEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Discussion"]>;
  };
  DiscussionOrder: DiscussionOrder;
  DiscussionPoll: Omit<DiscussionPoll, "discussion" | "options"> & {
    discussion?: Maybe<ResolversParentTypes["Discussion"]>;
    options?: Maybe<ResolversParentTypes["DiscussionPollOptionConnection"]>;
  };
  DiscussionPollOption: Omit<DiscussionPollOption, "poll"> & {
    poll?: Maybe<ResolversParentTypes["DiscussionPoll"]>;
  };
  DiscussionPollOptionConnection: Omit<
    DiscussionPollOptionConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["DiscussionPollOptionEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["DiscussionPollOption"]>>>;
  };
  DiscussionPollOptionEdge: Omit<DiscussionPollOptionEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["DiscussionPollOption"]>;
  };
  DiscussionPollOptionOrder: DiscussionPollOptionOrder;
  DismissPullRequestReviewInput: DismissPullRequestReviewInput;
  DismissPullRequestReviewPayload: Omit<
    DismissPullRequestReviewPayload,
    "pullRequestReview"
  > & { pullRequestReview?: Maybe<ResolversParentTypes["PullRequestReview"]> };
  DismissRepositoryVulnerabilityAlertInput: DismissRepositoryVulnerabilityAlertInput;
  DismissRepositoryVulnerabilityAlertPayload: Omit<
    DismissRepositoryVulnerabilityAlertPayload,
    "repositoryVulnerabilityAlert"
  > & {
    repositoryVulnerabilityAlert?: Maybe<
      ResolversParentTypes["RepositoryVulnerabilityAlert"]
    >;
  };
  DraftIssue: Omit<DraftIssue, "creator" | "projectV2Items" | "projectsV2"> & {
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    projectV2Items: ResolversParentTypes["ProjectV2ItemConnection"];
    projectsV2: ResolversParentTypes["ProjectV2Connection"];
  };
  DraftPullRequestReviewComment: DraftPullRequestReviewComment;
  DraftPullRequestReviewThread: DraftPullRequestReviewThread;
  EnablePullRequestAutoMergeInput: EnablePullRequestAutoMergeInput;
  EnablePullRequestAutoMergePayload: Omit<
    EnablePullRequestAutoMergePayload,
    "actor" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  EnqueuePullRequestInput: EnqueuePullRequestInput;
  EnqueuePullRequestPayload: Omit<
    EnqueuePullRequestPayload,
    "mergeQueueEntry"
  > & { mergeQueueEntry?: Maybe<ResolversParentTypes["MergeQueueEntry"]> };
  Enterprise: Omit<
    Enterprise,
    "billingInfo" | "members" | "organizations" | "ownerInfo"
  > & {
    billingInfo?: Maybe<ResolversParentTypes["EnterpriseBillingInfo"]>;
    members: ResolversParentTypes["EnterpriseMemberConnection"];
    organizations: ResolversParentTypes["OrganizationConnection"];
    ownerInfo?: Maybe<ResolversParentTypes["EnterpriseOwnerInfo"]>;
  };
  EnterpriseAdministratorConnection: Omit<
    EnterpriseAdministratorConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["EnterpriseAdministratorEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["User"]>>>;
  };
  EnterpriseAdministratorEdge: Omit<EnterpriseAdministratorEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["User"]>;
  };
  EnterpriseAdministratorInvitation: Omit<
    EnterpriseAdministratorInvitation,
    "enterprise" | "invitee" | "inviter"
  > & {
    enterprise: ResolversParentTypes["Enterprise"];
    invitee?: Maybe<ResolversParentTypes["User"]>;
    inviter?: Maybe<ResolversParentTypes["User"]>;
  };
  EnterpriseAdministratorInvitationConnection: Omit<
    EnterpriseAdministratorInvitationConnection,
    "nodes"
  > & {
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["EnterpriseAdministratorInvitation"]>>
    >;
  };
  EnterpriseAdministratorInvitationEdge: Omit<
    EnterpriseAdministratorInvitationEdge,
    "node"
  > & {
    node?: Maybe<ResolversParentTypes["EnterpriseAdministratorInvitation"]>;
  };
  EnterpriseAdministratorInvitationOrder: EnterpriseAdministratorInvitationOrder;
  EnterpriseAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>["EnterpriseAuditEntryData"];
  EnterpriseBillingInfo: EnterpriseBillingInfo;
  EnterpriseConnection: Omit<EnterpriseConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["EnterpriseEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Enterprise"]>>>;
  };
  EnterpriseEdge: Omit<EnterpriseEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Enterprise"]>;
  };
  EnterpriseFailedInvitationConnection: Omit<
    EnterpriseFailedInvitationConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["EnterpriseFailedInvitationEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["OrganizationInvitation"]>>>;
  };
  EnterpriseFailedInvitationEdge: Omit<
    EnterpriseFailedInvitationEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["OrganizationInvitation"]> };
  EnterpriseIdentityProvider: Omit<
    EnterpriseIdentityProvider,
    "enterprise" | "externalIdentities"
  > & {
    enterprise?: Maybe<ResolversParentTypes["Enterprise"]>;
    externalIdentities: ResolversParentTypes["ExternalIdentityConnection"];
  };
  EnterpriseMember: ResolversUnionTypes<ResolversParentTypes>["EnterpriseMember"];
  EnterpriseMemberConnection: Omit<
    EnterpriseMemberConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["EnterpriseMemberEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["EnterpriseMember"]>>>;
  };
  EnterpriseMemberEdge: Omit<EnterpriseMemberEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["EnterpriseMember"]>;
  };
  EnterpriseMemberInvitation: Omit<
    EnterpriseMemberInvitation,
    "enterprise" | "invitee" | "inviter"
  > & {
    enterprise: ResolversParentTypes["Enterprise"];
    invitee?: Maybe<ResolversParentTypes["User"]>;
    inviter?: Maybe<ResolversParentTypes["User"]>;
  };
  EnterpriseMemberInvitationConnection: Omit<
    EnterpriseMemberInvitationConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["EnterpriseMemberInvitationEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["EnterpriseMemberInvitation"]>>
    >;
  };
  EnterpriseMemberInvitationEdge: Omit<
    EnterpriseMemberInvitationEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["EnterpriseMemberInvitation"]> };
  EnterpriseMemberInvitationOrder: EnterpriseMemberInvitationOrder;
  EnterpriseMemberOrder: EnterpriseMemberOrder;
  EnterpriseOrder: EnterpriseOrder;
  EnterpriseOrganizationMembershipConnection: Omit<
    EnterpriseOrganizationMembershipConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["EnterpriseOrganizationMembershipEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Organization"]>>>;
  };
  EnterpriseOrganizationMembershipEdge: Omit<
    EnterpriseOrganizationMembershipEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["Organization"]> };
  EnterpriseOutsideCollaboratorConnection: Omit<
    EnterpriseOutsideCollaboratorConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["EnterpriseOutsideCollaboratorEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["User"]>>>;
  };
  EnterpriseOutsideCollaboratorEdge: Omit<
    EnterpriseOutsideCollaboratorEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["User"]> };
  EnterpriseOwnerInfo: Omit<
    EnterpriseOwnerInfo,
    | "admins"
    | "allowPrivateRepositoryForkingSettingOrganizations"
    | "defaultRepositoryPermissionSettingOrganizations"
    | "domains"
    | "enterpriseServerInstallations"
    | "failedInvitations"
    | "ipAllowListEntries"
    | "membersCanChangeRepositoryVisibilitySettingOrganizations"
    | "membersCanCreateRepositoriesSettingOrganizations"
    | "membersCanDeleteIssuesSettingOrganizations"
    | "membersCanDeleteRepositoriesSettingOrganizations"
    | "membersCanInviteCollaboratorsSettingOrganizations"
    | "membersCanUpdateProtectedBranchesSettingOrganizations"
    | "membersCanViewDependencyInsightsSettingOrganizations"
    | "oidcProvider"
    | "organizationProjectsSettingOrganizations"
    | "outsideCollaborators"
    | "pendingCollaboratorInvitations"
    | "pendingMemberInvitations"
    | "pendingUnaffiliatedMemberInvitations"
    | "repositoryProjectsSettingOrganizations"
    | "samlIdentityProvider"
    | "samlIdentityProviderSettingOrganizations"
    | "supportEntitlements"
    | "teamDiscussionsSettingOrganizations"
    | "twoFactorRequiredSettingOrganizations"
  > & {
    admins: ResolversParentTypes["EnterpriseAdministratorConnection"];
    allowPrivateRepositoryForkingSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    defaultRepositoryPermissionSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    domains: ResolversParentTypes["VerifiableDomainConnection"];
    enterpriseServerInstallations: ResolversParentTypes["EnterpriseServerInstallationConnection"];
    failedInvitations: ResolversParentTypes["EnterpriseFailedInvitationConnection"];
    ipAllowListEntries: ResolversParentTypes["IpAllowListEntryConnection"];
    membersCanChangeRepositoryVisibilitySettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    membersCanCreateRepositoriesSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    membersCanDeleteIssuesSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    membersCanDeleteRepositoriesSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    membersCanInviteCollaboratorsSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    membersCanUpdateProtectedBranchesSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    membersCanViewDependencyInsightsSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    oidcProvider?: Maybe<ResolversParentTypes["OIDCProvider"]>;
    organizationProjectsSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    outsideCollaborators: ResolversParentTypes["EnterpriseOutsideCollaboratorConnection"];
    pendingCollaboratorInvitations: ResolversParentTypes["RepositoryInvitationConnection"];
    pendingMemberInvitations: ResolversParentTypes["EnterprisePendingMemberInvitationConnection"];
    pendingUnaffiliatedMemberInvitations: ResolversParentTypes["EnterpriseMemberInvitationConnection"];
    repositoryProjectsSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    samlIdentityProvider?: Maybe<
      ResolversParentTypes["EnterpriseIdentityProvider"]
    >;
    samlIdentityProviderSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    supportEntitlements: ResolversParentTypes["EnterpriseMemberConnection"];
    teamDiscussionsSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
    twoFactorRequiredSettingOrganizations: ResolversParentTypes["OrganizationConnection"];
  };
  EnterprisePendingMemberInvitationConnection: Omit<
    EnterprisePendingMemberInvitationConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<
        Maybe<ResolversParentTypes["EnterprisePendingMemberInvitationEdge"]>
      >
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["OrganizationInvitation"]>>>;
  };
  EnterprisePendingMemberInvitationEdge: Omit<
    EnterprisePendingMemberInvitationEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["OrganizationInvitation"]> };
  EnterpriseRepositoryInfo: EnterpriseRepositoryInfo;
  EnterpriseRepositoryInfoConnection: EnterpriseRepositoryInfoConnection;
  EnterpriseRepositoryInfoEdge: EnterpriseRepositoryInfoEdge;
  EnterpriseServerInstallation: Omit<
    EnterpriseServerInstallation,
    "userAccountsUploads"
  > & {
    userAccountsUploads: ResolversParentTypes["EnterpriseServerUserAccountsUploadConnection"];
  };
  EnterpriseServerInstallationConnection: Omit<
    EnterpriseServerInstallationConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["EnterpriseServerInstallationEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["EnterpriseServerInstallation"]>>
    >;
  };
  EnterpriseServerInstallationEdge: Omit<
    EnterpriseServerInstallationEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["EnterpriseServerInstallation"]> };
  EnterpriseServerInstallationMembershipConnection: Omit<
    EnterpriseServerInstallationMembershipConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<
        Maybe<
          ResolversParentTypes["EnterpriseServerInstallationMembershipEdge"]
        >
      >
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["EnterpriseServerInstallation"]>>
    >;
  };
  EnterpriseServerInstallationMembershipEdge: Omit<
    EnterpriseServerInstallationMembershipEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["EnterpriseServerInstallation"]> };
  EnterpriseServerInstallationOrder: EnterpriseServerInstallationOrder;
  EnterpriseServerUserAccount: Omit<
    EnterpriseServerUserAccount,
    "enterpriseServerInstallation"
  > & {
    enterpriseServerInstallation: ResolversParentTypes["EnterpriseServerInstallation"];
  };
  EnterpriseServerUserAccountConnection: EnterpriseServerUserAccountConnection;
  EnterpriseServerUserAccountEdge: EnterpriseServerUserAccountEdge;
  EnterpriseServerUserAccountEmail: EnterpriseServerUserAccountEmail;
  EnterpriseServerUserAccountEmailConnection: EnterpriseServerUserAccountEmailConnection;
  EnterpriseServerUserAccountEmailEdge: EnterpriseServerUserAccountEmailEdge;
  EnterpriseServerUserAccountEmailOrder: EnterpriseServerUserAccountEmailOrder;
  EnterpriseServerUserAccountOrder: EnterpriseServerUserAccountOrder;
  EnterpriseServerUserAccountsUpload: Omit<
    EnterpriseServerUserAccountsUpload,
    "enterprise" | "enterpriseServerInstallation"
  > & {
    enterprise: ResolversParentTypes["Enterprise"];
    enterpriseServerInstallation: ResolversParentTypes["EnterpriseServerInstallation"];
  };
  EnterpriseServerUserAccountsUploadConnection: Omit<
    EnterpriseServerUserAccountsUploadConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<
        Maybe<ResolversParentTypes["EnterpriseServerUserAccountsUploadEdge"]>
      >
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["EnterpriseServerUserAccountsUpload"]>>
    >;
  };
  EnterpriseServerUserAccountsUploadEdge: Omit<
    EnterpriseServerUserAccountsUploadEdge,
    "node"
  > & {
    node?: Maybe<ResolversParentTypes["EnterpriseServerUserAccountsUpload"]>;
  };
  EnterpriseServerUserAccountsUploadOrder: EnterpriseServerUserAccountsUploadOrder;
  EnterpriseUserAccount: Omit<
    EnterpriseUserAccount,
    "enterprise" | "enterpriseInstallations" | "organizations" | "user"
  > & {
    enterprise: ResolversParentTypes["Enterprise"];
    enterpriseInstallations: ResolversParentTypes["EnterpriseServerInstallationMembershipConnection"];
    organizations: ResolversParentTypes["EnterpriseOrganizationMembershipConnection"];
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  Environment: Omit<
    Environment,
    "latestCompletedDeployment" | "protectionRules"
  > & {
    latestCompletedDeployment?: Maybe<ResolversParentTypes["Deployment"]>;
    protectionRules: ResolversParentTypes["DeploymentProtectionRuleConnection"];
  };
  EnvironmentConnection: Omit<EnvironmentConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["EnvironmentEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Environment"]>>>;
  };
  EnvironmentEdge: Omit<EnvironmentEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Environment"]>;
  };
  Environments: Environments;
  ExternalIdentity: Omit<
    ExternalIdentity,
    "organizationInvitation" | "user"
  > & {
    organizationInvitation?: Maybe<
      ResolversParentTypes["OrganizationInvitation"]
    >;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  ExternalIdentityAttribute: ExternalIdentityAttribute;
  ExternalIdentityConnection: Omit<
    ExternalIdentityConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ExternalIdentityEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ExternalIdentity"]>>>;
  };
  ExternalIdentityEdge: Omit<ExternalIdentityEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ExternalIdentity"]>;
  };
  ExternalIdentitySamlAttributes: ExternalIdentitySamlAttributes;
  ExternalIdentityScimAttributes: ExternalIdentityScimAttributes;
  FileAddition: FileAddition;
  FileChanges: FileChanges;
  FileDeletion: FileDeletion;
  FileExtensionRestrictionParameters: FileExtensionRestrictionParameters;
  FileExtensionRestrictionParametersInput: FileExtensionRestrictionParametersInput;
  FilePathRestrictionParameters: FilePathRestrictionParameters;
  FilePathRestrictionParametersInput: FilePathRestrictionParametersInput;
  Float: Scalars["Float"]["output"];
  FollowOrganizationInput: FollowOrganizationInput;
  FollowOrganizationPayload: Omit<FollowOrganizationPayload, "organization"> & {
    organization?: Maybe<ResolversParentTypes["Organization"]>;
  };
  FollowUserInput: FollowUserInput;
  FollowUserPayload: Omit<FollowUserPayload, "user"> & {
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  FollowerConnection: Omit<FollowerConnection, "nodes"> & {
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["User"]>>>;
  };
  FollowingConnection: Omit<FollowingConnection, "nodes"> & {
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["User"]>>>;
  };
  FundingLink: FundingLink;
  GenericHovercardContext: GenericHovercardContext;
  Gist: Omit<Gist, "comments" | "forks" | "owner"> & {
    comments: ResolversParentTypes["GistCommentConnection"];
    forks: ResolversParentTypes["GistConnection"];
    owner?: Maybe<ResolversParentTypes["RepositoryOwner"]>;
  };
  GistComment: Omit<
    GistComment,
    "author" | "editor" | "gist" | "userContentEdits"
  > & {
    author?: Maybe<ResolversParentTypes["Actor"]>;
    editor?: Maybe<ResolversParentTypes["Actor"]>;
    gist: ResolversParentTypes["Gist"];
    userContentEdits?: Maybe<ResolversParentTypes["UserContentEditConnection"]>;
  };
  GistCommentConnection: Omit<GistCommentConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["GistCommentEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["GistComment"]>>>;
  };
  GistCommentEdge: Omit<GistCommentEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["GistComment"]>;
  };
  GistConnection: Omit<GistConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["GistEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Gist"]>>>;
  };
  GistEdge: Omit<GistEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Gist"]>;
  };
  GistFile: GistFile;
  GistOrder: GistOrder;
  GitActor: Omit<GitActor, "user"> & {
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  GitActorConnection: GitActorConnection;
  GitActorEdge: GitActorEdge;
  GitHubMetadata: GitHubMetadata;
  GitObject: ResolversInterfaceTypes<ResolversParentTypes>["GitObject"];
  GitObjectID: Scalars["GitObjectID"]["output"];
  GitRefname: Scalars["GitRefname"]["output"];
  GitSSHRemote: Scalars["GitSSHRemote"]["output"];
  GitSignature: ResolversInterfaceTypes<ResolversParentTypes>["GitSignature"];
  GitTimestamp: Scalars["GitTimestamp"]["output"];
  GpgSignature: Omit<GpgSignature, "signer"> & {
    signer?: Maybe<ResolversParentTypes["User"]>;
  };
  GrantEnterpriseOrganizationsMigratorRoleInput: GrantEnterpriseOrganizationsMigratorRoleInput;
  GrantEnterpriseOrganizationsMigratorRolePayload: Omit<
    GrantEnterpriseOrganizationsMigratorRolePayload,
    "organizations"
  > & { organizations?: Maybe<ResolversParentTypes["OrganizationConnection"]> };
  GrantMigratorRoleInput: GrantMigratorRoleInput;
  GrantMigratorRolePayload: GrantMigratorRolePayload;
  HTML: Scalars["HTML"]["output"];
  HeadRefDeletedEvent: Omit<
    HeadRefDeletedEvent,
    "actor" | "headRef" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    headRef?: Maybe<ResolversParentTypes["Ref"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
  };
  HeadRefForcePushedEvent: Omit<
    HeadRefForcePushedEvent,
    "actor" | "afterCommit" | "beforeCommit" | "pullRequest" | "ref"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    afterCommit?: Maybe<ResolversParentTypes["Commit"]>;
    beforeCommit?: Maybe<ResolversParentTypes["Commit"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
    ref?: Maybe<ResolversParentTypes["Ref"]>;
  };
  HeadRefRestoredEvent: Omit<HeadRefRestoredEvent, "actor" | "pullRequest"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
  };
  Hovercard: Omit<Hovercard, "contexts"> & {
    contexts: Array<ResolversParentTypes["HovercardContext"]>;
  };
  HovercardContext: ResolversInterfaceTypes<ResolversParentTypes>["HovercardContext"];
  ID: Scalars["ID"]["output"];
  ImportProjectInput: ImportProjectInput;
  ImportProjectPayload: Omit<ImportProjectPayload, "project"> & {
    project?: Maybe<ResolversParentTypes["Project"]>;
  };
  Int: Scalars["Int"]["output"];
  InviteEnterpriseAdminInput: InviteEnterpriseAdminInput;
  InviteEnterpriseAdminPayload: Omit<
    InviteEnterpriseAdminPayload,
    "invitation"
  > & {
    invitation?: Maybe<
      ResolversParentTypes["EnterpriseAdministratorInvitation"]
    >;
  };
  InviteEnterpriseMemberInput: InviteEnterpriseMemberInput;
  InviteEnterpriseMemberPayload: Omit<
    InviteEnterpriseMemberPayload,
    "invitation"
  > & {
    invitation?: Maybe<ResolversParentTypes["EnterpriseMemberInvitation"]>;
  };
  IpAllowListEntry: Omit<IpAllowListEntry, "owner"> & {
    owner: ResolversParentTypes["IpAllowListOwner"];
  };
  IpAllowListEntryConnection: Omit<
    IpAllowListEntryConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["IpAllowListEntryEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["IpAllowListEntry"]>>>;
  };
  IpAllowListEntryEdge: Omit<IpAllowListEntryEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["IpAllowListEntry"]>;
  };
  IpAllowListEntryOrder: IpAllowListEntryOrder;
  IpAllowListOwner: ResolversUnionTypes<ResolversParentTypes>["IpAllowListOwner"];
  Issue: Omit<
    Issue,
    | "author"
    | "closedByPullRequestsReferences"
    | "comments"
    | "editor"
    | "hovercard"
    | "labels"
    | "milestone"
    | "projectCards"
    | "projectItems"
    | "projectV2"
    | "projectsV2"
    | "reactionGroups"
    | "reactions"
    | "repository"
    | "timeline"
    | "timelineItems"
    | "trackedInIssues"
    | "trackedIssues"
    | "userContentEdits"
  > & {
    author?: Maybe<ResolversParentTypes["Actor"]>;
    closedByPullRequestsReferences?: Maybe<
      ResolversParentTypes["PullRequestConnection"]
    >;
    comments: ResolversParentTypes["IssueCommentConnection"];
    editor?: Maybe<ResolversParentTypes["Actor"]>;
    hovercard: ResolversParentTypes["Hovercard"];
    labels?: Maybe<ResolversParentTypes["LabelConnection"]>;
    milestone?: Maybe<ResolversParentTypes["Milestone"]>;
    projectCards: ResolversParentTypes["ProjectCardConnection"];
    projectItems: ResolversParentTypes["ProjectV2ItemConnection"];
    projectV2?: Maybe<ResolversParentTypes["ProjectV2"]>;
    projectsV2: ResolversParentTypes["ProjectV2Connection"];
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    reactions: ResolversParentTypes["ReactionConnection"];
    repository: ResolversParentTypes["Repository"];
    timeline: ResolversParentTypes["IssueTimelineConnection"];
    timelineItems: ResolversParentTypes["IssueTimelineItemsConnection"];
    trackedInIssues: ResolversParentTypes["IssueConnection"];
    trackedIssues: ResolversParentTypes["IssueConnection"];
    userContentEdits?: Maybe<ResolversParentTypes["UserContentEditConnection"]>;
  };
  IssueComment: Omit<
    IssueComment,
    | "author"
    | "editor"
    | "issue"
    | "pullRequest"
    | "reactionGroups"
    | "reactions"
    | "repository"
    | "userContentEdits"
  > & {
    author?: Maybe<ResolversParentTypes["Actor"]>;
    editor?: Maybe<ResolversParentTypes["Actor"]>;
    issue: ResolversParentTypes["Issue"];
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    reactions: ResolversParentTypes["ReactionConnection"];
    repository: ResolversParentTypes["Repository"];
    userContentEdits?: Maybe<ResolversParentTypes["UserContentEditConnection"]>;
  };
  IssueCommentConnection: Omit<IssueCommentConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["IssueCommentEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["IssueComment"]>>>;
  };
  IssueCommentEdge: Omit<IssueCommentEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["IssueComment"]>;
  };
  IssueCommentOrder: IssueCommentOrder;
  IssueConnection: Omit<IssueConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["IssueEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Issue"]>>>;
  };
  IssueContributionsByRepository: Omit<
    IssueContributionsByRepository,
    "contributions" | "repository"
  > & {
    contributions: ResolversParentTypes["CreatedIssueContributionConnection"];
    repository: ResolversParentTypes["Repository"];
  };
  IssueEdge: Omit<IssueEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Issue"]>;
  };
  IssueFilters: IssueFilters;
  IssueOrPullRequest: ResolversUnionTypes<ResolversParentTypes>["IssueOrPullRequest"];
  IssueOrder: IssueOrder;
  IssueTemplate: Omit<IssueTemplate, "labels"> & {
    labels?: Maybe<ResolversParentTypes["LabelConnection"]>;
  };
  IssueTimelineConnection: Omit<IssueTimelineConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["IssueTimelineItemEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["IssueTimelineItem"]>>>;
  };
  IssueTimelineItem: ResolversUnionTypes<ResolversParentTypes>["IssueTimelineItem"];
  IssueTimelineItemEdge: Omit<IssueTimelineItemEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["IssueTimelineItem"]>;
  };
  IssueTimelineItems: ResolversUnionTypes<ResolversParentTypes>["IssueTimelineItems"];
  IssueTimelineItemsConnection: Omit<
    IssueTimelineItemsConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["IssueTimelineItemsEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["IssueTimelineItems"]>>>;
  };
  IssueTimelineItemsEdge: Omit<IssueTimelineItemsEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["IssueTimelineItems"]>;
  };
  JoinedGitHubContribution: Omit<JoinedGitHubContribution, "user"> & {
    user: ResolversParentTypes["User"];
  };
  Label: Omit<Label, "issues" | "pullRequests" | "repository"> & {
    issues: ResolversParentTypes["IssueConnection"];
    pullRequests: ResolversParentTypes["PullRequestConnection"];
    repository: ResolversParentTypes["Repository"];
  };
  LabelConnection: Omit<LabelConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["LabelEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Label"]>>>;
  };
  LabelEdge: Omit<LabelEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Label"]>;
  };
  LabelOrder: LabelOrder;
  Labelable: ResolversInterfaceTypes<ResolversParentTypes>["Labelable"];
  LabeledEvent: Omit<LabeledEvent, "actor" | "label" | "labelable"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    label: ResolversParentTypes["Label"];
    labelable: ResolversParentTypes["Labelable"];
  };
  Language: Language;
  LanguageConnection: LanguageConnection;
  LanguageEdge: LanguageEdge;
  LanguageOrder: LanguageOrder;
  License: License;
  LicenseRule: LicenseRule;
  LinkProjectV2ToRepositoryInput: LinkProjectV2ToRepositoryInput;
  LinkProjectV2ToRepositoryPayload: Omit<
    LinkProjectV2ToRepositoryPayload,
    "repository"
  > & { repository?: Maybe<ResolversParentTypes["Repository"]> };
  LinkProjectV2ToTeamInput: LinkProjectV2ToTeamInput;
  LinkProjectV2ToTeamPayload: Omit<LinkProjectV2ToTeamPayload, "team"> & {
    team?: Maybe<ResolversParentTypes["Team"]>;
  };
  LinkRepositoryToProjectInput: LinkRepositoryToProjectInput;
  LinkRepositoryToProjectPayload: Omit<
    LinkRepositoryToProjectPayload,
    "project" | "repository"
  > & {
    project?: Maybe<ResolversParentTypes["Project"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
  };
  LinkedBranch: Omit<LinkedBranch, "ref"> & {
    ref?: Maybe<ResolversParentTypes["Ref"]>;
  };
  LinkedBranchConnection: LinkedBranchConnection;
  LinkedBranchEdge: LinkedBranchEdge;
  LockLockableInput: LockLockableInput;
  LockLockablePayload: Omit<LockLockablePayload, "actor" | "lockedRecord"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    lockedRecord?: Maybe<ResolversParentTypes["Lockable"]>;
  };
  Lockable: ResolversInterfaceTypes<ResolversParentTypes>["Lockable"];
  LockedEvent: Omit<LockedEvent, "actor" | "lockable"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    lockable: ResolversParentTypes["Lockable"];
  };
  Mannequin: Omit<Mannequin, "claimant"> & {
    claimant?: Maybe<ResolversParentTypes["User"]>;
  };
  MannequinConnection: Omit<MannequinConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["MannequinEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Mannequin"]>>>;
  };
  MannequinEdge: Omit<MannequinEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Mannequin"]>;
  };
  MannequinOrder: MannequinOrder;
  MarkDiscussionCommentAsAnswerInput: MarkDiscussionCommentAsAnswerInput;
  MarkDiscussionCommentAsAnswerPayload: Omit<
    MarkDiscussionCommentAsAnswerPayload,
    "discussion"
  > & { discussion?: Maybe<ResolversParentTypes["Discussion"]> };
  MarkFileAsViewedInput: MarkFileAsViewedInput;
  MarkFileAsViewedPayload: Omit<MarkFileAsViewedPayload, "pullRequest"> & {
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  MarkNotificationAsDoneInput: MarkNotificationAsDoneInput;
  MarkNotificationAsDonePayload: Omit<
    MarkNotificationAsDonePayload,
    "viewer"
  > & { viewer?: Maybe<ResolversParentTypes["User"]> };
  MarkProjectV2AsTemplateInput: MarkProjectV2AsTemplateInput;
  MarkProjectV2AsTemplatePayload: Omit<
    MarkProjectV2AsTemplatePayload,
    "projectV2"
  > & { projectV2?: Maybe<ResolversParentTypes["ProjectV2"]> };
  MarkPullRequestReadyForReviewInput: MarkPullRequestReadyForReviewInput;
  MarkPullRequestReadyForReviewPayload: Omit<
    MarkPullRequestReadyForReviewPayload,
    "pullRequest"
  > & { pullRequest?: Maybe<ResolversParentTypes["PullRequest"]> };
  MarkedAsDuplicateEvent: Omit<
    MarkedAsDuplicateEvent,
    "actor" | "canonical" | "duplicate"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    canonical?: Maybe<ResolversParentTypes["IssueOrPullRequest"]>;
    duplicate?: Maybe<ResolversParentTypes["IssueOrPullRequest"]>;
  };
  MarketplaceCategory: MarketplaceCategory;
  MarketplaceListing: Omit<MarketplaceListing, "app"> & {
    app?: Maybe<ResolversParentTypes["App"]>;
  };
  MarketplaceListingConnection: Omit<
    MarketplaceListingConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["MarketplaceListingEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["MarketplaceListing"]>>>;
  };
  MarketplaceListingEdge: Omit<MarketplaceListingEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["MarketplaceListing"]>;
  };
  MaxFilePathLengthParameters: MaxFilePathLengthParameters;
  MaxFilePathLengthParametersInput: MaxFilePathLengthParametersInput;
  MaxFileSizeParameters: MaxFileSizeParameters;
  MaxFileSizeParametersInput: MaxFileSizeParametersInput;
  MemberFeatureRequestNotification: MemberFeatureRequestNotification;
  MemberStatusable: ResolversInterfaceTypes<ResolversParentTypes>["MemberStatusable"];
  MembersCanDeleteReposClearAuditEntry: Omit<
    MembersCanDeleteReposClearAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  MembersCanDeleteReposDisableAuditEntry: Omit<
    MembersCanDeleteReposDisableAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  MembersCanDeleteReposEnableAuditEntry: Omit<
    MembersCanDeleteReposEnableAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  MentionedEvent: Omit<MentionedEvent, "actor"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
  };
  MergeBranchInput: MergeBranchInput;
  MergeBranchPayload: Omit<MergeBranchPayload, "mergeCommit"> & {
    mergeCommit?: Maybe<ResolversParentTypes["Commit"]>;
  };
  MergePullRequestInput: MergePullRequestInput;
  MergePullRequestPayload: Omit<
    MergePullRequestPayload,
    "actor" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  MergeQueue: Omit<MergeQueue, "configuration" | "entries" | "repository"> & {
    configuration?: Maybe<ResolversParentTypes["MergeQueueConfiguration"]>;
    entries?: Maybe<ResolversParentTypes["MergeQueueEntryConnection"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
  };
  MergeQueueConfiguration: MergeQueueConfiguration;
  MergeQueueEntry: Omit<
    MergeQueueEntry,
    "baseCommit" | "enqueuer" | "headCommit" | "mergeQueue" | "pullRequest"
  > & {
    baseCommit?: Maybe<ResolversParentTypes["Commit"]>;
    enqueuer: ResolversParentTypes["Actor"];
    headCommit?: Maybe<ResolversParentTypes["Commit"]>;
    mergeQueue?: Maybe<ResolversParentTypes["MergeQueue"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  MergeQueueEntryConnection: Omit<
    MergeQueueEntryConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["MergeQueueEntryEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["MergeQueueEntry"]>>>;
  };
  MergeQueueEntryEdge: Omit<MergeQueueEntryEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["MergeQueueEntry"]>;
  };
  MergeQueueParameters: MergeQueueParameters;
  MergeQueueParametersInput: MergeQueueParametersInput;
  MergedEvent: Omit<
    MergedEvent,
    "actor" | "commit" | "mergeRef" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    commit?: Maybe<ResolversParentTypes["Commit"]>;
    mergeRef?: Maybe<ResolversParentTypes["Ref"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
  };
  Migration: ResolversInterfaceTypes<ResolversParentTypes>["Migration"];
  MigrationSource: MigrationSource;
  Milestone: Omit<
    Milestone,
    "creator" | "issues" | "pullRequests" | "repository"
  > & {
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    issues: ResolversParentTypes["IssueConnection"];
    pullRequests: ResolversParentTypes["PullRequestConnection"];
    repository: ResolversParentTypes["Repository"];
  };
  MilestoneConnection: Omit<MilestoneConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["MilestoneEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Milestone"]>>>;
  };
  MilestoneEdge: Omit<MilestoneEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Milestone"]>;
  };
  MilestoneItem: ResolversUnionTypes<ResolversParentTypes>["MilestoneItem"];
  MilestoneOrder: MilestoneOrder;
  MilestonedEvent: Omit<MilestonedEvent, "actor" | "subject"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    subject: ResolversParentTypes["MilestoneItem"];
  };
  Minimizable: ResolversInterfaceTypes<ResolversParentTypes>["Minimizable"];
  MinimizeCommentInput: MinimizeCommentInput;
  MinimizeCommentPayload: Omit<MinimizeCommentPayload, "minimizedComment"> & {
    minimizedComment?: Maybe<ResolversParentTypes["Minimizable"]>;
  };
  MoveProjectCardInput: MoveProjectCardInput;
  MoveProjectCardPayload: Omit<MoveProjectCardPayload, "cardEdge"> & {
    cardEdge?: Maybe<ResolversParentTypes["ProjectCardEdge"]>;
  };
  MoveProjectColumnInput: MoveProjectColumnInput;
  MoveProjectColumnPayload: MoveProjectColumnPayload;
  MovedColumnsInProjectEvent: Omit<
    MovedColumnsInProjectEvent,
    "actor" | "project" | "projectCard"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    project?: Maybe<ResolversParentTypes["Project"]>;
    projectCard?: Maybe<ResolversParentTypes["ProjectCard"]>;
  };
  Mutation: {};
  Node: ResolversInterfaceTypes<ResolversParentTypes>["Node"];
  OIDCProvider: Omit<OidcProvider, "enterprise" | "externalIdentities"> & {
    enterprise?: Maybe<ResolversParentTypes["Enterprise"]>;
    externalIdentities: ResolversParentTypes["ExternalIdentityConnection"];
  };
  OauthApplicationAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>["OauthApplicationAuditEntryData"];
  OauthApplicationCreateAuditEntry: Omit<
    OauthApplicationCreateAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgAddBillingManagerAuditEntry: Omit<
    OrgAddBillingManagerAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgAddMemberAuditEntry: Omit<
    OrgAddMemberAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgBlockUserAuditEntry: Omit<
    OrgBlockUserAuditEntry,
    "actor" | "blockedUser" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    blockedUser?: Maybe<ResolversParentTypes["User"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgConfigDisableCollaboratorsOnlyAuditEntry: Omit<
    OrgConfigDisableCollaboratorsOnlyAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgConfigEnableCollaboratorsOnlyAuditEntry: Omit<
    OrgConfigEnableCollaboratorsOnlyAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgCreateAuditEntry: Omit<
    OrgCreateAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgDisableOauthAppRestrictionsAuditEntry: Omit<
    OrgDisableOauthAppRestrictionsAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgDisableSamlAuditEntry: Omit<
    OrgDisableSamlAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgDisableTwoFactorRequirementAuditEntry: Omit<
    OrgDisableTwoFactorRequirementAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgEnableOauthAppRestrictionsAuditEntry: Omit<
    OrgEnableOauthAppRestrictionsAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgEnableSamlAuditEntry: Omit<
    OrgEnableSamlAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgEnableTwoFactorRequirementAuditEntry: Omit<
    OrgEnableTwoFactorRequirementAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgEnterpriseOwnerOrder: OrgEnterpriseOwnerOrder;
  OrgInviteMemberAuditEntry: Omit<
    OrgInviteMemberAuditEntry,
    "actor" | "organization" | "organizationInvitation" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    organizationInvitation?: Maybe<
      ResolversParentTypes["OrganizationInvitation"]
    >;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgInviteToBusinessAuditEntry: Omit<
    OrgInviteToBusinessAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgOauthAppAccessApprovedAuditEntry: Omit<
    OrgOauthAppAccessApprovedAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgOauthAppAccessBlockedAuditEntry: Omit<
    OrgOauthAppAccessBlockedAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgOauthAppAccessDeniedAuditEntry: Omit<
    OrgOauthAppAccessDeniedAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgOauthAppAccessRequestedAuditEntry: Omit<
    OrgOauthAppAccessRequestedAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgOauthAppAccessUnblockedAuditEntry: Omit<
    OrgOauthAppAccessUnblockedAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgRemoveBillingManagerAuditEntry: Omit<
    OrgRemoveBillingManagerAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgRemoveMemberAuditEntry: Omit<
    OrgRemoveMemberAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgRemoveOutsideCollaboratorAuditEntry: Omit<
    OrgRemoveOutsideCollaboratorAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgRestoreMemberAuditEntry: Omit<
    OrgRestoreMemberAuditEntry,
    "actor" | "organization" | "restoredMemberships" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    restoredMemberships?: Maybe<
      Array<ResolversParentTypes["OrgRestoreMemberAuditEntryMembership"]>
    >;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgRestoreMemberAuditEntryMembership: ResolversUnionTypes<ResolversParentTypes>["OrgRestoreMemberAuditEntryMembership"];
  OrgRestoreMemberMembershipOrganizationAuditEntryData: Omit<
    OrgRestoreMemberMembershipOrganizationAuditEntryData,
    "organization"
  > & { organization?: Maybe<ResolversParentTypes["Organization"]> };
  OrgRestoreMemberMembershipRepositoryAuditEntryData: Omit<
    OrgRestoreMemberMembershipRepositoryAuditEntryData,
    "repository"
  > & { repository?: Maybe<ResolversParentTypes["Repository"]> };
  OrgRestoreMemberMembershipTeamAuditEntryData: Omit<
    OrgRestoreMemberMembershipTeamAuditEntryData,
    "team"
  > & { team?: Maybe<ResolversParentTypes["Team"]> };
  OrgUnblockUserAuditEntry: Omit<
    OrgUnblockUserAuditEntry,
    "actor" | "blockedUser" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    blockedUser?: Maybe<ResolversParentTypes["User"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgUpdateDefaultRepositoryPermissionAuditEntry: Omit<
    OrgUpdateDefaultRepositoryPermissionAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgUpdateMemberAuditEntry: Omit<
    OrgUpdateMemberAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgUpdateMemberRepositoryCreationPermissionAuditEntry: Omit<
    OrgUpdateMemberRepositoryCreationPermissionAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: Omit<
    OrgUpdateMemberRepositoryInvitationPermissionAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  Organization: Omit<
    Organization,
    | "auditLog"
    | "domains"
    | "enterpriseOwners"
    | "ipAllowListEntries"
    | "itemShowcase"
    | "lifetimeReceivedSponsorshipValues"
    | "mannequins"
    | "memberStatuses"
    | "membersWithRole"
    | "packages"
    | "pinnableItems"
    | "pinnedItems"
    | "project"
    | "projectV2"
    | "projects"
    | "projectsV2"
    | "recentProjects"
    | "repositories"
    | "repository"
    | "repositoryDiscussionComments"
    | "repositoryDiscussions"
    | "ruleset"
    | "rulesets"
    | "samlIdentityProvider"
    | "sponsoring"
    | "sponsors"
    | "sponsorsActivities"
    | "sponsorsListing"
    | "sponsorshipForViewerAsSponsor"
    | "sponsorshipForViewerAsSponsorable"
    | "sponsorshipNewsletters"
    | "sponsorshipsAsMaintainer"
    | "sponsorshipsAsSponsor"
    | "team"
    | "teams"
  > & {
    auditLog: ResolversParentTypes["OrganizationAuditEntryConnection"];
    domains?: Maybe<ResolversParentTypes["VerifiableDomainConnection"]>;
    enterpriseOwners: ResolversParentTypes["OrganizationEnterpriseOwnerConnection"];
    ipAllowListEntries: ResolversParentTypes["IpAllowListEntryConnection"];
    itemShowcase: ResolversParentTypes["ProfileItemShowcase"];
    lifetimeReceivedSponsorshipValues: ResolversParentTypes["SponsorAndLifetimeValueConnection"];
    mannequins: ResolversParentTypes["MannequinConnection"];
    memberStatuses: ResolversParentTypes["UserStatusConnection"];
    membersWithRole: ResolversParentTypes["OrganizationMemberConnection"];
    packages: ResolversParentTypes["PackageConnection"];
    pinnableItems: ResolversParentTypes["PinnableItemConnection"];
    pinnedItems: ResolversParentTypes["PinnableItemConnection"];
    project?: Maybe<ResolversParentTypes["Project"]>;
    projectV2?: Maybe<ResolversParentTypes["ProjectV2"]>;
    projects: ResolversParentTypes["ProjectConnection"];
    projectsV2: ResolversParentTypes["ProjectV2Connection"];
    recentProjects: ResolversParentTypes["ProjectV2Connection"];
    repositories: ResolversParentTypes["RepositoryConnection"];
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    repositoryDiscussionComments: ResolversParentTypes["DiscussionCommentConnection"];
    repositoryDiscussions: ResolversParentTypes["DiscussionConnection"];
    ruleset?: Maybe<ResolversParentTypes["RepositoryRuleset"]>;
    rulesets?: Maybe<ResolversParentTypes["RepositoryRulesetConnection"]>;
    samlIdentityProvider?: Maybe<
      ResolversParentTypes["OrganizationIdentityProvider"]
    >;
    sponsoring: ResolversParentTypes["SponsorConnection"];
    sponsors: ResolversParentTypes["SponsorConnection"];
    sponsorsActivities: ResolversParentTypes["SponsorsActivityConnection"];
    sponsorsListing?: Maybe<ResolversParentTypes["SponsorsListing"]>;
    sponsorshipForViewerAsSponsor?: Maybe<ResolversParentTypes["Sponsorship"]>;
    sponsorshipForViewerAsSponsorable?: Maybe<
      ResolversParentTypes["Sponsorship"]
    >;
    sponsorshipNewsletters: ResolversParentTypes["SponsorshipNewsletterConnection"];
    sponsorshipsAsMaintainer: ResolversParentTypes["SponsorshipConnection"];
    sponsorshipsAsSponsor: ResolversParentTypes["SponsorshipConnection"];
    team?: Maybe<ResolversParentTypes["Team"]>;
    teams: ResolversParentTypes["TeamConnection"];
  };
  OrganizationAuditEntry: ResolversUnionTypes<ResolversParentTypes>["OrganizationAuditEntry"];
  OrganizationAuditEntryConnection: Omit<
    OrganizationAuditEntryConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["OrganizationAuditEntryEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["OrganizationAuditEntry"]>>>;
  };
  OrganizationAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>["OrganizationAuditEntryData"];
  OrganizationAuditEntryEdge: Omit<OrganizationAuditEntryEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["OrganizationAuditEntry"]>;
  };
  OrganizationConnection: Omit<OrganizationConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["OrganizationEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Organization"]>>>;
  };
  OrganizationEdge: Omit<OrganizationEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Organization"]>;
  };
  OrganizationEnterpriseOwnerConnection: Omit<
    OrganizationEnterpriseOwnerConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["OrganizationEnterpriseOwnerEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["User"]>>>;
  };
  OrganizationEnterpriseOwnerEdge: Omit<
    OrganizationEnterpriseOwnerEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["User"]> };
  OrganizationIdentityProvider: Omit<
    OrganizationIdentityProvider,
    "externalIdentities" | "organization"
  > & {
    externalIdentities: ResolversParentTypes["ExternalIdentityConnection"];
    organization?: Maybe<ResolversParentTypes["Organization"]>;
  };
  OrganizationInvitation: Omit<
    OrganizationInvitation,
    "invitee" | "inviter" | "inviterActor" | "organization"
  > & {
    invitee?: Maybe<ResolversParentTypes["User"]>;
    inviter: ResolversParentTypes["User"];
    inviterActor?: Maybe<ResolversParentTypes["User"]>;
    organization: ResolversParentTypes["Organization"];
  };
  OrganizationInvitationConnection: Omit<
    OrganizationInvitationConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["OrganizationInvitationEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["OrganizationInvitation"]>>>;
  };
  OrganizationInvitationEdge: Omit<OrganizationInvitationEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["OrganizationInvitation"]>;
  };
  OrganizationMemberConnection: Omit<
    OrganizationMemberConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["OrganizationMemberEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["User"]>>>;
  };
  OrganizationMemberEdge: Omit<OrganizationMemberEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["User"]>;
  };
  OrganizationMigration: OrganizationMigration;
  OrganizationOrUser: ResolversUnionTypes<ResolversParentTypes>["OrganizationOrUser"];
  OrganizationOrder: OrganizationOrder;
  OrganizationTeamsHovercardContext: Omit<
    OrganizationTeamsHovercardContext,
    "relevantTeams"
  > & { relevantTeams: ResolversParentTypes["TeamConnection"] };
  OrganizationsHovercardContext: Omit<
    OrganizationsHovercardContext,
    "relevantOrganizations"
  > & { relevantOrganizations: ResolversParentTypes["OrganizationConnection"] };
  Package: Omit<
    Package,
    "latestVersion" | "repository" | "version" | "versions"
  > & {
    latestVersion?: Maybe<ResolversParentTypes["PackageVersion"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    version?: Maybe<ResolversParentTypes["PackageVersion"]>;
    versions: ResolversParentTypes["PackageVersionConnection"];
  };
  PackageConnection: Omit<PackageConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["PackageEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Package"]>>>;
  };
  PackageEdge: Omit<PackageEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Package"]>;
  };
  PackageFile: Omit<PackageFile, "packageVersion"> & {
    packageVersion?: Maybe<ResolversParentTypes["PackageVersion"]>;
  };
  PackageFileConnection: PackageFileConnection;
  PackageFileEdge: PackageFileEdge;
  PackageFileOrder: PackageFileOrder;
  PackageOrder: PackageOrder;
  PackageOwner: ResolversInterfaceTypes<ResolversParentTypes>["PackageOwner"];
  PackageStatistics: PackageStatistics;
  PackageTag: Omit<PackageTag, "version"> & {
    version?: Maybe<ResolversParentTypes["PackageVersion"]>;
  };
  PackageVersion: Omit<PackageVersion, "package" | "release"> & {
    package?: Maybe<ResolversParentTypes["Package"]>;
    release?: Maybe<ResolversParentTypes["Release"]>;
  };
  PackageVersionConnection: Omit<
    PackageVersionConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["PackageVersionEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["PackageVersion"]>>>;
  };
  PackageVersionEdge: Omit<PackageVersionEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PackageVersion"]>;
  };
  PackageVersionOrder: PackageVersionOrder;
  PackageVersionStatistics: PackageVersionStatistics;
  PageInfo: PageInfo;
  PermissionGranter: ResolversUnionTypes<ResolversParentTypes>["PermissionGranter"];
  PermissionSource: Omit<PermissionSource, "organization" | "source"> & {
    organization: ResolversParentTypes["Organization"];
    source: ResolversParentTypes["PermissionGranter"];
  };
  PinEnvironmentInput: PinEnvironmentInput;
  PinEnvironmentPayload: Omit<
    PinEnvironmentPayload,
    "environment" | "pinnedEnvironment"
  > & {
    environment?: Maybe<ResolversParentTypes["Environment"]>;
    pinnedEnvironment?: Maybe<ResolversParentTypes["PinnedEnvironment"]>;
  };
  PinIssueInput: PinIssueInput;
  PinIssuePayload: Omit<PinIssuePayload, "issue"> & {
    issue?: Maybe<ResolversParentTypes["Issue"]>;
  };
  PinnableItem: ResolversUnionTypes<ResolversParentTypes>["PinnableItem"];
  PinnableItemConnection: Omit<PinnableItemConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["PinnableItemEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["PinnableItem"]>>>;
  };
  PinnableItemEdge: Omit<PinnableItemEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PinnableItem"]>;
  };
  PinnedDiscussion: Omit<
    PinnedDiscussion,
    "discussion" | "pinnedBy" | "repository"
  > & {
    discussion: ResolversParentTypes["Discussion"];
    pinnedBy: ResolversParentTypes["Actor"];
    repository: ResolversParentTypes["Repository"];
  };
  PinnedDiscussionConnection: Omit<
    PinnedDiscussionConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["PinnedDiscussionEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["PinnedDiscussion"]>>>;
  };
  PinnedDiscussionEdge: Omit<PinnedDiscussionEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PinnedDiscussion"]>;
  };
  PinnedEnvironment: Omit<PinnedEnvironment, "environment" | "repository"> & {
    environment: ResolversParentTypes["Environment"];
    repository: ResolversParentTypes["Repository"];
  };
  PinnedEnvironmentConnection: Omit<
    PinnedEnvironmentConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["PinnedEnvironmentEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["PinnedEnvironment"]>>>;
  };
  PinnedEnvironmentEdge: Omit<PinnedEnvironmentEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PinnedEnvironment"]>;
  };
  PinnedEnvironmentOrder: PinnedEnvironmentOrder;
  PinnedEvent: Omit<PinnedEvent, "actor" | "issue"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    issue: ResolversParentTypes["Issue"];
  };
  PinnedIssue: Omit<PinnedIssue, "issue" | "pinnedBy" | "repository"> & {
    issue: ResolversParentTypes["Issue"];
    pinnedBy: ResolversParentTypes["Actor"];
    repository: ResolversParentTypes["Repository"];
  };
  PinnedIssueConnection: Omit<PinnedIssueConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["PinnedIssueEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["PinnedIssue"]>>>;
  };
  PinnedIssueEdge: Omit<PinnedIssueEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PinnedIssue"]>;
  };
  PreciseDateTime: Scalars["PreciseDateTime"]["output"];
  PrivateRepositoryForkingDisableAuditEntry: Omit<
    PrivateRepositoryForkingDisableAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  PrivateRepositoryForkingEnableAuditEntry: Omit<
    PrivateRepositoryForkingEnableAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  ProfileItemShowcase: Omit<ProfileItemShowcase, "items"> & {
    items: ResolversParentTypes["PinnableItemConnection"];
  };
  ProfileOwner: ResolversInterfaceTypes<ResolversParentTypes>["ProfileOwner"];
  Project: Omit<Project, "creator" | "owner" | "pendingCards"> & {
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    owner: ResolversParentTypes["ProjectOwner"];
    pendingCards: ResolversParentTypes["ProjectCardConnection"];
  };
  ProjectCard: Omit<
    ProjectCard,
    "column" | "content" | "creator" | "project"
  > & {
    column?: Maybe<ResolversParentTypes["ProjectColumn"]>;
    content?: Maybe<ResolversParentTypes["ProjectCardItem"]>;
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    project: ResolversParentTypes["Project"];
  };
  ProjectCardConnection: Omit<ProjectCardConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ProjectCardEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ProjectCard"]>>>;
  };
  ProjectCardEdge: Omit<ProjectCardEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ProjectCard"]>;
  };
  ProjectCardImport: ProjectCardImport;
  ProjectCardItem: ResolversUnionTypes<ResolversParentTypes>["ProjectCardItem"];
  ProjectColumn: Omit<ProjectColumn, "cards" | "project"> & {
    cards: ResolversParentTypes["ProjectCardConnection"];
    project: ResolversParentTypes["Project"];
  };
  ProjectColumnConnection: Omit<ProjectColumnConnection, "nodes"> & {
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ProjectColumn"]>>>;
  };
  ProjectColumnEdge: Omit<ProjectColumnEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ProjectColumn"]>;
  };
  ProjectColumnImport: ProjectColumnImport;
  ProjectConnection: Omit<ProjectConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ProjectEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Project"]>>>;
  };
  ProjectEdge: Omit<ProjectEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Project"]>;
  };
  ProjectOrder: ProjectOrder;
  ProjectOwner: ResolversInterfaceTypes<ResolversParentTypes>["ProjectOwner"];
  ProjectProgress: ProjectProgress;
  ProjectV2: Omit<
    ProjectV2,
    | "creator"
    | "field"
    | "fields"
    | "items"
    | "owner"
    | "repositories"
    | "statusUpdates"
    | "teams"
    | "view"
    | "views"
    | "workflow"
    | "workflows"
  > & {
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    field?: Maybe<ResolversParentTypes["ProjectV2FieldConfiguration"]>;
    fields: ResolversParentTypes["ProjectV2FieldConfigurationConnection"];
    items: ResolversParentTypes["ProjectV2ItemConnection"];
    owner: ResolversParentTypes["ProjectV2Owner"];
    repositories: ResolversParentTypes["RepositoryConnection"];
    statusUpdates: ResolversParentTypes["ProjectV2StatusUpdateConnection"];
    teams: ResolversParentTypes["TeamConnection"];
    view?: Maybe<ResolversParentTypes["ProjectV2View"]>;
    views: ResolversParentTypes["ProjectV2ViewConnection"];
    workflow?: Maybe<ResolversParentTypes["ProjectV2Workflow"]>;
    workflows: ResolversParentTypes["ProjectV2WorkflowConnection"];
  };
  ProjectV2Actor: ResolversUnionTypes<ResolversParentTypes>["ProjectV2Actor"];
  ProjectV2ActorConnection: Omit<
    ProjectV2ActorConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2ActorEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2Actor"]>>>;
  };
  ProjectV2ActorEdge: Omit<ProjectV2ActorEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ProjectV2Actor"]>;
  };
  ProjectV2Collaborator: ProjectV2Collaborator;
  ProjectV2Connection: Omit<ProjectV2Connection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2Edge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2"]>>>;
  };
  ProjectV2Edge: Omit<ProjectV2Edge, "node"> & {
    node?: Maybe<ResolversParentTypes["ProjectV2"]>;
  };
  ProjectV2Field: Omit<ProjectV2Field, "project"> & {
    project: ResolversParentTypes["ProjectV2"];
  };
  ProjectV2FieldCommon: ResolversInterfaceTypes<ResolversParentTypes>["ProjectV2FieldCommon"];
  ProjectV2FieldConfiguration: ResolversUnionTypes<ResolversParentTypes>["ProjectV2FieldConfiguration"];
  ProjectV2FieldConfigurationConnection: Omit<
    ProjectV2FieldConfigurationConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["ProjectV2FieldConfigurationEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["ProjectV2FieldConfiguration"]>>
    >;
  };
  ProjectV2FieldConfigurationEdge: Omit<
    ProjectV2FieldConfigurationEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["ProjectV2FieldConfiguration"]> };
  ProjectV2FieldConnection: Omit<
    ProjectV2FieldConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2FieldEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2Field"]>>>;
  };
  ProjectV2FieldEdge: Omit<ProjectV2FieldEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ProjectV2Field"]>;
  };
  ProjectV2FieldOrder: ProjectV2FieldOrder;
  ProjectV2FieldValue: ProjectV2FieldValue;
  ProjectV2Filters: ProjectV2Filters;
  ProjectV2Item: Omit<
    ProjectV2Item,
    "content" | "creator" | "fieldValueByName" | "fieldValues" | "project"
  > & {
    content?: Maybe<ResolversParentTypes["ProjectV2ItemContent"]>;
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    fieldValueByName?: Maybe<ResolversParentTypes["ProjectV2ItemFieldValue"]>;
    fieldValues: ResolversParentTypes["ProjectV2ItemFieldValueConnection"];
    project: ResolversParentTypes["ProjectV2"];
  };
  ProjectV2ItemConnection: Omit<ProjectV2ItemConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2ItemEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2Item"]>>>;
  };
  ProjectV2ItemContent: ResolversUnionTypes<ResolversParentTypes>["ProjectV2ItemContent"];
  ProjectV2ItemEdge: Omit<ProjectV2ItemEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ProjectV2Item"]>;
  };
  ProjectV2ItemFieldDateValue: Omit<
    ProjectV2ItemFieldDateValue,
    "creator" | "field" | "item"
  > & {
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    field: ResolversParentTypes["ProjectV2FieldConfiguration"];
    item: ResolversParentTypes["ProjectV2Item"];
  };
  ProjectV2ItemFieldIterationValue: Omit<
    ProjectV2ItemFieldIterationValue,
    "creator" | "field" | "item"
  > & {
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    field: ResolversParentTypes["ProjectV2FieldConfiguration"];
    item: ResolversParentTypes["ProjectV2Item"];
  };
  ProjectV2ItemFieldLabelValue: Omit<
    ProjectV2ItemFieldLabelValue,
    "field" | "labels"
  > & {
    field: ResolversParentTypes["ProjectV2FieldConfiguration"];
    labels?: Maybe<ResolversParentTypes["LabelConnection"]>;
  };
  ProjectV2ItemFieldMilestoneValue: Omit<
    ProjectV2ItemFieldMilestoneValue,
    "field" | "milestone"
  > & {
    field: ResolversParentTypes["ProjectV2FieldConfiguration"];
    milestone?: Maybe<ResolversParentTypes["Milestone"]>;
  };
  ProjectV2ItemFieldNumberValue: Omit<
    ProjectV2ItemFieldNumberValue,
    "creator" | "field" | "item"
  > & {
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    field: ResolversParentTypes["ProjectV2FieldConfiguration"];
    item: ResolversParentTypes["ProjectV2Item"];
  };
  ProjectV2ItemFieldPullRequestValue: Omit<
    ProjectV2ItemFieldPullRequestValue,
    "field" | "pullRequests"
  > & {
    field: ResolversParentTypes["ProjectV2FieldConfiguration"];
    pullRequests?: Maybe<ResolversParentTypes["PullRequestConnection"]>;
  };
  ProjectV2ItemFieldRepositoryValue: Omit<
    ProjectV2ItemFieldRepositoryValue,
    "field" | "repository"
  > & {
    field: ResolversParentTypes["ProjectV2FieldConfiguration"];
    repository?: Maybe<ResolversParentTypes["Repository"]>;
  };
  ProjectV2ItemFieldReviewerValue: Omit<
    ProjectV2ItemFieldReviewerValue,
    "field" | "reviewers"
  > & {
    field: ResolversParentTypes["ProjectV2FieldConfiguration"];
    reviewers?: Maybe<ResolversParentTypes["RequestedReviewerConnection"]>;
  };
  ProjectV2ItemFieldSingleSelectValue: Omit<
    ProjectV2ItemFieldSingleSelectValue,
    "creator" | "field" | "item"
  > & {
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    field: ResolversParentTypes["ProjectV2FieldConfiguration"];
    item: ResolversParentTypes["ProjectV2Item"];
  };
  ProjectV2ItemFieldTextValue: Omit<
    ProjectV2ItemFieldTextValue,
    "creator" | "field" | "item"
  > & {
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    field: ResolversParentTypes["ProjectV2FieldConfiguration"];
    item: ResolversParentTypes["ProjectV2Item"];
  };
  ProjectV2ItemFieldUserValue: Omit<ProjectV2ItemFieldUserValue, "field"> & {
    field: ResolversParentTypes["ProjectV2FieldConfiguration"];
  };
  ProjectV2ItemFieldValue: ResolversUnionTypes<ResolversParentTypes>["ProjectV2ItemFieldValue"];
  ProjectV2ItemFieldValueCommon: ResolversInterfaceTypes<ResolversParentTypes>["ProjectV2ItemFieldValueCommon"];
  ProjectV2ItemFieldValueConnection: Omit<
    ProjectV2ItemFieldValueConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["ProjectV2ItemFieldValueEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["ProjectV2ItemFieldValue"]>>
    >;
  };
  ProjectV2ItemFieldValueEdge: Omit<ProjectV2ItemFieldValueEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ProjectV2ItemFieldValue"]>;
  };
  ProjectV2ItemFieldValueOrder: ProjectV2ItemFieldValueOrder;
  ProjectV2ItemOrder: ProjectV2ItemOrder;
  ProjectV2IterationField: Omit<ProjectV2IterationField, "project"> & {
    project: ResolversParentTypes["ProjectV2"];
  };
  ProjectV2IterationFieldConfiguration: ProjectV2IterationFieldConfiguration;
  ProjectV2IterationFieldIteration: ProjectV2IterationFieldIteration;
  ProjectV2Order: ProjectV2Order;
  ProjectV2Owner: ResolversInterfaceTypes<ResolversParentTypes>["ProjectV2Owner"];
  ProjectV2Recent: ResolversInterfaceTypes<ResolversParentTypes>["ProjectV2Recent"];
  ProjectV2SingleSelectField: Omit<ProjectV2SingleSelectField, "project"> & {
    project: ResolversParentTypes["ProjectV2"];
  };
  ProjectV2SingleSelectFieldOption: ProjectV2SingleSelectFieldOption;
  ProjectV2SingleSelectFieldOptionInput: ProjectV2SingleSelectFieldOptionInput;
  ProjectV2SortBy: Omit<ProjectV2SortBy, "field"> & {
    field: ResolversParentTypes["ProjectV2Field"];
  };
  ProjectV2SortByConnection: Omit<
    ProjectV2SortByConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2SortByEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2SortBy"]>>>;
  };
  ProjectV2SortByEdge: Omit<ProjectV2SortByEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ProjectV2SortBy"]>;
  };
  ProjectV2SortByField: Omit<ProjectV2SortByField, "field"> & {
    field: ResolversParentTypes["ProjectV2FieldConfiguration"];
  };
  ProjectV2SortByFieldConnection: Omit<
    ProjectV2SortByFieldConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["ProjectV2SortByFieldEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2SortByField"]>>>;
  };
  ProjectV2SortByFieldEdge: Omit<ProjectV2SortByFieldEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ProjectV2SortByField"]>;
  };
  ProjectV2StatusOrder: ProjectV2StatusOrder;
  ProjectV2StatusUpdate: Omit<ProjectV2StatusUpdate, "creator" | "project"> & {
    creator?: Maybe<ResolversParentTypes["Actor"]>;
    project: ResolversParentTypes["ProjectV2"];
  };
  ProjectV2StatusUpdateConnection: Omit<
    ProjectV2StatusUpdateConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["ProjectV2StatusUpdateEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2StatusUpdate"]>>>;
  };
  ProjectV2StatusUpdateEdge: Omit<ProjectV2StatusUpdateEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ProjectV2StatusUpdate"]>;
  };
  ProjectV2View: Omit<
    ProjectV2View,
    | "fields"
    | "groupBy"
    | "groupByFields"
    | "project"
    | "sortBy"
    | "sortByFields"
    | "verticalGroupBy"
    | "verticalGroupByFields"
    | "visibleFields"
  > & {
    fields?: Maybe<
      ResolversParentTypes["ProjectV2FieldConfigurationConnection"]
    >;
    groupBy?: Maybe<ResolversParentTypes["ProjectV2FieldConnection"]>;
    groupByFields?: Maybe<
      ResolversParentTypes["ProjectV2FieldConfigurationConnection"]
    >;
    project: ResolversParentTypes["ProjectV2"];
    sortBy?: Maybe<ResolversParentTypes["ProjectV2SortByConnection"]>;
    sortByFields?: Maybe<
      ResolversParentTypes["ProjectV2SortByFieldConnection"]
    >;
    verticalGroupBy?: Maybe<ResolversParentTypes["ProjectV2FieldConnection"]>;
    verticalGroupByFields?: Maybe<
      ResolversParentTypes["ProjectV2FieldConfigurationConnection"]
    >;
    visibleFields?: Maybe<ResolversParentTypes["ProjectV2FieldConnection"]>;
  };
  ProjectV2ViewConnection: Omit<ProjectV2ViewConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2ViewEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2View"]>>>;
  };
  ProjectV2ViewEdge: Omit<ProjectV2ViewEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ProjectV2View"]>;
  };
  ProjectV2ViewOrder: ProjectV2ViewOrder;
  ProjectV2Workflow: Omit<ProjectV2Workflow, "project"> & {
    project: ResolversParentTypes["ProjectV2"];
  };
  ProjectV2WorkflowConnection: Omit<
    ProjectV2WorkflowConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2WorkflowEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ProjectV2Workflow"]>>>;
  };
  ProjectV2WorkflowEdge: Omit<ProjectV2WorkflowEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ProjectV2Workflow"]>;
  };
  ProjectV2WorkflowOrder: ProjectV2WorkflowOrder;
  PropertyTargetDefinition: PropertyTargetDefinition;
  PropertyTargetDefinitionInput: PropertyTargetDefinitionInput;
  PublicKey: PublicKey;
  PublicKeyConnection: PublicKeyConnection;
  PublicKeyEdge: PublicKeyEdge;
  PublishSponsorsTierInput: PublishSponsorsTierInput;
  PublishSponsorsTierPayload: Omit<
    PublishSponsorsTierPayload,
    "sponsorsTier"
  > & { sponsorsTier?: Maybe<ResolversParentTypes["SponsorsTier"]> };
  PullRequest: Omit<
    PullRequest,
    | "author"
    | "autoMergeRequest"
    | "baseRef"
    | "baseRepository"
    | "closingIssuesReferences"
    | "comments"
    | "commits"
    | "editor"
    | "headRef"
    | "headRepository"
    | "headRepositoryOwner"
    | "hovercard"
    | "labels"
    | "latestOpinionatedReviews"
    | "latestReviews"
    | "mergeCommit"
    | "mergeQueue"
    | "mergeQueueEntry"
    | "mergedBy"
    | "milestone"
    | "potentialMergeCommit"
    | "projectCards"
    | "projectItems"
    | "projectV2"
    | "projectsV2"
    | "reactionGroups"
    | "reactions"
    | "repository"
    | "reviewRequests"
    | "reviewThreads"
    | "reviews"
    | "statusCheckRollup"
    | "timeline"
    | "timelineItems"
    | "userContentEdits"
    | "viewerLatestReview"
    | "viewerLatestReviewRequest"
  > & {
    author?: Maybe<ResolversParentTypes["Actor"]>;
    autoMergeRequest?: Maybe<ResolversParentTypes["AutoMergeRequest"]>;
    baseRef?: Maybe<ResolversParentTypes["Ref"]>;
    baseRepository?: Maybe<ResolversParentTypes["Repository"]>;
    closingIssuesReferences?: Maybe<ResolversParentTypes["IssueConnection"]>;
    comments: ResolversParentTypes["IssueCommentConnection"];
    commits: ResolversParentTypes["PullRequestCommitConnection"];
    editor?: Maybe<ResolversParentTypes["Actor"]>;
    headRef?: Maybe<ResolversParentTypes["Ref"]>;
    headRepository?: Maybe<ResolversParentTypes["Repository"]>;
    headRepositoryOwner?: Maybe<ResolversParentTypes["RepositoryOwner"]>;
    hovercard: ResolversParentTypes["Hovercard"];
    labels?: Maybe<ResolversParentTypes["LabelConnection"]>;
    latestOpinionatedReviews?: Maybe<
      ResolversParentTypes["PullRequestReviewConnection"]
    >;
    latestReviews?: Maybe<ResolversParentTypes["PullRequestReviewConnection"]>;
    mergeCommit?: Maybe<ResolversParentTypes["Commit"]>;
    mergeQueue?: Maybe<ResolversParentTypes["MergeQueue"]>;
    mergeQueueEntry?: Maybe<ResolversParentTypes["MergeQueueEntry"]>;
    mergedBy?: Maybe<ResolversParentTypes["Actor"]>;
    milestone?: Maybe<ResolversParentTypes["Milestone"]>;
    potentialMergeCommit?: Maybe<ResolversParentTypes["Commit"]>;
    projectCards: ResolversParentTypes["ProjectCardConnection"];
    projectItems: ResolversParentTypes["ProjectV2ItemConnection"];
    projectV2?: Maybe<ResolversParentTypes["ProjectV2"]>;
    projectsV2: ResolversParentTypes["ProjectV2Connection"];
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    reactions: ResolversParentTypes["ReactionConnection"];
    repository: ResolversParentTypes["Repository"];
    reviewRequests?: Maybe<ResolversParentTypes["ReviewRequestConnection"]>;
    reviewThreads: ResolversParentTypes["PullRequestReviewThreadConnection"];
    reviews?: Maybe<ResolversParentTypes["PullRequestReviewConnection"]>;
    statusCheckRollup?: Maybe<ResolversParentTypes["StatusCheckRollup"]>;
    timeline: ResolversParentTypes["PullRequestTimelineConnection"];
    timelineItems: ResolversParentTypes["PullRequestTimelineItemsConnection"];
    userContentEdits?: Maybe<ResolversParentTypes["UserContentEditConnection"]>;
    viewerLatestReview?: Maybe<ResolversParentTypes["PullRequestReview"]>;
    viewerLatestReviewRequest?: Maybe<ResolversParentTypes["ReviewRequest"]>;
  };
  PullRequestChangedFile: PullRequestChangedFile;
  PullRequestChangedFileConnection: PullRequestChangedFileConnection;
  PullRequestChangedFileEdge: PullRequestChangedFileEdge;
  PullRequestCommit: Omit<PullRequestCommit, "commit" | "pullRequest"> & {
    commit: ResolversParentTypes["Commit"];
    pullRequest: ResolversParentTypes["PullRequest"];
  };
  PullRequestCommitCommentThread: Omit<
    PullRequestCommitCommentThread,
    "comments" | "commit" | "pullRequest" | "repository"
  > & {
    comments: ResolversParentTypes["CommitCommentConnection"];
    commit: ResolversParentTypes["Commit"];
    pullRequest: ResolversParentTypes["PullRequest"];
    repository: ResolversParentTypes["Repository"];
  };
  PullRequestCommitConnection: Omit<
    PullRequestCommitConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["PullRequestCommitEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["PullRequestCommit"]>>>;
  };
  PullRequestCommitEdge: Omit<PullRequestCommitEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PullRequestCommit"]>;
  };
  PullRequestConnection: Omit<PullRequestConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["PullRequestEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["PullRequest"]>>>;
  };
  PullRequestContributionsByRepository: Omit<
    PullRequestContributionsByRepository,
    "contributions" | "repository"
  > & {
    contributions: ResolversParentTypes["CreatedPullRequestContributionConnection"];
    repository: ResolversParentTypes["Repository"];
  };
  PullRequestEdge: Omit<PullRequestEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  PullRequestOrder: PullRequestOrder;
  PullRequestParameters: PullRequestParameters;
  PullRequestParametersInput: PullRequestParametersInput;
  PullRequestReview: Omit<
    PullRequestReview,
    | "author"
    | "comments"
    | "commit"
    | "editor"
    | "onBehalfOf"
    | "pullRequest"
    | "reactionGroups"
    | "reactions"
    | "repository"
    | "userContentEdits"
  > & {
    author?: Maybe<ResolversParentTypes["Actor"]>;
    comments: ResolversParentTypes["PullRequestReviewCommentConnection"];
    commit?: Maybe<ResolversParentTypes["Commit"]>;
    editor?: Maybe<ResolversParentTypes["Actor"]>;
    onBehalfOf: ResolversParentTypes["TeamConnection"];
    pullRequest: ResolversParentTypes["PullRequest"];
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    reactions: ResolversParentTypes["ReactionConnection"];
    repository: ResolversParentTypes["Repository"];
    userContentEdits?: Maybe<ResolversParentTypes["UserContentEditConnection"]>;
  };
  PullRequestReviewComment: Omit<
    PullRequestReviewComment,
    | "author"
    | "commit"
    | "editor"
    | "originalCommit"
    | "pullRequest"
    | "pullRequestReview"
    | "reactionGroups"
    | "reactions"
    | "replyTo"
    | "repository"
    | "userContentEdits"
  > & {
    author?: Maybe<ResolversParentTypes["Actor"]>;
    commit?: Maybe<ResolversParentTypes["Commit"]>;
    editor?: Maybe<ResolversParentTypes["Actor"]>;
    originalCommit?: Maybe<ResolversParentTypes["Commit"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
    pullRequestReview?: Maybe<ResolversParentTypes["PullRequestReview"]>;
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    reactions: ResolversParentTypes["ReactionConnection"];
    replyTo?: Maybe<ResolversParentTypes["PullRequestReviewComment"]>;
    repository: ResolversParentTypes["Repository"];
    userContentEdits?: Maybe<ResolversParentTypes["UserContentEditConnection"]>;
  };
  PullRequestReviewCommentConnection: Omit<
    PullRequestReviewCommentConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["PullRequestReviewCommentEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["PullRequestReviewComment"]>>
    >;
  };
  PullRequestReviewCommentEdge: Omit<PullRequestReviewCommentEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PullRequestReviewComment"]>;
  };
  PullRequestReviewConnection: Omit<
    PullRequestReviewConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["PullRequestReviewEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["PullRequestReview"]>>>;
  };
  PullRequestReviewContributionsByRepository: Omit<
    PullRequestReviewContributionsByRepository,
    "contributions" | "repository"
  > & {
    contributions: ResolversParentTypes["CreatedPullRequestReviewContributionConnection"];
    repository: ResolversParentTypes["Repository"];
  };
  PullRequestReviewEdge: Omit<PullRequestReviewEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PullRequestReview"]>;
  };
  PullRequestReviewThread: Omit<
    PullRequestReviewThread,
    "comments" | "pullRequest" | "repository" | "resolvedBy"
  > & {
    comments: ResolversParentTypes["PullRequestReviewCommentConnection"];
    pullRequest: ResolversParentTypes["PullRequest"];
    repository: ResolversParentTypes["Repository"];
    resolvedBy?: Maybe<ResolversParentTypes["User"]>;
  };
  PullRequestReviewThreadConnection: Omit<
    PullRequestReviewThreadConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["PullRequestReviewThreadEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["PullRequestReviewThread"]>>
    >;
  };
  PullRequestReviewThreadEdge: Omit<PullRequestReviewThreadEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PullRequestReviewThread"]>;
  };
  PullRequestRevisionMarker: Omit<
    PullRequestRevisionMarker,
    "lastSeenCommit" | "pullRequest"
  > & {
    lastSeenCommit: ResolversParentTypes["Commit"];
    pullRequest: ResolversParentTypes["PullRequest"];
  };
  PullRequestTemplate: Omit<PullRequestTemplate, "repository"> & {
    repository: ResolversParentTypes["Repository"];
  };
  PullRequestThread: Omit<
    PullRequestThread,
    "comments" | "pullRequest" | "repository" | "resolvedBy"
  > & {
    comments: ResolversParentTypes["PullRequestReviewCommentConnection"];
    pullRequest: ResolversParentTypes["PullRequest"];
    repository: ResolversParentTypes["Repository"];
    resolvedBy?: Maybe<ResolversParentTypes["User"]>;
  };
  PullRequestTimelineConnection: Omit<
    PullRequestTimelineConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["PullRequestTimelineItemEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["PullRequestTimelineItem"]>>
    >;
  };
  PullRequestTimelineItem: ResolversUnionTypes<ResolversParentTypes>["PullRequestTimelineItem"];
  PullRequestTimelineItemEdge: Omit<PullRequestTimelineItemEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PullRequestTimelineItem"]>;
  };
  PullRequestTimelineItems: ResolversUnionTypes<ResolversParentTypes>["PullRequestTimelineItems"];
  PullRequestTimelineItemsConnection: Omit<
    PullRequestTimelineItemsConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["PullRequestTimelineItemsEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["PullRequestTimelineItems"]>>
    >;
  };
  PullRequestTimelineItemsEdge: Omit<PullRequestTimelineItemsEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PullRequestTimelineItems"]>;
  };
  Push: Omit<Push, "pusher" | "repository"> & {
    pusher: ResolversParentTypes["Actor"];
    repository: ResolversParentTypes["Repository"];
  };
  PushAllowance: Omit<PushAllowance, "actor" | "branchProtectionRule"> & {
    actor?: Maybe<ResolversParentTypes["PushAllowanceActor"]>;
    branchProtectionRule?: Maybe<ResolversParentTypes["BranchProtectionRule"]>;
  };
  PushAllowanceActor: ResolversUnionTypes<ResolversParentTypes>["PushAllowanceActor"];
  PushAllowanceConnection: Omit<PushAllowanceConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["PushAllowanceEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["PushAllowance"]>>>;
  };
  PushAllowanceEdge: Omit<PushAllowanceEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["PushAllowance"]>;
  };
  Query: {};
  RateLimit: RateLimit;
  Reactable: ResolversInterfaceTypes<ResolversParentTypes>["Reactable"];
  ReactingUserConnection: Omit<ReactingUserConnection, "nodes"> & {
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["User"]>>>;
  };
  ReactingUserEdge: Omit<ReactingUserEdge, "node"> & {
    node: ResolversParentTypes["User"];
  };
  Reaction: Omit<Reaction, "reactable" | "user"> & {
    reactable: ResolversParentTypes["Reactable"];
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  ReactionConnection: Omit<ReactionConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ReactionEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Reaction"]>>>;
  };
  ReactionEdge: Omit<ReactionEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Reaction"]>;
  };
  ReactionGroup: Omit<ReactionGroup, "reactors" | "subject"> & {
    reactors: ResolversParentTypes["ReactorConnection"];
    subject: ResolversParentTypes["Reactable"];
  };
  ReactionOrder: ReactionOrder;
  Reactor: ResolversUnionTypes<ResolversParentTypes>["Reactor"];
  ReactorConnection: Omit<ReactorConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ReactorEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Reactor"]>>>;
  };
  ReactorEdge: Omit<ReactorEdge, "node"> & {
    node: ResolversParentTypes["Reactor"];
  };
  ReadyForReviewEvent: Omit<ReadyForReviewEvent, "actor" | "pullRequest"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
  };
  Ref: Omit<
    Ref,
    | "associatedPullRequests"
    | "branchProtectionRule"
    | "compare"
    | "repository"
    | "rules"
    | "target"
  > & {
    associatedPullRequests: ResolversParentTypes["PullRequestConnection"];
    branchProtectionRule?: Maybe<ResolversParentTypes["BranchProtectionRule"]>;
    compare?: Maybe<ResolversParentTypes["Comparison"]>;
    repository: ResolversParentTypes["Repository"];
    rules?: Maybe<ResolversParentTypes["RepositoryRuleConnection"]>;
    target?: Maybe<ResolversParentTypes["GitObject"]>;
  };
  RefConnection: Omit<RefConnection, "nodes"> & {
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Ref"]>>>;
  };
  RefEdge: Omit<RefEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Ref"]>;
  };
  RefNameConditionTarget: RefNameConditionTarget;
  RefNameConditionTargetInput: RefNameConditionTargetInput;
  RefOrder: RefOrder;
  RefUpdate: RefUpdate;
  RefUpdateRule: RefUpdateRule;
  ReferencedEvent: Omit<
    ReferencedEvent,
    "actor" | "commit" | "commitRepository" | "subject"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    commit?: Maybe<ResolversParentTypes["Commit"]>;
    commitRepository: ResolversParentTypes["Repository"];
    subject: ResolversParentTypes["ReferencedSubject"];
  };
  ReferencedSubject: ResolversUnionTypes<ResolversParentTypes>["ReferencedSubject"];
  RegenerateEnterpriseIdentityProviderRecoveryCodesInput: RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: Omit<
    RegenerateEnterpriseIdentityProviderRecoveryCodesPayload,
    "identityProvider"
  > & {
    identityProvider?: Maybe<
      ResolversParentTypes["EnterpriseIdentityProvider"]
    >;
  };
  RegenerateVerifiableDomainTokenInput: RegenerateVerifiableDomainTokenInput;
  RegenerateVerifiableDomainTokenPayload: RegenerateVerifiableDomainTokenPayload;
  RejectDeploymentsInput: RejectDeploymentsInput;
  RejectDeploymentsPayload: Omit<RejectDeploymentsPayload, "deployments"> & {
    deployments?: Maybe<Array<ResolversParentTypes["Deployment"]>>;
  };
  Release: Omit<
    Release,
    | "author"
    | "reactionGroups"
    | "reactions"
    | "releaseAssets"
    | "repository"
    | "tag"
    | "tagCommit"
  > & {
    author?: Maybe<ResolversParentTypes["User"]>;
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    reactions: ResolversParentTypes["ReactionConnection"];
    releaseAssets: ResolversParentTypes["ReleaseAssetConnection"];
    repository: ResolversParentTypes["Repository"];
    tag?: Maybe<ResolversParentTypes["Ref"]>;
    tagCommit?: Maybe<ResolversParentTypes["Commit"]>;
  };
  ReleaseAsset: Omit<ReleaseAsset, "release" | "uploadedBy"> & {
    release?: Maybe<ResolversParentTypes["Release"]>;
    uploadedBy: ResolversParentTypes["User"];
  };
  ReleaseAssetConnection: Omit<ReleaseAssetConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ReleaseAssetEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ReleaseAsset"]>>>;
  };
  ReleaseAssetEdge: Omit<ReleaseAssetEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ReleaseAsset"]>;
  };
  ReleaseConnection: Omit<ReleaseConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ReleaseEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Release"]>>>;
  };
  ReleaseEdge: Omit<ReleaseEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Release"]>;
  };
  ReleaseOrder: ReleaseOrder;
  RemoveAssigneesFromAssignableInput: RemoveAssigneesFromAssignableInput;
  RemoveAssigneesFromAssignablePayload: Omit<
    RemoveAssigneesFromAssignablePayload,
    "assignable"
  > & { assignable?: Maybe<ResolversParentTypes["Assignable"]> };
  RemoveEnterpriseAdminInput: RemoveEnterpriseAdminInput;
  RemoveEnterpriseAdminPayload: Omit<
    RemoveEnterpriseAdminPayload,
    "admin" | "enterprise" | "viewer"
  > & {
    admin?: Maybe<ResolversParentTypes["User"]>;
    enterprise?: Maybe<ResolversParentTypes["Enterprise"]>;
    viewer?: Maybe<ResolversParentTypes["User"]>;
  };
  RemoveEnterpriseIdentityProviderInput: RemoveEnterpriseIdentityProviderInput;
  RemoveEnterpriseIdentityProviderPayload: Omit<
    RemoveEnterpriseIdentityProviderPayload,
    "identityProvider"
  > & {
    identityProvider?: Maybe<
      ResolversParentTypes["EnterpriseIdentityProvider"]
    >;
  };
  RemoveEnterpriseMemberInput: RemoveEnterpriseMemberInput;
  RemoveEnterpriseMemberPayload: Omit<
    RemoveEnterpriseMemberPayload,
    "enterprise" | "user" | "viewer"
  > & {
    enterprise?: Maybe<ResolversParentTypes["Enterprise"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
    viewer?: Maybe<ResolversParentTypes["User"]>;
  };
  RemoveEnterpriseOrganizationInput: RemoveEnterpriseOrganizationInput;
  RemoveEnterpriseOrganizationPayload: Omit<
    RemoveEnterpriseOrganizationPayload,
    "enterprise" | "organization" | "viewer"
  > & {
    enterprise?: Maybe<ResolversParentTypes["Enterprise"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    viewer?: Maybe<ResolversParentTypes["User"]>;
  };
  RemoveEnterpriseSupportEntitlementInput: RemoveEnterpriseSupportEntitlementInput;
  RemoveEnterpriseSupportEntitlementPayload: RemoveEnterpriseSupportEntitlementPayload;
  RemoveLabelsFromLabelableInput: RemoveLabelsFromLabelableInput;
  RemoveLabelsFromLabelablePayload: Omit<
    RemoveLabelsFromLabelablePayload,
    "labelable"
  > & { labelable?: Maybe<ResolversParentTypes["Labelable"]> };
  RemoveOutsideCollaboratorInput: RemoveOutsideCollaboratorInput;
  RemoveOutsideCollaboratorPayload: Omit<
    RemoveOutsideCollaboratorPayload,
    "removedUser"
  > & { removedUser?: Maybe<ResolversParentTypes["User"]> };
  RemoveReactionInput: RemoveReactionInput;
  RemoveReactionPayload: Omit<
    RemoveReactionPayload,
    "reaction" | "reactionGroups" | "subject"
  > & {
    reaction?: Maybe<ResolversParentTypes["Reaction"]>;
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    subject?: Maybe<ResolversParentTypes["Reactable"]>;
  };
  RemoveStarInput: RemoveStarInput;
  RemoveStarPayload: Omit<RemoveStarPayload, "starrable"> & {
    starrable?: Maybe<ResolversParentTypes["Starrable"]>;
  };
  RemoveUpvoteInput: RemoveUpvoteInput;
  RemoveUpvotePayload: Omit<RemoveUpvotePayload, "subject"> & {
    subject?: Maybe<ResolversParentTypes["Votable"]>;
  };
  RemovedFromMergeQueueEvent: Omit<
    RemovedFromMergeQueueEvent,
    "actor" | "beforeCommit" | "enqueuer" | "mergeQueue" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    beforeCommit?: Maybe<ResolversParentTypes["Commit"]>;
    enqueuer?: Maybe<ResolversParentTypes["User"]>;
    mergeQueue?: Maybe<ResolversParentTypes["MergeQueue"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  RemovedFromProjectEvent: Omit<
    RemovedFromProjectEvent,
    "actor" | "project"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    project?: Maybe<ResolversParentTypes["Project"]>;
  };
  RenamedTitleEvent: Omit<RenamedTitleEvent, "actor" | "subject"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    subject: ResolversParentTypes["RenamedTitleSubject"];
  };
  RenamedTitleSubject: ResolversUnionTypes<ResolversParentTypes>["RenamedTitleSubject"];
  ReopenDiscussionInput: ReopenDiscussionInput;
  ReopenDiscussionPayload: Omit<ReopenDiscussionPayload, "discussion"> & {
    discussion?: Maybe<ResolversParentTypes["Discussion"]>;
  };
  ReopenIssueInput: ReopenIssueInput;
  ReopenIssuePayload: Omit<ReopenIssuePayload, "issue"> & {
    issue?: Maybe<ResolversParentTypes["Issue"]>;
  };
  ReopenPullRequestInput: ReopenPullRequestInput;
  ReopenPullRequestPayload: Omit<ReopenPullRequestPayload, "pullRequest"> & {
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  ReopenedEvent: Omit<ReopenedEvent, "actor" | "closable"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    closable: ResolversParentTypes["Closable"];
  };
  ReorderEnvironmentInput: ReorderEnvironmentInput;
  ReorderEnvironmentPayload: Omit<ReorderEnvironmentPayload, "environment"> & {
    environment?: Maybe<ResolversParentTypes["Environment"]>;
  };
  RepoAccessAuditEntry: Omit<
    RepoAccessAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoAddMemberAuditEntry: Omit<
    RepoAddMemberAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoAddTopicAuditEntry: Omit<
    RepoAddTopicAuditEntry,
    "actor" | "organization" | "repository" | "topic" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    topic?: Maybe<ResolversParentTypes["Topic"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoArchivedAuditEntry: Omit<
    RepoArchivedAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoChangeMergeSettingAuditEntry: Omit<
    RepoChangeMergeSettingAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoConfigDisableAnonymousGitAccessAuditEntry: Omit<
    RepoConfigDisableAnonymousGitAccessAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoConfigDisableCollaboratorsOnlyAuditEntry: Omit<
    RepoConfigDisableCollaboratorsOnlyAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoConfigDisableContributorsOnlyAuditEntry: Omit<
    RepoConfigDisableContributorsOnlyAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoConfigDisableSockpuppetDisallowedAuditEntry: Omit<
    RepoConfigDisableSockpuppetDisallowedAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoConfigEnableAnonymousGitAccessAuditEntry: Omit<
    RepoConfigEnableAnonymousGitAccessAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoConfigEnableCollaboratorsOnlyAuditEntry: Omit<
    RepoConfigEnableCollaboratorsOnlyAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoConfigEnableContributorsOnlyAuditEntry: Omit<
    RepoConfigEnableContributorsOnlyAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoConfigEnableSockpuppetDisallowedAuditEntry: Omit<
    RepoConfigEnableSockpuppetDisallowedAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoConfigLockAnonymousGitAccessAuditEntry: Omit<
    RepoConfigLockAnonymousGitAccessAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoConfigUnlockAnonymousGitAccessAuditEntry: Omit<
    RepoConfigUnlockAnonymousGitAccessAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoCreateAuditEntry: Omit<
    RepoCreateAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoDestroyAuditEntry: Omit<
    RepoDestroyAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoRemoveMemberAuditEntry: Omit<
    RepoRemoveMemberAuditEntry,
    "actor" | "organization" | "repository" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepoRemoveTopicAuditEntry: Omit<
    RepoRemoveTopicAuditEntry,
    "actor" | "organization" | "repository" | "topic" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    topic?: Maybe<ResolversParentTypes["Topic"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  Repository: Omit<
    Repository,
    | "branchProtectionRules"
    | "collaborators"
    | "commitComments"
    | "defaultBranchRef"
    | "dependencyGraphManifests"
    | "deployments"
    | "discussion"
    | "discussionCategories"
    | "discussionCategory"
    | "discussions"
    | "environment"
    | "environments"
    | "forks"
    | "issue"
    | "issueOrPullRequest"
    | "issueTemplates"
    | "issues"
    | "label"
    | "labels"
    | "latestRelease"
    | "mergeQueue"
    | "milestone"
    | "milestones"
    | "object"
    | "owner"
    | "packages"
    | "parent"
    | "pinnedDiscussions"
    | "pinnedEnvironments"
    | "pinnedIssues"
    | "project"
    | "projectV2"
    | "projects"
    | "projectsV2"
    | "pullRequest"
    | "pullRequestTemplates"
    | "pullRequests"
    | "recentProjects"
    | "ref"
    | "release"
    | "releases"
    | "repositoryTopics"
    | "ruleset"
    | "rulesets"
    | "templateRepository"
    | "vulnerabilityAlert"
    | "vulnerabilityAlerts"
  > & {
    branchProtectionRules: ResolversParentTypes["BranchProtectionRuleConnection"];
    collaborators?: Maybe<
      ResolversParentTypes["RepositoryCollaboratorConnection"]
    >;
    commitComments: ResolversParentTypes["CommitCommentConnection"];
    defaultBranchRef?: Maybe<ResolversParentTypes["Ref"]>;
    dependencyGraphManifests?: Maybe<
      ResolversParentTypes["DependencyGraphManifestConnection"]
    >;
    deployments: ResolversParentTypes["DeploymentConnection"];
    discussion?: Maybe<ResolversParentTypes["Discussion"]>;
    discussionCategories: ResolversParentTypes["DiscussionCategoryConnection"];
    discussionCategory?: Maybe<ResolversParentTypes["DiscussionCategory"]>;
    discussions: ResolversParentTypes["DiscussionConnection"];
    environment?: Maybe<ResolversParentTypes["Environment"]>;
    environments: ResolversParentTypes["EnvironmentConnection"];
    forks: ResolversParentTypes["RepositoryConnection"];
    issue?: Maybe<ResolversParentTypes["Issue"]>;
    issueOrPullRequest?: Maybe<ResolversParentTypes["IssueOrPullRequest"]>;
    issueTemplates?: Maybe<Array<ResolversParentTypes["IssueTemplate"]>>;
    issues: ResolversParentTypes["IssueConnection"];
    label?: Maybe<ResolversParentTypes["Label"]>;
    labels?: Maybe<ResolversParentTypes["LabelConnection"]>;
    latestRelease?: Maybe<ResolversParentTypes["Release"]>;
    mergeQueue?: Maybe<ResolversParentTypes["MergeQueue"]>;
    milestone?: Maybe<ResolversParentTypes["Milestone"]>;
    milestones?: Maybe<ResolversParentTypes["MilestoneConnection"]>;
    object?: Maybe<ResolversParentTypes["GitObject"]>;
    owner: ResolversParentTypes["RepositoryOwner"];
    packages: ResolversParentTypes["PackageConnection"];
    parent?: Maybe<ResolversParentTypes["Repository"]>;
    pinnedDiscussions: ResolversParentTypes["PinnedDiscussionConnection"];
    pinnedEnvironments?: Maybe<
      ResolversParentTypes["PinnedEnvironmentConnection"]
    >;
    pinnedIssues?: Maybe<ResolversParentTypes["PinnedIssueConnection"]>;
    project?: Maybe<ResolversParentTypes["Project"]>;
    projectV2?: Maybe<ResolversParentTypes["ProjectV2"]>;
    projects: ResolversParentTypes["ProjectConnection"];
    projectsV2: ResolversParentTypes["ProjectV2Connection"];
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
    pullRequestTemplates?: Maybe<
      Array<ResolversParentTypes["PullRequestTemplate"]>
    >;
    pullRequests: ResolversParentTypes["PullRequestConnection"];
    recentProjects: ResolversParentTypes["ProjectV2Connection"];
    ref?: Maybe<ResolversParentTypes["Ref"]>;
    release?: Maybe<ResolversParentTypes["Release"]>;
    releases: ResolversParentTypes["ReleaseConnection"];
    repositoryTopics: ResolversParentTypes["RepositoryTopicConnection"];
    ruleset?: Maybe<ResolversParentTypes["RepositoryRuleset"]>;
    rulesets?: Maybe<ResolversParentTypes["RepositoryRulesetConnection"]>;
    templateRepository?: Maybe<ResolversParentTypes["Repository"]>;
    vulnerabilityAlert?: Maybe<
      ResolversParentTypes["RepositoryVulnerabilityAlert"]
    >;
    vulnerabilityAlerts?: Maybe<
      ResolversParentTypes["RepositoryVulnerabilityAlertConnection"]
    >;
  };
  RepositoryAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>["RepositoryAuditEntryData"];
  RepositoryCodeowners: RepositoryCodeowners;
  RepositoryCodeownersError: RepositoryCodeownersError;
  RepositoryCollaboratorConnection: Omit<
    RepositoryCollaboratorConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["RepositoryCollaboratorEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["User"]>>>;
  };
  RepositoryCollaboratorEdge: Omit<
    RepositoryCollaboratorEdge,
    "node" | "permissionSources"
  > & {
    node: ResolversParentTypes["User"];
    permissionSources?: Maybe<Array<ResolversParentTypes["PermissionSource"]>>;
  };
  RepositoryConnection: Omit<RepositoryConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["RepositoryEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Repository"]>>>;
  };
  RepositoryContactLink: RepositoryContactLink;
  RepositoryDiscussionAuthor: ResolversInterfaceTypes<ResolversParentTypes>["RepositoryDiscussionAuthor"];
  RepositoryDiscussionCommentAuthor: ResolversInterfaceTypes<ResolversParentTypes>["RepositoryDiscussionCommentAuthor"];
  RepositoryEdge: Omit<RepositoryEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Repository"]>;
  };
  RepositoryIdConditionTarget: RepositoryIdConditionTarget;
  RepositoryIdConditionTargetInput: RepositoryIdConditionTargetInput;
  RepositoryInfo: ResolversInterfaceTypes<ResolversParentTypes>["RepositoryInfo"];
  RepositoryInteractionAbility: RepositoryInteractionAbility;
  RepositoryInvitation: Omit<
    RepositoryInvitation,
    "invitee" | "inviter" | "repository"
  > & {
    invitee?: Maybe<ResolversParentTypes["User"]>;
    inviter: ResolversParentTypes["User"];
    repository?: Maybe<ResolversParentTypes["RepositoryInfo"]>;
  };
  RepositoryInvitationConnection: Omit<
    RepositoryInvitationConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["RepositoryInvitationEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["RepositoryInvitation"]>>>;
  };
  RepositoryInvitationEdge: Omit<RepositoryInvitationEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["RepositoryInvitation"]>;
  };
  RepositoryInvitationOrder: RepositoryInvitationOrder;
  RepositoryMigration: RepositoryMigration;
  RepositoryMigrationConnection: RepositoryMigrationConnection;
  RepositoryMigrationEdge: RepositoryMigrationEdge;
  RepositoryMigrationOrder: RepositoryMigrationOrder;
  RepositoryNameConditionTarget: RepositoryNameConditionTarget;
  RepositoryNameConditionTargetInput: RepositoryNameConditionTargetInput;
  RepositoryNode: ResolversInterfaceTypes<ResolversParentTypes>["RepositoryNode"];
  RepositoryOrder: RepositoryOrder;
  RepositoryOwner: ResolversInterfaceTypes<ResolversParentTypes>["RepositoryOwner"];
  RepositoryPlanFeatures: RepositoryPlanFeatures;
  RepositoryPropertyConditionTarget: RepositoryPropertyConditionTarget;
  RepositoryPropertyConditionTargetInput: RepositoryPropertyConditionTargetInput;
  RepositoryRule: Omit<RepositoryRule, "parameters" | "repositoryRuleset"> & {
    parameters?: Maybe<ResolversParentTypes["RuleParameters"]>;
    repositoryRuleset?: Maybe<ResolversParentTypes["RepositoryRuleset"]>;
  };
  RepositoryRuleConditions: RepositoryRuleConditions;
  RepositoryRuleConditionsInput: RepositoryRuleConditionsInput;
  RepositoryRuleConnection: Omit<
    RepositoryRuleConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["RepositoryRuleEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["RepositoryRule"]>>>;
  };
  RepositoryRuleEdge: Omit<RepositoryRuleEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["RepositoryRule"]>;
  };
  RepositoryRuleInput: RepositoryRuleInput;
  RepositoryRuleOrder: RepositoryRuleOrder;
  RepositoryRuleset: Omit<
    RepositoryRuleset,
    "bypassActors" | "rules" | "source"
  > & {
    bypassActors?: Maybe<
      ResolversParentTypes["RepositoryRulesetBypassActorConnection"]
    >;
    rules?: Maybe<ResolversParentTypes["RepositoryRuleConnection"]>;
    source: ResolversParentTypes["RuleSource"];
  };
  RepositoryRulesetBypassActor: Omit<
    RepositoryRulesetBypassActor,
    "actor" | "repositoryRuleset"
  > & {
    actor?: Maybe<ResolversParentTypes["BypassActor"]>;
    repositoryRuleset?: Maybe<ResolversParentTypes["RepositoryRuleset"]>;
  };
  RepositoryRulesetBypassActorConnection: Omit<
    RepositoryRulesetBypassActorConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["RepositoryRulesetBypassActorEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["RepositoryRulesetBypassActor"]>>
    >;
  };
  RepositoryRulesetBypassActorEdge: Omit<
    RepositoryRulesetBypassActorEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["RepositoryRulesetBypassActor"]> };
  RepositoryRulesetBypassActorInput: RepositoryRulesetBypassActorInput;
  RepositoryRulesetConnection: Omit<
    RepositoryRulesetConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["RepositoryRulesetEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["RepositoryRuleset"]>>>;
  };
  RepositoryRulesetEdge: Omit<RepositoryRulesetEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["RepositoryRuleset"]>;
  };
  RepositoryTopic: Omit<RepositoryTopic, "topic"> & {
    topic: ResolversParentTypes["Topic"];
  };
  RepositoryTopicConnection: Omit<
    RepositoryTopicConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["RepositoryTopicEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["RepositoryTopic"]>>>;
  };
  RepositoryTopicEdge: Omit<RepositoryTopicEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["RepositoryTopic"]>;
  };
  RepositoryVisibilityChangeDisableAuditEntry: Omit<
    RepositoryVisibilityChangeDisableAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepositoryVisibilityChangeEnableAuditEntry: Omit<
    RepositoryVisibilityChangeEnableAuditEntry,
    "actor" | "organization" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  RepositoryVulnerabilityAlert: Omit<
    RepositoryVulnerabilityAlert,
    "dependabotUpdate" | "dismisser" | "repository"
  > & {
    dependabotUpdate?: Maybe<ResolversParentTypes["DependabotUpdate"]>;
    dismisser?: Maybe<ResolversParentTypes["User"]>;
    repository: ResolversParentTypes["Repository"];
  };
  RepositoryVulnerabilityAlertConnection: Omit<
    RepositoryVulnerabilityAlertConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["RepositoryVulnerabilityAlertEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["RepositoryVulnerabilityAlert"]>>
    >;
  };
  RepositoryVulnerabilityAlertEdge: Omit<
    RepositoryVulnerabilityAlertEdge,
    "node"
  > & { node?: Maybe<ResolversParentTypes["RepositoryVulnerabilityAlert"]> };
  RequestReviewsInput: RequestReviewsInput;
  RequestReviewsPayload: Omit<
    RequestReviewsPayload,
    "actor" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  RequestedReviewer: ResolversUnionTypes<ResolversParentTypes>["RequestedReviewer"];
  RequestedReviewerConnection: Omit<
    RequestedReviewerConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["RequestedReviewerEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["RequestedReviewer"]>>>;
  };
  RequestedReviewerEdge: Omit<RequestedReviewerEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["RequestedReviewer"]>;
  };
  RequirableByPullRequest: ResolversInterfaceTypes<ResolversParentTypes>["RequirableByPullRequest"];
  RequiredDeploymentsParameters: RequiredDeploymentsParameters;
  RequiredDeploymentsParametersInput: RequiredDeploymentsParametersInput;
  RequiredStatusCheckDescription: Omit<
    RequiredStatusCheckDescription,
    "app"
  > & { app?: Maybe<ResolversParentTypes["App"]> };
  RequiredStatusCheckInput: RequiredStatusCheckInput;
  RequiredStatusChecksParameters: RequiredStatusChecksParameters;
  RequiredStatusChecksParametersInput: RequiredStatusChecksParametersInput;
  RerequestCheckSuiteInput: RerequestCheckSuiteInput;
  RerequestCheckSuitePayload: Omit<RerequestCheckSuitePayload, "checkSuite"> & {
    checkSuite?: Maybe<ResolversParentTypes["CheckSuite"]>;
  };
  ResolveReviewThreadInput: ResolveReviewThreadInput;
  ResolveReviewThreadPayload: Omit<ResolveReviewThreadPayload, "thread"> & {
    thread?: Maybe<ResolversParentTypes["PullRequestReviewThread"]>;
  };
  RestrictedContribution: Omit<RestrictedContribution, "user"> & {
    user: ResolversParentTypes["User"];
  };
  RetireSponsorsTierInput: RetireSponsorsTierInput;
  RetireSponsorsTierPayload: Omit<RetireSponsorsTierPayload, "sponsorsTier"> & {
    sponsorsTier?: Maybe<ResolversParentTypes["SponsorsTier"]>;
  };
  RevertPullRequestInput: RevertPullRequestInput;
  RevertPullRequestPayload: Omit<
    RevertPullRequestPayload,
    "pullRequest" | "revertPullRequest"
  > & {
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
    revertPullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  ReviewDismissalAllowance: Omit<
    ReviewDismissalAllowance,
    "actor" | "branchProtectionRule"
  > & {
    actor?: Maybe<ResolversParentTypes["ReviewDismissalAllowanceActor"]>;
    branchProtectionRule?: Maybe<ResolversParentTypes["BranchProtectionRule"]>;
  };
  ReviewDismissalAllowanceActor: ResolversUnionTypes<ResolversParentTypes>["ReviewDismissalAllowanceActor"];
  ReviewDismissalAllowanceConnection: Omit<
    ReviewDismissalAllowanceConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["ReviewDismissalAllowanceEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["ReviewDismissalAllowance"]>>
    >;
  };
  ReviewDismissalAllowanceEdge: Omit<ReviewDismissalAllowanceEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ReviewDismissalAllowance"]>;
  };
  ReviewDismissedEvent: Omit<
    ReviewDismissedEvent,
    "actor" | "pullRequest" | "pullRequestCommit" | "review"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
    pullRequestCommit?: Maybe<ResolversParentTypes["PullRequestCommit"]>;
    review?: Maybe<ResolversParentTypes["PullRequestReview"]>;
  };
  ReviewRequest: Omit<ReviewRequest, "pullRequest" | "requestedReviewer"> & {
    pullRequest: ResolversParentTypes["PullRequest"];
    requestedReviewer?: Maybe<ResolversParentTypes["RequestedReviewer"]>;
  };
  ReviewRequestConnection: Omit<ReviewRequestConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["ReviewRequestEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["ReviewRequest"]>>>;
  };
  ReviewRequestEdge: Omit<ReviewRequestEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["ReviewRequest"]>;
  };
  ReviewRequestRemovedEvent: Omit<
    ReviewRequestRemovedEvent,
    "actor" | "pullRequest" | "requestedReviewer"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
    requestedReviewer?: Maybe<ResolversParentTypes["RequestedReviewer"]>;
  };
  ReviewRequestedEvent: Omit<
    ReviewRequestedEvent,
    "actor" | "pullRequest" | "requestedReviewer"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest: ResolversParentTypes["PullRequest"];
    requestedReviewer?: Maybe<ResolversParentTypes["RequestedReviewer"]>;
  };
  ReviewStatusHovercardContext: ReviewStatusHovercardContext;
  RevokeEnterpriseOrganizationsMigratorRoleInput: RevokeEnterpriseOrganizationsMigratorRoleInput;
  RevokeEnterpriseOrganizationsMigratorRolePayload: Omit<
    RevokeEnterpriseOrganizationsMigratorRolePayload,
    "organizations"
  > & { organizations?: Maybe<ResolversParentTypes["OrganizationConnection"]> };
  RevokeMigratorRoleInput: RevokeMigratorRoleInput;
  RevokeMigratorRolePayload: RevokeMigratorRolePayload;
  RuleParameters: ResolversUnionTypes<ResolversParentTypes>["RuleParameters"];
  RuleParametersInput: RuleParametersInput;
  RuleSource: ResolversUnionTypes<ResolversParentTypes>["RuleSource"];
  SavedReply: Omit<SavedReply, "user"> & {
    user?: Maybe<ResolversParentTypes["Actor"]>;
  };
  SavedReplyConnection: Omit<SavedReplyConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["SavedReplyEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["SavedReply"]>>>;
  };
  SavedReplyEdge: Omit<SavedReplyEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["SavedReply"]>;
  };
  SavedReplyOrder: SavedReplyOrder;
  SearchResultItem: ResolversUnionTypes<ResolversParentTypes>["SearchResultItem"];
  SearchResultItemConnection: Omit<
    SearchResultItemConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["SearchResultItemEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["SearchResultItem"]>>>;
  };
  SearchResultItemEdge: Omit<SearchResultItemEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["SearchResultItem"]>;
  };
  SecurityAdvisory: SecurityAdvisory;
  SecurityAdvisoryConnection: SecurityAdvisoryConnection;
  SecurityAdvisoryEdge: SecurityAdvisoryEdge;
  SecurityAdvisoryIdentifier: SecurityAdvisoryIdentifier;
  SecurityAdvisoryIdentifierFilter: SecurityAdvisoryIdentifierFilter;
  SecurityAdvisoryOrder: SecurityAdvisoryOrder;
  SecurityAdvisoryPackage: SecurityAdvisoryPackage;
  SecurityAdvisoryPackageVersion: SecurityAdvisoryPackageVersion;
  SecurityAdvisoryReference: SecurityAdvisoryReference;
  SecurityVulnerability: SecurityVulnerability;
  SecurityVulnerabilityConnection: SecurityVulnerabilityConnection;
  SecurityVulnerabilityEdge: SecurityVulnerabilityEdge;
  SecurityVulnerabilityOrder: SecurityVulnerabilityOrder;
  SetEnterpriseIdentityProviderInput: SetEnterpriseIdentityProviderInput;
  SetEnterpriseIdentityProviderPayload: Omit<
    SetEnterpriseIdentityProviderPayload,
    "identityProvider"
  > & {
    identityProvider?: Maybe<
      ResolversParentTypes["EnterpriseIdentityProvider"]
    >;
  };
  SetOrganizationInteractionLimitInput: SetOrganizationInteractionLimitInput;
  SetOrganizationInteractionLimitPayload: Omit<
    SetOrganizationInteractionLimitPayload,
    "organization"
  > & { organization?: Maybe<ResolversParentTypes["Organization"]> };
  SetRepositoryInteractionLimitInput: SetRepositoryInteractionLimitInput;
  SetRepositoryInteractionLimitPayload: Omit<
    SetRepositoryInteractionLimitPayload,
    "repository"
  > & { repository?: Maybe<ResolversParentTypes["Repository"]> };
  SetUserInteractionLimitInput: SetUserInteractionLimitInput;
  SetUserInteractionLimitPayload: Omit<
    SetUserInteractionLimitPayload,
    "user"
  > & { user?: Maybe<ResolversParentTypes["User"]> };
  SmimeSignature: Omit<SmimeSignature, "signer"> & {
    signer?: Maybe<ResolversParentTypes["User"]>;
  };
  SocialAccount: SocialAccount;
  SocialAccountConnection: SocialAccountConnection;
  SocialAccountEdge: SocialAccountEdge;
  Sponsor: ResolversUnionTypes<ResolversParentTypes>["Sponsor"];
  SponsorAndLifetimeValue: Omit<
    SponsorAndLifetimeValue,
    "sponsor" | "sponsorable"
  > & {
    sponsor: ResolversParentTypes["Sponsorable"];
    sponsorable: ResolversParentTypes["Sponsorable"];
  };
  SponsorAndLifetimeValueConnection: Omit<
    SponsorAndLifetimeValueConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["SponsorAndLifetimeValueEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["SponsorAndLifetimeValue"]>>
    >;
  };
  SponsorAndLifetimeValueEdge: Omit<SponsorAndLifetimeValueEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["SponsorAndLifetimeValue"]>;
  };
  SponsorAndLifetimeValueOrder: SponsorAndLifetimeValueOrder;
  SponsorConnection: Omit<SponsorConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["SponsorEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Sponsor"]>>>;
  };
  SponsorEdge: Omit<SponsorEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Sponsor"]>;
  };
  SponsorOrder: SponsorOrder;
  Sponsorable: ResolversInterfaceTypes<ResolversParentTypes>["Sponsorable"];
  SponsorableItem: ResolversUnionTypes<ResolversParentTypes>["SponsorableItem"];
  SponsorableItemConnection: Omit<
    SponsorableItemConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["SponsorableItemEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["SponsorableItem"]>>>;
  };
  SponsorableItemEdge: Omit<SponsorableItemEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["SponsorableItem"]>;
  };
  SponsorableOrder: SponsorableOrder;
  SponsorsActivity: Omit<
    SponsorsActivity,
    "previousSponsorsTier" | "sponsor" | "sponsorable" | "sponsorsTier"
  > & {
    previousSponsorsTier?: Maybe<ResolversParentTypes["SponsorsTier"]>;
    sponsor?: Maybe<ResolversParentTypes["Sponsor"]>;
    sponsorable: ResolversParentTypes["Sponsorable"];
    sponsorsTier?: Maybe<ResolversParentTypes["SponsorsTier"]>;
  };
  SponsorsActivityConnection: Omit<
    SponsorsActivityConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["SponsorsActivityEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["SponsorsActivity"]>>>;
  };
  SponsorsActivityEdge: Omit<SponsorsActivityEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["SponsorsActivity"]>;
  };
  SponsorsActivityOrder: SponsorsActivityOrder;
  SponsorsGoal: SponsorsGoal;
  SponsorsListing: Omit<
    SponsorsListing,
    "activeGoal" | "featuredItems" | "fiscalHost" | "sponsorable" | "tiers"
  > & {
    activeGoal?: Maybe<ResolversParentTypes["SponsorsGoal"]>;
    featuredItems: Array<ResolversParentTypes["SponsorsListingFeaturedItem"]>;
    fiscalHost?: Maybe<ResolversParentTypes["Organization"]>;
    sponsorable: ResolversParentTypes["Sponsorable"];
    tiers?: Maybe<ResolversParentTypes["SponsorsTierConnection"]>;
  };
  SponsorsListingFeatureableItem: ResolversUnionTypes<ResolversParentTypes>["SponsorsListingFeatureableItem"];
  SponsorsListingFeaturedItem: Omit<
    SponsorsListingFeaturedItem,
    "featureable" | "sponsorsListing"
  > & {
    featureable: ResolversParentTypes["SponsorsListingFeatureableItem"];
    sponsorsListing: ResolversParentTypes["SponsorsListing"];
  };
  SponsorsTier: Omit<
    SponsorsTier,
    "adminInfo" | "closestLesserValueTier" | "sponsorsListing"
  > & {
    adminInfo?: Maybe<ResolversParentTypes["SponsorsTierAdminInfo"]>;
    closestLesserValueTier?: Maybe<ResolversParentTypes["SponsorsTier"]>;
    sponsorsListing: ResolversParentTypes["SponsorsListing"];
  };
  SponsorsTierAdminInfo: Omit<SponsorsTierAdminInfo, "sponsorships"> & {
    sponsorships: ResolversParentTypes["SponsorshipConnection"];
  };
  SponsorsTierConnection: Omit<SponsorsTierConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["SponsorsTierEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["SponsorsTier"]>>>;
  };
  SponsorsTierEdge: Omit<SponsorsTierEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["SponsorsTier"]>;
  };
  SponsorsTierOrder: SponsorsTierOrder;
  Sponsorship: Omit<
    Sponsorship,
    "maintainer" | "sponsor" | "sponsorEntity" | "sponsorable" | "tier"
  > & {
    maintainer: ResolversParentTypes["User"];
    sponsor?: Maybe<ResolversParentTypes["User"]>;
    sponsorEntity?: Maybe<ResolversParentTypes["Sponsor"]>;
    sponsorable: ResolversParentTypes["Sponsorable"];
    tier?: Maybe<ResolversParentTypes["SponsorsTier"]>;
  };
  SponsorshipConnection: Omit<SponsorshipConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["SponsorshipEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Sponsorship"]>>>;
  };
  SponsorshipEdge: Omit<SponsorshipEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Sponsorship"]>;
  };
  SponsorshipNewsletter: Omit<
    SponsorshipNewsletter,
    "author" | "sponsorable"
  > & {
    author?: Maybe<ResolversParentTypes["User"]>;
    sponsorable: ResolversParentTypes["Sponsorable"];
  };
  SponsorshipNewsletterConnection: Omit<
    SponsorshipNewsletterConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["SponsorshipNewsletterEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["SponsorshipNewsletter"]>>>;
  };
  SponsorshipNewsletterEdge: Omit<SponsorshipNewsletterEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["SponsorshipNewsletter"]>;
  };
  SponsorshipNewsletterOrder: SponsorshipNewsletterOrder;
  SponsorshipOrder: SponsorshipOrder;
  SshSignature: Omit<SshSignature, "signer"> & {
    signer?: Maybe<ResolversParentTypes["User"]>;
  };
  StarOrder: StarOrder;
  StargazerConnection: Omit<StargazerConnection, "nodes"> & {
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["User"]>>>;
  };
  StargazerEdge: Omit<StargazerEdge, "node"> & {
    node: ResolversParentTypes["User"];
  };
  Starrable: ResolversInterfaceTypes<ResolversParentTypes>["Starrable"];
  StarredRepositoryConnection: Omit<
    StarredRepositoryConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["StarredRepositoryEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Repository"]>>>;
  };
  StarredRepositoryEdge: Omit<StarredRepositoryEdge, "node"> & {
    node: ResolversParentTypes["Repository"];
  };
  StartOrganizationMigrationInput: StartOrganizationMigrationInput;
  StartOrganizationMigrationPayload: StartOrganizationMigrationPayload;
  StartRepositoryMigrationInput: StartRepositoryMigrationInput;
  StartRepositoryMigrationPayload: StartRepositoryMigrationPayload;
  Status: Omit<
    Status,
    "combinedContexts" | "commit" | "context" | "contexts"
  > & {
    combinedContexts: ResolversParentTypes["StatusCheckRollupContextConnection"];
    commit?: Maybe<ResolversParentTypes["Commit"]>;
    context?: Maybe<ResolversParentTypes["StatusContext"]>;
    contexts: Array<ResolversParentTypes["StatusContext"]>;
  };
  StatusCheckConfiguration: StatusCheckConfiguration;
  StatusCheckConfigurationInput: StatusCheckConfigurationInput;
  StatusCheckRollup: Omit<StatusCheckRollup, "commit" | "contexts"> & {
    commit?: Maybe<ResolversParentTypes["Commit"]>;
    contexts: ResolversParentTypes["StatusCheckRollupContextConnection"];
  };
  StatusCheckRollupContext: ResolversUnionTypes<ResolversParentTypes>["StatusCheckRollupContext"];
  StatusCheckRollupContextConnection: Omit<
    StatusCheckRollupContextConnection,
    "checkRunCountsByState" | "edges" | "nodes"
  > & {
    checkRunCountsByState?: Maybe<
      Array<ResolversParentTypes["CheckRunStateCount"]>
    >;
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["StatusCheckRollupContextEdge"]>>
    >;
    nodes?: Maybe<
      Array<Maybe<ResolversParentTypes["StatusCheckRollupContext"]>>
    >;
  };
  StatusCheckRollupContextEdge: Omit<StatusCheckRollupContextEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["StatusCheckRollupContext"]>;
  };
  StatusContext: Omit<StatusContext, "commit" | "creator"> & {
    commit?: Maybe<ResolversParentTypes["Commit"]>;
    creator?: Maybe<ResolversParentTypes["Actor"]>;
  };
  StatusContextStateCount: StatusContextStateCount;
  String: Scalars["String"]["output"];
  StripeConnectAccount: Omit<StripeConnectAccount, "sponsorsListing"> & {
    sponsorsListing: ResolversParentTypes["SponsorsListing"];
  };
  SubmitPullRequestReviewInput: SubmitPullRequestReviewInput;
  SubmitPullRequestReviewPayload: Omit<
    SubmitPullRequestReviewPayload,
    "pullRequestReview"
  > & { pullRequestReview?: Maybe<ResolversParentTypes["PullRequestReview"]> };
  Submodule: Submodule;
  SubmoduleConnection: SubmoduleConnection;
  SubmoduleEdge: SubmoduleEdge;
  Subscribable: ResolversInterfaceTypes<ResolversParentTypes>["Subscribable"];
  SubscribableThread: ResolversInterfaceTypes<ResolversParentTypes>["SubscribableThread"];
  SubscribedEvent: Omit<SubscribedEvent, "actor" | "subscribable"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    subscribable: ResolversParentTypes["Subscribable"];
  };
  SuggestedReviewer: Omit<SuggestedReviewer, "reviewer"> & {
    reviewer: ResolversParentTypes["User"];
  };
  Tag: Omit<Tag, "repository" | "target"> & {
    repository: ResolversParentTypes["Repository"];
    target: ResolversParentTypes["GitObject"];
  };
  TagNamePatternParameters: TagNamePatternParameters;
  TagNamePatternParametersInput: TagNamePatternParametersInput;
  Team: Omit<
    Team,
    | "ancestors"
    | "childTeams"
    | "discussion"
    | "discussions"
    | "invitations"
    | "memberStatuses"
    | "organization"
    | "parentTeam"
    | "projectV2"
    | "projectsV2"
    | "repositories"
  > & {
    ancestors: ResolversParentTypes["TeamConnection"];
    childTeams: ResolversParentTypes["TeamConnection"];
    discussion?: Maybe<ResolversParentTypes["TeamDiscussion"]>;
    discussions: ResolversParentTypes["TeamDiscussionConnection"];
    invitations?: Maybe<
      ResolversParentTypes["OrganizationInvitationConnection"]
    >;
    memberStatuses: ResolversParentTypes["UserStatusConnection"];
    organization: ResolversParentTypes["Organization"];
    parentTeam?: Maybe<ResolversParentTypes["Team"]>;
    projectV2?: Maybe<ResolversParentTypes["ProjectV2"]>;
    projectsV2: ResolversParentTypes["ProjectV2Connection"];
    repositories: ResolversParentTypes["TeamRepositoryConnection"];
  };
  TeamAddMemberAuditEntry: Omit<
    TeamAddMemberAuditEntry,
    "actor" | "organization" | "team" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    team?: Maybe<ResolversParentTypes["Team"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  TeamAddRepositoryAuditEntry: Omit<
    TeamAddRepositoryAuditEntry,
    "actor" | "organization" | "repository" | "team" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    team?: Maybe<ResolversParentTypes["Team"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  TeamAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>["TeamAuditEntryData"];
  TeamChangeParentTeamAuditEntry: Omit<
    TeamChangeParentTeamAuditEntry,
    "actor" | "organization" | "parentTeam" | "parentTeamWas" | "team" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    parentTeam?: Maybe<ResolversParentTypes["Team"]>;
    parentTeamWas?: Maybe<ResolversParentTypes["Team"]>;
    team?: Maybe<ResolversParentTypes["Team"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  TeamConnection: Omit<TeamConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["TeamEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Team"]>>>;
  };
  TeamDiscussion: Omit<
    TeamDiscussion,
    | "author"
    | "comments"
    | "editor"
    | "reactionGroups"
    | "reactions"
    | "team"
    | "userContentEdits"
  > & {
    author?: Maybe<ResolversParentTypes["Actor"]>;
    comments: ResolversParentTypes["TeamDiscussionCommentConnection"];
    editor?: Maybe<ResolversParentTypes["Actor"]>;
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    reactions: ResolversParentTypes["ReactionConnection"];
    team: ResolversParentTypes["Team"];
    userContentEdits?: Maybe<ResolversParentTypes["UserContentEditConnection"]>;
  };
  TeamDiscussionComment: Omit<
    TeamDiscussionComment,
    | "author"
    | "discussion"
    | "editor"
    | "reactionGroups"
    | "reactions"
    | "userContentEdits"
  > & {
    author?: Maybe<ResolversParentTypes["Actor"]>;
    discussion: ResolversParentTypes["TeamDiscussion"];
    editor?: Maybe<ResolversParentTypes["Actor"]>;
    reactionGroups?: Maybe<Array<ResolversParentTypes["ReactionGroup"]>>;
    reactions: ResolversParentTypes["ReactionConnection"];
    userContentEdits?: Maybe<ResolversParentTypes["UserContentEditConnection"]>;
  };
  TeamDiscussionCommentConnection: Omit<
    TeamDiscussionCommentConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<
      Array<Maybe<ResolversParentTypes["TeamDiscussionCommentEdge"]>>
    >;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["TeamDiscussionComment"]>>>;
  };
  TeamDiscussionCommentEdge: Omit<TeamDiscussionCommentEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["TeamDiscussionComment"]>;
  };
  TeamDiscussionCommentOrder: TeamDiscussionCommentOrder;
  TeamDiscussionConnection: Omit<
    TeamDiscussionConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["TeamDiscussionEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["TeamDiscussion"]>>>;
  };
  TeamDiscussionEdge: Omit<TeamDiscussionEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["TeamDiscussion"]>;
  };
  TeamDiscussionOrder: TeamDiscussionOrder;
  TeamEdge: Omit<TeamEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["Team"]>;
  };
  TeamMemberConnection: Omit<TeamMemberConnection, "nodes"> & {
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["User"]>>>;
  };
  TeamMemberEdge: Omit<TeamMemberEdge, "node"> & {
    node: ResolversParentTypes["User"];
  };
  TeamMemberOrder: TeamMemberOrder;
  TeamOrder: TeamOrder;
  TeamRemoveMemberAuditEntry: Omit<
    TeamRemoveMemberAuditEntry,
    "actor" | "organization" | "team" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    team?: Maybe<ResolversParentTypes["Team"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  TeamRemoveRepositoryAuditEntry: Omit<
    TeamRemoveRepositoryAuditEntry,
    "actor" | "organization" | "repository" | "team" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["AuditEntryActor"]>;
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    team?: Maybe<ResolversParentTypes["Team"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  TeamRepositoryConnection: Omit<
    TeamRepositoryConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["TeamRepositoryEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["Repository"]>>>;
  };
  TeamRepositoryEdge: Omit<TeamRepositoryEdge, "node"> & {
    node: ResolversParentTypes["Repository"];
  };
  TeamRepositoryOrder: TeamRepositoryOrder;
  TextMatch: TextMatch;
  TextMatchHighlight: TextMatchHighlight;
  Topic: Omit<Topic, "relatedTopics" | "repositories"> & {
    relatedTopics: Array<ResolversParentTypes["Topic"]>;
    repositories: ResolversParentTypes["RepositoryConnection"];
  };
  TopicAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>["TopicAuditEntryData"];
  TransferEnterpriseOrganizationInput: TransferEnterpriseOrganizationInput;
  TransferEnterpriseOrganizationPayload: Omit<
    TransferEnterpriseOrganizationPayload,
    "organization"
  > & { organization?: Maybe<ResolversParentTypes["Organization"]> };
  TransferIssueInput: TransferIssueInput;
  TransferIssuePayload: Omit<TransferIssuePayload, "issue"> & {
    issue?: Maybe<ResolversParentTypes["Issue"]>;
  };
  TransferredEvent: Omit<
    TransferredEvent,
    "actor" | "fromRepository" | "issue"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    fromRepository?: Maybe<ResolversParentTypes["Repository"]>;
    issue: ResolversParentTypes["Issue"];
  };
  Tree: Omit<Tree, "entries" | "repository"> & {
    entries?: Maybe<Array<ResolversParentTypes["TreeEntry"]>>;
    repository: ResolversParentTypes["Repository"];
  };
  TreeEntry: Omit<TreeEntry, "object" | "repository"> & {
    object?: Maybe<ResolversParentTypes["GitObject"]>;
    repository: ResolversParentTypes["Repository"];
  };
  URI: Scalars["URI"]["output"];
  UnarchiveProjectV2ItemInput: UnarchiveProjectV2ItemInput;
  UnarchiveProjectV2ItemPayload: Omit<UnarchiveProjectV2ItemPayload, "item"> & {
    item?: Maybe<ResolversParentTypes["ProjectV2Item"]>;
  };
  UnarchiveRepositoryInput: UnarchiveRepositoryInput;
  UnarchiveRepositoryPayload: Omit<UnarchiveRepositoryPayload, "repository"> & {
    repository?: Maybe<ResolversParentTypes["Repository"]>;
  };
  UnassignedEvent: Omit<
    UnassignedEvent,
    "actor" | "assignable" | "assignee" | "user"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    assignable: ResolversParentTypes["Assignable"];
    assignee?: Maybe<ResolversParentTypes["Assignee"]>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  UnfollowOrganizationInput: UnfollowOrganizationInput;
  UnfollowOrganizationPayload: Omit<
    UnfollowOrganizationPayload,
    "organization"
  > & { organization?: Maybe<ResolversParentTypes["Organization"]> };
  UnfollowUserInput: UnfollowUserInput;
  UnfollowUserPayload: Omit<UnfollowUserPayload, "user"> & {
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  UniformResourceLocatable: ResolversInterfaceTypes<ResolversParentTypes>["UniformResourceLocatable"];
  UnknownSignature: Omit<UnknownSignature, "signer"> & {
    signer?: Maybe<ResolversParentTypes["User"]>;
  };
  UnlabeledEvent: Omit<UnlabeledEvent, "actor" | "label" | "labelable"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    label: ResolversParentTypes["Label"];
    labelable: ResolversParentTypes["Labelable"];
  };
  UnlinkProjectV2FromRepositoryInput: UnlinkProjectV2FromRepositoryInput;
  UnlinkProjectV2FromRepositoryPayload: Omit<
    UnlinkProjectV2FromRepositoryPayload,
    "repository"
  > & { repository?: Maybe<ResolversParentTypes["Repository"]> };
  UnlinkProjectV2FromTeamInput: UnlinkProjectV2FromTeamInput;
  UnlinkProjectV2FromTeamPayload: Omit<
    UnlinkProjectV2FromTeamPayload,
    "team"
  > & { team?: Maybe<ResolversParentTypes["Team"]> };
  UnlinkRepositoryFromProjectInput: UnlinkRepositoryFromProjectInput;
  UnlinkRepositoryFromProjectPayload: Omit<
    UnlinkRepositoryFromProjectPayload,
    "project" | "repository"
  > & {
    project?: Maybe<ResolversParentTypes["Project"]>;
    repository?: Maybe<ResolversParentTypes["Repository"]>;
  };
  UnlockLockableInput: UnlockLockableInput;
  UnlockLockablePayload: Omit<
    UnlockLockablePayload,
    "actor" | "unlockedRecord"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    unlockedRecord?: Maybe<ResolversParentTypes["Lockable"]>;
  };
  UnlockedEvent: Omit<UnlockedEvent, "actor" | "lockable"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    lockable: ResolversParentTypes["Lockable"];
  };
  UnmarkDiscussionCommentAsAnswerInput: UnmarkDiscussionCommentAsAnswerInput;
  UnmarkDiscussionCommentAsAnswerPayload: Omit<
    UnmarkDiscussionCommentAsAnswerPayload,
    "discussion"
  > & { discussion?: Maybe<ResolversParentTypes["Discussion"]> };
  UnmarkFileAsViewedInput: UnmarkFileAsViewedInput;
  UnmarkFileAsViewedPayload: Omit<UnmarkFileAsViewedPayload, "pullRequest"> & {
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  UnmarkIssueAsDuplicateInput: UnmarkIssueAsDuplicateInput;
  UnmarkIssueAsDuplicatePayload: Omit<
    UnmarkIssueAsDuplicatePayload,
    "duplicate"
  > & { duplicate?: Maybe<ResolversParentTypes["IssueOrPullRequest"]> };
  UnmarkProjectV2AsTemplateInput: UnmarkProjectV2AsTemplateInput;
  UnmarkProjectV2AsTemplatePayload: Omit<
    UnmarkProjectV2AsTemplatePayload,
    "projectV2"
  > & { projectV2?: Maybe<ResolversParentTypes["ProjectV2"]> };
  UnmarkedAsDuplicateEvent: Omit<
    UnmarkedAsDuplicateEvent,
    "actor" | "canonical" | "duplicate"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    canonical?: Maybe<ResolversParentTypes["IssueOrPullRequest"]>;
    duplicate?: Maybe<ResolversParentTypes["IssueOrPullRequest"]>;
  };
  UnminimizeCommentInput: UnminimizeCommentInput;
  UnminimizeCommentPayload: Omit<
    UnminimizeCommentPayload,
    "unminimizedComment"
  > & { unminimizedComment?: Maybe<ResolversParentTypes["Minimizable"]> };
  UnpinIssueInput: UnpinIssueInput;
  UnpinIssuePayload: Omit<UnpinIssuePayload, "issue"> & {
    issue?: Maybe<ResolversParentTypes["Issue"]>;
  };
  UnpinnedEvent: Omit<UnpinnedEvent, "actor" | "issue"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    issue: ResolversParentTypes["Issue"];
  };
  UnresolveReviewThreadInput: UnresolveReviewThreadInput;
  UnresolveReviewThreadPayload: Omit<UnresolveReviewThreadPayload, "thread"> & {
    thread?: Maybe<ResolversParentTypes["PullRequestReviewThread"]>;
  };
  UnsubscribeFromNotificationsInput: UnsubscribeFromNotificationsInput;
  UnsubscribeFromNotificationsPayload: UnsubscribeFromNotificationsPayload;
  UnsubscribedEvent: Omit<UnsubscribedEvent, "actor" | "subscribable"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    subscribable: ResolversParentTypes["Subscribable"];
  };
  Updatable: ResolversInterfaceTypes<ResolversParentTypes>["Updatable"];
  UpdatableComment: ResolversInterfaceTypes<ResolversParentTypes>["UpdatableComment"];
  UpdateBranchProtectionRuleInput: UpdateBranchProtectionRuleInput;
  UpdateBranchProtectionRulePayload: Omit<
    UpdateBranchProtectionRulePayload,
    "branchProtectionRule"
  > & {
    branchProtectionRule?: Maybe<ResolversParentTypes["BranchProtectionRule"]>;
  };
  UpdateCheckRunInput: UpdateCheckRunInput;
  UpdateCheckRunPayload: Omit<UpdateCheckRunPayload, "checkRun"> & {
    checkRun?: Maybe<ResolversParentTypes["CheckRun"]>;
  };
  UpdateCheckSuitePreferencesInput: UpdateCheckSuitePreferencesInput;
  UpdateCheckSuitePreferencesPayload: Omit<
    UpdateCheckSuitePreferencesPayload,
    "repository"
  > & { repository?: Maybe<ResolversParentTypes["Repository"]> };
  UpdateDiscussionCommentInput: UpdateDiscussionCommentInput;
  UpdateDiscussionCommentPayload: Omit<
    UpdateDiscussionCommentPayload,
    "comment"
  > & { comment?: Maybe<ResolversParentTypes["DiscussionComment"]> };
  UpdateDiscussionInput: UpdateDiscussionInput;
  UpdateDiscussionPayload: Omit<UpdateDiscussionPayload, "discussion"> & {
    discussion?: Maybe<ResolversParentTypes["Discussion"]>;
  };
  UpdateEnterpriseAdministratorRoleInput: UpdateEnterpriseAdministratorRoleInput;
  UpdateEnterpriseAdministratorRolePayload: UpdateEnterpriseAdministratorRolePayload;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: Omit<
    UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseDefaultRepositoryPermissionSettingInput: UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: Omit<
    UpdateEnterpriseDefaultRepositoryPermissionSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: Omit<
    UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: Omit<
    UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseMembersCanDeleteIssuesSettingInput: UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
  UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: Omit<
    UpdateEnterpriseMembersCanDeleteIssuesSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: Omit<
    UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: Omit<
    UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseMembersCanMakePurchasesSettingInput: UpdateEnterpriseMembersCanMakePurchasesSettingInput;
  UpdateEnterpriseMembersCanMakePurchasesSettingPayload: Omit<
    UpdateEnterpriseMembersCanMakePurchasesSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: Omit<
    UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: Omit<
    UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseOrganizationProjectsSettingInput: UpdateEnterpriseOrganizationProjectsSettingInput;
  UpdateEnterpriseOrganizationProjectsSettingPayload: Omit<
    UpdateEnterpriseOrganizationProjectsSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseOwnerOrganizationRoleInput: UpdateEnterpriseOwnerOrganizationRoleInput;
  UpdateEnterpriseOwnerOrganizationRolePayload: UpdateEnterpriseOwnerOrganizationRolePayload;
  UpdateEnterpriseProfileInput: UpdateEnterpriseProfileInput;
  UpdateEnterpriseProfilePayload: Omit<
    UpdateEnterpriseProfilePayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseRepositoryProjectsSettingInput: UpdateEnterpriseRepositoryProjectsSettingInput;
  UpdateEnterpriseRepositoryProjectsSettingPayload: Omit<
    UpdateEnterpriseRepositoryProjectsSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseTeamDiscussionsSettingInput: UpdateEnterpriseTeamDiscussionsSettingInput;
  UpdateEnterpriseTeamDiscussionsSettingPayload: Omit<
    UpdateEnterpriseTeamDiscussionsSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: Omit<
    UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload,
    "enterprise"
  > & { enterprise?: Maybe<ResolversParentTypes["Enterprise"]> };
  UpdateEnvironmentInput: UpdateEnvironmentInput;
  UpdateEnvironmentPayload: Omit<UpdateEnvironmentPayload, "environment"> & {
    environment?: Maybe<ResolversParentTypes["Environment"]>;
  };
  UpdateIpAllowListEnabledSettingInput: UpdateIpAllowListEnabledSettingInput;
  UpdateIpAllowListEnabledSettingPayload: Omit<
    UpdateIpAllowListEnabledSettingPayload,
    "owner"
  > & { owner?: Maybe<ResolversParentTypes["IpAllowListOwner"]> };
  UpdateIpAllowListEntryInput: UpdateIpAllowListEntryInput;
  UpdateIpAllowListEntryPayload: Omit<
    UpdateIpAllowListEntryPayload,
    "ipAllowListEntry"
  > & { ipAllowListEntry?: Maybe<ResolversParentTypes["IpAllowListEntry"]> };
  UpdateIpAllowListForInstalledAppsEnabledSettingInput: UpdateIpAllowListForInstalledAppsEnabledSettingInput;
  UpdateIpAllowListForInstalledAppsEnabledSettingPayload: Omit<
    UpdateIpAllowListForInstalledAppsEnabledSettingPayload,
    "owner"
  > & { owner?: Maybe<ResolversParentTypes["IpAllowListOwner"]> };
  UpdateIssueCommentInput: UpdateIssueCommentInput;
  UpdateIssueCommentPayload: Omit<UpdateIssueCommentPayload, "issueComment"> & {
    issueComment?: Maybe<ResolversParentTypes["IssueComment"]>;
  };
  UpdateIssueInput: UpdateIssueInput;
  UpdateIssuePayload: Omit<UpdateIssuePayload, "actor" | "issue"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    issue?: Maybe<ResolversParentTypes["Issue"]>;
  };
  UpdateLabelInput: UpdateLabelInput;
  UpdateLabelPayload: Omit<UpdateLabelPayload, "label"> & {
    label?: Maybe<ResolversParentTypes["Label"]>;
  };
  UpdateNotificationRestrictionSettingInput: UpdateNotificationRestrictionSettingInput;
  UpdateNotificationRestrictionSettingPayload: Omit<
    UpdateNotificationRestrictionSettingPayload,
    "owner"
  > & { owner?: Maybe<ResolversParentTypes["VerifiableDomainOwner"]> };
  UpdateOrganizationAllowPrivateRepositoryForkingSettingInput: UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
  UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload: Omit<
    UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload,
    "organization"
  > & { organization?: Maybe<ResolversParentTypes["Organization"]> };
  UpdateOrganizationWebCommitSignoffSettingInput: UpdateOrganizationWebCommitSignoffSettingInput;
  UpdateOrganizationWebCommitSignoffSettingPayload: Omit<
    UpdateOrganizationWebCommitSignoffSettingPayload,
    "organization"
  > & { organization?: Maybe<ResolversParentTypes["Organization"]> };
  UpdateParameters: UpdateParameters;
  UpdateParametersInput: UpdateParametersInput;
  UpdatePatreonSponsorabilityInput: UpdatePatreonSponsorabilityInput;
  UpdatePatreonSponsorabilityPayload: Omit<
    UpdatePatreonSponsorabilityPayload,
    "sponsorsListing"
  > & { sponsorsListing?: Maybe<ResolversParentTypes["SponsorsListing"]> };
  UpdateProjectCardInput: UpdateProjectCardInput;
  UpdateProjectCardPayload: Omit<UpdateProjectCardPayload, "projectCard"> & {
    projectCard?: Maybe<ResolversParentTypes["ProjectCard"]>;
  };
  UpdateProjectColumnInput: UpdateProjectColumnInput;
  UpdateProjectColumnPayload: Omit<
    UpdateProjectColumnPayload,
    "projectColumn"
  > & { projectColumn?: Maybe<ResolversParentTypes["ProjectColumn"]> };
  UpdateProjectInput: UpdateProjectInput;
  UpdateProjectPayload: Omit<UpdateProjectPayload, "project"> & {
    project?: Maybe<ResolversParentTypes["Project"]>;
  };
  UpdateProjectV2CollaboratorsInput: UpdateProjectV2CollaboratorsInput;
  UpdateProjectV2CollaboratorsPayload: Omit<
    UpdateProjectV2CollaboratorsPayload,
    "collaborators"
  > & {
    collaborators?: Maybe<ResolversParentTypes["ProjectV2ActorConnection"]>;
  };
  UpdateProjectV2DraftIssueInput: UpdateProjectV2DraftIssueInput;
  UpdateProjectV2DraftIssuePayload: Omit<
    UpdateProjectV2DraftIssuePayload,
    "draftIssue"
  > & { draftIssue?: Maybe<ResolversParentTypes["DraftIssue"]> };
  UpdateProjectV2Input: UpdateProjectV2Input;
  UpdateProjectV2ItemFieldValueInput: UpdateProjectV2ItemFieldValueInput;
  UpdateProjectV2ItemFieldValuePayload: Omit<
    UpdateProjectV2ItemFieldValuePayload,
    "projectV2Item"
  > & { projectV2Item?: Maybe<ResolversParentTypes["ProjectV2Item"]> };
  UpdateProjectV2ItemPositionInput: UpdateProjectV2ItemPositionInput;
  UpdateProjectV2ItemPositionPayload: Omit<
    UpdateProjectV2ItemPositionPayload,
    "items"
  > & { items?: Maybe<ResolversParentTypes["ProjectV2ItemConnection"]> };
  UpdateProjectV2Payload: Omit<UpdateProjectV2Payload, "projectV2"> & {
    projectV2?: Maybe<ResolversParentTypes["ProjectV2"]>;
  };
  UpdateProjectV2StatusUpdateInput: UpdateProjectV2StatusUpdateInput;
  UpdateProjectV2StatusUpdatePayload: Omit<
    UpdateProjectV2StatusUpdatePayload,
    "statusUpdate"
  > & { statusUpdate?: Maybe<ResolversParentTypes["ProjectV2StatusUpdate"]> };
  UpdatePullRequestBranchInput: UpdatePullRequestBranchInput;
  UpdatePullRequestBranchPayload: Omit<
    UpdatePullRequestBranchPayload,
    "pullRequest"
  > & { pullRequest?: Maybe<ResolversParentTypes["PullRequest"]> };
  UpdatePullRequestInput: UpdatePullRequestInput;
  UpdatePullRequestPayload: Omit<
    UpdatePullRequestPayload,
    "actor" | "pullRequest"
  > & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    pullRequest?: Maybe<ResolversParentTypes["PullRequest"]>;
  };
  UpdatePullRequestReviewCommentInput: UpdatePullRequestReviewCommentInput;
  UpdatePullRequestReviewCommentPayload: Omit<
    UpdatePullRequestReviewCommentPayload,
    "pullRequestReviewComment"
  > & {
    pullRequestReviewComment?: Maybe<
      ResolversParentTypes["PullRequestReviewComment"]
    >;
  };
  UpdatePullRequestReviewInput: UpdatePullRequestReviewInput;
  UpdatePullRequestReviewPayload: Omit<
    UpdatePullRequestReviewPayload,
    "pullRequestReview"
  > & { pullRequestReview?: Maybe<ResolversParentTypes["PullRequestReview"]> };
  UpdateRefInput: UpdateRefInput;
  UpdateRefPayload: Omit<UpdateRefPayload, "ref"> & {
    ref?: Maybe<ResolversParentTypes["Ref"]>;
  };
  UpdateRefsInput: UpdateRefsInput;
  UpdateRefsPayload: UpdateRefsPayload;
  UpdateRepositoryInput: UpdateRepositoryInput;
  UpdateRepositoryPayload: Omit<UpdateRepositoryPayload, "repository"> & {
    repository?: Maybe<ResolversParentTypes["Repository"]>;
  };
  UpdateRepositoryRulesetInput: UpdateRepositoryRulesetInput;
  UpdateRepositoryRulesetPayload: Omit<
    UpdateRepositoryRulesetPayload,
    "ruleset"
  > & { ruleset?: Maybe<ResolversParentTypes["RepositoryRuleset"]> };
  UpdateRepositoryWebCommitSignoffSettingInput: UpdateRepositoryWebCommitSignoffSettingInput;
  UpdateRepositoryWebCommitSignoffSettingPayload: Omit<
    UpdateRepositoryWebCommitSignoffSettingPayload,
    "repository"
  > & { repository?: Maybe<ResolversParentTypes["Repository"]> };
  UpdateSponsorshipPreferencesInput: UpdateSponsorshipPreferencesInput;
  UpdateSponsorshipPreferencesPayload: Omit<
    UpdateSponsorshipPreferencesPayload,
    "sponsorship"
  > & { sponsorship?: Maybe<ResolversParentTypes["Sponsorship"]> };
  UpdateSubscriptionInput: UpdateSubscriptionInput;
  UpdateSubscriptionPayload: Omit<UpdateSubscriptionPayload, "subscribable"> & {
    subscribable?: Maybe<ResolversParentTypes["Subscribable"]>;
  };
  UpdateTeamDiscussionCommentInput: UpdateTeamDiscussionCommentInput;
  UpdateTeamDiscussionCommentPayload: Omit<
    UpdateTeamDiscussionCommentPayload,
    "teamDiscussionComment"
  > & {
    teamDiscussionComment?: Maybe<
      ResolversParentTypes["TeamDiscussionComment"]
    >;
  };
  UpdateTeamDiscussionInput: UpdateTeamDiscussionInput;
  UpdateTeamDiscussionPayload: Omit<
    UpdateTeamDiscussionPayload,
    "teamDiscussion"
  > & { teamDiscussion?: Maybe<ResolversParentTypes["TeamDiscussion"]> };
  UpdateTeamReviewAssignmentInput: UpdateTeamReviewAssignmentInput;
  UpdateTeamReviewAssignmentPayload: Omit<
    UpdateTeamReviewAssignmentPayload,
    "team"
  > & { team?: Maybe<ResolversParentTypes["Team"]> };
  UpdateTeamsRepositoryInput: UpdateTeamsRepositoryInput;
  UpdateTeamsRepositoryPayload: Omit<
    UpdateTeamsRepositoryPayload,
    "repository" | "teams"
  > & {
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    teams?: Maybe<Array<ResolversParentTypes["Team"]>>;
  };
  UpdateTopicsInput: UpdateTopicsInput;
  UpdateTopicsPayload: Omit<UpdateTopicsPayload, "repository"> & {
    repository?: Maybe<ResolversParentTypes["Repository"]>;
  };
  UpdateUserListInput: UpdateUserListInput;
  UpdateUserListPayload: Omit<UpdateUserListPayload, "list"> & {
    list?: Maybe<ResolversParentTypes["UserList"]>;
  };
  UpdateUserListsForItemInput: UpdateUserListsForItemInput;
  UpdateUserListsForItemPayload: Omit<
    UpdateUserListsForItemPayload,
    "item" | "lists" | "user"
  > & {
    item?: Maybe<ResolversParentTypes["UserListItems"]>;
    lists?: Maybe<Array<ResolversParentTypes["UserList"]>>;
    user?: Maybe<ResolversParentTypes["User"]>;
  };
  User: Omit<
    User,
    | "commitComments"
    | "contributionsCollection"
    | "enterprises"
    | "followers"
    | "following"
    | "gist"
    | "gistComments"
    | "gists"
    | "hovercard"
    | "issueComments"
    | "issues"
    | "itemShowcase"
    | "lifetimeReceivedSponsorshipValues"
    | "lists"
    | "organization"
    | "organizations"
    | "packages"
    | "pinnableItems"
    | "pinnedItems"
    | "project"
    | "projectV2"
    | "projects"
    | "projectsV2"
    | "pullRequests"
    | "recentProjects"
    | "repositories"
    | "repositoriesContributedTo"
    | "repository"
    | "repositoryDiscussionComments"
    | "repositoryDiscussions"
    | "savedReplies"
    | "sponsoring"
    | "sponsors"
    | "sponsorsActivities"
    | "sponsorsListing"
    | "sponsorshipForViewerAsSponsor"
    | "sponsorshipForViewerAsSponsorable"
    | "sponsorshipNewsletters"
    | "sponsorshipsAsMaintainer"
    | "sponsorshipsAsSponsor"
    | "starredRepositories"
    | "status"
    | "topRepositories"
    | "watching"
  > & {
    commitComments: ResolversParentTypes["CommitCommentConnection"];
    contributionsCollection: ResolversParentTypes["ContributionsCollection"];
    enterprises?: Maybe<ResolversParentTypes["EnterpriseConnection"]>;
    followers: ResolversParentTypes["FollowerConnection"];
    following: ResolversParentTypes["FollowingConnection"];
    gist?: Maybe<ResolversParentTypes["Gist"]>;
    gistComments: ResolversParentTypes["GistCommentConnection"];
    gists: ResolversParentTypes["GistConnection"];
    hovercard: ResolversParentTypes["Hovercard"];
    issueComments: ResolversParentTypes["IssueCommentConnection"];
    issues: ResolversParentTypes["IssueConnection"];
    itemShowcase: ResolversParentTypes["ProfileItemShowcase"];
    lifetimeReceivedSponsorshipValues: ResolversParentTypes["SponsorAndLifetimeValueConnection"];
    lists: ResolversParentTypes["UserListConnection"];
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    organizations: ResolversParentTypes["OrganizationConnection"];
    packages: ResolversParentTypes["PackageConnection"];
    pinnableItems: ResolversParentTypes["PinnableItemConnection"];
    pinnedItems: ResolversParentTypes["PinnableItemConnection"];
    project?: Maybe<ResolversParentTypes["Project"]>;
    projectV2?: Maybe<ResolversParentTypes["ProjectV2"]>;
    projects: ResolversParentTypes["ProjectConnection"];
    projectsV2: ResolversParentTypes["ProjectV2Connection"];
    pullRequests: ResolversParentTypes["PullRequestConnection"];
    recentProjects: ResolversParentTypes["ProjectV2Connection"];
    repositories: ResolversParentTypes["RepositoryConnection"];
    repositoriesContributedTo: ResolversParentTypes["RepositoryConnection"];
    repository?: Maybe<ResolversParentTypes["Repository"]>;
    repositoryDiscussionComments: ResolversParentTypes["DiscussionCommentConnection"];
    repositoryDiscussions: ResolversParentTypes["DiscussionConnection"];
    savedReplies?: Maybe<ResolversParentTypes["SavedReplyConnection"]>;
    sponsoring: ResolversParentTypes["SponsorConnection"];
    sponsors: ResolversParentTypes["SponsorConnection"];
    sponsorsActivities: ResolversParentTypes["SponsorsActivityConnection"];
    sponsorsListing?: Maybe<ResolversParentTypes["SponsorsListing"]>;
    sponsorshipForViewerAsSponsor?: Maybe<ResolversParentTypes["Sponsorship"]>;
    sponsorshipForViewerAsSponsorable?: Maybe<
      ResolversParentTypes["Sponsorship"]
    >;
    sponsorshipNewsletters: ResolversParentTypes["SponsorshipNewsletterConnection"];
    sponsorshipsAsMaintainer: ResolversParentTypes["SponsorshipConnection"];
    sponsorshipsAsSponsor: ResolversParentTypes["SponsorshipConnection"];
    starredRepositories: ResolversParentTypes["StarredRepositoryConnection"];
    status?: Maybe<ResolversParentTypes["UserStatus"]>;
    topRepositories: ResolversParentTypes["RepositoryConnection"];
    watching: ResolversParentTypes["RepositoryConnection"];
  };
  UserBlockedEvent: Omit<UserBlockedEvent, "actor" | "subject"> & {
    actor?: Maybe<ResolversParentTypes["Actor"]>;
    subject?: Maybe<ResolversParentTypes["User"]>;
  };
  UserConnection: Omit<UserConnection, "nodes"> & {
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["User"]>>>;
  };
  UserContentEdit: Omit<UserContentEdit, "deletedBy" | "editor"> & {
    deletedBy?: Maybe<ResolversParentTypes["Actor"]>;
    editor?: Maybe<ResolversParentTypes["Actor"]>;
  };
  UserContentEditConnection: Omit<
    UserContentEditConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["UserContentEditEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["UserContentEdit"]>>>;
  };
  UserContentEditEdge: Omit<UserContentEditEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["UserContentEdit"]>;
  };
  UserEdge: Omit<UserEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["User"]>;
  };
  UserEmailMetadata: UserEmailMetadata;
  UserList: Omit<UserList, "items" | "user"> & {
    items: ResolversParentTypes["UserListItemsConnection"];
    user: ResolversParentTypes["User"];
  };
  UserListConnection: Omit<UserListConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["UserListEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["UserList"]>>>;
  };
  UserListEdge: Omit<UserListEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["UserList"]>;
  };
  UserListItems: ResolversUnionTypes<ResolversParentTypes>["UserListItems"];
  UserListItemsConnection: Omit<UserListItemsConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["UserListItemsEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["UserListItems"]>>>;
  };
  UserListItemsEdge: Omit<UserListItemsEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["UserListItems"]>;
  };
  UserListSuggestion: UserListSuggestion;
  UserStatus: Omit<UserStatus, "organization" | "user"> & {
    organization?: Maybe<ResolversParentTypes["Organization"]>;
    user: ResolversParentTypes["User"];
  };
  UserStatusConnection: Omit<UserStatusConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["UserStatusEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["UserStatus"]>>>;
  };
  UserStatusEdge: Omit<UserStatusEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["UserStatus"]>;
  };
  UserStatusOrder: UserStatusOrder;
  VerifiableDomain: Omit<VerifiableDomain, "owner"> & {
    owner: ResolversParentTypes["VerifiableDomainOwner"];
  };
  VerifiableDomainConnection: Omit<
    VerifiableDomainConnection,
    "edges" | "nodes"
  > & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["VerifiableDomainEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["VerifiableDomain"]>>>;
  };
  VerifiableDomainEdge: Omit<VerifiableDomainEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["VerifiableDomain"]>;
  };
  VerifiableDomainOrder: VerifiableDomainOrder;
  VerifiableDomainOwner: ResolversUnionTypes<ResolversParentTypes>["VerifiableDomainOwner"];
  VerifyVerifiableDomainInput: VerifyVerifiableDomainInput;
  VerifyVerifiableDomainPayload: Omit<
    VerifyVerifiableDomainPayload,
    "domain"
  > & { domain?: Maybe<ResolversParentTypes["VerifiableDomain"]> };
  ViewerHovercardContext: Omit<ViewerHovercardContext, "viewer"> & {
    viewer: ResolversParentTypes["User"];
  };
  Votable: ResolversInterfaceTypes<ResolversParentTypes>["Votable"];
  Workflow: Omit<Workflow, "runs"> & {
    runs: ResolversParentTypes["WorkflowRunConnection"];
  };
  WorkflowFileReference: WorkflowFileReference;
  WorkflowFileReferenceInput: WorkflowFileReferenceInput;
  WorkflowRun: Omit<
    WorkflowRun,
    | "checkSuite"
    | "deploymentReviews"
    | "file"
    | "pendingDeploymentRequests"
    | "workflow"
  > & {
    checkSuite: ResolversParentTypes["CheckSuite"];
    deploymentReviews: ResolversParentTypes["DeploymentReviewConnection"];
    file?: Maybe<ResolversParentTypes["WorkflowRunFile"]>;
    pendingDeploymentRequests: ResolversParentTypes["DeploymentRequestConnection"];
    workflow: ResolversParentTypes["Workflow"];
  };
  WorkflowRunConnection: Omit<WorkflowRunConnection, "edges" | "nodes"> & {
    edges?: Maybe<Array<Maybe<ResolversParentTypes["WorkflowRunEdge"]>>>;
    nodes?: Maybe<Array<Maybe<ResolversParentTypes["WorkflowRun"]>>>;
  };
  WorkflowRunEdge: Omit<WorkflowRunEdge, "node"> & {
    node?: Maybe<ResolversParentTypes["WorkflowRun"]>;
  };
  WorkflowRunFile: Omit<WorkflowRunFile, "run"> & {
    run: ResolversParentTypes["WorkflowRun"];
  };
  WorkflowRunOrder: WorkflowRunOrder;
  WorkflowsParameters: WorkflowsParameters;
  WorkflowsParametersInput: WorkflowsParametersInput;
  X509Certificate: Scalars["X509Certificate"]["output"];
};

export type PossibleTypesDirectiveArgs = {
  abstractType?: Maybe<Scalars["String"]["input"]>;
  concreteTypes: Array<Scalars["String"]["input"]>;
};

export type PossibleTypesDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = PossibleTypesDirectiveArgs,
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type PreviewDirectiveArgs = {
  toggledBy: Scalars["String"]["input"];
};

export type PreviewDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = PreviewDirectiveArgs,
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type RequiredCapabilitiesDirectiveArgs = {
  requiredCapabilities?: Maybe<Array<Scalars["String"]["input"]>>;
};

export type RequiredCapabilitiesDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = RequiredCapabilitiesDirectiveArgs,
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type AbortQueuedMigrationsPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AbortQueuedMigrationsPayload"] = ResolversParentTypes["AbortQueuedMigrationsPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  success?: Resolver<Maybe<ResolversTypes["Boolean"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AbortRepositoryMigrationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AbortRepositoryMigrationPayload"] = ResolversParentTypes["AbortRepositoryMigrationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  success?: Resolver<Maybe<ResolversTypes["Boolean"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AcceptEnterpriseAdministratorInvitationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AcceptEnterpriseAdministratorInvitationPayload"] = ResolversParentTypes["AcceptEnterpriseAdministratorInvitationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  invitation?: Resolver<
    Maybe<ResolversTypes["EnterpriseAdministratorInvitation"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AcceptEnterpriseMemberInvitationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AcceptEnterpriseMemberInvitationPayload"] = ResolversParentTypes["AcceptEnterpriseMemberInvitationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  invitation?: Resolver<
    Maybe<ResolversTypes["EnterpriseMemberInvitation"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AcceptTopicSuggestionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AcceptTopicSuggestionPayload"] = ResolversParentTypes["AcceptTopicSuggestionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  topic?: Resolver<Maybe<ResolversTypes["Topic"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Actor"] = ResolversParentTypes["Actor"],
> = {
  __resolveType: TypeResolveFn<
    "Bot" | "EnterpriseUserAccount" | "Mannequin" | "Organization" | "User",
    ParentType,
    ContextType
  >;
  avatarUrl?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType,
    Partial<ActorAvatarUrlArgs>
  >;
  login?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
};

export type ActorLocationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ActorLocation"] = ResolversParentTypes["ActorLocation"],
> = {
  city?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  countryCode?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  region?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  regionCode?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddAssigneesToAssignablePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddAssigneesToAssignablePayload"] = ResolversParentTypes["AddAssigneesToAssignablePayload"],
> = {
  assignable?: Resolver<
    Maybe<ResolversTypes["Assignable"]>,
    ParentType,
    ContextType
  >;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddCommentPayload"] = ResolversParentTypes["AddCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  commentEdge?: Resolver<
    Maybe<ResolversTypes["IssueCommentEdge"]>,
    ParentType,
    ContextType
  >;
  subject?: Resolver<Maybe<ResolversTypes["Node"]>, ParentType, ContextType>;
  timelineEdge?: Resolver<
    Maybe<ResolversTypes["IssueTimelineItemEdge"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddDiscussionCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddDiscussionCommentPayload"] = ResolversParentTypes["AddDiscussionCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  comment?: Resolver<
    Maybe<ResolversTypes["DiscussionComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddDiscussionPollVotePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddDiscussionPollVotePayload"] = ResolversParentTypes["AddDiscussionPollVotePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pollOption?: Resolver<
    Maybe<ResolversTypes["DiscussionPollOption"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddEnterpriseOrganizationMemberPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddEnterpriseOrganizationMemberPayload"] = ResolversParentTypes["AddEnterpriseOrganizationMemberPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  users?: Resolver<
    Maybe<Array<ResolversTypes["User"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddEnterpriseSupportEntitlementPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddEnterpriseSupportEntitlementPayload"] = ResolversParentTypes["AddEnterpriseSupportEntitlementPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddLabelsToLabelablePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddLabelsToLabelablePayload"] = ResolversParentTypes["AddLabelsToLabelablePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  labelable?: Resolver<
    Maybe<ResolversTypes["Labelable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddProjectCardPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddProjectCardPayload"] = ResolversParentTypes["AddProjectCardPayload"],
> = {
  cardEdge?: Resolver<
    Maybe<ResolversTypes["ProjectCardEdge"]>,
    ParentType,
    ContextType
  >;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectColumn?: Resolver<
    Maybe<ResolversTypes["ProjectColumn"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddProjectColumnPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddProjectColumnPayload"] = ResolversParentTypes["AddProjectColumnPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  columnEdge?: Resolver<
    Maybe<ResolversTypes["ProjectColumnEdge"]>,
    ParentType,
    ContextType
  >;
  project?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddProjectV2DraftIssuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddProjectV2DraftIssuePayload"] = ResolversParentTypes["AddProjectV2DraftIssuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectItem?: Resolver<
    Maybe<ResolversTypes["ProjectV2Item"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddProjectV2ItemByIdPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddProjectV2ItemByIdPayload"] = ResolversParentTypes["AddProjectV2ItemByIdPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  item?: Resolver<
    Maybe<ResolversTypes["ProjectV2Item"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddPullRequestReviewCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddPullRequestReviewCommentPayload"] = ResolversParentTypes["AddPullRequestReviewCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  comment?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewComment"]>,
    ParentType,
    ContextType
  >;
  commentEdge?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewCommentEdge"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddPullRequestReviewPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddPullRequestReviewPayload"] = ResolversParentTypes["AddPullRequestReviewPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequestReview?: Resolver<
    Maybe<ResolversTypes["PullRequestReview"]>,
    ParentType,
    ContextType
  >;
  reviewEdge?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewEdge"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddPullRequestReviewThreadPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddPullRequestReviewThreadPayload"] = ResolversParentTypes["AddPullRequestReviewThreadPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  thread?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewThread"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddPullRequestReviewThreadReplyPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddPullRequestReviewThreadReplyPayload"] = ResolversParentTypes["AddPullRequestReviewThreadReplyPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  comment?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddReactionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddReactionPayload"] = ResolversParentTypes["AddReactionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  reaction?: Resolver<
    Maybe<ResolversTypes["Reaction"]>,
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  subject?: Resolver<
    Maybe<ResolversTypes["Reactable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddStarPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddStarPayload"] = ResolversParentTypes["AddStarPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  starrable?: Resolver<
    Maybe<ResolversTypes["Starrable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddUpvotePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddUpvotePayload"] = ResolversParentTypes["AddUpvotePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  subject?: Resolver<Maybe<ResolversTypes["Votable"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddVerifiableDomainPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddVerifiableDomainPayload"] = ResolversParentTypes["AddVerifiableDomainPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  domain?: Resolver<
    Maybe<ResolversTypes["VerifiableDomain"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddedToMergeQueueEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddedToMergeQueueEvent"] = ResolversParentTypes["AddedToMergeQueueEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  enqueuer?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  mergeQueue?: Resolver<
    Maybe<ResolversTypes["MergeQueue"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddedToProjectEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AddedToProjectEvent"] = ResolversParentTypes["AddedToProjectEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  projectCard?: Resolver<
    Maybe<ResolversTypes["ProjectCard"]>,
    ParentType,
    ContextType
  >;
  projectColumnName?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnnouncementBannerResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AnnouncementBanner"] = ResolversParentTypes["AnnouncementBanner"],
> = {
  __resolveType: TypeResolveFn<
    "Enterprise" | "Organization",
    ParentType,
    ContextType
  >;
  announcement?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  announcementCreatedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  announcementExpiresAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  announcementUserDismissible?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
};

export type AppResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["App"] = ResolversParentTypes["App"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  ipAllowListEntries?: Resolver<
    ResolversTypes["IpAllowListEntryConnection"],
    ParentType,
    ContextType,
    RequireFields<AppIpAllowListEntriesArgs, "orderBy">
  >;
  logoBackgroundColor?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  logoUrl?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType,
    Partial<AppLogoUrlArgs>
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApproveDeploymentsPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ApproveDeploymentsPayload"] = ResolversParentTypes["ApproveDeploymentsPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  deployments?: Resolver<
    Maybe<Array<ResolversTypes["Deployment"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApproveVerifiableDomainPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ApproveVerifiableDomainPayload"] = ResolversParentTypes["ApproveVerifiableDomainPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  domain?: Resolver<
    Maybe<ResolversTypes["VerifiableDomain"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ArchiveProjectV2ItemPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ArchiveProjectV2ItemPayload"] = ResolversParentTypes["ArchiveProjectV2ItemPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  item?: Resolver<
    Maybe<ResolversTypes["ProjectV2Item"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ArchiveRepositoryPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ArchiveRepositoryPayload"] = ResolversParentTypes["ArchiveRepositoryPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Assignable"] = ResolversParentTypes["Assignable"],
> = {
  __resolveType: TypeResolveFn<
    "Issue" | "PullRequest",
    ParentType,
    ContextType
  >;
  assignees?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<AssignableAssigneesArgs>
  >;
};

export type AssignedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AssignedEvent"] = ResolversParentTypes["AssignedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  assignable?: Resolver<ResolversTypes["Assignable"], ParentType, ContextType>;
  assignee?: Resolver<
    Maybe<ResolversTypes["Assignee"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssigneeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Assignee"] = ResolversParentTypes["Assignee"],
> = {
  __resolveType: TypeResolveFn<
    "Bot" | "Mannequin" | "Organization" | "User",
    ParentType,
    ContextType
  >;
};

export type AuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AuditEntry"] = ResolversParentTypes["AuditEntry"],
> = {
  __resolveType: TypeResolveFn<
    | "MembersCanDeleteReposClearAuditEntry"
    | "MembersCanDeleteReposDisableAuditEntry"
    | "MembersCanDeleteReposEnableAuditEntry"
    | "OauthApplicationCreateAuditEntry"
    | "OrgAddBillingManagerAuditEntry"
    | "OrgAddMemberAuditEntry"
    | "OrgBlockUserAuditEntry"
    | "OrgConfigDisableCollaboratorsOnlyAuditEntry"
    | "OrgConfigEnableCollaboratorsOnlyAuditEntry"
    | "OrgCreateAuditEntry"
    | "OrgDisableOauthAppRestrictionsAuditEntry"
    | "OrgDisableSamlAuditEntry"
    | "OrgDisableTwoFactorRequirementAuditEntry"
    | "OrgEnableOauthAppRestrictionsAuditEntry"
    | "OrgEnableSamlAuditEntry"
    | "OrgEnableTwoFactorRequirementAuditEntry"
    | "OrgInviteMemberAuditEntry"
    | "OrgInviteToBusinessAuditEntry"
    | "OrgOauthAppAccessApprovedAuditEntry"
    | "OrgOauthAppAccessBlockedAuditEntry"
    | "OrgOauthAppAccessDeniedAuditEntry"
    | "OrgOauthAppAccessRequestedAuditEntry"
    | "OrgOauthAppAccessUnblockedAuditEntry"
    | "OrgRemoveBillingManagerAuditEntry"
    | "OrgRemoveMemberAuditEntry"
    | "OrgRemoveOutsideCollaboratorAuditEntry"
    | "OrgRestoreMemberAuditEntry"
    | "OrgUnblockUserAuditEntry"
    | "OrgUpdateDefaultRepositoryPermissionAuditEntry"
    | "OrgUpdateMemberAuditEntry"
    | "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
    | "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
    | "PrivateRepositoryForkingDisableAuditEntry"
    | "PrivateRepositoryForkingEnableAuditEntry"
    | "RepoAccessAuditEntry"
    | "RepoAddMemberAuditEntry"
    | "RepoAddTopicAuditEntry"
    | "RepoArchivedAuditEntry"
    | "RepoChangeMergeSettingAuditEntry"
    | "RepoConfigDisableAnonymousGitAccessAuditEntry"
    | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
    | "RepoConfigDisableContributorsOnlyAuditEntry"
    | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
    | "RepoConfigEnableAnonymousGitAccessAuditEntry"
    | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
    | "RepoConfigEnableContributorsOnlyAuditEntry"
    | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
    | "RepoConfigLockAnonymousGitAccessAuditEntry"
    | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
    | "RepoCreateAuditEntry"
    | "RepoDestroyAuditEntry"
    | "RepoRemoveMemberAuditEntry"
    | "RepoRemoveTopicAuditEntry"
    | "RepositoryVisibilityChangeDisableAuditEntry"
    | "RepositoryVisibilityChangeEnableAuditEntry"
    | "TeamAddMemberAuditEntry"
    | "TeamAddRepositoryAuditEntry"
    | "TeamChangeParentTeamAuditEntry"
    | "TeamRemoveMemberAuditEntry"
    | "TeamRemoveRepositoryAuditEntry",
    ParentType,
    ContextType
  >;
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
};

export type AuditEntryActorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AuditEntryActor"] = ResolversParentTypes["AuditEntryActor"],
> = {
  __resolveType: TypeResolveFn<
    "Bot" | "Organization" | "User",
    ParentType,
    ContextType
  >;
};

export type AutoMergeDisabledEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AutoMergeDisabledEvent"] = ResolversParentTypes["AutoMergeDisabledEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  disabler?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  reason?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  reasonCode?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AutoMergeEnabledEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AutoMergeEnabledEvent"] = ResolversParentTypes["AutoMergeEnabledEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  enabler?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AutoMergeRequestResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AutoMergeRequest"] = ResolversParentTypes["AutoMergeRequest"],
> = {
  authorEmail?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  commitBody?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  commitHeadline?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enabledAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  enabledBy?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  mergeMethod?: Resolver<
    ResolversTypes["PullRequestMergeMethod"],
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AutoRebaseEnabledEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AutoRebaseEnabledEvent"] = ResolversParentTypes["AutoRebaseEnabledEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  enabler?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AutoSquashEnabledEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AutoSquashEnabledEvent"] = ResolversParentTypes["AutoSquashEnabledEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  enabler?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AutomaticBaseChangeFailedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AutomaticBaseChangeFailedEvent"] = ResolversParentTypes["AutomaticBaseChangeFailedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  newBase?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  oldBase?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AutomaticBaseChangeSucceededEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["AutomaticBaseChangeSucceededEvent"] = ResolversParentTypes["AutomaticBaseChangeSucceededEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  newBase?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  oldBase?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface Base64StringScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["Base64String"], any> {
  name: "Base64String";
}

export type BaseRefChangedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BaseRefChangedEvent"] = ResolversParentTypes["BaseRefChangedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  currentRefName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  previousRefName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BaseRefDeletedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BaseRefDeletedEvent"] = ResolversParentTypes["BaseRefDeletedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  baseRefName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BaseRefForcePushedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BaseRefForcePushedEvent"] = ResolversParentTypes["BaseRefForcePushedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  afterCommit?: Resolver<
    Maybe<ResolversTypes["Commit"]>,
    ParentType,
    ContextType
  >;
  beforeCommit?: Resolver<
    Maybe<ResolversTypes["Commit"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  ref?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface BigIntScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["BigInt"], any> {
  name: "BigInt";
}

export type BlameResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Blame"] = ResolversParentTypes["Blame"],
> = {
  ranges?: Resolver<
    Array<ResolversTypes["BlameRange"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BlameRangeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BlameRange"] = ResolversParentTypes["BlameRange"],
> = {
  age?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  commit?: Resolver<ResolversTypes["Commit"], ParentType, ContextType>;
  endingLine?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  startingLine?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BlobResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Blob"] = ResolversParentTypes["Blob"],
> = {
  abbreviatedOid?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  byteSize?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isBinary?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  isTruncated?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes["GitObjectID"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Bot"] = ResolversParentTypes["Bot"],
> = {
  avatarUrl?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType,
    Partial<BotAvatarUrlArgs>
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  login?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BranchActorAllowanceActorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BranchActorAllowanceActor"] = ResolversParentTypes["BranchActorAllowanceActor"],
> = {
  __resolveType: TypeResolveFn<
    "App" | "Team" | "User",
    ParentType,
    ContextType
  >;
};

export type BranchNamePatternParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BranchNamePatternParameters"] = ResolversParentTypes["BranchNamePatternParameters"],
> = {
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BranchProtectionRuleResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BranchProtectionRule"] = ResolversParentTypes["BranchProtectionRule"],
> = {
  allowsDeletions?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  allowsForcePushes?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  blocksCreations?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  branchProtectionRuleConflicts?: Resolver<
    ResolversTypes["BranchProtectionRuleConflictConnection"],
    ParentType,
    ContextType,
    Partial<BranchProtectionRuleBranchProtectionRuleConflictsArgs>
  >;
  bypassForcePushAllowances?: Resolver<
    ResolversTypes["BypassForcePushAllowanceConnection"],
    ParentType,
    ContextType,
    Partial<BranchProtectionRuleBypassForcePushAllowancesArgs>
  >;
  bypassPullRequestAllowances?: Resolver<
    ResolversTypes["BypassPullRequestAllowanceConnection"],
    ParentType,
    ContextType,
    Partial<BranchProtectionRuleBypassPullRequestAllowancesArgs>
  >;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  dismissesStaleReviews?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isAdminEnforced?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  lockAllowsFetchAndMerge?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  lockBranch?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  matchingRefs?: Resolver<
    ResolversTypes["RefConnection"],
    ParentType,
    ContextType,
    Partial<BranchProtectionRuleMatchingRefsArgs>
  >;
  pattern?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pushAllowances?: Resolver<
    ResolversTypes["PushAllowanceConnection"],
    ParentType,
    ContextType,
    Partial<BranchProtectionRulePushAllowancesArgs>
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  requireLastPushApproval?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiredApprovingReviewCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  requiredDeploymentEnvironments?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["String"]>>>,
    ParentType,
    ContextType
  >;
  requiredStatusCheckContexts?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["String"]>>>,
    ParentType,
    ContextType
  >;
  requiredStatusChecks?: Resolver<
    Maybe<Array<ResolversTypes["RequiredStatusCheckDescription"]>>,
    ParentType,
    ContextType
  >;
  requiresApprovingReviews?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiresCodeOwnerReviews?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiresCommitSignatures?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiresConversationResolution?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiresDeployments?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiresLinearHistory?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiresStatusChecks?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiresStrictStatusChecks?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  restrictsPushes?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  restrictsReviewDismissals?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  reviewDismissalAllowances?: Resolver<
    ResolversTypes["ReviewDismissalAllowanceConnection"],
    ParentType,
    ContextType,
    Partial<BranchProtectionRuleReviewDismissalAllowancesArgs>
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BranchProtectionRuleConflictResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BranchProtectionRuleConflict"] = ResolversParentTypes["BranchProtectionRuleConflict"],
> = {
  branchProtectionRule?: Resolver<
    Maybe<ResolversTypes["BranchProtectionRule"]>,
    ParentType,
    ContextType
  >;
  conflictingBranchProtectionRule?: Resolver<
    Maybe<ResolversTypes["BranchProtectionRule"]>,
    ParentType,
    ContextType
  >;
  ref?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BranchProtectionRuleConflictConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BranchProtectionRuleConflictConnection"] = ResolversParentTypes["BranchProtectionRuleConflictConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["BranchProtectionRuleConflictEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["BranchProtectionRuleConflict"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BranchProtectionRuleConflictEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BranchProtectionRuleConflictEdge"] = ResolversParentTypes["BranchProtectionRuleConflictEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["BranchProtectionRuleConflict"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BranchProtectionRuleConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BranchProtectionRuleConnection"] = ResolversParentTypes["BranchProtectionRuleConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["BranchProtectionRuleEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["BranchProtectionRule"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BranchProtectionRuleEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BranchProtectionRuleEdge"] = ResolversParentTypes["BranchProtectionRuleEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["BranchProtectionRule"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BypassActorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BypassActor"] = ResolversParentTypes["BypassActor"],
> = {
  __resolveType: TypeResolveFn<"App" | "Team", ParentType, ContextType>;
};

export type BypassForcePushAllowanceResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BypassForcePushAllowance"] = ResolversParentTypes["BypassForcePushAllowance"],
> = {
  actor?: Resolver<
    Maybe<ResolversTypes["BranchActorAllowanceActor"]>,
    ParentType,
    ContextType
  >;
  branchProtectionRule?: Resolver<
    Maybe<ResolversTypes["BranchProtectionRule"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BypassForcePushAllowanceConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BypassForcePushAllowanceConnection"] = ResolversParentTypes["BypassForcePushAllowanceConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["BypassForcePushAllowanceEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["BypassForcePushAllowance"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BypassForcePushAllowanceEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BypassForcePushAllowanceEdge"] = ResolversParentTypes["BypassForcePushAllowanceEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["BypassForcePushAllowance"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BypassPullRequestAllowanceResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BypassPullRequestAllowance"] = ResolversParentTypes["BypassPullRequestAllowance"],
> = {
  actor?: Resolver<
    Maybe<ResolversTypes["BranchActorAllowanceActor"]>,
    ParentType,
    ContextType
  >;
  branchProtectionRule?: Resolver<
    Maybe<ResolversTypes["BranchProtectionRule"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BypassPullRequestAllowanceConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BypassPullRequestAllowanceConnection"] = ResolversParentTypes["BypassPullRequestAllowanceConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["BypassPullRequestAllowanceEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["BypassPullRequestAllowance"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BypassPullRequestAllowanceEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["BypassPullRequestAllowanceEdge"] = ResolversParentTypes["BypassPullRequestAllowanceEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["BypassPullRequestAllowance"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CvssResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CVSS"] = ResolversParentTypes["CVSS"],
> = {
  score?: Resolver<ResolversTypes["Float"], ParentType, ContextType>;
  vectorString?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CweResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["CWE"] = ResolversParentTypes["CWE"],
> = {
  cweId?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  description?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CweConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CWEConnection"] = ResolversParentTypes["CWEConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CWEEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CWE"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CweEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CWEEdge"] = ResolversParentTypes["CWEEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["CWE"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CancelEnterpriseAdminInvitationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CancelEnterpriseAdminInvitationPayload"] = ResolversParentTypes["CancelEnterpriseAdminInvitationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  invitation?: Resolver<
    Maybe<ResolversTypes["EnterpriseAdministratorInvitation"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CancelEnterpriseMemberInvitationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CancelEnterpriseMemberInvitationPayload"] = ResolversParentTypes["CancelEnterpriseMemberInvitationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  invitation?: Resolver<
    Maybe<ResolversTypes["EnterpriseMemberInvitation"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CancelSponsorshipPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CancelSponsorshipPayload"] = ResolversParentTypes["CancelSponsorshipPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  sponsorsTier?: Resolver<
    Maybe<ResolversTypes["SponsorsTier"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChangeUserStatusPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ChangeUserStatusPayload"] = ResolversParentTypes["ChangeUserStatusPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  status?: Resolver<
    Maybe<ResolversTypes["UserStatus"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckAnnotationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckAnnotation"] = ResolversParentTypes["CheckAnnotation"],
> = {
  annotationLevel?: Resolver<
    Maybe<ResolversTypes["CheckAnnotationLevel"]>,
    ParentType,
    ContextType
  >;
  blobUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  location?: Resolver<
    ResolversTypes["CheckAnnotationSpan"],
    ParentType,
    ContextType
  >;
  message?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  path?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  rawDetails?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  title?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckAnnotationConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckAnnotationConnection"] = ResolversParentTypes["CheckAnnotationConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CheckAnnotationEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CheckAnnotation"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckAnnotationEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckAnnotationEdge"] = ResolversParentTypes["CheckAnnotationEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["CheckAnnotation"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckAnnotationPositionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckAnnotationPosition"] = ResolversParentTypes["CheckAnnotationPosition"],
> = {
  column?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  line?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckAnnotationSpanResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckAnnotationSpan"] = ResolversParentTypes["CheckAnnotationSpan"],
> = {
  end?: Resolver<
    ResolversTypes["CheckAnnotationPosition"],
    ParentType,
    ContextType
  >;
  start?: Resolver<
    ResolversTypes["CheckAnnotationPosition"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckRunResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckRun"] = ResolversParentTypes["CheckRun"],
> = {
  annotations?: Resolver<
    Maybe<ResolversTypes["CheckAnnotationConnection"]>,
    ParentType,
    ContextType,
    Partial<CheckRunAnnotationsArgs>
  >;
  checkSuite?: Resolver<ResolversTypes["CheckSuite"], ParentType, ContextType>;
  completedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  conclusion?: Resolver<
    Maybe<ResolversTypes["CheckConclusionState"]>,
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  deployment?: Resolver<
    Maybe<ResolversTypes["Deployment"]>,
    ParentType,
    ContextType
  >;
  detailsUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  externalId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isRequired?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    Partial<CheckRunIsRequiredArgs>
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pendingDeploymentRequest?: Resolver<
    Maybe<ResolversTypes["DeploymentRequest"]>,
    ParentType,
    ContextType
  >;
  permalink?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  startedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  status?: Resolver<
    ResolversTypes["CheckStatusState"],
    ParentType,
    ContextType
  >;
  steps?: Resolver<
    Maybe<ResolversTypes["CheckStepConnection"]>,
    ParentType,
    ContextType,
    Partial<CheckRunStepsArgs>
  >;
  summary?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckRunConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckRunConnection"] = ResolversParentTypes["CheckRunConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CheckRunEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CheckRun"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckRunEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckRunEdge"] = ResolversParentTypes["CheckRunEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["CheckRun"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckRunStateCountResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckRunStateCount"] = ResolversParentTypes["CheckRunStateCount"],
> = {
  count?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  state?: Resolver<ResolversTypes["CheckRunState"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckStepResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckStep"] = ResolversParentTypes["CheckStep"],
> = {
  completedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  conclusion?: Resolver<
    Maybe<ResolversTypes["CheckConclusionState"]>,
    ParentType,
    ContextType
  >;
  externalId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  secondsToCompletion?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  startedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  status?: Resolver<
    ResolversTypes["CheckStatusState"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckStepConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckStepConnection"] = ResolversParentTypes["CheckStepConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CheckStepEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CheckStep"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckStepEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckStepEdge"] = ResolversParentTypes["CheckStepEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["CheckStep"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckSuiteResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckSuite"] = ResolversParentTypes["CheckSuite"],
> = {
  app?: Resolver<Maybe<ResolversTypes["App"]>, ParentType, ContextType>;
  branch?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  checkRuns?: Resolver<
    Maybe<ResolversTypes["CheckRunConnection"]>,
    ParentType,
    ContextType,
    Partial<CheckSuiteCheckRunsArgs>
  >;
  commit?: Resolver<ResolversTypes["Commit"], ParentType, ContextType>;
  conclusion?: Resolver<
    Maybe<ResolversTypes["CheckConclusionState"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  matchingPullRequests?: Resolver<
    Maybe<ResolversTypes["PullRequestConnection"]>,
    ParentType,
    ContextType,
    Partial<CheckSuiteMatchingPullRequestsArgs>
  >;
  push?: Resolver<Maybe<ResolversTypes["Push"]>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  status?: Resolver<
    ResolversTypes["CheckStatusState"],
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  workflowRun?: Resolver<
    Maybe<ResolversTypes["WorkflowRun"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckSuiteConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckSuiteConnection"] = ResolversParentTypes["CheckSuiteConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CheckSuiteEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CheckSuite"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckSuiteEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CheckSuiteEdge"] = ResolversParentTypes["CheckSuiteEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["CheckSuite"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ClaimableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Claimable"] = ResolversParentTypes["Claimable"],
> = {
  __resolveType: TypeResolveFn<"Mannequin" | "User", ParentType, ContextType>;
};

export type ClearLabelsFromLabelablePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ClearLabelsFromLabelablePayload"] = ResolversParentTypes["ClearLabelsFromLabelablePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  labelable?: Resolver<
    Maybe<ResolversTypes["Labelable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ClearProjectV2ItemFieldValuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ClearProjectV2ItemFieldValuePayload"] = ResolversParentTypes["ClearProjectV2ItemFieldValuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectV2Item?: Resolver<
    Maybe<ResolversTypes["ProjectV2Item"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CloneProjectPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CloneProjectPayload"] = ResolversParentTypes["CloneProjectPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  jobStatusId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  project?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CloneTemplateRepositoryPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CloneTemplateRepositoryPayload"] = ResolversParentTypes["CloneTemplateRepositoryPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ClosableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Closable"] = ResolversParentTypes["Closable"],
> = {
  __resolveType: TypeResolveFn<
    | "Discussion"
    | "Issue"
    | "Milestone"
    | "Project"
    | "ProjectV2"
    | "PullRequest",
    ParentType,
    ContextType
  >;
  closed?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  closedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  viewerCanClose?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanReopen?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
};

export type CloseDiscussionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CloseDiscussionPayload"] = ResolversParentTypes["CloseDiscussionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  discussion?: Resolver<
    Maybe<ResolversTypes["Discussion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CloseIssuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CloseIssuePayload"] = ResolversParentTypes["CloseIssuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  issue?: Resolver<Maybe<ResolversTypes["Issue"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ClosePullRequestPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ClosePullRequestPayload"] = ResolversParentTypes["ClosePullRequestPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ClosedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ClosedEvent"] = ResolversParentTypes["ClosedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  closable?: Resolver<ResolversTypes["Closable"], ParentType, ContextType>;
  closer?: Resolver<Maybe<ResolversTypes["Closer"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  stateReason?: Resolver<
    Maybe<ResolversTypes["IssueStateReason"]>,
    ParentType,
    ContextType
  >;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CloserResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Closer"] = ResolversParentTypes["Closer"],
> = {
  __resolveType: TypeResolveFn<
    "Commit" | "ProjectV2" | "PullRequest",
    ParentType,
    ContextType
  >;
};

export type CodeOfConductResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CodeOfConduct"] = ResolversParentTypes["CodeOfConduct"],
> = {
  body?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  key?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  resourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  url?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CodeScanningParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CodeScanningParameters"] = ResolversParentTypes["CodeScanningParameters"],
> = {
  codeScanningTools?: Resolver<
    Array<ResolversTypes["CodeScanningTool"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CodeScanningToolResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CodeScanningTool"] = ResolversParentTypes["CodeScanningTool"],
> = {
  alertsThreshold?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  securityAlertsThreshold?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  tool?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Comment"] = ResolversParentTypes["Comment"],
> = {
  __resolveType: TypeResolveFn<
    | "CommitComment"
    | "Discussion"
    | "DiscussionComment"
    | "GistComment"
    | "Issue"
    | "IssueComment"
    | "PullRequest"
    | "PullRequestReview"
    | "PullRequestReviewComment"
    | "TeamDiscussion"
    | "TeamDiscussionComment",
    ParentType,
    ContextType
  >;
  author?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  authorAssociation?: Resolver<
    ResolversTypes["CommentAuthorAssociation"],
    ParentType,
    ContextType
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  createdViaEmail?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  lastEditedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  userContentEdits?: Resolver<
    Maybe<ResolversTypes["UserContentEditConnection"]>,
    ParentType,
    ContextType,
    Partial<CommentUserContentEditsArgs>
  >;
  viewerDidAuthor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
};

export type CommentDeletedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CommentDeletedEvent"] = ResolversParentTypes["CommentDeletedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  deletedCommentAuthor?: Resolver<
    Maybe<ResolversTypes["Actor"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommitResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Commit"] = ResolversParentTypes["Commit"],
> = {
  abbreviatedOid?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  additions?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  associatedPullRequests?: Resolver<
    Maybe<ResolversTypes["PullRequestConnection"]>,
    ParentType,
    ContextType,
    RequireFields<CommitAssociatedPullRequestsArgs, "orderBy">
  >;
  author?: Resolver<Maybe<ResolversTypes["GitActor"]>, ParentType, ContextType>;
  authoredByCommitter?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  authoredDate?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  authors?: Resolver<
    ResolversTypes["GitActorConnection"],
    ParentType,
    ContextType,
    Partial<CommitAuthorsArgs>
  >;
  blame?: Resolver<
    ResolversTypes["Blame"],
    ParentType,
    ContextType,
    RequireFields<CommitBlameArgs, "path">
  >;
  changedFiles?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  changedFilesIfAvailable?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  checkSuites?: Resolver<
    Maybe<ResolversTypes["CheckSuiteConnection"]>,
    ParentType,
    ContextType,
    Partial<CommitCheckSuitesArgs>
  >;
  comments?: Resolver<
    ResolversTypes["CommitCommentConnection"],
    ParentType,
    ContextType,
    Partial<CommitCommentsArgs>
  >;
  commitResourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  committedDate?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  committedViaWeb?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  committer?: Resolver<
    Maybe<ResolversTypes["GitActor"]>,
    ParentType,
    ContextType
  >;
  deletions?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  deployments?: Resolver<
    Maybe<ResolversTypes["DeploymentConnection"]>,
    ParentType,
    ContextType,
    RequireFields<CommitDeploymentsArgs, "orderBy">
  >;
  file?: Resolver<
    Maybe<ResolversTypes["TreeEntry"]>,
    ParentType,
    ContextType,
    RequireFields<CommitFileArgs, "path">
  >;
  history?: Resolver<
    ResolversTypes["CommitHistoryConnection"],
    ParentType,
    ContextType,
    Partial<CommitHistoryArgs>
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  message?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  messageBody?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  messageBodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  messageHeadline?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  messageHeadlineHTML?: Resolver<
    ResolversTypes["HTML"],
    ParentType,
    ContextType
  >;
  oid?: Resolver<ResolversTypes["GitObjectID"], ParentType, ContextType>;
  onBehalfOf?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  parents?: Resolver<
    ResolversTypes["CommitConnection"],
    ParentType,
    ContextType,
    Partial<CommitParentsArgs>
  >;
  pushedDate?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  signature?: Resolver<
    Maybe<ResolversTypes["GitSignature"]>,
    ParentType,
    ContextType
  >;
  status?: Resolver<Maybe<ResolversTypes["Status"]>, ParentType, ContextType>;
  statusCheckRollup?: Resolver<
    Maybe<ResolversTypes["StatusCheckRollup"]>,
    ParentType,
    ContextType
  >;
  submodules?: Resolver<
    ResolversTypes["SubmoduleConnection"],
    ParentType,
    ContextType,
    Partial<CommitSubmodulesArgs>
  >;
  tarballUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  tree?: Resolver<ResolversTypes["Tree"], ParentType, ContextType>;
  treeResourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  treeUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerSubscription?: Resolver<
    Maybe<ResolversTypes["SubscriptionState"]>,
    ParentType,
    ContextType
  >;
  zipballUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommitAuthorEmailPatternParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CommitAuthorEmailPatternParameters"] = ResolversParentTypes["CommitAuthorEmailPatternParameters"],
> = {
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommitCommentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CommitComment"] = ResolversParentTypes["CommitComment"],
> = {
  author?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  authorAssociation?: Resolver<
    ResolversTypes["CommentAuthorAssociation"],
    ParentType,
    ContextType
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes["Commit"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  createdViaEmail?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isMinimized?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  lastEditedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  minimizedReason?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  path?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  reactions?: Resolver<
    ResolversTypes["ReactionConnection"],
    ParentType,
    ContextType,
    Partial<CommitCommentReactionsArgs>
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  userContentEdits?: Resolver<
    Maybe<ResolversTypes["UserContentEditConnection"]>,
    ParentType,
    ContextType,
    Partial<CommitCommentUserContentEditsArgs>
  >;
  viewerCanDelete?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanMinimize?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanReact?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCannotUpdateReasons?: Resolver<
    Array<ResolversTypes["CommentCannotUpdateReason"]>,
    ParentType,
    ContextType
  >;
  viewerDidAuthor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommitCommentConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CommitCommentConnection"] = ResolversParentTypes["CommitCommentConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CommitCommentEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CommitComment"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommitCommentEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CommitCommentEdge"] = ResolversParentTypes["CommitCommentEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["CommitComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommitCommentThreadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CommitCommentThread"] = ResolversParentTypes["CommitCommentThread"],
> = {
  comments?: Resolver<
    ResolversTypes["CommitCommentConnection"],
    ParentType,
    ContextType,
    Partial<CommitCommentThreadCommentsArgs>
  >;
  commit?: Resolver<Maybe<ResolversTypes["Commit"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommitConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CommitConnection"] = ResolversParentTypes["CommitConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CommitEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Commit"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommitContributionsByRepositoryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CommitContributionsByRepository"] = ResolversParentTypes["CommitContributionsByRepository"],
> = {
  contributions?: Resolver<
    ResolversTypes["CreatedCommitContributionConnection"],
    ParentType,
    ContextType,
    RequireFields<CommitContributionsByRepositoryContributionsArgs, "orderBy">
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommitEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CommitEdge"] = ResolversParentTypes["CommitEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Commit"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommitHistoryConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CommitHistoryConnection"] = ResolversParentTypes["CommitHistoryConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CommitEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Commit"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommitMessagePatternParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CommitMessagePatternParameters"] = ResolversParentTypes["CommitMessagePatternParameters"],
> = {
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommitterEmailPatternParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CommitterEmailPatternParameters"] = ResolversParentTypes["CommitterEmailPatternParameters"],
> = {
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ComparisonResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Comparison"] = ResolversParentTypes["Comparison"],
> = {
  aheadBy?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  baseTarget?: Resolver<ResolversTypes["GitObject"], ParentType, ContextType>;
  behindBy?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  commits?: Resolver<
    ResolversTypes["ComparisonCommitConnection"],
    ParentType,
    ContextType,
    Partial<ComparisonCommitsArgs>
  >;
  headTarget?: Resolver<ResolversTypes["GitObject"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  status?: Resolver<
    ResolversTypes["ComparisonStatus"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ComparisonCommitConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ComparisonCommitConnection"] = ResolversParentTypes["ComparisonCommitConnection"],
> = {
  authorCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CommitEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Commit"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConnectedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ConnectedEvent"] = ResolversParentTypes["ConnectedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isCrossRepository?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  source?: Resolver<
    ResolversTypes["ReferencedSubject"],
    ParentType,
    ContextType
  >;
  subject?: Resolver<
    ResolversTypes["ReferencedSubject"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributingGuidelinesResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ContributingGuidelines"] = ResolversParentTypes["ContributingGuidelines"],
> = {
  body?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  resourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  url?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Contribution"] = ResolversParentTypes["Contribution"],
> = {
  __resolveType: TypeResolveFn<
    | "CreatedCommitContribution"
    | "CreatedIssueContribution"
    | "CreatedPullRequestContribution"
    | "CreatedPullRequestReviewContribution"
    | "CreatedRepositoryContribution"
    | "JoinedGitHubContribution"
    | "RestrictedContribution",
    ParentType,
    ContextType
  >;
  isRestricted?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
};

export type ContributionCalendarResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ContributionCalendar"] = ResolversParentTypes["ContributionCalendar"],
> = {
  colors?: Resolver<Array<ResolversTypes["String"]>, ParentType, ContextType>;
  isHalloween?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  months?: Resolver<
    Array<ResolversTypes["ContributionCalendarMonth"]>,
    ParentType,
    ContextType
  >;
  totalContributions?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  weeks?: Resolver<
    Array<ResolversTypes["ContributionCalendarWeek"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributionCalendarDayResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ContributionCalendarDay"] = ResolversParentTypes["ContributionCalendarDay"],
> = {
  color?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  contributionCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  contributionLevel?: Resolver<
    ResolversTypes["ContributionLevel"],
    ParentType,
    ContextType
  >;
  date?: Resolver<ResolversTypes["Date"], ParentType, ContextType>;
  weekday?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributionCalendarMonthResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ContributionCalendarMonth"] = ResolversParentTypes["ContributionCalendarMonth"],
> = {
  firstDay?: Resolver<ResolversTypes["Date"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  totalWeeks?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  year?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributionCalendarWeekResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ContributionCalendarWeek"] = ResolversParentTypes["ContributionCalendarWeek"],
> = {
  contributionDays?: Resolver<
    Array<ResolversTypes["ContributionCalendarDay"]>,
    ParentType,
    ContextType
  >;
  firstDay?: Resolver<ResolversTypes["Date"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributionsCollectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ContributionsCollection"] = ResolversParentTypes["ContributionsCollection"],
> = {
  commitContributionsByRepository?: Resolver<
    Array<ResolversTypes["CommitContributionsByRepository"]>,
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionCommitContributionsByRepositoryArgs,
      "maxRepositories"
    >
  >;
  contributionCalendar?: Resolver<
    ResolversTypes["ContributionCalendar"],
    ParentType,
    ContextType
  >;
  contributionYears?: Resolver<
    Array<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  doesEndInCurrentMonth?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  earliestRestrictedContributionDate?: Resolver<
    Maybe<ResolversTypes["Date"]>,
    ParentType,
    ContextType
  >;
  endedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  firstIssueContribution?: Resolver<
    Maybe<ResolversTypes["CreatedIssueOrRestrictedContribution"]>,
    ParentType,
    ContextType
  >;
  firstPullRequestContribution?: Resolver<
    Maybe<ResolversTypes["CreatedPullRequestOrRestrictedContribution"]>,
    ParentType,
    ContextType
  >;
  firstRepositoryContribution?: Resolver<
    Maybe<ResolversTypes["CreatedRepositoryOrRestrictedContribution"]>,
    ParentType,
    ContextType
  >;
  hasActivityInThePast?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasAnyContributions?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasAnyRestrictedContributions?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isSingleDay?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  issueContributions?: Resolver<
    ResolversTypes["CreatedIssueContributionConnection"],
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionIssueContributionsArgs,
      "excludeFirst" | "excludePopular" | "orderBy"
    >
  >;
  issueContributionsByRepository?: Resolver<
    Array<ResolversTypes["IssueContributionsByRepository"]>,
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionIssueContributionsByRepositoryArgs,
      "excludeFirst" | "excludePopular" | "maxRepositories"
    >
  >;
  joinedGitHubContribution?: Resolver<
    Maybe<ResolversTypes["JoinedGitHubContribution"]>,
    ParentType,
    ContextType
  >;
  latestRestrictedContributionDate?: Resolver<
    Maybe<ResolversTypes["Date"]>,
    ParentType,
    ContextType
  >;
  mostRecentCollectionWithActivity?: Resolver<
    Maybe<ResolversTypes["ContributionsCollection"]>,
    ParentType,
    ContextType
  >;
  mostRecentCollectionWithoutActivity?: Resolver<
    Maybe<ResolversTypes["ContributionsCollection"]>,
    ParentType,
    ContextType
  >;
  popularIssueContribution?: Resolver<
    Maybe<ResolversTypes["CreatedIssueContribution"]>,
    ParentType,
    ContextType
  >;
  popularPullRequestContribution?: Resolver<
    Maybe<ResolversTypes["CreatedPullRequestContribution"]>,
    ParentType,
    ContextType
  >;
  pullRequestContributions?: Resolver<
    ResolversTypes["CreatedPullRequestContributionConnection"],
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionPullRequestContributionsArgs,
      "excludeFirst" | "excludePopular" | "orderBy"
    >
  >;
  pullRequestContributionsByRepository?: Resolver<
    Array<ResolversTypes["PullRequestContributionsByRepository"]>,
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionPullRequestContributionsByRepositoryArgs,
      "excludeFirst" | "excludePopular" | "maxRepositories"
    >
  >;
  pullRequestReviewContributions?: Resolver<
    ResolversTypes["CreatedPullRequestReviewContributionConnection"],
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionPullRequestReviewContributionsArgs,
      "orderBy"
    >
  >;
  pullRequestReviewContributionsByRepository?: Resolver<
    Array<ResolversTypes["PullRequestReviewContributionsByRepository"]>,
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionPullRequestReviewContributionsByRepositoryArgs,
      "maxRepositories"
    >
  >;
  repositoryContributions?: Resolver<
    ResolversTypes["CreatedRepositoryContributionConnection"],
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionRepositoryContributionsArgs,
      "excludeFirst" | "orderBy"
    >
  >;
  restrictedContributionsCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  startedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  totalCommitContributions?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalIssueContributions?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionTotalIssueContributionsArgs,
      "excludeFirst" | "excludePopular"
    >
  >;
  totalPullRequestContributions?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionTotalPullRequestContributionsArgs,
      "excludeFirst" | "excludePopular"
    >
  >;
  totalPullRequestReviewContributions?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalRepositoriesWithContributedCommits?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalRepositoriesWithContributedIssues?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionTotalRepositoriesWithContributedIssuesArgs,
      "excludeFirst" | "excludePopular"
    >
  >;
  totalRepositoriesWithContributedPullRequestReviews?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalRepositoriesWithContributedPullRequests?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionTotalRepositoriesWithContributedPullRequestsArgs,
      "excludeFirst" | "excludePopular"
    >
  >;
  totalRepositoryContributions?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType,
    RequireFields<
      ContributionsCollectionTotalRepositoryContributionsArgs,
      "excludeFirst"
    >
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConvertProjectCardNoteToIssuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ConvertProjectCardNoteToIssuePayload"] = ResolversParentTypes["ConvertProjectCardNoteToIssuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectCard?: Resolver<
    Maybe<ResolversTypes["ProjectCard"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConvertProjectV2DraftIssueItemToIssuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ConvertProjectV2DraftIssueItemToIssuePayload"] = ResolversParentTypes["ConvertProjectV2DraftIssueItemToIssuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  item?: Resolver<
    Maybe<ResolversTypes["ProjectV2Item"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConvertPullRequestToDraftPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ConvertPullRequestToDraftPayload"] = ResolversParentTypes["ConvertPullRequestToDraftPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConvertToDraftEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ConvertToDraftEvent"] = ResolversParentTypes["ConvertToDraftEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConvertedNoteToIssueEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ConvertedNoteToIssueEvent"] = ResolversParentTypes["ConvertedNoteToIssueEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  projectCard?: Resolver<
    Maybe<ResolversTypes["ProjectCard"]>,
    ParentType,
    ContextType
  >;
  projectColumnName?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConvertedToDiscussionEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ConvertedToDiscussionEvent"] = ResolversParentTypes["ConvertedToDiscussionEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  discussion?: Resolver<
    Maybe<ResolversTypes["Discussion"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CopilotEndpointsResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CopilotEndpoints"] = ResolversParentTypes["CopilotEndpoints"],
> = {
  api?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  originTracker?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  proxy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  telemetry?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CopyProjectV2PayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CopyProjectV2Payload"] = ResolversParentTypes["CopyProjectV2Payload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateAttributionInvitationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateAttributionInvitationPayload"] = ResolversParentTypes["CreateAttributionInvitationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  owner?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  source?: Resolver<
    Maybe<ResolversTypes["Claimable"]>,
    ParentType,
    ContextType
  >;
  target?: Resolver<
    Maybe<ResolversTypes["Claimable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateBranchProtectionRulePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateBranchProtectionRulePayload"] = ResolversParentTypes["CreateBranchProtectionRulePayload"],
> = {
  branchProtectionRule?: Resolver<
    Maybe<ResolversTypes["BranchProtectionRule"]>,
    ParentType,
    ContextType
  >;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateCheckRunPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateCheckRunPayload"] = ResolversParentTypes["CreateCheckRunPayload"],
> = {
  checkRun?: Resolver<
    Maybe<ResolversTypes["CheckRun"]>,
    ParentType,
    ContextType
  >;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateCheckSuitePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateCheckSuitePayload"] = ResolversParentTypes["CreateCheckSuitePayload"],
> = {
  checkSuite?: Resolver<
    Maybe<ResolversTypes["CheckSuite"]>,
    ParentType,
    ContextType
  >;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateCommitOnBranchPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateCommitOnBranchPayload"] = ResolversParentTypes["CreateCommitOnBranchPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  commit?: Resolver<Maybe<ResolversTypes["Commit"]>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDeploymentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateDeploymentPayload"] = ResolversParentTypes["CreateDeploymentPayload"],
> = {
  autoMerged?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  deployment?: Resolver<
    Maybe<ResolversTypes["Deployment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDeploymentStatusPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateDeploymentStatusPayload"] = ResolversParentTypes["CreateDeploymentStatusPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  deploymentStatus?: Resolver<
    Maybe<ResolversTypes["DeploymentStatus"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDiscussionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateDiscussionPayload"] = ResolversParentTypes["CreateDiscussionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  discussion?: Resolver<
    Maybe<ResolversTypes["Discussion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateEnterpriseOrganizationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateEnterpriseOrganizationPayload"] = ResolversParentTypes["CreateEnterpriseOrganizationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateEnvironmentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateEnvironmentPayload"] = ResolversParentTypes["CreateEnvironmentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  environment?: Resolver<
    Maybe<ResolversTypes["Environment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateIpAllowListEntryPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateIpAllowListEntryPayload"] = ResolversParentTypes["CreateIpAllowListEntryPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  ipAllowListEntry?: Resolver<
    Maybe<ResolversTypes["IpAllowListEntry"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateIssuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateIssuePayload"] = ResolversParentTypes["CreateIssuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  issue?: Resolver<Maybe<ResolversTypes["Issue"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateLabelPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateLabelPayload"] = ResolversParentTypes["CreateLabelPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  label?: Resolver<Maybe<ResolversTypes["Label"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateLinkedBranchPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateLinkedBranchPayload"] = ResolversParentTypes["CreateLinkedBranchPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  issue?: Resolver<Maybe<ResolversTypes["Issue"]>, ParentType, ContextType>;
  linkedBranch?: Resolver<
    Maybe<ResolversTypes["LinkedBranch"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateMigrationSourcePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateMigrationSourcePayload"] = ResolversParentTypes["CreateMigrationSourcePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  migrationSource?: Resolver<
    Maybe<ResolversTypes["MigrationSource"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateProjectPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateProjectPayload"] = ResolversParentTypes["CreateProjectPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  project?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateProjectV2FieldPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateProjectV2FieldPayload"] = ResolversParentTypes["CreateProjectV2FieldPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectV2Field?: Resolver<
    Maybe<ResolversTypes["ProjectV2FieldConfiguration"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateProjectV2PayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateProjectV2Payload"] = ResolversParentTypes["CreateProjectV2Payload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateProjectV2StatusUpdatePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateProjectV2StatusUpdatePayload"] = ResolversParentTypes["CreateProjectV2StatusUpdatePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  statusUpdate?: Resolver<
    Maybe<ResolversTypes["ProjectV2StatusUpdate"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatePullRequestPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatePullRequestPayload"] = ResolversParentTypes["CreatePullRequestPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateRefPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateRefPayload"] = ResolversParentTypes["CreateRefPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  ref?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateRepositoryPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateRepositoryPayload"] = ResolversParentTypes["CreateRepositoryPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateRepositoryRulesetPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateRepositoryRulesetPayload"] = ResolversParentTypes["CreateRepositoryRulesetPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  ruleset?: Resolver<
    Maybe<ResolversTypes["RepositoryRuleset"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateSponsorsListingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateSponsorsListingPayload"] = ResolversParentTypes["CreateSponsorsListingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  sponsorsListing?: Resolver<
    Maybe<ResolversTypes["SponsorsListing"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateSponsorsTierPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateSponsorsTierPayload"] = ResolversParentTypes["CreateSponsorsTierPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  sponsorsTier?: Resolver<
    Maybe<ResolversTypes["SponsorsTier"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateSponsorshipPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateSponsorshipPayload"] = ResolversParentTypes["CreateSponsorshipPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  sponsorship?: Resolver<
    Maybe<ResolversTypes["Sponsorship"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateSponsorshipsPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateSponsorshipsPayload"] = ResolversParentTypes["CreateSponsorshipsPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  sponsorables?: Resolver<
    Maybe<Array<ResolversTypes["Sponsorable"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTeamDiscussionCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateTeamDiscussionCommentPayload"] = ResolversParentTypes["CreateTeamDiscussionCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  teamDiscussionComment?: Resolver<
    Maybe<ResolversTypes["TeamDiscussionComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTeamDiscussionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateTeamDiscussionPayload"] = ResolversParentTypes["CreateTeamDiscussionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  teamDiscussion?: Resolver<
    Maybe<ResolversTypes["TeamDiscussion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateUserListPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreateUserListPayload"] = ResolversParentTypes["CreateUserListPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  list?: Resolver<Maybe<ResolversTypes["UserList"]>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedCommitContributionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedCommitContribution"] = ResolversParentTypes["CreatedCommitContribution"],
> = {
  commitCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  isRestricted?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedCommitContributionConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedCommitContributionConnection"] = ResolversParentTypes["CreatedCommitContributionConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CreatedCommitContributionEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CreatedCommitContribution"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedCommitContributionEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedCommitContributionEdge"] = ResolversParentTypes["CreatedCommitContributionEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["CreatedCommitContribution"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedIssueContributionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedIssueContribution"] = ResolversParentTypes["CreatedIssueContribution"],
> = {
  isRestricted?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes["Issue"], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedIssueContributionConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedIssueContributionConnection"] = ResolversParentTypes["CreatedIssueContributionConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CreatedIssueContributionEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CreatedIssueContribution"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedIssueContributionEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedIssueContributionEdge"] = ResolversParentTypes["CreatedIssueContributionEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["CreatedIssueContribution"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedIssueOrRestrictedContributionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedIssueOrRestrictedContribution"] = ResolversParentTypes["CreatedIssueOrRestrictedContribution"],
> = {
  __resolveType: TypeResolveFn<
    "CreatedIssueContribution" | "RestrictedContribution",
    ParentType,
    ContextType
  >;
};

export type CreatedPullRequestContributionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedPullRequestContribution"] = ResolversParentTypes["CreatedPullRequestContribution"],
> = {
  isRestricted?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedPullRequestContributionConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedPullRequestContributionConnection"] = ResolversParentTypes["CreatedPullRequestContributionConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CreatedPullRequestContributionEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CreatedPullRequestContribution"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedPullRequestContributionEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedPullRequestContributionEdge"] = ResolversParentTypes["CreatedPullRequestContributionEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["CreatedPullRequestContribution"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedPullRequestOrRestrictedContributionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedPullRequestOrRestrictedContribution"] = ResolversParentTypes["CreatedPullRequestOrRestrictedContribution"],
> = {
  __resolveType: TypeResolveFn<
    "CreatedPullRequestContribution" | "RestrictedContribution",
    ParentType,
    ContextType
  >;
};

export type CreatedPullRequestReviewContributionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedPullRequestReviewContribution"] = ResolversParentTypes["CreatedPullRequestReviewContribution"],
> = {
  isRestricted?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  pullRequestReview?: Resolver<
    ResolversTypes["PullRequestReview"],
    ParentType,
    ContextType
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedPullRequestReviewContributionConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedPullRequestReviewContributionConnection"] = ResolversParentTypes["CreatedPullRequestReviewContributionConnection"],
> = {
  edges?: Resolver<
    Maybe<
      Array<Maybe<ResolversTypes["CreatedPullRequestReviewContributionEdge"]>>
    >,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CreatedPullRequestReviewContribution"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedPullRequestReviewContributionEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedPullRequestReviewContributionEdge"] = ResolversParentTypes["CreatedPullRequestReviewContributionEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["CreatedPullRequestReviewContribution"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedRepositoryContributionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedRepositoryContribution"] = ResolversParentTypes["CreatedRepositoryContribution"],
> = {
  isRestricted?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedRepositoryContributionConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedRepositoryContributionConnection"] = ResolversParentTypes["CreatedRepositoryContributionConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CreatedRepositoryContributionEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CreatedRepositoryContribution"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedRepositoryContributionEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedRepositoryContributionEdge"] = ResolversParentTypes["CreatedRepositoryContributionEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["CreatedRepositoryContribution"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatedRepositoryOrRestrictedContributionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CreatedRepositoryOrRestrictedContribution"] = ResolversParentTypes["CreatedRepositoryOrRestrictedContribution"],
> = {
  __resolveType: TypeResolveFn<
    "CreatedRepositoryContribution" | "RestrictedContribution",
    ParentType,
    ContextType
  >;
};

export type CrossReferencedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["CrossReferencedEvent"] = ResolversParentTypes["CrossReferencedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isCrossRepository?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  referencedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  source?: Resolver<
    ResolversTypes["ReferencedSubject"],
    ParentType,
    ContextType
  >;
  target?: Resolver<
    ResolversTypes["ReferencedSubject"],
    ParentType,
    ContextType
  >;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  willCloseTarget?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface DateScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["Date"], any> {
  name: "Date";
}

export interface DateTimeScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["DateTime"], any> {
  name: "DateTime";
}

export type DeclineTopicSuggestionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeclineTopicSuggestionPayload"] = ResolversParentTypes["DeclineTopicSuggestionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  topic?: Resolver<Maybe<ResolversTypes["Topic"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Deletable"] = ResolversParentTypes["Deletable"],
> = {
  __resolveType: TypeResolveFn<
    | "CommitComment"
    | "Discussion"
    | "DiscussionComment"
    | "GistComment"
    | "Issue"
    | "IssueComment"
    | "PullRequestReview"
    | "PullRequestReviewComment"
    | "TeamDiscussion"
    | "TeamDiscussionComment",
    ParentType,
    ContextType
  >;
  viewerCanDelete?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
};

export type DeleteBranchProtectionRulePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteBranchProtectionRulePayload"] = ResolversParentTypes["DeleteBranchProtectionRulePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDeploymentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteDeploymentPayload"] = ResolversParentTypes["DeleteDeploymentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDiscussionCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteDiscussionCommentPayload"] = ResolversParentTypes["DeleteDiscussionCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  comment?: Resolver<
    Maybe<ResolversTypes["DiscussionComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDiscussionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteDiscussionPayload"] = ResolversParentTypes["DeleteDiscussionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  discussion?: Resolver<
    Maybe<ResolversTypes["Discussion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteEnvironmentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteEnvironmentPayload"] = ResolversParentTypes["DeleteEnvironmentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteIpAllowListEntryPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteIpAllowListEntryPayload"] = ResolversParentTypes["DeleteIpAllowListEntryPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  ipAllowListEntry?: Resolver<
    Maybe<ResolversTypes["IpAllowListEntry"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteIssueCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteIssueCommentPayload"] = ResolversParentTypes["DeleteIssueCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteIssuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteIssuePayload"] = ResolversParentTypes["DeleteIssuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteLabelPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteLabelPayload"] = ResolversParentTypes["DeleteLabelPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteLinkedBranchPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteLinkedBranchPayload"] = ResolversParentTypes["DeleteLinkedBranchPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  issue?: Resolver<Maybe<ResolversTypes["Issue"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletePackageVersionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeletePackageVersionPayload"] = ResolversParentTypes["DeletePackageVersionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  success?: Resolver<Maybe<ResolversTypes["Boolean"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteProjectCardPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteProjectCardPayload"] = ResolversParentTypes["DeleteProjectCardPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  column?: Resolver<
    Maybe<ResolversTypes["ProjectColumn"]>,
    ParentType,
    ContextType
  >;
  deletedCardId?: Resolver<
    Maybe<ResolversTypes["ID"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteProjectColumnPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteProjectColumnPayload"] = ResolversParentTypes["DeleteProjectColumnPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  deletedColumnId?: Resolver<
    Maybe<ResolversTypes["ID"]>,
    ParentType,
    ContextType
  >;
  project?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteProjectPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteProjectPayload"] = ResolversParentTypes["DeleteProjectPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  owner?: Resolver<
    Maybe<ResolversTypes["ProjectOwner"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteProjectV2FieldPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteProjectV2FieldPayload"] = ResolversParentTypes["DeleteProjectV2FieldPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectV2Field?: Resolver<
    Maybe<ResolversTypes["ProjectV2FieldConfiguration"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteProjectV2ItemPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteProjectV2ItemPayload"] = ResolversParentTypes["DeleteProjectV2ItemPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  deletedItemId?: Resolver<
    Maybe<ResolversTypes["ID"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteProjectV2PayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteProjectV2Payload"] = ResolversParentTypes["DeleteProjectV2Payload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteProjectV2StatusUpdatePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteProjectV2StatusUpdatePayload"] = ResolversParentTypes["DeleteProjectV2StatusUpdatePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  deletedStatusUpdateId?: Resolver<
    Maybe<ResolversTypes["ID"]>,
    ParentType,
    ContextType
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteProjectV2WorkflowPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteProjectV2WorkflowPayload"] = ResolversParentTypes["DeleteProjectV2WorkflowPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  deletedWorkflowId?: Resolver<
    Maybe<ResolversTypes["ID"]>,
    ParentType,
    ContextType
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletePullRequestReviewCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeletePullRequestReviewCommentPayload"] = ResolversParentTypes["DeletePullRequestReviewCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequestReview?: Resolver<
    Maybe<ResolversTypes["PullRequestReview"]>,
    ParentType,
    ContextType
  >;
  pullRequestReviewComment?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletePullRequestReviewPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeletePullRequestReviewPayload"] = ResolversParentTypes["DeletePullRequestReviewPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequestReview?: Resolver<
    Maybe<ResolversTypes["PullRequestReview"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteRefPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteRefPayload"] = ResolversParentTypes["DeleteRefPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteRepositoryRulesetPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteRepositoryRulesetPayload"] = ResolversParentTypes["DeleteRepositoryRulesetPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTeamDiscussionCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteTeamDiscussionCommentPayload"] = ResolversParentTypes["DeleteTeamDiscussionCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTeamDiscussionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteTeamDiscussionPayload"] = ResolversParentTypes["DeleteTeamDiscussionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteUserListPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteUserListPayload"] = ResolversParentTypes["DeleteUserListPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteVerifiableDomainPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeleteVerifiableDomainPayload"] = ResolversParentTypes["DeleteVerifiableDomainPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  owner?: Resolver<
    Maybe<ResolversTypes["VerifiableDomainOwner"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DemilestonedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DemilestonedEvent"] = ResolversParentTypes["DemilestonedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  milestoneTitle?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes["MilestoneItem"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DependabotUpdateResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DependabotUpdate"] = ResolversParentTypes["DependabotUpdate"],
> = {
  error?: Resolver<
    Maybe<ResolversTypes["DependabotUpdateError"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DependabotUpdateErrorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DependabotUpdateError"] = ResolversParentTypes["DependabotUpdateError"],
> = {
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  errorType?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DependencyGraphDependencyResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DependencyGraphDependency"] = ResolversParentTypes["DependencyGraphDependency"],
> = {
  hasDependencies?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  packageLabel?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  packageManager?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  packageName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  requirements?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DependencyGraphDependencyConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DependencyGraphDependencyConnection"] = ResolversParentTypes["DependencyGraphDependencyConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DependencyGraphDependencyEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DependencyGraphDependency"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DependencyGraphDependencyEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DependencyGraphDependencyEdge"] = ResolversParentTypes["DependencyGraphDependencyEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["DependencyGraphDependency"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DependencyGraphManifestResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DependencyGraphManifest"] = ResolversParentTypes["DependencyGraphManifest"],
> = {
  blobPath?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  dependencies?: Resolver<
    Maybe<ResolversTypes["DependencyGraphDependencyConnection"]>,
    ParentType,
    ContextType,
    Partial<DependencyGraphManifestDependenciesArgs>
  >;
  dependenciesCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  exceedsMaxSize?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  filename?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  parseable?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DependencyGraphManifestConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DependencyGraphManifestConnection"] = ResolversParentTypes["DependencyGraphManifestConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DependencyGraphManifestEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DependencyGraphManifest"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DependencyGraphManifestEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DependencyGraphManifestEdge"] = ResolversParentTypes["DependencyGraphManifestEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["DependencyGraphManifest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeployKeyResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeployKey"] = ResolversParentTypes["DeployKey"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  key?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  readOnly?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  verified?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeployKeyConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeployKeyConnection"] = ResolversParentTypes["DeployKeyConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeployKeyEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeployKey"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeployKeyEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeployKeyEdge"] = ResolversParentTypes["DeployKeyEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["DeployKey"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeployedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeployedEvent"] = ResolversParentTypes["DeployedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  deployment?: Resolver<ResolversTypes["Deployment"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  ref?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Deployment"] = ResolversParentTypes["Deployment"],
> = {
  commit?: Resolver<Maybe<ResolversTypes["Commit"]>, ParentType, ContextType>;
  commitOid?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<ResolversTypes["Actor"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  environment?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  latestEnvironment?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  latestStatus?: Resolver<
    Maybe<ResolversTypes["DeploymentStatus"]>,
    ParentType,
    ContextType
  >;
  originalEnvironment?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  payload?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  state?: Resolver<
    Maybe<ResolversTypes["DeploymentState"]>,
    ParentType,
    ContextType
  >;
  statuses?: Resolver<
    Maybe<ResolversTypes["DeploymentStatusConnection"]>,
    ParentType,
    ContextType,
    Partial<DeploymentStatusesArgs>
  >;
  task?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentConnection"] = ResolversParentTypes["DeploymentConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeploymentEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Deployment"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentEdge"] = ResolversParentTypes["DeploymentEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Deployment"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentEnvironmentChangedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentEnvironmentChangedEvent"] = ResolversParentTypes["DeploymentEnvironmentChangedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  deploymentStatus?: Resolver<
    ResolversTypes["DeploymentStatus"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentProtectionRuleResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentProtectionRule"] = ResolversParentTypes["DeploymentProtectionRule"],
> = {
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  preventSelfReview?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  reviewers?: Resolver<
    ResolversTypes["DeploymentReviewerConnection"],
    ParentType,
    ContextType,
    Partial<DeploymentProtectionRuleReviewersArgs>
  >;
  timeout?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  type?: Resolver<
    ResolversTypes["DeploymentProtectionRuleType"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentProtectionRuleConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentProtectionRuleConnection"] = ResolversParentTypes["DeploymentProtectionRuleConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeploymentProtectionRuleEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeploymentProtectionRule"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentProtectionRuleEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentProtectionRuleEdge"] = ResolversParentTypes["DeploymentProtectionRuleEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["DeploymentProtectionRule"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentRequestResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentRequest"] = ResolversParentTypes["DeploymentRequest"],
> = {
  currentUserCanApprove?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  environment?: Resolver<
    ResolversTypes["Environment"],
    ParentType,
    ContextType
  >;
  reviewers?: Resolver<
    ResolversTypes["DeploymentReviewerConnection"],
    ParentType,
    ContextType,
    Partial<DeploymentRequestReviewersArgs>
  >;
  waitTimer?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  waitTimerStartedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentRequestConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentRequestConnection"] = ResolversParentTypes["DeploymentRequestConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeploymentRequestEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeploymentRequest"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentRequestEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentRequestEdge"] = ResolversParentTypes["DeploymentRequestEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["DeploymentRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentReviewResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentReview"] = ResolversParentTypes["DeploymentReview"],
> = {
  comment?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  environments?: Resolver<
    ResolversTypes["EnvironmentConnection"],
    ParentType,
    ContextType,
    Partial<DeploymentReviewEnvironmentsArgs>
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  state?: Resolver<
    ResolversTypes["DeploymentReviewState"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentReviewConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentReviewConnection"] = ResolversParentTypes["DeploymentReviewConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeploymentReviewEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeploymentReview"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentReviewEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentReviewEdge"] = ResolversParentTypes["DeploymentReviewEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["DeploymentReview"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentReviewerResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentReviewer"] = ResolversParentTypes["DeploymentReviewer"],
> = {
  __resolveType: TypeResolveFn<"Team" | "User", ParentType, ContextType>;
};

export type DeploymentReviewerConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentReviewerConnection"] = ResolversParentTypes["DeploymentReviewerConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeploymentReviewerEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeploymentReviewer"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentReviewerEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentReviewerEdge"] = ResolversParentTypes["DeploymentReviewerEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["DeploymentReviewer"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentStatusResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentStatus"] = ResolversParentTypes["DeploymentStatus"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<ResolversTypes["Actor"], ParentType, ContextType>;
  deployment?: Resolver<ResolversTypes["Deployment"], ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  environment?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  environmentUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  logUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  state?: Resolver<
    ResolversTypes["DeploymentStatusState"],
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentStatusConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentStatusConnection"] = ResolversParentTypes["DeploymentStatusConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeploymentStatusEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DeploymentStatus"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeploymentStatusEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DeploymentStatusEdge"] = ResolversParentTypes["DeploymentStatusEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["DeploymentStatus"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DequeuePullRequestPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DequeuePullRequestPayload"] = ResolversParentTypes["DequeuePullRequestPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  mergeQueueEntry?: Resolver<
    Maybe<ResolversTypes["MergeQueueEntry"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DisablePullRequestAutoMergePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DisablePullRequestAutoMergePayload"] = ResolversParentTypes["DisablePullRequestAutoMergePayload"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DisconnectedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DisconnectedEvent"] = ResolversParentTypes["DisconnectedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isCrossRepository?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  source?: Resolver<
    ResolversTypes["ReferencedSubject"],
    ParentType,
    ContextType
  >;
  subject?: Resolver<
    ResolversTypes["ReferencedSubject"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Discussion"] = ResolversParentTypes["Discussion"],
> = {
  activeLockReason?: Resolver<
    Maybe<ResolversTypes["LockReason"]>,
    ParentType,
    ContextType
  >;
  answer?: Resolver<
    Maybe<ResolversTypes["DiscussionComment"]>,
    ParentType,
    ContextType
  >;
  answerChosenAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  answerChosenBy?: Resolver<
    Maybe<ResolversTypes["Actor"]>,
    ParentType,
    ContextType
  >;
  author?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  authorAssociation?: Resolver<
    ResolversTypes["CommentAuthorAssociation"],
    ParentType,
    ContextType
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  category?: Resolver<
    ResolversTypes["DiscussionCategory"],
    ParentType,
    ContextType
  >;
  closed?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  closedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  comments?: Resolver<
    ResolversTypes["DiscussionCommentConnection"],
    ParentType,
    ContextType,
    Partial<DiscussionCommentsArgs>
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  createdViaEmail?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isAnswered?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  labels?: Resolver<
    Maybe<ResolversTypes["LabelConnection"]>,
    ParentType,
    ContextType,
    RequireFields<DiscussionLabelsArgs, "orderBy">
  >;
  lastEditedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  locked?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  poll?: Resolver<
    Maybe<ResolversTypes["DiscussionPoll"]>,
    ParentType,
    ContextType
  >;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  reactions?: Resolver<
    ResolversTypes["ReactionConnection"],
    ParentType,
    ContextType,
    Partial<DiscussionReactionsArgs>
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  stateReason?: Resolver<
    Maybe<ResolversTypes["DiscussionStateReason"]>,
    ParentType,
    ContextType
  >;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  upvoteCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  userContentEdits?: Resolver<
    Maybe<ResolversTypes["UserContentEditConnection"]>,
    ParentType,
    ContextType,
    Partial<DiscussionUserContentEditsArgs>
  >;
  viewerCanClose?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanDelete?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanLabel?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanReopen?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanSubscribe?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUpvote?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerDidAuthor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerHasUpvoted?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerSubscription?: Resolver<
    Maybe<ResolversTypes["SubscriptionState"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionCategoryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DiscussionCategory"] = ResolversParentTypes["DiscussionCategory"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  emoji?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emojiHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isAnswerable?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionCategoryConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DiscussionCategoryConnection"] = ResolversParentTypes["DiscussionCategoryConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DiscussionCategoryEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DiscussionCategory"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionCategoryEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DiscussionCategoryEdge"] = ResolversParentTypes["DiscussionCategoryEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["DiscussionCategory"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionCommentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DiscussionComment"] = ResolversParentTypes["DiscussionComment"],
> = {
  author?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  authorAssociation?: Resolver<
    ResolversTypes["CommentAuthorAssociation"],
    ParentType,
    ContextType
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  createdViaEmail?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  deletedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  discussion?: Resolver<
    Maybe<ResolversTypes["Discussion"]>,
    ParentType,
    ContextType
  >;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isAnswer?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  lastEditedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  minimizedReason?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  reactions?: Resolver<
    ResolversTypes["ReactionConnection"],
    ParentType,
    ContextType,
    Partial<DiscussionCommentReactionsArgs>
  >;
  replies?: Resolver<
    ResolversTypes["DiscussionCommentConnection"],
    ParentType,
    ContextType,
    Partial<DiscussionCommentRepliesArgs>
  >;
  replyTo?: Resolver<
    Maybe<ResolversTypes["DiscussionComment"]>,
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  upvoteCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  userContentEdits?: Resolver<
    Maybe<ResolversTypes["UserContentEditConnection"]>,
    ParentType,
    ContextType,
    Partial<DiscussionCommentUserContentEditsArgs>
  >;
  viewerCanDelete?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanMarkAsAnswer?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanMinimize?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanReact?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanUnmarkAsAnswer?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUpvote?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCannotUpdateReasons?: Resolver<
    Array<ResolversTypes["CommentCannotUpdateReason"]>,
    ParentType,
    ContextType
  >;
  viewerDidAuthor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerHasUpvoted?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionCommentConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DiscussionCommentConnection"] = ResolversParentTypes["DiscussionCommentConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DiscussionCommentEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DiscussionComment"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionCommentEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DiscussionCommentEdge"] = ResolversParentTypes["DiscussionCommentEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["DiscussionComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DiscussionConnection"] = ResolversParentTypes["DiscussionConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DiscussionEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Discussion"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DiscussionEdge"] = ResolversParentTypes["DiscussionEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Discussion"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionPollResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DiscussionPoll"] = ResolversParentTypes["DiscussionPoll"],
> = {
  discussion?: Resolver<
    Maybe<ResolversTypes["Discussion"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  options?: Resolver<
    Maybe<ResolversTypes["DiscussionPollOptionConnection"]>,
    ParentType,
    ContextType,
    RequireFields<DiscussionPollOptionsArgs, "orderBy">
  >;
  question?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  totalVoteCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  viewerCanVote?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerHasVoted?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionPollOptionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DiscussionPollOption"] = ResolversParentTypes["DiscussionPollOption"],
> = {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  option?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  poll?: Resolver<
    Maybe<ResolversTypes["DiscussionPoll"]>,
    ParentType,
    ContextType
  >;
  totalVoteCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  viewerHasVoted?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionPollOptionConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DiscussionPollOptionConnection"] = ResolversParentTypes["DiscussionPollOptionConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DiscussionPollOptionEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["DiscussionPollOption"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscussionPollOptionEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DiscussionPollOptionEdge"] = ResolversParentTypes["DiscussionPollOptionEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["DiscussionPollOption"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DismissPullRequestReviewPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DismissPullRequestReviewPayload"] = ResolversParentTypes["DismissPullRequestReviewPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequestReview?: Resolver<
    Maybe<ResolversTypes["PullRequestReview"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DismissRepositoryVulnerabilityAlertPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DismissRepositoryVulnerabilityAlertPayload"] = ResolversParentTypes["DismissRepositoryVulnerabilityAlertPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryVulnerabilityAlert?: Resolver<
    Maybe<ResolversTypes["RepositoryVulnerabilityAlert"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DraftIssueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["DraftIssue"] = ResolversParentTypes["DraftIssue"],
> = {
  assignees?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<DraftIssueAssigneesArgs>
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  projectV2Items?: Resolver<
    ResolversTypes["ProjectV2ItemConnection"],
    ParentType,
    ContextType,
    Partial<DraftIssueProjectV2ItemsArgs>
  >;
  projectsV2?: Resolver<
    ResolversTypes["ProjectV2Connection"],
    ParentType,
    ContextType,
    Partial<DraftIssueProjectsV2Args>
  >;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnablePullRequestAutoMergePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnablePullRequestAutoMergePayload"] = ResolversParentTypes["EnablePullRequestAutoMergePayload"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnqueuePullRequestPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnqueuePullRequestPayload"] = ResolversParentTypes["EnqueuePullRequestPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  mergeQueueEntry?: Resolver<
    Maybe<ResolversTypes["MergeQueueEntry"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Enterprise"] = ResolversParentTypes["Enterprise"],
> = {
  announcement?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  announcementCreatedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  announcementExpiresAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  announcementUserDismissible?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  avatarUrl?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType,
    Partial<EnterpriseAvatarUrlArgs>
  >;
  billingEmail?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  billingInfo?: Resolver<
    Maybe<ResolversTypes["EnterpriseBillingInfo"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  descriptionHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  members?: Resolver<
    ResolversTypes["EnterpriseMemberConnection"],
    ParentType,
    ContextType,
    RequireFields<EnterpriseMembersArgs, "hasTwoFactorEnabled" | "orderBy">
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  organizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<EnterpriseOrganizationsArgs, "orderBy">
  >;
  ownerInfo?: Resolver<
    Maybe<ResolversTypes["EnterpriseOwnerInfo"]>,
    ParentType,
    ContextType
  >;
  readme?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  readmeHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  viewerIsAdmin?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseAdministratorConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseAdministratorConnection"] = ResolversParentTypes["EnterpriseAdministratorConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseAdministratorEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["User"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseAdministratorEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseAdministratorEdge"] = ResolversParentTypes["EnterpriseAdministratorEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  role?: Resolver<
    ResolversTypes["EnterpriseAdministratorRole"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseAdministratorInvitationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseAdministratorInvitation"] = ResolversParentTypes["EnterpriseAdministratorInvitation"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes["Enterprise"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  invitee?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  inviter?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  role?: Resolver<
    ResolversTypes["EnterpriseAdministratorRole"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseAdministratorInvitationConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseAdministratorInvitationConnection"] = ResolversParentTypes["EnterpriseAdministratorInvitationConnection"],
> = {
  edges?: Resolver<
    Maybe<
      Array<Maybe<ResolversTypes["EnterpriseAdministratorInvitationEdge"]>>
    >,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseAdministratorInvitation"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseAdministratorInvitationEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseAdministratorInvitationEdge"] = ResolversParentTypes["EnterpriseAdministratorInvitationEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["EnterpriseAdministratorInvitation"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseAuditEntryDataResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseAuditEntryData"] = ResolversParentTypes["EnterpriseAuditEntryData"],
> = {
  __resolveType: TypeResolveFn<
    | "MembersCanDeleteReposClearAuditEntry"
    | "MembersCanDeleteReposDisableAuditEntry"
    | "MembersCanDeleteReposEnableAuditEntry"
    | "OrgInviteToBusinessAuditEntry"
    | "PrivateRepositoryForkingDisableAuditEntry"
    | "PrivateRepositoryForkingEnableAuditEntry"
    | "RepositoryVisibilityChangeDisableAuditEntry"
    | "RepositoryVisibilityChangeEnableAuditEntry",
    ParentType,
    ContextType
  >;
  enterpriseResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  enterpriseSlug?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterpriseUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
};

export type EnterpriseBillingInfoResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseBillingInfo"] = ResolversParentTypes["EnterpriseBillingInfo"],
> = {
  allLicensableUsersCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  assetPacks?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  bandwidthQuota?: Resolver<ResolversTypes["Float"], ParentType, ContextType>;
  bandwidthUsage?: Resolver<ResolversTypes["Float"], ParentType, ContextType>;
  bandwidthUsagePercentage?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  storageQuota?: Resolver<ResolversTypes["Float"], ParentType, ContextType>;
  storageUsage?: Resolver<ResolversTypes["Float"], ParentType, ContextType>;
  storageUsagePercentage?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalAvailableLicenses?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalLicenses?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseConnection"] = ResolversParentTypes["EnterpriseConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Enterprise"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseEdge"] = ResolversParentTypes["EnterpriseEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Enterprise"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseFailedInvitationConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseFailedInvitationConnection"] = ResolversParentTypes["EnterpriseFailedInvitationConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseFailedInvitationEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["OrganizationInvitation"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  totalUniqueUserCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseFailedInvitationEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseFailedInvitationEdge"] = ResolversParentTypes["EnterpriseFailedInvitationEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["OrganizationInvitation"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseIdentityProviderResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseIdentityProvider"] = ResolversParentTypes["EnterpriseIdentityProvider"],
> = {
  digestMethod?: Resolver<
    Maybe<ResolversTypes["SamlDigestAlgorithm"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  externalIdentities?: Resolver<
    ResolversTypes["ExternalIdentityConnection"],
    ParentType,
    ContextType,
    Partial<EnterpriseIdentityProviderExternalIdentitiesArgs>
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  idpCertificate?: Resolver<
    Maybe<ResolversTypes["X509Certificate"]>,
    ParentType,
    ContextType
  >;
  issuer?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  recoveryCodes?: Resolver<
    Maybe<Array<ResolversTypes["String"]>>,
    ParentType,
    ContextType
  >;
  signatureMethod?: Resolver<
    Maybe<ResolversTypes["SamlSignatureAlgorithm"]>,
    ParentType,
    ContextType
  >;
  ssoUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseMemberResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseMember"] = ResolversParentTypes["EnterpriseMember"],
> = {
  __resolveType: TypeResolveFn<
    "EnterpriseUserAccount" | "User",
    ParentType,
    ContextType
  >;
};

export type EnterpriseMemberConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseMemberConnection"] = ResolversParentTypes["EnterpriseMemberConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseMemberEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseMember"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseMemberEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseMemberEdge"] = ResolversParentTypes["EnterpriseMemberEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["EnterpriseMember"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseMemberInvitationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseMemberInvitation"] = ResolversParentTypes["EnterpriseMemberInvitation"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes["Enterprise"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  invitee?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  inviter?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseMemberInvitationConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseMemberInvitationConnection"] = ResolversParentTypes["EnterpriseMemberInvitationConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseMemberInvitationEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseMemberInvitation"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseMemberInvitationEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseMemberInvitationEdge"] = ResolversParentTypes["EnterpriseMemberInvitationEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["EnterpriseMemberInvitation"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseOrganizationMembershipConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseOrganizationMembershipConnection"] = ResolversParentTypes["EnterpriseOrganizationMembershipConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseOrganizationMembershipEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Organization"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseOrganizationMembershipEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseOrganizationMembershipEdge"] = ResolversParentTypes["EnterpriseOrganizationMembershipEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  role?: Resolver<
    ResolversTypes["EnterpriseUserAccountMembershipRole"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseOutsideCollaboratorConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseOutsideCollaboratorConnection"] = ResolversParentTypes["EnterpriseOutsideCollaboratorConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseOutsideCollaboratorEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["User"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseOutsideCollaboratorEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseOutsideCollaboratorEdge"] = ResolversParentTypes["EnterpriseOutsideCollaboratorEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  repositories?: Resolver<
    ResolversTypes["EnterpriseRepositoryInfoConnection"],
    ParentType,
    ContextType,
    RequireFields<EnterpriseOutsideCollaboratorEdgeRepositoriesArgs, "orderBy">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseOwnerInfoResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseOwnerInfo"] = ResolversParentTypes["EnterpriseOwnerInfo"],
> = {
  admins?: Resolver<
    ResolversTypes["EnterpriseAdministratorConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoAdminsArgs,
      "hasTwoFactorEnabled" | "orderBy"
    >
  >;
  affiliatedUsersWithTwoFactorDisabled?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<EnterpriseOwnerInfoAffiliatedUsersWithTwoFactorDisabledArgs>
  >;
  affiliatedUsersWithTwoFactorDisabledExist?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  allowPrivateRepositoryForkingSetting?: Resolver<
    ResolversTypes["EnterpriseEnabledDisabledSettingValue"],
    ParentType,
    ContextType
  >;
  allowPrivateRepositoryForkingSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoAllowPrivateRepositoryForkingSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  allowPrivateRepositoryForkingSettingPolicyValue?: Resolver<
    Maybe<ResolversTypes["EnterpriseAllowPrivateRepositoryForkingPolicyValue"]>,
    ParentType,
    ContextType
  >;
  defaultRepositoryPermissionSetting?: Resolver<
    ResolversTypes["EnterpriseDefaultRepositoryPermissionSettingValue"],
    ParentType,
    ContextType
  >;
  defaultRepositoryPermissionSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoDefaultRepositoryPermissionSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  domains?: Resolver<
    ResolversTypes["VerifiableDomainConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoDomainsArgs,
      "isApproved" | "isVerified" | "orderBy"
    >
  >;
  enterpriseServerInstallations?: Resolver<
    ResolversTypes["EnterpriseServerInstallationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoEnterpriseServerInstallationsArgs,
      "connectedOnly" | "orderBy"
    >
  >;
  failedInvitations?: Resolver<
    ResolversTypes["EnterpriseFailedInvitationConnection"],
    ParentType,
    ContextType,
    Partial<EnterpriseOwnerInfoFailedInvitationsArgs>
  >;
  ipAllowListEnabledSetting?: Resolver<
    ResolversTypes["IpAllowListEnabledSettingValue"],
    ParentType,
    ContextType
  >;
  ipAllowListEntries?: Resolver<
    ResolversTypes["IpAllowListEntryConnection"],
    ParentType,
    ContextType,
    RequireFields<EnterpriseOwnerInfoIpAllowListEntriesArgs, "orderBy">
  >;
  ipAllowListForInstalledAppsEnabledSetting?: Resolver<
    ResolversTypes["IpAllowListForInstalledAppsEnabledSettingValue"],
    ParentType,
    ContextType
  >;
  isUpdatingDefaultRepositoryPermission?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isUpdatingTwoFactorRequirement?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  membersCanChangeRepositoryVisibilitySetting?: Resolver<
    ResolversTypes["EnterpriseEnabledDisabledSettingValue"],
    ParentType,
    ContextType
  >;
  membersCanChangeRepositoryVisibilitySettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoMembersCanChangeRepositoryVisibilitySettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  membersCanCreateInternalRepositoriesSetting?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  membersCanCreatePrivateRepositoriesSetting?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  membersCanCreatePublicRepositoriesSetting?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  membersCanCreateRepositoriesSetting?: Resolver<
    Maybe<ResolversTypes["EnterpriseMembersCanCreateRepositoriesSettingValue"]>,
    ParentType,
    ContextType
  >;
  membersCanCreateRepositoriesSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoMembersCanCreateRepositoriesSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  membersCanDeleteIssuesSetting?: Resolver<
    ResolversTypes["EnterpriseEnabledDisabledSettingValue"],
    ParentType,
    ContextType
  >;
  membersCanDeleteIssuesSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoMembersCanDeleteIssuesSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  membersCanDeleteRepositoriesSetting?: Resolver<
    ResolversTypes["EnterpriseEnabledDisabledSettingValue"],
    ParentType,
    ContextType
  >;
  membersCanDeleteRepositoriesSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoMembersCanDeleteRepositoriesSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  membersCanInviteCollaboratorsSetting?: Resolver<
    ResolversTypes["EnterpriseEnabledDisabledSettingValue"],
    ParentType,
    ContextType
  >;
  membersCanInviteCollaboratorsSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoMembersCanInviteCollaboratorsSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  membersCanMakePurchasesSetting?: Resolver<
    ResolversTypes["EnterpriseMembersCanMakePurchasesSettingValue"],
    ParentType,
    ContextType
  >;
  membersCanUpdateProtectedBranchesSetting?: Resolver<
    ResolversTypes["EnterpriseEnabledDisabledSettingValue"],
    ParentType,
    ContextType
  >;
  membersCanUpdateProtectedBranchesSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoMembersCanUpdateProtectedBranchesSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  membersCanViewDependencyInsightsSetting?: Resolver<
    ResolversTypes["EnterpriseEnabledDisabledSettingValue"],
    ParentType,
    ContextType
  >;
  membersCanViewDependencyInsightsSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoMembersCanViewDependencyInsightsSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  notificationDeliveryRestrictionEnabledSetting?: Resolver<
    ResolversTypes["NotificationRestrictionSettingValue"],
    ParentType,
    ContextType
  >;
  oidcProvider?: Resolver<
    Maybe<ResolversTypes["OIDCProvider"]>,
    ParentType,
    ContextType
  >;
  organizationProjectsSetting?: Resolver<
    ResolversTypes["EnterpriseEnabledDisabledSettingValue"],
    ParentType,
    ContextType
  >;
  organizationProjectsSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoOrganizationProjectsSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  outsideCollaborators?: Resolver<
    ResolversTypes["EnterpriseOutsideCollaboratorConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoOutsideCollaboratorsArgs,
      "hasTwoFactorEnabled" | "orderBy"
    >
  >;
  pendingAdminInvitations?: Resolver<
    ResolversTypes["EnterpriseAdministratorInvitationConnection"],
    ParentType,
    ContextType,
    RequireFields<EnterpriseOwnerInfoPendingAdminInvitationsArgs, "orderBy">
  >;
  pendingCollaboratorInvitations?: Resolver<
    ResolversTypes["RepositoryInvitationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoPendingCollaboratorInvitationsArgs,
      "orderBy"
    >
  >;
  pendingMemberInvitations?: Resolver<
    ResolversTypes["EnterprisePendingMemberInvitationConnection"],
    ParentType,
    ContextType,
    Partial<EnterpriseOwnerInfoPendingMemberInvitationsArgs>
  >;
  pendingUnaffiliatedMemberInvitations?: Resolver<
    ResolversTypes["EnterpriseMemberInvitationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoPendingUnaffiliatedMemberInvitationsArgs,
      "orderBy"
    >
  >;
  repositoryProjectsSetting?: Resolver<
    ResolversTypes["EnterpriseEnabledDisabledSettingValue"],
    ParentType,
    ContextType
  >;
  repositoryProjectsSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoRepositoryProjectsSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  samlIdentityProvider?: Resolver<
    Maybe<ResolversTypes["EnterpriseIdentityProvider"]>,
    ParentType,
    ContextType
  >;
  samlIdentityProviderSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoSamlIdentityProviderSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  supportEntitlements?: Resolver<
    ResolversTypes["EnterpriseMemberConnection"],
    ParentType,
    ContextType,
    RequireFields<EnterpriseOwnerInfoSupportEntitlementsArgs, "orderBy">
  >;
  teamDiscussionsSetting?: Resolver<
    ResolversTypes["EnterpriseEnabledDisabledSettingValue"],
    ParentType,
    ContextType
  >;
  teamDiscussionsSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoTeamDiscussionsSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  twoFactorRequiredSetting?: Resolver<
    ResolversTypes["EnterpriseEnabledSettingValue"],
    ParentType,
    ContextType
  >;
  twoFactorRequiredSettingOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseOwnerInfoTwoFactorRequiredSettingOrganizationsArgs,
      "orderBy" | "value"
    >
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterprisePendingMemberInvitationConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterprisePendingMemberInvitationConnection"] = ResolversParentTypes["EnterprisePendingMemberInvitationConnection"],
> = {
  edges?: Resolver<
    Maybe<
      Array<Maybe<ResolversTypes["EnterprisePendingMemberInvitationEdge"]>>
    >,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["OrganizationInvitation"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  totalUniqueUserCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterprisePendingMemberInvitationEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterprisePendingMemberInvitationEdge"] = ResolversParentTypes["EnterprisePendingMemberInvitationEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["OrganizationInvitation"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseRepositoryInfoResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseRepositoryInfo"] = ResolversParentTypes["EnterpriseRepositoryInfo"],
> = {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  nameWithOwner?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseRepositoryInfoConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseRepositoryInfoConnection"] = ResolversParentTypes["EnterpriseRepositoryInfoConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseRepositoryInfoEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseRepositoryInfo"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseRepositoryInfoEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseRepositoryInfoEdge"] = ResolversParentTypes["EnterpriseRepositoryInfoEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["EnterpriseRepositoryInfo"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerInstallationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerInstallation"] = ResolversParentTypes["EnterpriseServerInstallation"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  customerName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  hostName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isConnected?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  userAccounts?: Resolver<
    ResolversTypes["EnterpriseServerUserAccountConnection"],
    ParentType,
    ContextType,
    RequireFields<EnterpriseServerInstallationUserAccountsArgs, "orderBy">
  >;
  userAccountsUploads?: Resolver<
    ResolversTypes["EnterpriseServerUserAccountsUploadConnection"],
    ParentType,
    ContextType,
    RequireFields<
      EnterpriseServerInstallationUserAccountsUploadsArgs,
      "orderBy"
    >
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerInstallationConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerInstallationConnection"] = ResolversParentTypes["EnterpriseServerInstallationConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseServerInstallationEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseServerInstallation"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerInstallationEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerInstallationEdge"] = ResolversParentTypes["EnterpriseServerInstallationEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["EnterpriseServerInstallation"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerInstallationMembershipConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerInstallationMembershipConnection"] = ResolversParentTypes["EnterpriseServerInstallationMembershipConnection"],
> = {
  edges?: Resolver<
    Maybe<
      Array<Maybe<ResolversTypes["EnterpriseServerInstallationMembershipEdge"]>>
    >,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseServerInstallation"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerInstallationMembershipEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerInstallationMembershipEdge"] = ResolversParentTypes["EnterpriseServerInstallationMembershipEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["EnterpriseServerInstallation"]>,
    ParentType,
    ContextType
  >;
  role?: Resolver<
    ResolversTypes["EnterpriseUserAccountMembershipRole"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerUserAccountResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerUserAccount"] = ResolversParentTypes["EnterpriseServerUserAccount"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  emails?: Resolver<
    ResolversTypes["EnterpriseServerUserAccountEmailConnection"],
    ParentType,
    ContextType,
    RequireFields<EnterpriseServerUserAccountEmailsArgs, "orderBy">
  >;
  enterpriseServerInstallation?: Resolver<
    ResolversTypes["EnterpriseServerInstallation"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isSiteAdmin?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  login?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  profileName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  remoteCreatedAt?: Resolver<
    ResolversTypes["DateTime"],
    ParentType,
    ContextType
  >;
  remoteUserId?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerUserAccountConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerUserAccountConnection"] = ResolversParentTypes["EnterpriseServerUserAccountConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseServerUserAccountEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseServerUserAccount"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerUserAccountEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerUserAccountEdge"] = ResolversParentTypes["EnterpriseServerUserAccountEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["EnterpriseServerUserAccount"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerUserAccountEmailResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerUserAccountEmail"] = ResolversParentTypes["EnterpriseServerUserAccountEmail"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  email?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isPrimary?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  userAccount?: Resolver<
    ResolversTypes["EnterpriseServerUserAccount"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerUserAccountEmailConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerUserAccountEmailConnection"] = ResolversParentTypes["EnterpriseServerUserAccountEmailConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseServerUserAccountEmailEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseServerUserAccountEmail"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerUserAccountEmailEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerUserAccountEmailEdge"] = ResolversParentTypes["EnterpriseServerUserAccountEmailEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["EnterpriseServerUserAccountEmail"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerUserAccountsUploadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerUserAccountsUpload"] = ResolversParentTypes["EnterpriseServerUserAccountsUpload"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes["Enterprise"], ParentType, ContextType>;
  enterpriseServerInstallation?: Resolver<
    ResolversTypes["EnterpriseServerInstallation"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  syncState?: Resolver<
    ResolversTypes["EnterpriseServerUserAccountsUploadSyncState"],
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerUserAccountsUploadConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerUserAccountsUploadConnection"] = ResolversParentTypes["EnterpriseServerUserAccountsUploadConnection"],
> = {
  edges?: Resolver<
    Maybe<
      Array<Maybe<ResolversTypes["EnterpriseServerUserAccountsUploadEdge"]>>
    >,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnterpriseServerUserAccountsUpload"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseServerUserAccountsUploadEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseServerUserAccountsUploadEdge"] = ResolversParentTypes["EnterpriseServerUserAccountsUploadEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["EnterpriseServerUserAccountsUpload"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnterpriseUserAccountResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnterpriseUserAccount"] = ResolversParentTypes["EnterpriseUserAccount"],
> = {
  avatarUrl?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType,
    Partial<EnterpriseUserAccountAvatarUrlArgs>
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes["Enterprise"], ParentType, ContextType>;
  enterpriseInstallations?: Resolver<
    ResolversTypes["EnterpriseServerInstallationMembershipConnection"],
    ParentType,
    ContextType,
    RequireFields<EnterpriseUserAccountEnterpriseInstallationsArgs, "orderBy">
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  login?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  organizations?: Resolver<
    ResolversTypes["EnterpriseOrganizationMembershipConnection"],
    ParentType,
    ContextType,
    RequireFields<EnterpriseUserAccountOrganizationsArgs, "orderBy">
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnvironmentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Environment"] = ResolversParentTypes["Environment"],
> = {
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isPinned?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  latestCompletedDeployment?: Resolver<
    Maybe<ResolversTypes["Deployment"]>,
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pinnedPosition?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  protectionRules?: Resolver<
    ResolversTypes["DeploymentProtectionRuleConnection"],
    ParentType,
    ContextType,
    Partial<EnvironmentProtectionRulesArgs>
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnvironmentConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnvironmentConnection"] = ResolversParentTypes["EnvironmentConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["EnvironmentEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Environment"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnvironmentEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["EnvironmentEdge"] = ResolversParentTypes["EnvironmentEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["Environment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalIdentityResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ExternalIdentity"] = ResolversParentTypes["ExternalIdentity"],
> = {
  guid?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  organizationInvitation?: Resolver<
    Maybe<ResolversTypes["OrganizationInvitation"]>,
    ParentType,
    ContextType
  >;
  samlIdentity?: Resolver<
    Maybe<ResolversTypes["ExternalIdentitySamlAttributes"]>,
    ParentType,
    ContextType
  >;
  scimIdentity?: Resolver<
    Maybe<ResolversTypes["ExternalIdentityScimAttributes"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalIdentityAttributeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ExternalIdentityAttribute"] = ResolversParentTypes["ExternalIdentityAttribute"],
> = {
  metadata?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  value?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalIdentityConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ExternalIdentityConnection"] = ResolversParentTypes["ExternalIdentityConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ExternalIdentityEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ExternalIdentity"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalIdentityEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ExternalIdentityEdge"] = ResolversParentTypes["ExternalIdentityEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ExternalIdentity"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalIdentitySamlAttributesResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ExternalIdentitySamlAttributes"] = ResolversParentTypes["ExternalIdentitySamlAttributes"],
> = {
  attributes?: Resolver<
    Array<ResolversTypes["ExternalIdentityAttribute"]>,
    ParentType,
    ContextType
  >;
  emails?: Resolver<
    Maybe<Array<ResolversTypes["UserEmailMetadata"]>>,
    ParentType,
    ContextType
  >;
  familyName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  givenName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  groups?: Resolver<
    Maybe<Array<ResolversTypes["String"]>>,
    ParentType,
    ContextType
  >;
  nameId?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalIdentityScimAttributesResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ExternalIdentityScimAttributes"] = ResolversParentTypes["ExternalIdentityScimAttributes"],
> = {
  emails?: Resolver<
    Maybe<Array<ResolversTypes["UserEmailMetadata"]>>,
    ParentType,
    ContextType
  >;
  familyName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  givenName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  groups?: Resolver<
    Maybe<Array<ResolversTypes["String"]>>,
    ParentType,
    ContextType
  >;
  username?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FileExtensionRestrictionParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["FileExtensionRestrictionParameters"] = ResolversParentTypes["FileExtensionRestrictionParameters"],
> = {
  restrictedFileExtensions?: Resolver<
    Array<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilePathRestrictionParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["FilePathRestrictionParameters"] = ResolversParentTypes["FilePathRestrictionParameters"],
> = {
  restrictedFilePaths?: Resolver<
    Array<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FollowOrganizationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["FollowOrganizationPayload"] = ResolversParentTypes["FollowOrganizationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FollowUserPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["FollowUserPayload"] = ResolversParentTypes["FollowUserPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FollowerConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["FollowerConnection"] = ResolversParentTypes["FollowerConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["User"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FollowingConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["FollowingConnection"] = ResolversParentTypes["FollowingConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["User"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FundingLinkResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["FundingLink"] = ResolversParentTypes["FundingLink"],
> = {
  platform?: Resolver<
    ResolversTypes["FundingPlatform"],
    ParentType,
    ContextType
  >;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GenericHovercardContextResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GenericHovercardContext"] = ResolversParentTypes["GenericHovercardContext"],
> = {
  message?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GistResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Gist"] = ResolversParentTypes["Gist"],
> = {
  comments?: Resolver<
    ResolversTypes["GistCommentConnection"],
    ParentType,
    ContextType,
    Partial<GistCommentsArgs>
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  files?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["GistFile"]>>>,
    ParentType,
    ContextType,
    RequireFields<GistFilesArgs, "limit">
  >;
  forks?: Resolver<
    ResolversTypes["GistConnection"],
    ParentType,
    ContextType,
    Partial<GistForksArgs>
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isFork?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isPublic?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  owner?: Resolver<
    Maybe<ResolversTypes["RepositoryOwner"]>,
    ParentType,
    ContextType
  >;
  pushedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  stargazerCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  stargazers?: Resolver<
    ResolversTypes["StargazerConnection"],
    ParentType,
    ContextType,
    Partial<GistStargazersArgs>
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  viewerHasStarred?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GistCommentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GistComment"] = ResolversParentTypes["GistComment"],
> = {
  author?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  authorAssociation?: Resolver<
    ResolversTypes["CommentAuthorAssociation"],
    ParentType,
    ContextType
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  createdViaEmail?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  gist?: Resolver<ResolversTypes["Gist"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isMinimized?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  lastEditedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  minimizedReason?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  userContentEdits?: Resolver<
    Maybe<ResolversTypes["UserContentEditConnection"]>,
    ParentType,
    ContextType,
    Partial<GistCommentUserContentEditsArgs>
  >;
  viewerCanDelete?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanMinimize?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCannotUpdateReasons?: Resolver<
    Array<ResolversTypes["CommentCannotUpdateReason"]>,
    ParentType,
    ContextType
  >;
  viewerDidAuthor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GistCommentConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GistCommentConnection"] = ResolversParentTypes["GistCommentConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["GistCommentEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["GistComment"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GistCommentEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GistCommentEdge"] = ResolversParentTypes["GistCommentEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["GistComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GistConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GistConnection"] = ResolversParentTypes["GistConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["GistEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Gist"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GistEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GistEdge"] = ResolversParentTypes["GistEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Gist"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GistFileResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GistFile"] = ResolversParentTypes["GistFile"],
> = {
  encodedName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  encoding?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  extension?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  isImage?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isTruncated?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  language?: Resolver<
    Maybe<ResolversTypes["Language"]>,
    ParentType,
    ContextType
  >;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  text?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType,
    Partial<GistFileTextArgs>
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GitActorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GitActor"] = ResolversParentTypes["GitActor"],
> = {
  avatarUrl?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType,
    Partial<GitActorAvatarUrlArgs>
  >;
  date?: Resolver<
    Maybe<ResolversTypes["GitTimestamp"]>,
    ParentType,
    ContextType
  >;
  email?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GitActorConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GitActorConnection"] = ResolversParentTypes["GitActorConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["GitActorEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["GitActor"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GitActorEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GitActorEdge"] = ResolversParentTypes["GitActorEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["GitActor"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GitHubMetadataResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GitHubMetadata"] = ResolversParentTypes["GitHubMetadata"],
> = {
  gitHubServicesSha?: Resolver<
    ResolversTypes["GitObjectID"],
    ParentType,
    ContextType
  >;
  gitIpAddresses?: Resolver<
    Maybe<Array<ResolversTypes["String"]>>,
    ParentType,
    ContextType
  >;
  githubEnterpriseImporterIpAddresses?: Resolver<
    Maybe<Array<ResolversTypes["String"]>>,
    ParentType,
    ContextType
  >;
  hookIpAddresses?: Resolver<
    Maybe<Array<ResolversTypes["String"]>>,
    ParentType,
    ContextType
  >;
  importerIpAddresses?: Resolver<
    Maybe<Array<ResolversTypes["String"]>>,
    ParentType,
    ContextType
  >;
  isPasswordAuthenticationVerifiable?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  pagesIpAddresses?: Resolver<
    Maybe<Array<ResolversTypes["String"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GitObjectResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GitObject"] = ResolversParentTypes["GitObject"],
> = {
  __resolveType: TypeResolveFn<
    "Blob" | "Commit" | "Tag" | "Tree",
    ParentType,
    ContextType
  >;
  abbreviatedOid?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes["GitObjectID"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
};

export interface GitObjectIdScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["GitObjectID"], any> {
  name: "GitObjectID";
}

export interface GitRefnameScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["GitRefname"], any> {
  name: "GitRefname";
}

export interface GitSshRemoteScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["GitSSHRemote"], any> {
  name: "GitSSHRemote";
}

export type GitSignatureResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GitSignature"] = ResolversParentTypes["GitSignature"],
> = {
  __resolveType: TypeResolveFn<
    "GpgSignature" | "SmimeSignature" | "SshSignature" | "UnknownSignature",
    ParentType,
    ContextType
  >;
  email?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  state?: Resolver<
    ResolversTypes["GitSignatureState"],
    ParentType,
    ContextType
  >;
  wasSignedByGitHub?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
};

export interface GitTimestampScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["GitTimestamp"], any> {
  name: "GitTimestamp";
}

export type GpgSignatureResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GpgSignature"] = ResolversParentTypes["GpgSignature"],
> = {
  email?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  keyId?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  payload?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  state?: Resolver<
    ResolversTypes["GitSignatureState"],
    ParentType,
    ContextType
  >;
  wasSignedByGitHub?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrantEnterpriseOrganizationsMigratorRolePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GrantEnterpriseOrganizationsMigratorRolePayload"] = ResolversParentTypes["GrantEnterpriseOrganizationsMigratorRolePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizations?: Resolver<
    Maybe<ResolversTypes["OrganizationConnection"]>,
    ParentType,
    ContextType,
    Partial<GrantEnterpriseOrganizationsMigratorRolePayloadOrganizationsArgs>
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrantMigratorRolePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["GrantMigratorRolePayload"] = ResolversParentTypes["GrantMigratorRolePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  success?: Resolver<Maybe<ResolversTypes["Boolean"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface HtmlScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["HTML"], any> {
  name: "HTML";
}

export type HeadRefDeletedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["HeadRefDeletedEvent"] = ResolversParentTypes["HeadRefDeletedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  headRef?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  headRefName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HeadRefForcePushedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["HeadRefForcePushedEvent"] = ResolversParentTypes["HeadRefForcePushedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  afterCommit?: Resolver<
    Maybe<ResolversTypes["Commit"]>,
    ParentType,
    ContextType
  >;
  beforeCommit?: Resolver<
    Maybe<ResolversTypes["Commit"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  ref?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HeadRefRestoredEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["HeadRefRestoredEvent"] = ResolversParentTypes["HeadRefRestoredEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HovercardResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Hovercard"] = ResolversParentTypes["Hovercard"],
> = {
  contexts?: Resolver<
    Array<ResolversTypes["HovercardContext"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HovercardContextResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["HovercardContext"] = ResolversParentTypes["HovercardContext"],
> = {
  __resolveType: TypeResolveFn<
    | "GenericHovercardContext"
    | "OrganizationTeamsHovercardContext"
    | "OrganizationsHovercardContext"
    | "ReviewStatusHovercardContext"
    | "ViewerHovercardContext",
    ParentType,
    ContextType
  >;
  message?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
};

export type ImportProjectPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ImportProjectPayload"] = ResolversParentTypes["ImportProjectPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  project?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InviteEnterpriseAdminPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["InviteEnterpriseAdminPayload"] = ResolversParentTypes["InviteEnterpriseAdminPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  invitation?: Resolver<
    Maybe<ResolversTypes["EnterpriseAdministratorInvitation"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InviteEnterpriseMemberPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["InviteEnterpriseMemberPayload"] = ResolversParentTypes["InviteEnterpriseMemberPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  invitation?: Resolver<
    Maybe<ResolversTypes["EnterpriseMemberInvitation"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IpAllowListEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IpAllowListEntry"] = ResolversParentTypes["IpAllowListEntry"],
> = {
  allowListValue?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  owner?: Resolver<ResolversTypes["IpAllowListOwner"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IpAllowListEntryConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IpAllowListEntryConnection"] = ResolversParentTypes["IpAllowListEntryConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["IpAllowListEntryEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["IpAllowListEntry"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IpAllowListEntryEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IpAllowListEntryEdge"] = ResolversParentTypes["IpAllowListEntryEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["IpAllowListEntry"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IpAllowListOwnerResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IpAllowListOwner"] = ResolversParentTypes["IpAllowListOwner"],
> = {
  __resolveType: TypeResolveFn<
    "App" | "Enterprise" | "Organization",
    ParentType,
    ContextType
  >;
};

export type IssueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Issue"] = ResolversParentTypes["Issue"],
> = {
  activeLockReason?: Resolver<
    Maybe<ResolversTypes["LockReason"]>,
    ParentType,
    ContextType
  >;
  assignees?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<IssueAssigneesArgs>
  >;
  author?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  authorAssociation?: Resolver<
    ResolversTypes["CommentAuthorAssociation"],
    ParentType,
    ContextType
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyResourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  closedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  closedByPullRequestsReferences?: Resolver<
    Maybe<ResolversTypes["PullRequestConnection"]>,
    ParentType,
    ContextType,
    RequireFields<
      IssueClosedByPullRequestsReferencesArgs,
      "includeClosedPrs" | "orderByState" | "userLinkedOnly"
    >
  >;
  comments?: Resolver<
    ResolversTypes["IssueCommentConnection"],
    ParentType,
    ContextType,
    Partial<IssueCommentsArgs>
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  createdViaEmail?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  fullDatabaseId?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  hovercard?: Resolver<
    ResolversTypes["Hovercard"],
    ParentType,
    ContextType,
    RequireFields<IssueHovercardArgs, "includeNotificationContexts">
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isPinned?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  isReadByViewer?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  labels?: Resolver<
    Maybe<ResolversTypes["LabelConnection"]>,
    ParentType,
    ContextType,
    RequireFields<IssueLabelsArgs, "orderBy">
  >;
  lastEditedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  linkedBranches?: Resolver<
    ResolversTypes["LinkedBranchConnection"],
    ParentType,
    ContextType,
    Partial<IssueLinkedBranchesArgs>
  >;
  locked?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  milestone?: Resolver<
    Maybe<ResolversTypes["Milestone"]>,
    ParentType,
    ContextType
  >;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  participants?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<IssueParticipantsArgs>
  >;
  projectCards?: Resolver<
    ResolversTypes["ProjectCardConnection"],
    ParentType,
    ContextType,
    RequireFields<IssueProjectCardsArgs, "archivedStates">
  >;
  projectItems?: Resolver<
    ResolversTypes["ProjectV2ItemConnection"],
    ParentType,
    ContextType,
    RequireFields<IssueProjectItemsArgs, "includeArchived">
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType,
    RequireFields<IssueProjectV2Args, "number">
  >;
  projectsV2?: Resolver<
    ResolversTypes["ProjectV2Connection"],
    ParentType,
    ContextType,
    RequireFields<IssueProjectsV2Args, "minPermissionLevel" | "orderBy">
  >;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  reactions?: Resolver<
    ResolversTypes["ReactionConnection"],
    ParentType,
    ContextType,
    Partial<IssueReactionsArgs>
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  state?: Resolver<ResolversTypes["IssueState"], ParentType, ContextType>;
  stateReason?: Resolver<
    Maybe<ResolversTypes["IssueStateReason"]>,
    ParentType,
    ContextType
  >;
  timeline?: Resolver<
    ResolversTypes["IssueTimelineConnection"],
    ParentType,
    ContextType,
    Partial<IssueTimelineArgs>
  >;
  timelineItems?: Resolver<
    ResolversTypes["IssueTimelineItemsConnection"],
    ParentType,
    ContextType,
    Partial<IssueTimelineItemsArgs>
  >;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  trackedInIssues?: Resolver<
    ResolversTypes["IssueConnection"],
    ParentType,
    ContextType,
    Partial<IssueTrackedInIssuesArgs>
  >;
  trackedIssues?: Resolver<
    ResolversTypes["IssueConnection"],
    ParentType,
    ContextType,
    Partial<IssueTrackedIssuesArgs>
  >;
  trackedIssuesCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType,
    Partial<IssueTrackedIssuesCountArgs>
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  userContentEdits?: Resolver<
    Maybe<ResolversTypes["UserContentEditConnection"]>,
    ParentType,
    ContextType,
    Partial<IssueUserContentEditsArgs>
  >;
  viewerCanClose?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanDelete?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanLabel?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanReopen?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanSubscribe?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCannotUpdateReasons?: Resolver<
    Array<ResolversTypes["CommentCannotUpdateReason"]>,
    ParentType,
    ContextType
  >;
  viewerDidAuthor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerSubscription?: Resolver<
    Maybe<ResolversTypes["SubscriptionState"]>,
    ParentType,
    ContextType
  >;
  viewerThreadSubscriptionFormAction?: Resolver<
    Maybe<ResolversTypes["ThreadSubscriptionFormAction"]>,
    ParentType,
    ContextType
  >;
  viewerThreadSubscriptionStatus?: Resolver<
    Maybe<ResolversTypes["ThreadSubscriptionState"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IssueCommentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueComment"] = ResolversParentTypes["IssueComment"],
> = {
  author?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  authorAssociation?: Resolver<
    ResolversTypes["CommentAuthorAssociation"],
    ParentType,
    ContextType
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  createdViaEmail?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  fullDatabaseId?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isMinimized?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes["Issue"], ParentType, ContextType>;
  lastEditedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  minimizedReason?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  reactions?: Resolver<
    ResolversTypes["ReactionConnection"],
    ParentType,
    ContextType,
    Partial<IssueCommentReactionsArgs>
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  userContentEdits?: Resolver<
    Maybe<ResolversTypes["UserContentEditConnection"]>,
    ParentType,
    ContextType,
    Partial<IssueCommentUserContentEditsArgs>
  >;
  viewerCanDelete?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanMinimize?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanReact?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCannotUpdateReasons?: Resolver<
    Array<ResolversTypes["CommentCannotUpdateReason"]>,
    ParentType,
    ContextType
  >;
  viewerDidAuthor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IssueCommentConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueCommentConnection"] = ResolversParentTypes["IssueCommentConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["IssueCommentEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["IssueComment"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IssueCommentEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueCommentEdge"] = ResolversParentTypes["IssueCommentEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["IssueComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IssueConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueConnection"] = ResolversParentTypes["IssueConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["IssueEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Issue"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IssueContributionsByRepositoryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueContributionsByRepository"] = ResolversParentTypes["IssueContributionsByRepository"],
> = {
  contributions?: Resolver<
    ResolversTypes["CreatedIssueContributionConnection"],
    ParentType,
    ContextType,
    RequireFields<IssueContributionsByRepositoryContributionsArgs, "orderBy">
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IssueEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueEdge"] = ResolversParentTypes["IssueEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Issue"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IssueOrPullRequestResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueOrPullRequest"] = ResolversParentTypes["IssueOrPullRequest"],
> = {
  __resolveType: TypeResolveFn<
    "Issue" | "PullRequest",
    ParentType,
    ContextType
  >;
};

export type IssueTemplateResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueTemplate"] = ResolversParentTypes["IssueTemplate"],
> = {
  about?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  assignees?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<IssueTemplateAssigneesArgs>
  >;
  body?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  filename?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  labels?: Resolver<
    Maybe<ResolversTypes["LabelConnection"]>,
    ParentType,
    ContextType,
    RequireFields<IssueTemplateLabelsArgs, "orderBy">
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IssueTimelineConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueTimelineConnection"] = ResolversParentTypes["IssueTimelineConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["IssueTimelineItemEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["IssueTimelineItem"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IssueTimelineItemResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueTimelineItem"] = ResolversParentTypes["IssueTimelineItem"],
> = {
  __resolveType: TypeResolveFn<
    | "AssignedEvent"
    | "ClosedEvent"
    | "Commit"
    | "CrossReferencedEvent"
    | "DemilestonedEvent"
    | "IssueComment"
    | "LabeledEvent"
    | "LockedEvent"
    | "MilestonedEvent"
    | "ReferencedEvent"
    | "RenamedTitleEvent"
    | "ReopenedEvent"
    | "SubscribedEvent"
    | "TransferredEvent"
    | "UnassignedEvent"
    | "UnlabeledEvent"
    | "UnlockedEvent"
    | "UnsubscribedEvent"
    | "UserBlockedEvent",
    ParentType,
    ContextType
  >;
};

export type IssueTimelineItemEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueTimelineItemEdge"] = ResolversParentTypes["IssueTimelineItemEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["IssueTimelineItem"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IssueTimelineItemsResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueTimelineItems"] = ResolversParentTypes["IssueTimelineItems"],
> = {
  __resolveType: TypeResolveFn<
    | "AddedToProjectEvent"
    | "AssignedEvent"
    | "ClosedEvent"
    | "CommentDeletedEvent"
    | "ConnectedEvent"
    | "ConvertedNoteToIssueEvent"
    | "ConvertedToDiscussionEvent"
    | "CrossReferencedEvent"
    | "DemilestonedEvent"
    | "DisconnectedEvent"
    | "IssueComment"
    | "LabeledEvent"
    | "LockedEvent"
    | "MarkedAsDuplicateEvent"
    | "MentionedEvent"
    | "MilestonedEvent"
    | "MovedColumnsInProjectEvent"
    | "PinnedEvent"
    | "ReferencedEvent"
    | "RemovedFromProjectEvent"
    | "RenamedTitleEvent"
    | "ReopenedEvent"
    | "SubscribedEvent"
    | "TransferredEvent"
    | "UnassignedEvent"
    | "UnlabeledEvent"
    | "UnlockedEvent"
    | "UnmarkedAsDuplicateEvent"
    | "UnpinnedEvent"
    | "UnsubscribedEvent"
    | "UserBlockedEvent",
    ParentType,
    ContextType
  >;
};

export type IssueTimelineItemsConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueTimelineItemsConnection"] = ResolversParentTypes["IssueTimelineItemsConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["IssueTimelineItemsEdge"]>>>,
    ParentType,
    ContextType
  >;
  filteredCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["IssueTimelineItems"]>>>,
    ParentType,
    ContextType
  >;
  pageCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IssueTimelineItemsEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["IssueTimelineItemsEdge"] = ResolversParentTypes["IssueTimelineItemsEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["IssueTimelineItems"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type JoinedGitHubContributionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["JoinedGitHubContribution"] = ResolversParentTypes["JoinedGitHubContribution"],
> = {
  isRestricted?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LabelResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Label"] = ResolversParentTypes["Label"],
> = {
  color?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isDefault?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  issues?: Resolver<
    ResolversTypes["IssueConnection"],
    ParentType,
    ContextType,
    Partial<LabelIssuesArgs>
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pullRequests?: Resolver<
    ResolversTypes["PullRequestConnection"],
    ParentType,
    ContextType,
    Partial<LabelPullRequestsArgs>
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  updatedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LabelConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LabelConnection"] = ResolversParentTypes["LabelConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["LabelEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Label"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LabelEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LabelEdge"] = ResolversParentTypes["LabelEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Label"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LabelableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Labelable"] = ResolversParentTypes["Labelable"],
> = {
  __resolveType: TypeResolveFn<
    "Discussion" | "Issue" | "PullRequest",
    ParentType,
    ContextType
  >;
  labels?: Resolver<
    Maybe<ResolversTypes["LabelConnection"]>,
    ParentType,
    ContextType,
    RequireFields<LabelableLabelsArgs, "orderBy">
  >;
  viewerCanLabel?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
};

export type LabeledEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LabeledEvent"] = ResolversParentTypes["LabeledEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  label?: Resolver<ResolversTypes["Label"], ParentType, ContextType>;
  labelable?: Resolver<ResolversTypes["Labelable"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LanguageResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Language"] = ResolversParentTypes["Language"],
> = {
  color?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LanguageConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LanguageConnection"] = ResolversParentTypes["LanguageConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["LanguageEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Language"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  totalSize?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LanguageEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LanguageEdge"] = ResolversParentTypes["LanguageEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<ResolversTypes["Language"], ParentType, ContextType>;
  size?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LicenseResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["License"] = ResolversParentTypes["License"],
> = {
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  conditions?: Resolver<
    Array<Maybe<ResolversTypes["LicenseRule"]>>,
    ParentType,
    ContextType
  >;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  featured?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  hidden?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  implementation?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  key?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  limitations?: Resolver<
    Array<Maybe<ResolversTypes["LicenseRule"]>>,
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  nickname?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  permissions?: Resolver<
    Array<Maybe<ResolversTypes["LicenseRule"]>>,
    ParentType,
    ContextType
  >;
  pseudoLicense?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  spdxId?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LicenseRuleResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LicenseRule"] = ResolversParentTypes["LicenseRule"],
> = {
  description?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  key?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  label?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LinkProjectV2ToRepositoryPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LinkProjectV2ToRepositoryPayload"] = ResolversParentTypes["LinkProjectV2ToRepositoryPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LinkProjectV2ToTeamPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LinkProjectV2ToTeamPayload"] = ResolversParentTypes["LinkProjectV2ToTeamPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  team?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LinkRepositoryToProjectPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LinkRepositoryToProjectPayload"] = ResolversParentTypes["LinkRepositoryToProjectPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  project?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LinkedBranchResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LinkedBranch"] = ResolversParentTypes["LinkedBranch"],
> = {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LinkedBranchConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LinkedBranchConnection"] = ResolversParentTypes["LinkedBranchConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["LinkedBranchEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["LinkedBranch"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LinkedBranchEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LinkedBranchEdge"] = ResolversParentTypes["LinkedBranchEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["LinkedBranch"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LockLockablePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LockLockablePayload"] = ResolversParentTypes["LockLockablePayload"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  lockedRecord?: Resolver<
    Maybe<ResolversTypes["Lockable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LockableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Lockable"] = ResolversParentTypes["Lockable"],
> = {
  __resolveType: TypeResolveFn<
    "Discussion" | "Issue" | "PullRequest",
    ParentType,
    ContextType
  >;
  activeLockReason?: Resolver<
    Maybe<ResolversTypes["LockReason"]>,
    ParentType,
    ContextType
  >;
  locked?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
};

export type LockedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["LockedEvent"] = ResolversParentTypes["LockedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lockReason?: Resolver<
    Maybe<ResolversTypes["LockReason"]>,
    ParentType,
    ContextType
  >;
  lockable?: Resolver<ResolversTypes["Lockable"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MannequinResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Mannequin"] = ResolversParentTypes["Mannequin"],
> = {
  avatarUrl?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType,
    Partial<MannequinAvatarUrlArgs>
  >;
  claimant?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  login?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MannequinConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MannequinConnection"] = ResolversParentTypes["MannequinConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["MannequinEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Mannequin"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MannequinEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MannequinEdge"] = ResolversParentTypes["MannequinEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Mannequin"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkDiscussionCommentAsAnswerPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MarkDiscussionCommentAsAnswerPayload"] = ResolversParentTypes["MarkDiscussionCommentAsAnswerPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  discussion?: Resolver<
    Maybe<ResolversTypes["Discussion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkFileAsViewedPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MarkFileAsViewedPayload"] = ResolversParentTypes["MarkFileAsViewedPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkNotificationAsDonePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MarkNotificationAsDonePayload"] = ResolversParentTypes["MarkNotificationAsDonePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  success?: Resolver<Maybe<ResolversTypes["Boolean"]>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkProjectV2AsTemplatePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MarkProjectV2AsTemplatePayload"] = ResolversParentTypes["MarkProjectV2AsTemplatePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkPullRequestReadyForReviewPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MarkPullRequestReadyForReviewPayload"] = ResolversParentTypes["MarkPullRequestReadyForReviewPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkedAsDuplicateEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MarkedAsDuplicateEvent"] = ResolversParentTypes["MarkedAsDuplicateEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  canonical?: Resolver<
    Maybe<ResolversTypes["IssueOrPullRequest"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  duplicate?: Resolver<
    Maybe<ResolversTypes["IssueOrPullRequest"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isCrossRepository?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarketplaceCategoryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MarketplaceCategory"] = ResolversParentTypes["MarketplaceCategory"],
> = {
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  howItWorks?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  primaryListingCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  secondaryListingCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  slug?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarketplaceListingResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MarketplaceListing"] = ResolversParentTypes["MarketplaceListing"],
> = {
  app?: Resolver<Maybe<ResolversTypes["App"]>, ParentType, ContextType>;
  companyUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  configurationResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  configurationUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  documentationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  extendedDescription?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  extendedDescriptionHTML?: Resolver<
    ResolversTypes["HTML"],
    ParentType,
    ContextType
  >;
  fullDescription?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  fullDescriptionHTML?: Resolver<
    ResolversTypes["HTML"],
    ParentType,
    ContextType
  >;
  hasPublishedFreeTrialPlans?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasTermsOfService?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasVerifiedOwner?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  howItWorks?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  howItWorksHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  installationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  installedForViewer?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isArchived?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isDraft?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isPaid?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isPublic?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isRejected?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isUnverified?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isUnverifiedPending?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isVerificationPendingFromDraft?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isVerificationPendingFromUnverified?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isVerified?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  logoBackgroundColor?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  logoUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType,
    RequireFields<MarketplaceListingLogoUrlArgs, "size">
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  normalizedShortDescription?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  pricingUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  primaryCategory?: Resolver<
    ResolversTypes["MarketplaceCategory"],
    ParentType,
    ContextType
  >;
  privacyPolicyUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  screenshotUrls?: Resolver<
    Array<Maybe<ResolversTypes["String"]>>,
    ParentType,
    ContextType
  >;
  secondaryCategory?: Resolver<
    Maybe<ResolversTypes["MarketplaceCategory"]>,
    ParentType,
    ContextType
  >;
  shortDescription?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  slug?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  statusUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  supportEmail?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  supportUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  termsOfServiceUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  viewerCanAddPlans?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanApprove?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanDelist?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanEdit?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanEditCategories?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanEditPlans?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanRedraft?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanReject?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanRequestApproval?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerHasPurchased?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerHasPurchasedForAllOrganizations?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerIsListingAdmin?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarketplaceListingConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MarketplaceListingConnection"] = ResolversParentTypes["MarketplaceListingConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["MarketplaceListingEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["MarketplaceListing"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarketplaceListingEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MarketplaceListingEdge"] = ResolversParentTypes["MarketplaceListingEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["MarketplaceListing"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MaxFilePathLengthParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MaxFilePathLengthParameters"] = ResolversParentTypes["MaxFilePathLengthParameters"],
> = {
  maxFilePathLength?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MaxFileSizeParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MaxFileSizeParameters"] = ResolversParentTypes["MaxFileSizeParameters"],
> = {
  maxFileSize?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberFeatureRequestNotificationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MemberFeatureRequestNotification"] = ResolversParentTypes["MemberFeatureRequestNotification"],
> = {
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberStatusableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MemberStatusable"] = ResolversParentTypes["MemberStatusable"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "Team",
    ParentType,
    ContextType
  >;
  memberStatuses?: Resolver<
    ResolversTypes["UserStatusConnection"],
    ParentType,
    ContextType,
    RequireFields<MemberStatusableMemberStatusesArgs, "orderBy">
  >;
};

export type MembersCanDeleteReposClearAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MembersCanDeleteReposClearAuditEntry"] = ResolversParentTypes["MembersCanDeleteReposClearAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  enterpriseResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  enterpriseSlug?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterpriseUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MembersCanDeleteReposDisableAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MembersCanDeleteReposDisableAuditEntry"] = ResolversParentTypes["MembersCanDeleteReposDisableAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  enterpriseResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  enterpriseSlug?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterpriseUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MembersCanDeleteReposEnableAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MembersCanDeleteReposEnableAuditEntry"] = ResolversParentTypes["MembersCanDeleteReposEnableAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  enterpriseResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  enterpriseSlug?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterpriseUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MentionedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MentionedEvent"] = ResolversParentTypes["MentionedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MergeBranchPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MergeBranchPayload"] = ResolversParentTypes["MergeBranchPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  mergeCommit?: Resolver<
    Maybe<ResolversTypes["Commit"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MergePullRequestPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MergePullRequestPayload"] = ResolversParentTypes["MergePullRequestPayload"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MergeQueueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MergeQueue"] = ResolversParentTypes["MergeQueue"],
> = {
  configuration?: Resolver<
    Maybe<ResolversTypes["MergeQueueConfiguration"]>,
    ParentType,
    ContextType
  >;
  entries?: Resolver<
    Maybe<ResolversTypes["MergeQueueEntryConnection"]>,
    ParentType,
    ContextType,
    Partial<MergeQueueEntriesArgs>
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  nextEntryEstimatedTimeToMerge?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MergeQueueConfigurationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MergeQueueConfiguration"] = ResolversParentTypes["MergeQueueConfiguration"],
> = {
  checkResponseTimeout?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  maximumEntriesToBuild?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  maximumEntriesToMerge?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  mergeMethod?: Resolver<
    Maybe<ResolversTypes["PullRequestMergeMethod"]>,
    ParentType,
    ContextType
  >;
  mergingStrategy?: Resolver<
    Maybe<ResolversTypes["MergeQueueMergingStrategy"]>,
    ParentType,
    ContextType
  >;
  minimumEntriesToMerge?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  minimumEntriesToMergeWaitTime?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MergeQueueEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MergeQueueEntry"] = ResolversParentTypes["MergeQueueEntry"],
> = {
  baseCommit?: Resolver<
    Maybe<ResolversTypes["Commit"]>,
    ParentType,
    ContextType
  >;
  enqueuedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  enqueuer?: Resolver<ResolversTypes["Actor"], ParentType, ContextType>;
  estimatedTimeToMerge?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  headCommit?: Resolver<
    Maybe<ResolversTypes["Commit"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  jump?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  mergeQueue?: Resolver<
    Maybe<ResolversTypes["MergeQueue"]>,
    ParentType,
    ContextType
  >;
  position?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  solo?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  state?: Resolver<
    ResolversTypes["MergeQueueEntryState"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MergeQueueEntryConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MergeQueueEntryConnection"] = ResolversParentTypes["MergeQueueEntryConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["MergeQueueEntryEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["MergeQueueEntry"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MergeQueueEntryEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MergeQueueEntryEdge"] = ResolversParentTypes["MergeQueueEntryEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["MergeQueueEntry"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MergeQueueParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MergeQueueParameters"] = ResolversParentTypes["MergeQueueParameters"],
> = {
  checkResponseTimeoutMinutes?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  groupingStrategy?: Resolver<
    ResolversTypes["MergeQueueGroupingStrategy"],
    ParentType,
    ContextType
  >;
  maxEntriesToBuild?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  maxEntriesToMerge?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  mergeMethod?: Resolver<
    ResolversTypes["MergeQueueMergeMethod"],
    ParentType,
    ContextType
  >;
  minEntriesToMerge?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  minEntriesToMergeWaitMinutes?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MergedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MergedEvent"] = ResolversParentTypes["MergedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes["Commit"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  mergeRef?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  mergeRefName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MigrationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Migration"] = ResolversParentTypes["Migration"],
> = {
  __resolveType: TypeResolveFn<"RepositoryMigration", ParentType, ContextType>;
  continueOnError?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  failureReason?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  migrationLogUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  migrationSource?: Resolver<
    ResolversTypes["MigrationSource"],
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  sourceUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  state?: Resolver<ResolversTypes["MigrationState"], ParentType, ContextType>;
  warningsCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
};

export type MigrationSourceResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MigrationSource"] = ResolversParentTypes["MigrationSource"],
> = {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  type?: Resolver<
    ResolversTypes["MigrationSourceType"],
    ParentType,
    ContextType
  >;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MilestoneResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Milestone"] = ResolversParentTypes["Milestone"],
> = {
  closed?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  closedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  dueOn?: Resolver<Maybe<ResolversTypes["DateTime"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  issues?: Resolver<
    ResolversTypes["IssueConnection"],
    ParentType,
    ContextType,
    Partial<MilestoneIssuesArgs>
  >;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  progressPercentage?: Resolver<
    ResolversTypes["Float"],
    ParentType,
    ContextType
  >;
  pullRequests?: Resolver<
    ResolversTypes["PullRequestConnection"],
    ParentType,
    ContextType,
    Partial<MilestonePullRequestsArgs>
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  state?: Resolver<ResolversTypes["MilestoneState"], ParentType, ContextType>;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  viewerCanClose?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanReopen?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MilestoneConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MilestoneConnection"] = ResolversParentTypes["MilestoneConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["MilestoneEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Milestone"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MilestoneEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MilestoneEdge"] = ResolversParentTypes["MilestoneEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Milestone"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MilestoneItemResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MilestoneItem"] = ResolversParentTypes["MilestoneItem"],
> = {
  __resolveType: TypeResolveFn<
    "Issue" | "PullRequest",
    ParentType,
    ContextType
  >;
};

export type MilestonedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MilestonedEvent"] = ResolversParentTypes["MilestonedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  milestoneTitle?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes["MilestoneItem"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MinimizableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Minimizable"] = ResolversParentTypes["Minimizable"],
> = {
  __resolveType: TypeResolveFn<
    | "CommitComment"
    | "DiscussionComment"
    | "GistComment"
    | "IssueComment"
    | "PullRequestReview"
    | "PullRequestReviewComment",
    ParentType,
    ContextType
  >;
  isMinimized?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  minimizedReason?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  viewerCanMinimize?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
};

export type MinimizeCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MinimizeCommentPayload"] = ResolversParentTypes["MinimizeCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  minimizedComment?: Resolver<
    Maybe<ResolversTypes["Minimizable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MoveProjectCardPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MoveProjectCardPayload"] = ResolversParentTypes["MoveProjectCardPayload"],
> = {
  cardEdge?: Resolver<
    Maybe<ResolversTypes["ProjectCardEdge"]>,
    ParentType,
    ContextType
  >;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MoveProjectColumnPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MoveProjectColumnPayload"] = ResolversParentTypes["MoveProjectColumnPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  columnEdge?: Resolver<
    Maybe<ResolversTypes["ProjectColumnEdge"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MovedColumnsInProjectEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["MovedColumnsInProjectEvent"] = ResolversParentTypes["MovedColumnsInProjectEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  previousProjectColumnName?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  project?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  projectCard?: Resolver<
    Maybe<ResolversTypes["ProjectCard"]>,
    ParentType,
    ContextType
  >;
  projectColumnName?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Mutation"] = ResolversParentTypes["Mutation"],
> = {
  abortQueuedMigrations?: Resolver<
    Maybe<ResolversTypes["AbortQueuedMigrationsPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAbortQueuedMigrationsArgs, "input">
  >;
  abortRepositoryMigration?: Resolver<
    Maybe<ResolversTypes["AbortRepositoryMigrationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAbortRepositoryMigrationArgs, "input">
  >;
  acceptEnterpriseAdministratorInvitation?: Resolver<
    Maybe<ResolversTypes["AcceptEnterpriseAdministratorInvitationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAcceptEnterpriseAdministratorInvitationArgs, "input">
  >;
  acceptEnterpriseMemberInvitation?: Resolver<
    Maybe<ResolversTypes["AcceptEnterpriseMemberInvitationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAcceptEnterpriseMemberInvitationArgs, "input">
  >;
  acceptTopicSuggestion?: Resolver<
    Maybe<ResolversTypes["AcceptTopicSuggestionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAcceptTopicSuggestionArgs, "input">
  >;
  addAssigneesToAssignable?: Resolver<
    Maybe<ResolversTypes["AddAssigneesToAssignablePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddAssigneesToAssignableArgs, "input">
  >;
  addComment?: Resolver<
    Maybe<ResolversTypes["AddCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddCommentArgs, "input">
  >;
  addDiscussionComment?: Resolver<
    Maybe<ResolversTypes["AddDiscussionCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddDiscussionCommentArgs, "input">
  >;
  addDiscussionPollVote?: Resolver<
    Maybe<ResolversTypes["AddDiscussionPollVotePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddDiscussionPollVoteArgs, "input">
  >;
  addEnterpriseOrganizationMember?: Resolver<
    Maybe<ResolversTypes["AddEnterpriseOrganizationMemberPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddEnterpriseOrganizationMemberArgs, "input">
  >;
  addEnterpriseSupportEntitlement?: Resolver<
    Maybe<ResolversTypes["AddEnterpriseSupportEntitlementPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddEnterpriseSupportEntitlementArgs, "input">
  >;
  addLabelsToLabelable?: Resolver<
    Maybe<ResolversTypes["AddLabelsToLabelablePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddLabelsToLabelableArgs, "input">
  >;
  addProjectCard?: Resolver<
    Maybe<ResolversTypes["AddProjectCardPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddProjectCardArgs, "input">
  >;
  addProjectColumn?: Resolver<
    Maybe<ResolversTypes["AddProjectColumnPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddProjectColumnArgs, "input">
  >;
  addProjectV2DraftIssue?: Resolver<
    Maybe<ResolversTypes["AddProjectV2DraftIssuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddProjectV2DraftIssueArgs, "input">
  >;
  addProjectV2ItemById?: Resolver<
    Maybe<ResolversTypes["AddProjectV2ItemByIdPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddProjectV2ItemByIdArgs, "input">
  >;
  addPullRequestReview?: Resolver<
    Maybe<ResolversTypes["AddPullRequestReviewPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddPullRequestReviewArgs, "input">
  >;
  addPullRequestReviewComment?: Resolver<
    Maybe<ResolversTypes["AddPullRequestReviewCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddPullRequestReviewCommentArgs, "input">
  >;
  addPullRequestReviewThread?: Resolver<
    Maybe<ResolversTypes["AddPullRequestReviewThreadPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddPullRequestReviewThreadArgs, "input">
  >;
  addPullRequestReviewThreadReply?: Resolver<
    Maybe<ResolversTypes["AddPullRequestReviewThreadReplyPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddPullRequestReviewThreadReplyArgs, "input">
  >;
  addReaction?: Resolver<
    Maybe<ResolversTypes["AddReactionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddReactionArgs, "input">
  >;
  addStar?: Resolver<
    Maybe<ResolversTypes["AddStarPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddStarArgs, "input">
  >;
  addUpvote?: Resolver<
    Maybe<ResolversTypes["AddUpvotePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddUpvoteArgs, "input">
  >;
  addVerifiableDomain?: Resolver<
    Maybe<ResolversTypes["AddVerifiableDomainPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationAddVerifiableDomainArgs, "input">
  >;
  approveDeployments?: Resolver<
    Maybe<ResolversTypes["ApproveDeploymentsPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationApproveDeploymentsArgs, "input">
  >;
  approveVerifiableDomain?: Resolver<
    Maybe<ResolversTypes["ApproveVerifiableDomainPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationApproveVerifiableDomainArgs, "input">
  >;
  archiveProjectV2Item?: Resolver<
    Maybe<ResolversTypes["ArchiveProjectV2ItemPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationArchiveProjectV2ItemArgs, "input">
  >;
  archiveRepository?: Resolver<
    Maybe<ResolversTypes["ArchiveRepositoryPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationArchiveRepositoryArgs, "input">
  >;
  cancelEnterpriseAdminInvitation?: Resolver<
    Maybe<ResolversTypes["CancelEnterpriseAdminInvitationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCancelEnterpriseAdminInvitationArgs, "input">
  >;
  cancelEnterpriseMemberInvitation?: Resolver<
    Maybe<ResolversTypes["CancelEnterpriseMemberInvitationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCancelEnterpriseMemberInvitationArgs, "input">
  >;
  cancelSponsorship?: Resolver<
    Maybe<ResolversTypes["CancelSponsorshipPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCancelSponsorshipArgs, "input">
  >;
  changeUserStatus?: Resolver<
    Maybe<ResolversTypes["ChangeUserStatusPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationChangeUserStatusArgs, "input">
  >;
  clearLabelsFromLabelable?: Resolver<
    Maybe<ResolversTypes["ClearLabelsFromLabelablePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationClearLabelsFromLabelableArgs, "input">
  >;
  clearProjectV2ItemFieldValue?: Resolver<
    Maybe<ResolversTypes["ClearProjectV2ItemFieldValuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationClearProjectV2ItemFieldValueArgs, "input">
  >;
  cloneProject?: Resolver<
    Maybe<ResolversTypes["CloneProjectPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCloneProjectArgs, "input">
  >;
  cloneTemplateRepository?: Resolver<
    Maybe<ResolversTypes["CloneTemplateRepositoryPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCloneTemplateRepositoryArgs, "input">
  >;
  closeDiscussion?: Resolver<
    Maybe<ResolversTypes["CloseDiscussionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCloseDiscussionArgs, "input">
  >;
  closeIssue?: Resolver<
    Maybe<ResolversTypes["CloseIssuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCloseIssueArgs, "input">
  >;
  closePullRequest?: Resolver<
    Maybe<ResolversTypes["ClosePullRequestPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationClosePullRequestArgs, "input">
  >;
  convertProjectCardNoteToIssue?: Resolver<
    Maybe<ResolversTypes["ConvertProjectCardNoteToIssuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationConvertProjectCardNoteToIssueArgs, "input">
  >;
  convertProjectV2DraftIssueItemToIssue?: Resolver<
    Maybe<ResolversTypes["ConvertProjectV2DraftIssueItemToIssuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationConvertProjectV2DraftIssueItemToIssueArgs, "input">
  >;
  convertPullRequestToDraft?: Resolver<
    Maybe<ResolversTypes["ConvertPullRequestToDraftPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationConvertPullRequestToDraftArgs, "input">
  >;
  copyProjectV2?: Resolver<
    Maybe<ResolversTypes["CopyProjectV2Payload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCopyProjectV2Args, "input">
  >;
  createAttributionInvitation?: Resolver<
    Maybe<ResolversTypes["CreateAttributionInvitationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateAttributionInvitationArgs, "input">
  >;
  createBranchProtectionRule?: Resolver<
    Maybe<ResolversTypes["CreateBranchProtectionRulePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateBranchProtectionRuleArgs, "input">
  >;
  createCheckRun?: Resolver<
    Maybe<ResolversTypes["CreateCheckRunPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateCheckRunArgs, "input">
  >;
  createCheckSuite?: Resolver<
    Maybe<ResolversTypes["CreateCheckSuitePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateCheckSuiteArgs, "input">
  >;
  createCommitOnBranch?: Resolver<
    Maybe<ResolversTypes["CreateCommitOnBranchPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateCommitOnBranchArgs, "input">
  >;
  createDeployment?: Resolver<
    Maybe<ResolversTypes["CreateDeploymentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateDeploymentArgs, "input">
  >;
  createDeploymentStatus?: Resolver<
    Maybe<ResolversTypes["CreateDeploymentStatusPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateDeploymentStatusArgs, "input">
  >;
  createDiscussion?: Resolver<
    Maybe<ResolversTypes["CreateDiscussionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateDiscussionArgs, "input">
  >;
  createEnterpriseOrganization?: Resolver<
    Maybe<ResolversTypes["CreateEnterpriseOrganizationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateEnterpriseOrganizationArgs, "input">
  >;
  createEnvironment?: Resolver<
    Maybe<ResolversTypes["CreateEnvironmentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateEnvironmentArgs, "input">
  >;
  createIpAllowListEntry?: Resolver<
    Maybe<ResolversTypes["CreateIpAllowListEntryPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateIpAllowListEntryArgs, "input">
  >;
  createIssue?: Resolver<
    Maybe<ResolversTypes["CreateIssuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateIssueArgs, "input">
  >;
  createLabel?: Resolver<
    Maybe<ResolversTypes["CreateLabelPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateLabelArgs, "input">
  >;
  createLinkedBranch?: Resolver<
    Maybe<ResolversTypes["CreateLinkedBranchPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateLinkedBranchArgs, "input">
  >;
  createMigrationSource?: Resolver<
    Maybe<ResolversTypes["CreateMigrationSourcePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateMigrationSourceArgs, "input">
  >;
  createProject?: Resolver<
    Maybe<ResolversTypes["CreateProjectPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateProjectArgs, "input">
  >;
  createProjectV2?: Resolver<
    Maybe<ResolversTypes["CreateProjectV2Payload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateProjectV2Args, "input">
  >;
  createProjectV2Field?: Resolver<
    Maybe<ResolversTypes["CreateProjectV2FieldPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateProjectV2FieldArgs, "input">
  >;
  createProjectV2StatusUpdate?: Resolver<
    Maybe<ResolversTypes["CreateProjectV2StatusUpdatePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateProjectV2StatusUpdateArgs, "input">
  >;
  createPullRequest?: Resolver<
    Maybe<ResolversTypes["CreatePullRequestPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreatePullRequestArgs, "input">
  >;
  createRef?: Resolver<
    Maybe<ResolversTypes["CreateRefPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateRefArgs, "input">
  >;
  createRepository?: Resolver<
    Maybe<ResolversTypes["CreateRepositoryPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateRepositoryArgs, "input">
  >;
  createRepositoryRuleset?: Resolver<
    Maybe<ResolversTypes["CreateRepositoryRulesetPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateRepositoryRulesetArgs, "input">
  >;
  createSponsorsListing?: Resolver<
    Maybe<ResolversTypes["CreateSponsorsListingPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateSponsorsListingArgs, "input">
  >;
  createSponsorsTier?: Resolver<
    Maybe<ResolversTypes["CreateSponsorsTierPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateSponsorsTierArgs, "input">
  >;
  createSponsorship?: Resolver<
    Maybe<ResolversTypes["CreateSponsorshipPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateSponsorshipArgs, "input">
  >;
  createSponsorships?: Resolver<
    Maybe<ResolversTypes["CreateSponsorshipsPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateSponsorshipsArgs, "input">
  >;
  createTeamDiscussion?: Resolver<
    Maybe<ResolversTypes["CreateTeamDiscussionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateTeamDiscussionArgs, "input">
  >;
  createTeamDiscussionComment?: Resolver<
    Maybe<ResolversTypes["CreateTeamDiscussionCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateTeamDiscussionCommentArgs, "input">
  >;
  createUserList?: Resolver<
    Maybe<ResolversTypes["CreateUserListPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateUserListArgs, "input">
  >;
  declineTopicSuggestion?: Resolver<
    Maybe<ResolversTypes["DeclineTopicSuggestionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeclineTopicSuggestionArgs, "input">
  >;
  deleteBranchProtectionRule?: Resolver<
    Maybe<ResolversTypes["DeleteBranchProtectionRulePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteBranchProtectionRuleArgs, "input">
  >;
  deleteDeployment?: Resolver<
    Maybe<ResolversTypes["DeleteDeploymentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteDeploymentArgs, "input">
  >;
  deleteDiscussion?: Resolver<
    Maybe<ResolversTypes["DeleteDiscussionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteDiscussionArgs, "input">
  >;
  deleteDiscussionComment?: Resolver<
    Maybe<ResolversTypes["DeleteDiscussionCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteDiscussionCommentArgs, "input">
  >;
  deleteEnvironment?: Resolver<
    Maybe<ResolversTypes["DeleteEnvironmentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteEnvironmentArgs, "input">
  >;
  deleteIpAllowListEntry?: Resolver<
    Maybe<ResolversTypes["DeleteIpAllowListEntryPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteIpAllowListEntryArgs, "input">
  >;
  deleteIssue?: Resolver<
    Maybe<ResolversTypes["DeleteIssuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteIssueArgs, "input">
  >;
  deleteIssueComment?: Resolver<
    Maybe<ResolversTypes["DeleteIssueCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteIssueCommentArgs, "input">
  >;
  deleteLabel?: Resolver<
    Maybe<ResolversTypes["DeleteLabelPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteLabelArgs, "input">
  >;
  deleteLinkedBranch?: Resolver<
    Maybe<ResolversTypes["DeleteLinkedBranchPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteLinkedBranchArgs, "input">
  >;
  deletePackageVersion?: Resolver<
    Maybe<ResolversTypes["DeletePackageVersionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeletePackageVersionArgs, "input">
  >;
  deleteProject?: Resolver<
    Maybe<ResolversTypes["DeleteProjectPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteProjectArgs, "input">
  >;
  deleteProjectCard?: Resolver<
    Maybe<ResolversTypes["DeleteProjectCardPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteProjectCardArgs, "input">
  >;
  deleteProjectColumn?: Resolver<
    Maybe<ResolversTypes["DeleteProjectColumnPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteProjectColumnArgs, "input">
  >;
  deleteProjectV2?: Resolver<
    Maybe<ResolversTypes["DeleteProjectV2Payload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteProjectV2Args, "input">
  >;
  deleteProjectV2Field?: Resolver<
    Maybe<ResolversTypes["DeleteProjectV2FieldPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteProjectV2FieldArgs, "input">
  >;
  deleteProjectV2Item?: Resolver<
    Maybe<ResolversTypes["DeleteProjectV2ItemPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteProjectV2ItemArgs, "input">
  >;
  deleteProjectV2StatusUpdate?: Resolver<
    Maybe<ResolversTypes["DeleteProjectV2StatusUpdatePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteProjectV2StatusUpdateArgs, "input">
  >;
  deleteProjectV2Workflow?: Resolver<
    Maybe<ResolversTypes["DeleteProjectV2WorkflowPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteProjectV2WorkflowArgs, "input">
  >;
  deletePullRequestReview?: Resolver<
    Maybe<ResolversTypes["DeletePullRequestReviewPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeletePullRequestReviewArgs, "input">
  >;
  deletePullRequestReviewComment?: Resolver<
    Maybe<ResolversTypes["DeletePullRequestReviewCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeletePullRequestReviewCommentArgs, "input">
  >;
  deleteRef?: Resolver<
    Maybe<ResolversTypes["DeleteRefPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteRefArgs, "input">
  >;
  deleteRepositoryRuleset?: Resolver<
    Maybe<ResolversTypes["DeleteRepositoryRulesetPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteRepositoryRulesetArgs, "input">
  >;
  deleteTeamDiscussion?: Resolver<
    Maybe<ResolversTypes["DeleteTeamDiscussionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteTeamDiscussionArgs, "input">
  >;
  deleteTeamDiscussionComment?: Resolver<
    Maybe<ResolversTypes["DeleteTeamDiscussionCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteTeamDiscussionCommentArgs, "input">
  >;
  deleteUserList?: Resolver<
    Maybe<ResolversTypes["DeleteUserListPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteUserListArgs, "input">
  >;
  deleteVerifiableDomain?: Resolver<
    Maybe<ResolversTypes["DeleteVerifiableDomainPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDeleteVerifiableDomainArgs, "input">
  >;
  dequeuePullRequest?: Resolver<
    Maybe<ResolversTypes["DequeuePullRequestPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDequeuePullRequestArgs, "input">
  >;
  disablePullRequestAutoMerge?: Resolver<
    Maybe<ResolversTypes["DisablePullRequestAutoMergePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDisablePullRequestAutoMergeArgs, "input">
  >;
  dismissPullRequestReview?: Resolver<
    Maybe<ResolversTypes["DismissPullRequestReviewPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDismissPullRequestReviewArgs, "input">
  >;
  dismissRepositoryVulnerabilityAlert?: Resolver<
    Maybe<ResolversTypes["DismissRepositoryVulnerabilityAlertPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationDismissRepositoryVulnerabilityAlertArgs, "input">
  >;
  enablePullRequestAutoMerge?: Resolver<
    Maybe<ResolversTypes["EnablePullRequestAutoMergePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationEnablePullRequestAutoMergeArgs, "input">
  >;
  enqueuePullRequest?: Resolver<
    Maybe<ResolversTypes["EnqueuePullRequestPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationEnqueuePullRequestArgs, "input">
  >;
  followOrganization?: Resolver<
    Maybe<ResolversTypes["FollowOrganizationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationFollowOrganizationArgs, "input">
  >;
  followUser?: Resolver<
    Maybe<ResolversTypes["FollowUserPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationFollowUserArgs, "input">
  >;
  grantEnterpriseOrganizationsMigratorRole?: Resolver<
    Maybe<ResolversTypes["GrantEnterpriseOrganizationsMigratorRolePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationGrantEnterpriseOrganizationsMigratorRoleArgs, "input">
  >;
  grantMigratorRole?: Resolver<
    Maybe<ResolversTypes["GrantMigratorRolePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationGrantMigratorRoleArgs, "input">
  >;
  importProject?: Resolver<
    Maybe<ResolversTypes["ImportProjectPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationImportProjectArgs, "input">
  >;
  inviteEnterpriseAdmin?: Resolver<
    Maybe<ResolversTypes["InviteEnterpriseAdminPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationInviteEnterpriseAdminArgs, "input">
  >;
  inviteEnterpriseMember?: Resolver<
    Maybe<ResolversTypes["InviteEnterpriseMemberPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationInviteEnterpriseMemberArgs, "input">
  >;
  linkProjectV2ToRepository?: Resolver<
    Maybe<ResolversTypes["LinkProjectV2ToRepositoryPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationLinkProjectV2ToRepositoryArgs, "input">
  >;
  linkProjectV2ToTeam?: Resolver<
    Maybe<ResolversTypes["LinkProjectV2ToTeamPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationLinkProjectV2ToTeamArgs, "input">
  >;
  linkRepositoryToProject?: Resolver<
    Maybe<ResolversTypes["LinkRepositoryToProjectPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationLinkRepositoryToProjectArgs, "input">
  >;
  lockLockable?: Resolver<
    Maybe<ResolversTypes["LockLockablePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationLockLockableArgs, "input">
  >;
  markDiscussionCommentAsAnswer?: Resolver<
    Maybe<ResolversTypes["MarkDiscussionCommentAsAnswerPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationMarkDiscussionCommentAsAnswerArgs, "input">
  >;
  markFileAsViewed?: Resolver<
    Maybe<ResolversTypes["MarkFileAsViewedPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationMarkFileAsViewedArgs, "input">
  >;
  markNotificationAsDone?: Resolver<
    Maybe<ResolversTypes["MarkNotificationAsDonePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationMarkNotificationAsDoneArgs, "input">
  >;
  markProjectV2AsTemplate?: Resolver<
    Maybe<ResolversTypes["MarkProjectV2AsTemplatePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationMarkProjectV2AsTemplateArgs, "input">
  >;
  markPullRequestReadyForReview?: Resolver<
    Maybe<ResolversTypes["MarkPullRequestReadyForReviewPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationMarkPullRequestReadyForReviewArgs, "input">
  >;
  mergeBranch?: Resolver<
    Maybe<ResolversTypes["MergeBranchPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationMergeBranchArgs, "input">
  >;
  mergePullRequest?: Resolver<
    Maybe<ResolversTypes["MergePullRequestPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationMergePullRequestArgs, "input">
  >;
  minimizeComment?: Resolver<
    Maybe<ResolversTypes["MinimizeCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationMinimizeCommentArgs, "input">
  >;
  moveProjectCard?: Resolver<
    Maybe<ResolversTypes["MoveProjectCardPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationMoveProjectCardArgs, "input">
  >;
  moveProjectColumn?: Resolver<
    Maybe<ResolversTypes["MoveProjectColumnPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationMoveProjectColumnArgs, "input">
  >;
  pinEnvironment?: Resolver<
    Maybe<ResolversTypes["PinEnvironmentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationPinEnvironmentArgs, "input">
  >;
  pinIssue?: Resolver<
    Maybe<ResolversTypes["PinIssuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationPinIssueArgs, "input">
  >;
  publishSponsorsTier?: Resolver<
    Maybe<ResolversTypes["PublishSponsorsTierPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationPublishSponsorsTierArgs, "input">
  >;
  regenerateEnterpriseIdentityProviderRecoveryCodes?: Resolver<
    Maybe<
      ResolversTypes["RegenerateEnterpriseIdentityProviderRecoveryCodesPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationRegenerateEnterpriseIdentityProviderRecoveryCodesArgs,
      "input"
    >
  >;
  regenerateVerifiableDomainToken?: Resolver<
    Maybe<ResolversTypes["RegenerateVerifiableDomainTokenPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRegenerateVerifiableDomainTokenArgs, "input">
  >;
  rejectDeployments?: Resolver<
    Maybe<ResolversTypes["RejectDeploymentsPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRejectDeploymentsArgs, "input">
  >;
  removeAssigneesFromAssignable?: Resolver<
    Maybe<ResolversTypes["RemoveAssigneesFromAssignablePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRemoveAssigneesFromAssignableArgs, "input">
  >;
  removeEnterpriseAdmin?: Resolver<
    Maybe<ResolversTypes["RemoveEnterpriseAdminPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRemoveEnterpriseAdminArgs, "input">
  >;
  removeEnterpriseIdentityProvider?: Resolver<
    Maybe<ResolversTypes["RemoveEnterpriseIdentityProviderPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRemoveEnterpriseIdentityProviderArgs, "input">
  >;
  removeEnterpriseMember?: Resolver<
    Maybe<ResolversTypes["RemoveEnterpriseMemberPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRemoveEnterpriseMemberArgs, "input">
  >;
  removeEnterpriseOrganization?: Resolver<
    Maybe<ResolversTypes["RemoveEnterpriseOrganizationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRemoveEnterpriseOrganizationArgs, "input">
  >;
  removeEnterpriseSupportEntitlement?: Resolver<
    Maybe<ResolversTypes["RemoveEnterpriseSupportEntitlementPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRemoveEnterpriseSupportEntitlementArgs, "input">
  >;
  removeLabelsFromLabelable?: Resolver<
    Maybe<ResolversTypes["RemoveLabelsFromLabelablePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRemoveLabelsFromLabelableArgs, "input">
  >;
  removeOutsideCollaborator?: Resolver<
    Maybe<ResolversTypes["RemoveOutsideCollaboratorPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRemoveOutsideCollaboratorArgs, "input">
  >;
  removeReaction?: Resolver<
    Maybe<ResolversTypes["RemoveReactionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRemoveReactionArgs, "input">
  >;
  removeStar?: Resolver<
    Maybe<ResolversTypes["RemoveStarPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRemoveStarArgs, "input">
  >;
  removeUpvote?: Resolver<
    Maybe<ResolversTypes["RemoveUpvotePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRemoveUpvoteArgs, "input">
  >;
  reopenDiscussion?: Resolver<
    Maybe<ResolversTypes["ReopenDiscussionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationReopenDiscussionArgs, "input">
  >;
  reopenIssue?: Resolver<
    Maybe<ResolversTypes["ReopenIssuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationReopenIssueArgs, "input">
  >;
  reopenPullRequest?: Resolver<
    Maybe<ResolversTypes["ReopenPullRequestPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationReopenPullRequestArgs, "input">
  >;
  reorderEnvironment?: Resolver<
    Maybe<ResolversTypes["ReorderEnvironmentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationReorderEnvironmentArgs, "input">
  >;
  requestReviews?: Resolver<
    Maybe<ResolversTypes["RequestReviewsPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRequestReviewsArgs, "input">
  >;
  rerequestCheckSuite?: Resolver<
    Maybe<ResolversTypes["RerequestCheckSuitePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRerequestCheckSuiteArgs, "input">
  >;
  resolveReviewThread?: Resolver<
    Maybe<ResolversTypes["ResolveReviewThreadPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationResolveReviewThreadArgs, "input">
  >;
  retireSponsorsTier?: Resolver<
    Maybe<ResolversTypes["RetireSponsorsTierPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRetireSponsorsTierArgs, "input">
  >;
  revertPullRequest?: Resolver<
    Maybe<ResolversTypes["RevertPullRequestPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRevertPullRequestArgs, "input">
  >;
  revokeEnterpriseOrganizationsMigratorRole?: Resolver<
    Maybe<ResolversTypes["RevokeEnterpriseOrganizationsMigratorRolePayload"]>,
    ParentType,
    ContextType,
    RequireFields<
      MutationRevokeEnterpriseOrganizationsMigratorRoleArgs,
      "input"
    >
  >;
  revokeMigratorRole?: Resolver<
    Maybe<ResolversTypes["RevokeMigratorRolePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationRevokeMigratorRoleArgs, "input">
  >;
  setEnterpriseIdentityProvider?: Resolver<
    Maybe<ResolversTypes["SetEnterpriseIdentityProviderPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationSetEnterpriseIdentityProviderArgs, "input">
  >;
  setOrganizationInteractionLimit?: Resolver<
    Maybe<ResolversTypes["SetOrganizationInteractionLimitPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationSetOrganizationInteractionLimitArgs, "input">
  >;
  setRepositoryInteractionLimit?: Resolver<
    Maybe<ResolversTypes["SetRepositoryInteractionLimitPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationSetRepositoryInteractionLimitArgs, "input">
  >;
  setUserInteractionLimit?: Resolver<
    Maybe<ResolversTypes["SetUserInteractionLimitPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationSetUserInteractionLimitArgs, "input">
  >;
  startOrganizationMigration?: Resolver<
    Maybe<ResolversTypes["StartOrganizationMigrationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationStartOrganizationMigrationArgs, "input">
  >;
  startRepositoryMigration?: Resolver<
    Maybe<ResolversTypes["StartRepositoryMigrationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationStartRepositoryMigrationArgs, "input">
  >;
  submitPullRequestReview?: Resolver<
    Maybe<ResolversTypes["SubmitPullRequestReviewPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationSubmitPullRequestReviewArgs, "input">
  >;
  transferEnterpriseOrganization?: Resolver<
    Maybe<ResolversTypes["TransferEnterpriseOrganizationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationTransferEnterpriseOrganizationArgs, "input">
  >;
  transferIssue?: Resolver<
    Maybe<ResolversTypes["TransferIssuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationTransferIssueArgs, "input">
  >;
  unarchiveProjectV2Item?: Resolver<
    Maybe<ResolversTypes["UnarchiveProjectV2ItemPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnarchiveProjectV2ItemArgs, "input">
  >;
  unarchiveRepository?: Resolver<
    Maybe<ResolversTypes["UnarchiveRepositoryPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnarchiveRepositoryArgs, "input">
  >;
  unfollowOrganization?: Resolver<
    Maybe<ResolversTypes["UnfollowOrganizationPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnfollowOrganizationArgs, "input">
  >;
  unfollowUser?: Resolver<
    Maybe<ResolversTypes["UnfollowUserPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnfollowUserArgs, "input">
  >;
  unlinkProjectV2FromRepository?: Resolver<
    Maybe<ResolversTypes["UnlinkProjectV2FromRepositoryPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnlinkProjectV2FromRepositoryArgs, "input">
  >;
  unlinkProjectV2FromTeam?: Resolver<
    Maybe<ResolversTypes["UnlinkProjectV2FromTeamPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnlinkProjectV2FromTeamArgs, "input">
  >;
  unlinkRepositoryFromProject?: Resolver<
    Maybe<ResolversTypes["UnlinkRepositoryFromProjectPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnlinkRepositoryFromProjectArgs, "input">
  >;
  unlockLockable?: Resolver<
    Maybe<ResolversTypes["UnlockLockablePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnlockLockableArgs, "input">
  >;
  unmarkDiscussionCommentAsAnswer?: Resolver<
    Maybe<ResolversTypes["UnmarkDiscussionCommentAsAnswerPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnmarkDiscussionCommentAsAnswerArgs, "input">
  >;
  unmarkFileAsViewed?: Resolver<
    Maybe<ResolversTypes["UnmarkFileAsViewedPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnmarkFileAsViewedArgs, "input">
  >;
  unmarkIssueAsDuplicate?: Resolver<
    Maybe<ResolversTypes["UnmarkIssueAsDuplicatePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnmarkIssueAsDuplicateArgs, "input">
  >;
  unmarkProjectV2AsTemplate?: Resolver<
    Maybe<ResolversTypes["UnmarkProjectV2AsTemplatePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnmarkProjectV2AsTemplateArgs, "input">
  >;
  unminimizeComment?: Resolver<
    Maybe<ResolversTypes["UnminimizeCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnminimizeCommentArgs, "input">
  >;
  unpinIssue?: Resolver<
    Maybe<ResolversTypes["UnpinIssuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnpinIssueArgs, "input">
  >;
  unresolveReviewThread?: Resolver<
    Maybe<ResolversTypes["UnresolveReviewThreadPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnresolveReviewThreadArgs, "input">
  >;
  unsubscribeFromNotifications?: Resolver<
    Maybe<ResolversTypes["UnsubscribeFromNotificationsPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUnsubscribeFromNotificationsArgs, "input">
  >;
  updateBranchProtectionRule?: Resolver<
    Maybe<ResolversTypes["UpdateBranchProtectionRulePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateBranchProtectionRuleArgs, "input">
  >;
  updateCheckRun?: Resolver<
    Maybe<ResolversTypes["UpdateCheckRunPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateCheckRunArgs, "input">
  >;
  updateCheckSuitePreferences?: Resolver<
    Maybe<ResolversTypes["UpdateCheckSuitePreferencesPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateCheckSuitePreferencesArgs, "input">
  >;
  updateDiscussion?: Resolver<
    Maybe<ResolversTypes["UpdateDiscussionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateDiscussionArgs, "input">
  >;
  updateDiscussionComment?: Resolver<
    Maybe<ResolversTypes["UpdateDiscussionCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateDiscussionCommentArgs, "input">
  >;
  updateEnterpriseAdministratorRole?: Resolver<
    Maybe<ResolversTypes["UpdateEnterpriseAdministratorRolePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateEnterpriseAdministratorRoleArgs, "input">
  >;
  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseAllowPrivateRepositoryForkingSettingArgs,
      "input"
    >
  >;
  updateEnterpriseDefaultRepositoryPermissionSetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateEnterpriseDefaultRepositoryPermissionSettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseDefaultRepositoryPermissionSettingArgs,
      "input"
    >
  >;
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs,
      "input"
    >
  >;
  updateEnterpriseMembersCanCreateRepositoriesSetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseMembersCanCreateRepositoriesSettingArgs,
      "input"
    >
  >;
  updateEnterpriseMembersCanDeleteIssuesSetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateEnterpriseMembersCanDeleteIssuesSettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseMembersCanDeleteIssuesSettingArgs,
      "input"
    >
  >;
  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseMembersCanDeleteRepositoriesSettingArgs,
      "input"
    >
  >;
  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseMembersCanInviteCollaboratorsSettingArgs,
      "input"
    >
  >;
  updateEnterpriseMembersCanMakePurchasesSetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateEnterpriseMembersCanMakePurchasesSettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseMembersCanMakePurchasesSettingArgs,
      "input"
    >
  >;
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs,
      "input"
    >
  >;
  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseMembersCanViewDependencyInsightsSettingArgs,
      "input"
    >
  >;
  updateEnterpriseOrganizationProjectsSetting?: Resolver<
    Maybe<ResolversTypes["UpdateEnterpriseOrganizationProjectsSettingPayload"]>,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseOrganizationProjectsSettingArgs,
      "input"
    >
  >;
  updateEnterpriseOwnerOrganizationRole?: Resolver<
    Maybe<ResolversTypes["UpdateEnterpriseOwnerOrganizationRolePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateEnterpriseOwnerOrganizationRoleArgs, "input">
  >;
  updateEnterpriseProfile?: Resolver<
    Maybe<ResolversTypes["UpdateEnterpriseProfilePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateEnterpriseProfileArgs, "input">
  >;
  updateEnterpriseRepositoryProjectsSetting?: Resolver<
    Maybe<ResolversTypes["UpdateEnterpriseRepositoryProjectsSettingPayload"]>,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseRepositoryProjectsSettingArgs,
      "input"
    >
  >;
  updateEnterpriseTeamDiscussionsSetting?: Resolver<
    Maybe<ResolversTypes["UpdateEnterpriseTeamDiscussionsSettingPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateEnterpriseTeamDiscussionsSettingArgs, "input">
  >;
  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs,
      "input"
    >
  >;
  updateEnvironment?: Resolver<
    Maybe<ResolversTypes["UpdateEnvironmentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateEnvironmentArgs, "input">
  >;
  updateIpAllowListEnabledSetting?: Resolver<
    Maybe<ResolversTypes["UpdateIpAllowListEnabledSettingPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateIpAllowListEnabledSettingArgs, "input">
  >;
  updateIpAllowListEntry?: Resolver<
    Maybe<ResolversTypes["UpdateIpAllowListEntryPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateIpAllowListEntryArgs, "input">
  >;
  updateIpAllowListForInstalledAppsEnabledSetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateIpAllowListForInstalledAppsEnabledSettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateIpAllowListForInstalledAppsEnabledSettingArgs,
      "input"
    >
  >;
  updateIssue?: Resolver<
    Maybe<ResolversTypes["UpdateIssuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateIssueArgs, "input">
  >;
  updateIssueComment?: Resolver<
    Maybe<ResolversTypes["UpdateIssueCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateIssueCommentArgs, "input">
  >;
  updateLabel?: Resolver<
    Maybe<ResolversTypes["UpdateLabelPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateLabelArgs, "input">
  >;
  updateNotificationRestrictionSetting?: Resolver<
    Maybe<ResolversTypes["UpdateNotificationRestrictionSettingPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateNotificationRestrictionSettingArgs, "input">
  >;
  updateOrganizationAllowPrivateRepositoryForkingSetting?: Resolver<
    Maybe<
      ResolversTypes["UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload"]
    >,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateOrganizationAllowPrivateRepositoryForkingSettingArgs,
      "input"
    >
  >;
  updateOrganizationWebCommitSignoffSetting?: Resolver<
    Maybe<ResolversTypes["UpdateOrganizationWebCommitSignoffSettingPayload"]>,
    ParentType,
    ContextType,
    RequireFields<
      MutationUpdateOrganizationWebCommitSignoffSettingArgs,
      "input"
    >
  >;
  updatePatreonSponsorability?: Resolver<
    Maybe<ResolversTypes["UpdatePatreonSponsorabilityPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdatePatreonSponsorabilityArgs, "input">
  >;
  updateProject?: Resolver<
    Maybe<ResolversTypes["UpdateProjectPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateProjectArgs, "input">
  >;
  updateProjectCard?: Resolver<
    Maybe<ResolversTypes["UpdateProjectCardPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateProjectCardArgs, "input">
  >;
  updateProjectColumn?: Resolver<
    Maybe<ResolversTypes["UpdateProjectColumnPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateProjectColumnArgs, "input">
  >;
  updateProjectV2?: Resolver<
    Maybe<ResolversTypes["UpdateProjectV2Payload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateProjectV2Args, "input">
  >;
  updateProjectV2Collaborators?: Resolver<
    Maybe<ResolversTypes["UpdateProjectV2CollaboratorsPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateProjectV2CollaboratorsArgs, "input">
  >;
  updateProjectV2DraftIssue?: Resolver<
    Maybe<ResolversTypes["UpdateProjectV2DraftIssuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateProjectV2DraftIssueArgs, "input">
  >;
  updateProjectV2ItemFieldValue?: Resolver<
    Maybe<ResolversTypes["UpdateProjectV2ItemFieldValuePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateProjectV2ItemFieldValueArgs, "input">
  >;
  updateProjectV2ItemPosition?: Resolver<
    Maybe<ResolversTypes["UpdateProjectV2ItemPositionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateProjectV2ItemPositionArgs, "input">
  >;
  updateProjectV2StatusUpdate?: Resolver<
    Maybe<ResolversTypes["UpdateProjectV2StatusUpdatePayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateProjectV2StatusUpdateArgs, "input">
  >;
  updatePullRequest?: Resolver<
    Maybe<ResolversTypes["UpdatePullRequestPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdatePullRequestArgs, "input">
  >;
  updatePullRequestBranch?: Resolver<
    Maybe<ResolversTypes["UpdatePullRequestBranchPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdatePullRequestBranchArgs, "input">
  >;
  updatePullRequestReview?: Resolver<
    Maybe<ResolversTypes["UpdatePullRequestReviewPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdatePullRequestReviewArgs, "input">
  >;
  updatePullRequestReviewComment?: Resolver<
    Maybe<ResolversTypes["UpdatePullRequestReviewCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdatePullRequestReviewCommentArgs, "input">
  >;
  updateRef?: Resolver<
    Maybe<ResolversTypes["UpdateRefPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateRefArgs, "input">
  >;
  updateRefs?: Resolver<
    Maybe<ResolversTypes["UpdateRefsPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateRefsArgs, "input">
  >;
  updateRepository?: Resolver<
    Maybe<ResolversTypes["UpdateRepositoryPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateRepositoryArgs, "input">
  >;
  updateRepositoryRuleset?: Resolver<
    Maybe<ResolversTypes["UpdateRepositoryRulesetPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateRepositoryRulesetArgs, "input">
  >;
  updateRepositoryWebCommitSignoffSetting?: Resolver<
    Maybe<ResolversTypes["UpdateRepositoryWebCommitSignoffSettingPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateRepositoryWebCommitSignoffSettingArgs, "input">
  >;
  updateSponsorshipPreferences?: Resolver<
    Maybe<ResolversTypes["UpdateSponsorshipPreferencesPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateSponsorshipPreferencesArgs, "input">
  >;
  updateSubscription?: Resolver<
    Maybe<ResolversTypes["UpdateSubscriptionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateSubscriptionArgs, "input">
  >;
  updateTeamDiscussion?: Resolver<
    Maybe<ResolversTypes["UpdateTeamDiscussionPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateTeamDiscussionArgs, "input">
  >;
  updateTeamDiscussionComment?: Resolver<
    Maybe<ResolversTypes["UpdateTeamDiscussionCommentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateTeamDiscussionCommentArgs, "input">
  >;
  updateTeamReviewAssignment?: Resolver<
    Maybe<ResolversTypes["UpdateTeamReviewAssignmentPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateTeamReviewAssignmentArgs, "input">
  >;
  updateTeamsRepository?: Resolver<
    Maybe<ResolversTypes["UpdateTeamsRepositoryPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateTeamsRepositoryArgs, "input">
  >;
  updateTopics?: Resolver<
    Maybe<ResolversTypes["UpdateTopicsPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateTopicsArgs, "input">
  >;
  updateUserList?: Resolver<
    Maybe<ResolversTypes["UpdateUserListPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateUserListArgs, "input">
  >;
  updateUserListsForItem?: Resolver<
    Maybe<ResolversTypes["UpdateUserListsForItemPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateUserListsForItemArgs, "input">
  >;
  verifyVerifiableDomain?: Resolver<
    Maybe<ResolversTypes["VerifyVerifiableDomainPayload"]>,
    ParentType,
    ContextType,
    RequireFields<MutationVerifyVerifiableDomainArgs, "input">
  >;
};

export type NodeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Node"] = ResolversParentTypes["Node"],
> = {
  __resolveType: TypeResolveFn<
    | "AddedToMergeQueueEvent"
    | "AddedToProjectEvent"
    | "App"
    | "AssignedEvent"
    | "AutoMergeDisabledEvent"
    | "AutoMergeEnabledEvent"
    | "AutoRebaseEnabledEvent"
    | "AutoSquashEnabledEvent"
    | "AutomaticBaseChangeFailedEvent"
    | "AutomaticBaseChangeSucceededEvent"
    | "BaseRefChangedEvent"
    | "BaseRefDeletedEvent"
    | "BaseRefForcePushedEvent"
    | "Blob"
    | "Bot"
    | "BranchProtectionRule"
    | "BypassForcePushAllowance"
    | "BypassPullRequestAllowance"
    | "CWE"
    | "CheckRun"
    | "CheckSuite"
    | "ClosedEvent"
    | "CodeOfConduct"
    | "CommentDeletedEvent"
    | "Commit"
    | "CommitComment"
    | "CommitCommentThread"
    | "Comparison"
    | "ConnectedEvent"
    | "ConvertToDraftEvent"
    | "ConvertedNoteToIssueEvent"
    | "ConvertedToDiscussionEvent"
    | "CrossReferencedEvent"
    | "DemilestonedEvent"
    | "DependencyGraphManifest"
    | "DeployKey"
    | "DeployedEvent"
    | "Deployment"
    | "DeploymentEnvironmentChangedEvent"
    | "DeploymentReview"
    | "DeploymentStatus"
    | "DisconnectedEvent"
    | "Discussion"
    | "DiscussionCategory"
    | "DiscussionComment"
    | "DiscussionPoll"
    | "DiscussionPollOption"
    | "DraftIssue"
    | "Enterprise"
    | "EnterpriseAdministratorInvitation"
    | "EnterpriseIdentityProvider"
    | "EnterpriseMemberInvitation"
    | "EnterpriseRepositoryInfo"
    | "EnterpriseServerInstallation"
    | "EnterpriseServerUserAccount"
    | "EnterpriseServerUserAccountEmail"
    | "EnterpriseServerUserAccountsUpload"
    | "EnterpriseUserAccount"
    | "Environment"
    | "ExternalIdentity"
    | "Gist"
    | "GistComment"
    | "HeadRefDeletedEvent"
    | "HeadRefForcePushedEvent"
    | "HeadRefRestoredEvent"
    | "IpAllowListEntry"
    | "Issue"
    | "IssueComment"
    | "Label"
    | "LabeledEvent"
    | "Language"
    | "License"
    | "LinkedBranch"
    | "LockedEvent"
    | "Mannequin"
    | "MarkedAsDuplicateEvent"
    | "MarketplaceCategory"
    | "MarketplaceListing"
    | "MemberFeatureRequestNotification"
    | "MembersCanDeleteReposClearAuditEntry"
    | "MembersCanDeleteReposDisableAuditEntry"
    | "MembersCanDeleteReposEnableAuditEntry"
    | "MentionedEvent"
    | "MergeQueue"
    | "MergeQueueEntry"
    | "MergedEvent"
    | "MigrationSource"
    | "Milestone"
    | "MilestonedEvent"
    | "MovedColumnsInProjectEvent"
    | "OIDCProvider"
    | "OauthApplicationCreateAuditEntry"
    | "OrgAddBillingManagerAuditEntry"
    | "OrgAddMemberAuditEntry"
    | "OrgBlockUserAuditEntry"
    | "OrgConfigDisableCollaboratorsOnlyAuditEntry"
    | "OrgConfigEnableCollaboratorsOnlyAuditEntry"
    | "OrgCreateAuditEntry"
    | "OrgDisableOauthAppRestrictionsAuditEntry"
    | "OrgDisableSamlAuditEntry"
    | "OrgDisableTwoFactorRequirementAuditEntry"
    | "OrgEnableOauthAppRestrictionsAuditEntry"
    | "OrgEnableSamlAuditEntry"
    | "OrgEnableTwoFactorRequirementAuditEntry"
    | "OrgInviteMemberAuditEntry"
    | "OrgInviteToBusinessAuditEntry"
    | "OrgOauthAppAccessApprovedAuditEntry"
    | "OrgOauthAppAccessBlockedAuditEntry"
    | "OrgOauthAppAccessDeniedAuditEntry"
    | "OrgOauthAppAccessRequestedAuditEntry"
    | "OrgOauthAppAccessUnblockedAuditEntry"
    | "OrgRemoveBillingManagerAuditEntry"
    | "OrgRemoveMemberAuditEntry"
    | "OrgRemoveOutsideCollaboratorAuditEntry"
    | "OrgRestoreMemberAuditEntry"
    | "OrgUnblockUserAuditEntry"
    | "OrgUpdateDefaultRepositoryPermissionAuditEntry"
    | "OrgUpdateMemberAuditEntry"
    | "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
    | "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
    | "Organization"
    | "OrganizationIdentityProvider"
    | "OrganizationInvitation"
    | "OrganizationMigration"
    | "Package"
    | "PackageFile"
    | "PackageTag"
    | "PackageVersion"
    | "PinnedDiscussion"
    | "PinnedEnvironment"
    | "PinnedEvent"
    | "PinnedIssue"
    | "PrivateRepositoryForkingDisableAuditEntry"
    | "PrivateRepositoryForkingEnableAuditEntry"
    | "Project"
    | "ProjectCard"
    | "ProjectColumn"
    | "ProjectV2"
    | "ProjectV2Field"
    | "ProjectV2Item"
    | "ProjectV2ItemFieldDateValue"
    | "ProjectV2ItemFieldIterationValue"
    | "ProjectV2ItemFieldNumberValue"
    | "ProjectV2ItemFieldSingleSelectValue"
    | "ProjectV2ItemFieldTextValue"
    | "ProjectV2IterationField"
    | "ProjectV2SingleSelectField"
    | "ProjectV2StatusUpdate"
    | "ProjectV2View"
    | "ProjectV2Workflow"
    | "PublicKey"
    | "PullRequest"
    | "PullRequestCommit"
    | "PullRequestCommitCommentThread"
    | "PullRequestReview"
    | "PullRequestReviewComment"
    | "PullRequestReviewThread"
    | "PullRequestThread"
    | "Push"
    | "PushAllowance"
    | "Reaction"
    | "ReadyForReviewEvent"
    | "Ref"
    | "ReferencedEvent"
    | "Release"
    | "ReleaseAsset"
    | "RemovedFromMergeQueueEvent"
    | "RemovedFromProjectEvent"
    | "RenamedTitleEvent"
    | "ReopenedEvent"
    | "RepoAccessAuditEntry"
    | "RepoAddMemberAuditEntry"
    | "RepoAddTopicAuditEntry"
    | "RepoArchivedAuditEntry"
    | "RepoChangeMergeSettingAuditEntry"
    | "RepoConfigDisableAnonymousGitAccessAuditEntry"
    | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
    | "RepoConfigDisableContributorsOnlyAuditEntry"
    | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
    | "RepoConfigEnableAnonymousGitAccessAuditEntry"
    | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
    | "RepoConfigEnableContributorsOnlyAuditEntry"
    | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
    | "RepoConfigLockAnonymousGitAccessAuditEntry"
    | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
    | "RepoCreateAuditEntry"
    | "RepoDestroyAuditEntry"
    | "RepoRemoveMemberAuditEntry"
    | "RepoRemoveTopicAuditEntry"
    | "Repository"
    | "RepositoryInvitation"
    | "RepositoryMigration"
    | "RepositoryRule"
    | "RepositoryRuleset"
    | "RepositoryRulesetBypassActor"
    | "RepositoryTopic"
    | "RepositoryVisibilityChangeDisableAuditEntry"
    | "RepositoryVisibilityChangeEnableAuditEntry"
    | "RepositoryVulnerabilityAlert"
    | "ReviewDismissalAllowance"
    | "ReviewDismissedEvent"
    | "ReviewRequest"
    | "ReviewRequestRemovedEvent"
    | "ReviewRequestedEvent"
    | "SavedReply"
    | "SecurityAdvisory"
    | "SponsorsActivity"
    | "SponsorsListing"
    | "SponsorsListingFeaturedItem"
    | "SponsorsTier"
    | "Sponsorship"
    | "SponsorshipNewsletter"
    | "Status"
    | "StatusCheckRollup"
    | "StatusContext"
    | "SubscribedEvent"
    | "Tag"
    | "Team"
    | "TeamAddMemberAuditEntry"
    | "TeamAddRepositoryAuditEntry"
    | "TeamChangeParentTeamAuditEntry"
    | "TeamDiscussion"
    | "TeamDiscussionComment"
    | "TeamRemoveMemberAuditEntry"
    | "TeamRemoveRepositoryAuditEntry"
    | "Topic"
    | "TransferredEvent"
    | "Tree"
    | "UnassignedEvent"
    | "UnlabeledEvent"
    | "UnlockedEvent"
    | "UnmarkedAsDuplicateEvent"
    | "UnpinnedEvent"
    | "UnsubscribedEvent"
    | "User"
    | "UserBlockedEvent"
    | "UserContentEdit"
    | "UserList"
    | "UserStatus"
    | "VerifiableDomain"
    | "Workflow"
    | "WorkflowRun"
    | "WorkflowRunFile",
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
};

export type OidcProviderResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OIDCProvider"] = ResolversParentTypes["OIDCProvider"],
> = {
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  externalIdentities?: Resolver<
    ResolversTypes["ExternalIdentityConnection"],
    ParentType,
    ContextType,
    Partial<OidcProviderExternalIdentitiesArgs>
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  providerType?: Resolver<
    ResolversTypes["OIDCProviderType"],
    ParentType,
    ContextType
  >;
  tenantId?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OauthApplicationAuditEntryDataResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OauthApplicationAuditEntryData"] = ResolversParentTypes["OauthApplicationAuditEntryData"],
> = {
  __resolveType: TypeResolveFn<
    | "OauthApplicationCreateAuditEntry"
    | "OrgOauthAppAccessApprovedAuditEntry"
    | "OrgOauthAppAccessBlockedAuditEntry"
    | "OrgOauthAppAccessDeniedAuditEntry"
    | "OrgOauthAppAccessRequestedAuditEntry"
    | "OrgOauthAppAccessUnblockedAuditEntry",
    ParentType,
    ContextType
  >;
  oauthApplicationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
};

export type OauthApplicationCreateAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OauthApplicationCreateAuditEntry"] = ResolversParentTypes["OauthApplicationCreateAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  applicationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  callbackUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  oauthApplicationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  rateLimit?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  state?: Resolver<
    Maybe<ResolversTypes["OauthApplicationCreateAuditEntryState"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgAddBillingManagerAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgAddBillingManagerAuditEntry"] = ResolversParentTypes["OrgAddBillingManagerAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  invitationEmail?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgAddMemberAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgAddMemberAuditEntry"] = ResolversParentTypes["OrgAddMemberAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  permission?: Resolver<
    Maybe<ResolversTypes["OrgAddMemberAuditEntryPermission"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgBlockUserAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgBlockUserAuditEntry"] = ResolversParentTypes["OrgBlockUserAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  blockedUser?: Resolver<
    Maybe<ResolversTypes["User"]>,
    ParentType,
    ContextType
  >;
  blockedUserName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  blockedUserResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  blockedUserUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgConfigDisableCollaboratorsOnlyAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgConfigDisableCollaboratorsOnlyAuditEntry"] = ResolversParentTypes["OrgConfigDisableCollaboratorsOnlyAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgConfigEnableCollaboratorsOnlyAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgConfigEnableCollaboratorsOnlyAuditEntry"] = ResolversParentTypes["OrgConfigEnableCollaboratorsOnlyAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgCreateAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgCreateAuditEntry"] = ResolversParentTypes["OrgCreateAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  billingPlan?: Resolver<
    Maybe<ResolversTypes["OrgCreateAuditEntryBillingPlan"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgDisableOauthAppRestrictionsAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgDisableOauthAppRestrictionsAuditEntry"] = ResolversParentTypes["OrgDisableOauthAppRestrictionsAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgDisableSamlAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgDisableSamlAuditEntry"] = ResolversParentTypes["OrgDisableSamlAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  digestMethodUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  issuerUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  signatureMethodUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  singleSignOnUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgDisableTwoFactorRequirementAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgDisableTwoFactorRequirementAuditEntry"] = ResolversParentTypes["OrgDisableTwoFactorRequirementAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgEnableOauthAppRestrictionsAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgEnableOauthAppRestrictionsAuditEntry"] = ResolversParentTypes["OrgEnableOauthAppRestrictionsAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgEnableSamlAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgEnableSamlAuditEntry"] = ResolversParentTypes["OrgEnableSamlAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  digestMethodUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  issuerUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  signatureMethodUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  singleSignOnUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgEnableTwoFactorRequirementAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgEnableTwoFactorRequirementAuditEntry"] = ResolversParentTypes["OrgEnableTwoFactorRequirementAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgInviteMemberAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgInviteMemberAuditEntry"] = ResolversParentTypes["OrgInviteMemberAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  email?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationInvitation?: Resolver<
    Maybe<ResolversTypes["OrganizationInvitation"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgInviteToBusinessAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgInviteToBusinessAuditEntry"] = ResolversParentTypes["OrgInviteToBusinessAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  enterpriseResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  enterpriseSlug?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterpriseUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgOauthAppAccessApprovedAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgOauthAppAccessApprovedAuditEntry"] = ResolversParentTypes["OrgOauthAppAccessApprovedAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  oauthApplicationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgOauthAppAccessBlockedAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgOauthAppAccessBlockedAuditEntry"] = ResolversParentTypes["OrgOauthAppAccessBlockedAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  oauthApplicationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgOauthAppAccessDeniedAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgOauthAppAccessDeniedAuditEntry"] = ResolversParentTypes["OrgOauthAppAccessDeniedAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  oauthApplicationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgOauthAppAccessRequestedAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgOauthAppAccessRequestedAuditEntry"] = ResolversParentTypes["OrgOauthAppAccessRequestedAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  oauthApplicationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgOauthAppAccessUnblockedAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgOauthAppAccessUnblockedAuditEntry"] = ResolversParentTypes["OrgOauthAppAccessUnblockedAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  oauthApplicationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  oauthApplicationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgRemoveBillingManagerAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgRemoveBillingManagerAuditEntry"] = ResolversParentTypes["OrgRemoveBillingManagerAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  reason?: Resolver<
    Maybe<ResolversTypes["OrgRemoveBillingManagerAuditEntryReason"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgRemoveMemberAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgRemoveMemberAuditEntry"] = ResolversParentTypes["OrgRemoveMemberAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  membershipTypes?: Resolver<
    Maybe<Array<ResolversTypes["OrgRemoveMemberAuditEntryMembershipType"]>>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  reason?: Resolver<
    Maybe<ResolversTypes["OrgRemoveMemberAuditEntryReason"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgRemoveOutsideCollaboratorAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgRemoveOutsideCollaboratorAuditEntry"] = ResolversParentTypes["OrgRemoveOutsideCollaboratorAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  membershipTypes?: Resolver<
    Maybe<
      Array<
        ResolversTypes["OrgRemoveOutsideCollaboratorAuditEntryMembershipType"]
      >
    >,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  reason?: Resolver<
    Maybe<ResolversTypes["OrgRemoveOutsideCollaboratorAuditEntryReason"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgRestoreMemberAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgRestoreMemberAuditEntry"] = ResolversParentTypes["OrgRestoreMemberAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  restoredCustomEmailRoutingsCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  restoredIssueAssignmentsCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  restoredMemberships?: Resolver<
    Maybe<Array<ResolversTypes["OrgRestoreMemberAuditEntryMembership"]>>,
    ParentType,
    ContextType
  >;
  restoredMembershipsCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  restoredRepositoriesCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  restoredRepositoryStarsCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  restoredRepositoryWatchesCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgRestoreMemberAuditEntryMembershipResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgRestoreMemberAuditEntryMembership"] = ResolversParentTypes["OrgRestoreMemberAuditEntryMembership"],
> = {
  __resolveType: TypeResolveFn<
    | "OrgRestoreMemberMembershipOrganizationAuditEntryData"
    | "OrgRestoreMemberMembershipRepositoryAuditEntryData"
    | "OrgRestoreMemberMembershipTeamAuditEntryData",
    ParentType,
    ContextType
  >;
};

export type OrgRestoreMemberMembershipOrganizationAuditEntryDataResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgRestoreMemberMembershipOrganizationAuditEntryData"] = ResolversParentTypes["OrgRestoreMemberMembershipOrganizationAuditEntryData"],
> = {
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgRestoreMemberMembershipRepositoryAuditEntryDataResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgRestoreMemberMembershipRepositoryAuditEntryData"] = ResolversParentTypes["OrgRestoreMemberMembershipRepositoryAuditEntryData"],
> = {
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgRestoreMemberMembershipTeamAuditEntryDataResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgRestoreMemberMembershipTeamAuditEntryData"] = ResolversParentTypes["OrgRestoreMemberMembershipTeamAuditEntryData"],
> = {
  team?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  teamResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  teamUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgUnblockUserAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgUnblockUserAuditEntry"] = ResolversParentTypes["OrgUnblockUserAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  blockedUser?: Resolver<
    Maybe<ResolversTypes["User"]>,
    ParentType,
    ContextType
  >;
  blockedUserName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  blockedUserResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  blockedUserUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgUpdateDefaultRepositoryPermissionAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgUpdateDefaultRepositoryPermissionAuditEntry"] = ResolversParentTypes["OrgUpdateDefaultRepositoryPermissionAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  permission?: Resolver<
    Maybe<
      ResolversTypes["OrgUpdateDefaultRepositoryPermissionAuditEntryPermission"]
    >,
    ParentType,
    ContextType
  >;
  permissionWas?: Resolver<
    Maybe<
      ResolversTypes["OrgUpdateDefaultRepositoryPermissionAuditEntryPermission"]
    >,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgUpdateMemberAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgUpdateMemberAuditEntry"] = ResolversParentTypes["OrgUpdateMemberAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  permission?: Resolver<
    Maybe<ResolversTypes["OrgUpdateMemberAuditEntryPermission"]>,
    ParentType,
    ContextType
  >;
  permissionWas?: Resolver<
    Maybe<ResolversTypes["OrgUpdateMemberAuditEntryPermission"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgUpdateMemberRepositoryCreationPermissionAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgUpdateMemberRepositoryCreationPermissionAuditEntry"] = ResolversParentTypes["OrgUpdateMemberRepositoryCreationPermissionAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  canCreateRepositories?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  visibility?: Resolver<
    Maybe<
      ResolversTypes["OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility"]
    >,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgUpdateMemberRepositoryInvitationPermissionAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"] = ResolversParentTypes["OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  canInviteOutsideCollaboratorsToRepositories?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Organization"] = ResolversParentTypes["Organization"],
> = {
  announcement?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  announcementCreatedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  announcementExpiresAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  announcementUserDismissible?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  anyPinnableItems?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    Partial<OrganizationAnyPinnableItemsArgs>
  >;
  archivedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  auditLog?: Resolver<
    ResolversTypes["OrganizationAuditEntryConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationAuditLogArgs, "orderBy">
  >;
  avatarUrl?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType,
    Partial<OrganizationAvatarUrlArgs>
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  descriptionHTML?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  domains?: Resolver<
    Maybe<ResolversTypes["VerifiableDomainConnection"]>,
    ParentType,
    ContextType,
    RequireFields<
      OrganizationDomainsArgs,
      "isApproved" | "isVerified" | "orderBy"
    >
  >;
  email?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  enterpriseOwners?: Resolver<
    ResolversTypes["OrganizationEnterpriseOwnerConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationEnterpriseOwnersArgs, "orderBy">
  >;
  estimatedNextSponsorsPayoutInCents?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  hasSponsorsListing?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  interactionAbility?: Resolver<
    Maybe<ResolversTypes["RepositoryInteractionAbility"]>,
    ParentType,
    ContextType
  >;
  ipAllowListEnabledSetting?: Resolver<
    ResolversTypes["IpAllowListEnabledSettingValue"],
    ParentType,
    ContextType
  >;
  ipAllowListEntries?: Resolver<
    ResolversTypes["IpAllowListEntryConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationIpAllowListEntriesArgs, "orderBy">
  >;
  ipAllowListForInstalledAppsEnabledSetting?: Resolver<
    ResolversTypes["IpAllowListForInstalledAppsEnabledSettingValue"],
    ParentType,
    ContextType
  >;
  isSponsoredBy?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<OrganizationIsSponsoredByArgs, "accountLogin">
  >;
  isSponsoringViewer?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isVerified?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  itemShowcase?: Resolver<
    ResolversTypes["ProfileItemShowcase"],
    ParentType,
    ContextType
  >;
  lifetimeReceivedSponsorshipValues?: Resolver<
    ResolversTypes["SponsorAndLifetimeValueConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationLifetimeReceivedSponsorshipValuesArgs, "orderBy">
  >;
  location?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  login?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  mannequins?: Resolver<
    ResolversTypes["MannequinConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationMannequinsArgs, "orderBy">
  >;
  memberStatuses?: Resolver<
    ResolversTypes["UserStatusConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationMemberStatusesArgs, "orderBy">
  >;
  membersCanForkPrivateRepositories?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  membersWithRole?: Resolver<
    ResolversTypes["OrganizationMemberConnection"],
    ParentType,
    ContextType,
    Partial<OrganizationMembersWithRoleArgs>
  >;
  monthlyEstimatedSponsorsIncomeInCents?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  newTeamResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  newTeamUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  notificationDeliveryRestrictionEnabledSetting?: Resolver<
    ResolversTypes["NotificationRestrictionSettingValue"],
    ParentType,
    ContextType
  >;
  organizationBillingEmail?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  packages?: Resolver<
    ResolversTypes["PackageConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationPackagesArgs, "orderBy">
  >;
  pendingMembers?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<OrganizationPendingMembersArgs>
  >;
  pinnableItems?: Resolver<
    ResolversTypes["PinnableItemConnection"],
    ParentType,
    ContextType,
    Partial<OrganizationPinnableItemsArgs>
  >;
  pinnedItems?: Resolver<
    ResolversTypes["PinnableItemConnection"],
    ParentType,
    ContextType,
    Partial<OrganizationPinnedItemsArgs>
  >;
  pinnedItemsRemaining?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  project?: Resolver<
    Maybe<ResolversTypes["Project"]>,
    ParentType,
    ContextType,
    RequireFields<OrganizationProjectArgs, "number">
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType,
    RequireFields<OrganizationProjectV2Args, "number">
  >;
  projects?: Resolver<
    ResolversTypes["ProjectConnection"],
    ParentType,
    ContextType,
    Partial<OrganizationProjectsArgs>
  >;
  projectsResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  projectsUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  projectsV2?: Resolver<
    ResolversTypes["ProjectV2Connection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationProjectsV2Args, "minPermissionLevel" | "orderBy">
  >;
  recentProjects?: Resolver<
    ResolversTypes["ProjectV2Connection"],
    ParentType,
    ContextType,
    Partial<OrganizationRecentProjectsArgs>
  >;
  repositories?: Resolver<
    ResolversTypes["RepositoryConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationRepositoriesArgs, "ownerAffiliations">
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType,
    RequireFields<OrganizationRepositoryArgs, "followRenames" | "name">
  >;
  repositoryDiscussionComments?: Resolver<
    ResolversTypes["DiscussionCommentConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationRepositoryDiscussionCommentsArgs, "onlyAnswers">
  >;
  repositoryDiscussions?: Resolver<
    ResolversTypes["DiscussionConnection"],
    ParentType,
    ContextType,
    RequireFields<
      OrganizationRepositoryDiscussionsArgs,
      "answered" | "orderBy" | "states"
    >
  >;
  repositoryMigrations?: Resolver<
    ResolversTypes["RepositoryMigrationConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationRepositoryMigrationsArgs, "orderBy">
  >;
  requiresTwoFactorAuthentication?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  ruleset?: Resolver<
    Maybe<ResolversTypes["RepositoryRuleset"]>,
    ParentType,
    ContextType,
    RequireFields<OrganizationRulesetArgs, "databaseId">
  >;
  rulesets?: Resolver<
    Maybe<ResolversTypes["RepositoryRulesetConnection"]>,
    ParentType,
    ContextType,
    RequireFields<OrganizationRulesetsArgs, "includeParents">
  >;
  samlIdentityProvider?: Resolver<
    Maybe<ResolversTypes["OrganizationIdentityProvider"]>,
    ParentType,
    ContextType
  >;
  sponsoring?: Resolver<
    ResolversTypes["SponsorConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationSponsoringArgs, "orderBy">
  >;
  sponsors?: Resolver<
    ResolversTypes["SponsorConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationSponsorsArgs, "orderBy">
  >;
  sponsorsActivities?: Resolver<
    ResolversTypes["SponsorsActivityConnection"],
    ParentType,
    ContextType,
    RequireFields<
      OrganizationSponsorsActivitiesArgs,
      "actions" | "includeAsSponsor" | "includePrivate" | "orderBy" | "period"
    >
  >;
  sponsorsListing?: Resolver<
    Maybe<ResolversTypes["SponsorsListing"]>,
    ParentType,
    ContextType
  >;
  sponsorshipForViewerAsSponsor?: Resolver<
    Maybe<ResolversTypes["Sponsorship"]>,
    ParentType,
    ContextType,
    RequireFields<OrganizationSponsorshipForViewerAsSponsorArgs, "activeOnly">
  >;
  sponsorshipForViewerAsSponsorable?: Resolver<
    Maybe<ResolversTypes["Sponsorship"]>,
    ParentType,
    ContextType,
    RequireFields<
      OrganizationSponsorshipForViewerAsSponsorableArgs,
      "activeOnly"
    >
  >;
  sponsorshipNewsletters?: Resolver<
    ResolversTypes["SponsorshipNewsletterConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationSponsorshipNewslettersArgs, "orderBy">
  >;
  sponsorshipsAsMaintainer?: Resolver<
    ResolversTypes["SponsorshipConnection"],
    ParentType,
    ContextType,
    RequireFields<
      OrganizationSponsorshipsAsMaintainerArgs,
      "activeOnly" | "includePrivate"
    >
  >;
  sponsorshipsAsSponsor?: Resolver<
    ResolversTypes["SponsorshipConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationSponsorshipsAsSponsorArgs, "activeOnly">
  >;
  team?: Resolver<
    Maybe<ResolversTypes["Team"]>,
    ParentType,
    ContextType,
    RequireFields<OrganizationTeamArgs, "slug">
  >;
  teams?: Resolver<
    ResolversTypes["TeamConnection"],
    ParentType,
    ContextType,
    RequireFields<OrganizationTeamsArgs, "rootTeamsOnly">
  >;
  teamsResourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  teamsUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  totalSponsorshipAmountAsSponsorInCents?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType,
    RequireFields<
      OrganizationTotalSponsorshipAmountAsSponsorInCentsArgs,
      "sponsorableLogins"
    >
  >;
  twitterUsername?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanChangePinnedItems?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanCreateProjects?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanCreateRepositories?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanCreateTeams?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanSponsor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerIsAMember?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerIsFollowing?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerIsSponsoring?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  webCommitSignoffRequired?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  websiteUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationAuditEntry"] = ResolversParentTypes["OrganizationAuditEntry"],
> = {
  __resolveType: TypeResolveFn<
    | "MembersCanDeleteReposClearAuditEntry"
    | "MembersCanDeleteReposDisableAuditEntry"
    | "MembersCanDeleteReposEnableAuditEntry"
    | "OauthApplicationCreateAuditEntry"
    | "OrgAddBillingManagerAuditEntry"
    | "OrgAddMemberAuditEntry"
    | "OrgBlockUserAuditEntry"
    | "OrgConfigDisableCollaboratorsOnlyAuditEntry"
    | "OrgConfigEnableCollaboratorsOnlyAuditEntry"
    | "OrgCreateAuditEntry"
    | "OrgDisableOauthAppRestrictionsAuditEntry"
    | "OrgDisableSamlAuditEntry"
    | "OrgDisableTwoFactorRequirementAuditEntry"
    | "OrgEnableOauthAppRestrictionsAuditEntry"
    | "OrgEnableSamlAuditEntry"
    | "OrgEnableTwoFactorRequirementAuditEntry"
    | "OrgInviteMemberAuditEntry"
    | "OrgInviteToBusinessAuditEntry"
    | "OrgOauthAppAccessApprovedAuditEntry"
    | "OrgOauthAppAccessBlockedAuditEntry"
    | "OrgOauthAppAccessDeniedAuditEntry"
    | "OrgOauthAppAccessRequestedAuditEntry"
    | "OrgOauthAppAccessUnblockedAuditEntry"
    | "OrgRemoveBillingManagerAuditEntry"
    | "OrgRemoveMemberAuditEntry"
    | "OrgRemoveOutsideCollaboratorAuditEntry"
    | "OrgRestoreMemberAuditEntry"
    | "OrgUnblockUserAuditEntry"
    | "OrgUpdateDefaultRepositoryPermissionAuditEntry"
    | "OrgUpdateMemberAuditEntry"
    | "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
    | "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
    | "PrivateRepositoryForkingDisableAuditEntry"
    | "PrivateRepositoryForkingEnableAuditEntry"
    | "RepoAccessAuditEntry"
    | "RepoAddMemberAuditEntry"
    | "RepoAddTopicAuditEntry"
    | "RepoArchivedAuditEntry"
    | "RepoChangeMergeSettingAuditEntry"
    | "RepoConfigDisableAnonymousGitAccessAuditEntry"
    | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
    | "RepoConfigDisableContributorsOnlyAuditEntry"
    | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
    | "RepoConfigEnableAnonymousGitAccessAuditEntry"
    | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
    | "RepoConfigEnableContributorsOnlyAuditEntry"
    | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
    | "RepoConfigLockAnonymousGitAccessAuditEntry"
    | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
    | "RepoCreateAuditEntry"
    | "RepoDestroyAuditEntry"
    | "RepoRemoveMemberAuditEntry"
    | "RepoRemoveTopicAuditEntry"
    | "RepositoryVisibilityChangeDisableAuditEntry"
    | "RepositoryVisibilityChangeEnableAuditEntry"
    | "TeamAddMemberAuditEntry"
    | "TeamAddRepositoryAuditEntry"
    | "TeamChangeParentTeamAuditEntry"
    | "TeamRemoveMemberAuditEntry"
    | "TeamRemoveRepositoryAuditEntry",
    ParentType,
    ContextType
  >;
};

export type OrganizationAuditEntryConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationAuditEntryConnection"] = ResolversParentTypes["OrganizationAuditEntryConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["OrganizationAuditEntryEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["OrganizationAuditEntry"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationAuditEntryDataResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationAuditEntryData"] = ResolversParentTypes["OrganizationAuditEntryData"],
> = {
  __resolveType: TypeResolveFn<
    | "MembersCanDeleteReposClearAuditEntry"
    | "MembersCanDeleteReposDisableAuditEntry"
    | "MembersCanDeleteReposEnableAuditEntry"
    | "OauthApplicationCreateAuditEntry"
    | "OrgAddBillingManagerAuditEntry"
    | "OrgAddMemberAuditEntry"
    | "OrgBlockUserAuditEntry"
    | "OrgConfigDisableCollaboratorsOnlyAuditEntry"
    | "OrgConfigEnableCollaboratorsOnlyAuditEntry"
    | "OrgCreateAuditEntry"
    | "OrgDisableOauthAppRestrictionsAuditEntry"
    | "OrgDisableSamlAuditEntry"
    | "OrgDisableTwoFactorRequirementAuditEntry"
    | "OrgEnableOauthAppRestrictionsAuditEntry"
    | "OrgEnableSamlAuditEntry"
    | "OrgEnableTwoFactorRequirementAuditEntry"
    | "OrgInviteMemberAuditEntry"
    | "OrgInviteToBusinessAuditEntry"
    | "OrgOauthAppAccessApprovedAuditEntry"
    | "OrgOauthAppAccessBlockedAuditEntry"
    | "OrgOauthAppAccessDeniedAuditEntry"
    | "OrgOauthAppAccessRequestedAuditEntry"
    | "OrgOauthAppAccessUnblockedAuditEntry"
    | "OrgRemoveBillingManagerAuditEntry"
    | "OrgRemoveMemberAuditEntry"
    | "OrgRemoveOutsideCollaboratorAuditEntry"
    | "OrgRestoreMemberAuditEntry"
    | "OrgRestoreMemberMembershipOrganizationAuditEntryData"
    | "OrgUnblockUserAuditEntry"
    | "OrgUpdateDefaultRepositoryPermissionAuditEntry"
    | "OrgUpdateMemberAuditEntry"
    | "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
    | "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
    | "PrivateRepositoryForkingDisableAuditEntry"
    | "PrivateRepositoryForkingEnableAuditEntry"
    | "RepoAccessAuditEntry"
    | "RepoAddMemberAuditEntry"
    | "RepoAddTopicAuditEntry"
    | "RepoArchivedAuditEntry"
    | "RepoChangeMergeSettingAuditEntry"
    | "RepoConfigDisableAnonymousGitAccessAuditEntry"
    | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
    | "RepoConfigDisableContributorsOnlyAuditEntry"
    | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
    | "RepoConfigEnableAnonymousGitAccessAuditEntry"
    | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
    | "RepoConfigEnableContributorsOnlyAuditEntry"
    | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
    | "RepoConfigLockAnonymousGitAccessAuditEntry"
    | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
    | "RepoCreateAuditEntry"
    | "RepoDestroyAuditEntry"
    | "RepoRemoveMemberAuditEntry"
    | "RepoRemoveTopicAuditEntry"
    | "RepositoryVisibilityChangeDisableAuditEntry"
    | "RepositoryVisibilityChangeEnableAuditEntry"
    | "TeamAddMemberAuditEntry"
    | "TeamAddRepositoryAuditEntry"
    | "TeamChangeParentTeamAuditEntry"
    | "TeamRemoveMemberAuditEntry"
    | "TeamRemoveRepositoryAuditEntry",
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
};

export type OrganizationAuditEntryEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationAuditEntryEdge"] = ResolversParentTypes["OrganizationAuditEntryEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["OrganizationAuditEntry"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationConnection"] = ResolversParentTypes["OrganizationConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["OrganizationEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Organization"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationEdge"] = ResolversParentTypes["OrganizationEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationEnterpriseOwnerConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationEnterpriseOwnerConnection"] = ResolversParentTypes["OrganizationEnterpriseOwnerConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["OrganizationEnterpriseOwnerEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["User"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationEnterpriseOwnerEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationEnterpriseOwnerEdge"] = ResolversParentTypes["OrganizationEnterpriseOwnerEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  organizationRole?: Resolver<
    ResolversTypes["RoleInOrganization"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationIdentityProviderResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationIdentityProvider"] = ResolversParentTypes["OrganizationIdentityProvider"],
> = {
  digestMethod?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  externalIdentities?: Resolver<
    ResolversTypes["ExternalIdentityConnection"],
    ParentType,
    ContextType,
    Partial<OrganizationIdentityProviderExternalIdentitiesArgs>
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  idpCertificate?: Resolver<
    Maybe<ResolversTypes["X509Certificate"]>,
    ParentType,
    ContextType
  >;
  issuer?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  signatureMethod?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  ssoUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationInvitationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationInvitation"] = ResolversParentTypes["OrganizationInvitation"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  invitationSource?: Resolver<
    ResolversTypes["OrganizationInvitationSource"],
    ParentType,
    ContextType
  >;
  invitationType?: Resolver<
    ResolversTypes["OrganizationInvitationType"],
    ParentType,
    ContextType
  >;
  invitee?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  inviter?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  inviterActor?: Resolver<
    Maybe<ResolversTypes["User"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    ResolversTypes["Organization"],
    ParentType,
    ContextType
  >;
  role?: Resolver<
    ResolversTypes["OrganizationInvitationRole"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationInvitationConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationInvitationConnection"] = ResolversParentTypes["OrganizationInvitationConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["OrganizationInvitationEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["OrganizationInvitation"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationInvitationEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationInvitationEdge"] = ResolversParentTypes["OrganizationInvitationEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["OrganizationInvitation"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationMemberConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationMemberConnection"] = ResolversParentTypes["OrganizationMemberConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["OrganizationMemberEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["User"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationMemberEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationMemberEdge"] = ResolversParentTypes["OrganizationMemberEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  hasTwoFactorEnabled?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  node?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  role?: Resolver<
    Maybe<ResolversTypes["OrganizationMemberRole"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationMigrationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationMigration"] = ResolversParentTypes["OrganizationMigration"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  failureReason?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  remainingRepositoriesCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  sourceOrgName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  sourceOrgUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  state?: Resolver<
    ResolversTypes["OrganizationMigrationState"],
    ParentType,
    ContextType
  >;
  targetOrgName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  totalRepositoriesCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationOrUserResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationOrUser"] = ResolversParentTypes["OrganizationOrUser"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "User",
    ParentType,
    ContextType
  >;
};

export type OrganizationTeamsHovercardContextResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationTeamsHovercardContext"] = ResolversParentTypes["OrganizationTeamsHovercardContext"],
> = {
  message?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  relevantTeams?: Resolver<
    ResolversTypes["TeamConnection"],
    ParentType,
    ContextType,
    Partial<OrganizationTeamsHovercardContextRelevantTeamsArgs>
  >;
  teamsResourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  teamsUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  totalTeamCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationsHovercardContextResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["OrganizationsHovercardContext"] = ResolversParentTypes["OrganizationsHovercardContext"],
> = {
  message?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  relevantOrganizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<
      OrganizationsHovercardContextRelevantOrganizationsArgs,
      "orderBy"
    >
  >;
  totalOrganizationCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PackageResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Package"] = ResolversParentTypes["Package"],
> = {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  latestVersion?: Resolver<
    Maybe<ResolversTypes["PackageVersion"]>,
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  packageType?: Resolver<
    ResolversTypes["PackageType"],
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  statistics?: Resolver<
    Maybe<ResolversTypes["PackageStatistics"]>,
    ParentType,
    ContextType
  >;
  version?: Resolver<
    Maybe<ResolversTypes["PackageVersion"]>,
    ParentType,
    ContextType,
    RequireFields<PackageVersionArgs, "version">
  >;
  versions?: Resolver<
    ResolversTypes["PackageVersionConnection"],
    ParentType,
    ContextType,
    RequireFields<PackageVersionsArgs, "orderBy">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PackageConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PackageConnection"] = ResolversParentTypes["PackageConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PackageEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Package"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PackageEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PackageEdge"] = ResolversParentTypes["PackageEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Package"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PackageFileResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PackageFile"] = ResolversParentTypes["PackageFile"],
> = {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  md5?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  packageVersion?: Resolver<
    Maybe<ResolversTypes["PackageVersion"]>,
    ParentType,
    ContextType
  >;
  sha1?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  sha256?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PackageFileConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PackageFileConnection"] = ResolversParentTypes["PackageFileConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PackageFileEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PackageFile"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PackageFileEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PackageFileEdge"] = ResolversParentTypes["PackageFileEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PackageFile"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PackageOwnerResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PackageOwner"] = ResolversParentTypes["PackageOwner"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "Repository" | "User",
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  packages?: Resolver<
    ResolversTypes["PackageConnection"],
    ParentType,
    ContextType,
    RequireFields<PackageOwnerPackagesArgs, "orderBy">
  >;
};

export type PackageStatisticsResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PackageStatistics"] = ResolversParentTypes["PackageStatistics"],
> = {
  downloadsTotalCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PackageTagResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PackageTag"] = ResolversParentTypes["PackageTag"],
> = {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  version?: Resolver<
    Maybe<ResolversTypes["PackageVersion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PackageVersionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PackageVersion"] = ResolversParentTypes["PackageVersion"],
> = {
  files?: Resolver<
    ResolversTypes["PackageFileConnection"],
    ParentType,
    ContextType,
    RequireFields<PackageVersionFilesArgs, "orderBy">
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  package?: Resolver<Maybe<ResolversTypes["Package"]>, ParentType, ContextType>;
  platform?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  preRelease?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  readme?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  release?: Resolver<Maybe<ResolversTypes["Release"]>, ParentType, ContextType>;
  statistics?: Resolver<
    Maybe<ResolversTypes["PackageVersionStatistics"]>,
    ParentType,
    ContextType
  >;
  summary?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PackageVersionConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PackageVersionConnection"] = ResolversParentTypes["PackageVersionConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PackageVersionEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PackageVersion"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PackageVersionEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PackageVersionEdge"] = ResolversParentTypes["PackageVersionEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PackageVersion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PackageVersionStatisticsResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PackageVersionStatistics"] = ResolversParentTypes["PackageVersionStatistics"],
> = {
  downloadsTotalCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageInfoResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PageInfo"] = ResolversParentTypes["PageInfo"],
> = {
  endCursor?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  hasNextPage?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  hasPreviousPage?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  startCursor?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionGranterResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PermissionGranter"] = ResolversParentTypes["PermissionGranter"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "Repository" | "Team",
    ParentType,
    ContextType
  >;
};

export type PermissionSourceResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PermissionSource"] = ResolversParentTypes["PermissionSource"],
> = {
  organization?: Resolver<
    ResolversTypes["Organization"],
    ParentType,
    ContextType
  >;
  permission?: Resolver<
    ResolversTypes["DefaultRepositoryPermissionField"],
    ParentType,
    ContextType
  >;
  roleName?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  source?: Resolver<
    ResolversTypes["PermissionGranter"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinEnvironmentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinEnvironmentPayload"] = ResolversParentTypes["PinEnvironmentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  environment?: Resolver<
    Maybe<ResolversTypes["Environment"]>,
    ParentType,
    ContextType
  >;
  pinnedEnvironment?: Resolver<
    Maybe<ResolversTypes["PinnedEnvironment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinIssuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinIssuePayload"] = ResolversParentTypes["PinIssuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  issue?: Resolver<Maybe<ResolversTypes["Issue"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinnableItemResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnableItem"] = ResolversParentTypes["PinnableItem"],
> = {
  __resolveType: TypeResolveFn<"Gist" | "Repository", ParentType, ContextType>;
};

export type PinnableItemConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnableItemConnection"] = ResolversParentTypes["PinnableItemConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PinnableItemEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PinnableItem"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinnableItemEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnableItemEdge"] = ResolversParentTypes["PinnableItemEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PinnableItem"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinnedDiscussionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnedDiscussion"] = ResolversParentTypes["PinnedDiscussion"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  discussion?: Resolver<ResolversTypes["Discussion"], ParentType, ContextType>;
  gradientStopColors?: Resolver<
    Array<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pattern?: Resolver<
    ResolversTypes["PinnedDiscussionPattern"],
    ParentType,
    ContextType
  >;
  pinnedBy?: Resolver<ResolversTypes["Actor"], ParentType, ContextType>;
  preconfiguredGradient?: Resolver<
    Maybe<ResolversTypes["PinnedDiscussionGradient"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinnedDiscussionConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnedDiscussionConnection"] = ResolversParentTypes["PinnedDiscussionConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PinnedDiscussionEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PinnedDiscussion"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinnedDiscussionEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnedDiscussionEdge"] = ResolversParentTypes["PinnedDiscussionEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PinnedDiscussion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinnedEnvironmentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnedEnvironment"] = ResolversParentTypes["PinnedEnvironment"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  environment?: Resolver<
    ResolversTypes["Environment"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  position?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinnedEnvironmentConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnedEnvironmentConnection"] = ResolversParentTypes["PinnedEnvironmentConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PinnedEnvironmentEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PinnedEnvironment"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinnedEnvironmentEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnedEnvironmentEdge"] = ResolversParentTypes["PinnedEnvironmentEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PinnedEnvironment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinnedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnedEvent"] = ResolversParentTypes["PinnedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes["Issue"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinnedIssueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnedIssue"] = ResolversParentTypes["PinnedIssue"],
> = {
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  fullDatabaseId?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes["Issue"], ParentType, ContextType>;
  pinnedBy?: Resolver<ResolversTypes["Actor"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinnedIssueConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnedIssueConnection"] = ResolversParentTypes["PinnedIssueConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PinnedIssueEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PinnedIssue"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PinnedIssueEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PinnedIssueEdge"] = ResolversParentTypes["PinnedIssueEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PinnedIssue"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface PreciseDateTimeScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["PreciseDateTime"], any> {
  name: "PreciseDateTime";
}

export type PrivateRepositoryForkingDisableAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PrivateRepositoryForkingDisableAuditEntry"] = ResolversParentTypes["PrivateRepositoryForkingDisableAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  enterpriseResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  enterpriseSlug?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterpriseUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PrivateRepositoryForkingEnableAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PrivateRepositoryForkingEnableAuditEntry"] = ResolversParentTypes["PrivateRepositoryForkingEnableAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  enterpriseResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  enterpriseSlug?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterpriseUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProfileItemShowcaseResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProfileItemShowcase"] = ResolversParentTypes["ProfileItemShowcase"],
> = {
  hasPinnedItems?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  items?: Resolver<
    ResolversTypes["PinnableItemConnection"],
    ParentType,
    ContextType,
    Partial<ProfileItemShowcaseItemsArgs>
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProfileOwnerResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProfileOwner"] = ResolversParentTypes["ProfileOwner"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "User",
    ParentType,
    ContextType
  >;
  anyPinnableItems?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    Partial<ProfileOwnerAnyPinnableItemsArgs>
  >;
  email?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  itemShowcase?: Resolver<
    ResolversTypes["ProfileItemShowcase"],
    ParentType,
    ContextType
  >;
  location?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  login?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  pinnableItems?: Resolver<
    ResolversTypes["PinnableItemConnection"],
    ParentType,
    ContextType,
    Partial<ProfileOwnerPinnableItemsArgs>
  >;
  pinnedItems?: Resolver<
    ResolversTypes["PinnableItemConnection"],
    ParentType,
    ContextType,
    Partial<ProfileOwnerPinnedItemsArgs>
  >;
  pinnedItemsRemaining?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  viewerCanChangePinnedItems?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  websiteUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
};

export type ProjectResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Project"] = ResolversParentTypes["Project"],
> = {
  body?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  closedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  columns?: Resolver<
    ResolversTypes["ProjectColumnConnection"],
    ParentType,
    ContextType,
    Partial<ProjectColumnsArgs>
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes["ProjectOwner"], ParentType, ContextType>;
  pendingCards?: Resolver<
    ResolversTypes["ProjectCardConnection"],
    ParentType,
    ContextType,
    RequireFields<ProjectPendingCardsArgs, "archivedStates">
  >;
  progress?: Resolver<
    ResolversTypes["ProjectProgress"],
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  state?: Resolver<ResolversTypes["ProjectState"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  viewerCanClose?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanReopen?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectCardResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectCard"] = ResolversParentTypes["ProjectCard"],
> = {
  column?: Resolver<
    Maybe<ResolversTypes["ProjectColumn"]>,
    ParentType,
    ContextType
  >;
  content?: Resolver<
    Maybe<ResolversTypes["ProjectCardItem"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  note?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  project?: Resolver<ResolversTypes["Project"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  state?: Resolver<
    Maybe<ResolversTypes["ProjectCardState"]>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectCardConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectCardConnection"] = ResolversParentTypes["ProjectCardConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectCardEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectCard"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectCardEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectCardEdge"] = ResolversParentTypes["ProjectCardEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ProjectCard"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectCardItemResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectCardItem"] = ResolversParentTypes["ProjectCardItem"],
> = {
  __resolveType: TypeResolveFn<
    "Issue" | "PullRequest",
    ParentType,
    ContextType
  >;
};

export type ProjectColumnResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectColumn"] = ResolversParentTypes["ProjectColumn"],
> = {
  cards?: Resolver<
    ResolversTypes["ProjectCardConnection"],
    ParentType,
    ContextType,
    RequireFields<ProjectColumnCardsArgs, "archivedStates">
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  project?: Resolver<ResolversTypes["Project"], ParentType, ContextType>;
  purpose?: Resolver<
    Maybe<ResolversTypes["ProjectColumnPurpose"]>,
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectColumnConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectColumnConnection"] = ResolversParentTypes["ProjectColumnConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectColumnEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectColumn"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectColumnEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectColumnEdge"] = ResolversParentTypes["ProjectColumnEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ProjectColumn"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectConnection"] = ResolversParentTypes["ProjectConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Project"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectEdge"] = ResolversParentTypes["ProjectEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectOwnerResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectOwner"] = ResolversParentTypes["ProjectOwner"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "Repository" | "User",
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  project?: Resolver<
    Maybe<ResolversTypes["Project"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectOwnerProjectArgs, "number">
  >;
  projects?: Resolver<
    ResolversTypes["ProjectConnection"],
    ParentType,
    ContextType,
    Partial<ProjectOwnerProjectsArgs>
  >;
  projectsResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  projectsUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
};

export type ProjectProgressResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectProgress"] = ResolversParentTypes["ProjectProgress"],
> = {
  doneCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  donePercentage?: Resolver<ResolversTypes["Float"], ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  inProgressCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  inProgressPercentage?: Resolver<
    ResolversTypes["Float"],
    ParentType,
    ContextType
  >;
  todoCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  todoPercentage?: Resolver<ResolversTypes["Float"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2Resolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2"] = ResolversParentTypes["ProjectV2"],
> = {
  closed?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  closedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  field?: Resolver<
    Maybe<ResolversTypes["ProjectV2FieldConfiguration"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectV2FieldArgs, "name">
  >;
  fields?: Resolver<
    ResolversTypes["ProjectV2FieldConfigurationConnection"],
    ParentType,
    ContextType,
    RequireFields<ProjectV2FieldsArgs, "orderBy">
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  items?: Resolver<
    ResolversTypes["ProjectV2ItemConnection"],
    ParentType,
    ContextType,
    RequireFields<ProjectV2ItemsArgs, "orderBy">
  >;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes["ProjectV2Owner"], ParentType, ContextType>;
  public?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  readme?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  repositories?: Resolver<
    ResolversTypes["RepositoryConnection"],
    ParentType,
    ContextType,
    RequireFields<ProjectV2RepositoriesArgs, "orderBy">
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  shortDescription?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  statusUpdates?: Resolver<
    ResolversTypes["ProjectV2StatusUpdateConnection"],
    ParentType,
    ContextType,
    RequireFields<ProjectV2StatusUpdatesArgs, "orderBy">
  >;
  teams?: Resolver<
    ResolversTypes["TeamConnection"],
    ParentType,
    ContextType,
    RequireFields<ProjectV2TeamsArgs, "orderBy">
  >;
  template?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  view?: Resolver<
    Maybe<ResolversTypes["ProjectV2View"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectV2ViewArgs, "number">
  >;
  viewerCanClose?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanReopen?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  views?: Resolver<
    ResolversTypes["ProjectV2ViewConnection"],
    ParentType,
    ContextType,
    RequireFields<ProjectV2ViewsArgs, "orderBy">
  >;
  workflow?: Resolver<
    Maybe<ResolversTypes["ProjectV2Workflow"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectV2WorkflowArgs, "number">
  >;
  workflows?: Resolver<
    ResolversTypes["ProjectV2WorkflowConnection"],
    ParentType,
    ContextType,
    RequireFields<ProjectV2WorkflowsArgs, "orderBy">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ActorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2Actor"] = ResolversParentTypes["ProjectV2Actor"],
> = {
  __resolveType: TypeResolveFn<"Team" | "User", ParentType, ContextType>;
};

export type ProjectV2ActorConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ActorConnection"] = ResolversParentTypes["ProjectV2ActorConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2ActorEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2Actor"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ActorEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ActorEdge"] = ResolversParentTypes["ProjectV2ActorEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ProjectV2Actor"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2Connection"] = ResolversParentTypes["ProjectV2Connection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2Edge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2EdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2Edge"] = ResolversParentTypes["ProjectV2Edge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["ProjectV2"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2FieldResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2Field"] = ResolversParentTypes["ProjectV2Field"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  dataType?: Resolver<
    ResolversTypes["ProjectV2FieldType"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  project?: Resolver<ResolversTypes["ProjectV2"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2FieldCommonResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2FieldCommon"] = ResolversParentTypes["ProjectV2FieldCommon"],
> = {
  __resolveType: TypeResolveFn<
    "ProjectV2Field" | "ProjectV2IterationField" | "ProjectV2SingleSelectField",
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  dataType?: Resolver<
    ResolversTypes["ProjectV2FieldType"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  project?: Resolver<ResolversTypes["ProjectV2"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
};

export type ProjectV2FieldConfigurationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2FieldConfiguration"] = ResolversParentTypes["ProjectV2FieldConfiguration"],
> = {
  __resolveType: TypeResolveFn<
    "ProjectV2Field" | "ProjectV2IterationField" | "ProjectV2SingleSelectField",
    ParentType,
    ContextType
  >;
};

export type ProjectV2FieldConfigurationConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2FieldConfigurationConnection"] = ResolversParentTypes["ProjectV2FieldConfigurationConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2FieldConfigurationEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2FieldConfiguration"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2FieldConfigurationEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2FieldConfigurationEdge"] = ResolversParentTypes["ProjectV2FieldConfigurationEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ProjectV2FieldConfiguration"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2FieldConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2FieldConnection"] = ResolversParentTypes["ProjectV2FieldConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2FieldEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2Field"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2FieldEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2FieldEdge"] = ResolversParentTypes["ProjectV2FieldEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ProjectV2Field"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2Item"] = ResolversParentTypes["ProjectV2Item"],
> = {
  content?: Resolver<
    Maybe<ResolversTypes["ProjectV2ItemContent"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  fieldValueByName?: Resolver<
    Maybe<ResolversTypes["ProjectV2ItemFieldValue"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectV2ItemFieldValueByNameArgs, "name">
  >;
  fieldValues?: Resolver<
    ResolversTypes["ProjectV2ItemFieldValueConnection"],
    ParentType,
    ContextType,
    RequireFields<ProjectV2ItemFieldValuesArgs, "orderBy">
  >;
  fullDatabaseId?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  project?: Resolver<ResolversTypes["ProjectV2"], ParentType, ContextType>;
  type?: Resolver<ResolversTypes["ProjectV2ItemType"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemConnection"] = ResolversParentTypes["ProjectV2ItemConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2ItemEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2Item"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemContentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemContent"] = ResolversParentTypes["ProjectV2ItemContent"],
> = {
  __resolveType: TypeResolveFn<
    "DraftIssue" | "Issue" | "PullRequest",
    ParentType,
    ContextType
  >;
};

export type ProjectV2ItemEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemEdge"] = ResolversParentTypes["ProjectV2ItemEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ProjectV2Item"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldDateValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldDateValue"] = ResolversParentTypes["ProjectV2ItemFieldDateValue"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes["Date"]>, ParentType, ContextType>;
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  item?: Resolver<ResolversTypes["ProjectV2Item"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldIterationValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldIterationValue"] = ResolversParentTypes["ProjectV2ItemFieldIterationValue"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  duration?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  item?: Resolver<ResolversTypes["ProjectV2Item"], ParentType, ContextType>;
  iterationId?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  startDate?: Resolver<ResolversTypes["Date"], ParentType, ContextType>;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldLabelValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldLabelValue"] = ResolversParentTypes["ProjectV2ItemFieldLabelValue"],
> = {
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  labels?: Resolver<
    Maybe<ResolversTypes["LabelConnection"]>,
    ParentType,
    ContextType,
    Partial<ProjectV2ItemFieldLabelValueLabelsArgs>
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldMilestoneValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldMilestoneValue"] = ResolversParentTypes["ProjectV2ItemFieldMilestoneValue"],
> = {
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  milestone?: Resolver<
    Maybe<ResolversTypes["Milestone"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldNumberValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldNumberValue"] = ResolversParentTypes["ProjectV2ItemFieldNumberValue"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  item?: Resolver<ResolversTypes["ProjectV2Item"], ParentType, ContextType>;
  number?: Resolver<Maybe<ResolversTypes["Float"]>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldPullRequestValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldPullRequestValue"] = ResolversParentTypes["ProjectV2ItemFieldPullRequestValue"],
> = {
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  pullRequests?: Resolver<
    Maybe<ResolversTypes["PullRequestConnection"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectV2ItemFieldPullRequestValuePullRequestsArgs, "orderBy">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldRepositoryValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldRepositoryValue"] = ResolversParentTypes["ProjectV2ItemFieldRepositoryValue"],
> = {
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldReviewerValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldReviewerValue"] = ResolversParentTypes["ProjectV2ItemFieldReviewerValue"],
> = {
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  reviewers?: Resolver<
    Maybe<ResolversTypes["RequestedReviewerConnection"]>,
    ParentType,
    ContextType,
    Partial<ProjectV2ItemFieldReviewerValueReviewersArgs>
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldSingleSelectValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldSingleSelectValue"] = ResolversParentTypes["ProjectV2ItemFieldSingleSelectValue"],
> = {
  color?: Resolver<
    ResolversTypes["ProjectV2SingleSelectFieldOptionColor"],
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  descriptionHTML?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  item?: Resolver<ResolversTypes["ProjectV2Item"], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  nameHTML?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  optionId?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldTextValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldTextValue"] = ResolversParentTypes["ProjectV2ItemFieldTextValue"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  item?: Resolver<ResolversTypes["ProjectV2Item"], ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldUserValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldUserValue"] = ResolversParentTypes["ProjectV2ItemFieldUserValue"],
> = {
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  users?: Resolver<
    Maybe<ResolversTypes["UserConnection"]>,
    ParentType,
    ContextType,
    Partial<ProjectV2ItemFieldUserValueUsersArgs>
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldValue"] = ResolversParentTypes["ProjectV2ItemFieldValue"],
> = {
  __resolveType: TypeResolveFn<
    | "ProjectV2ItemFieldDateValue"
    | "ProjectV2ItemFieldIterationValue"
    | "ProjectV2ItemFieldLabelValue"
    | "ProjectV2ItemFieldMilestoneValue"
    | "ProjectV2ItemFieldNumberValue"
    | "ProjectV2ItemFieldPullRequestValue"
    | "ProjectV2ItemFieldRepositoryValue"
    | "ProjectV2ItemFieldReviewerValue"
    | "ProjectV2ItemFieldSingleSelectValue"
    | "ProjectV2ItemFieldTextValue"
    | "ProjectV2ItemFieldUserValue",
    ParentType,
    ContextType
  >;
};

export type ProjectV2ItemFieldValueCommonResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldValueCommon"] = ResolversParentTypes["ProjectV2ItemFieldValueCommon"],
> = {
  __resolveType: TypeResolveFn<
    | "ProjectV2ItemFieldDateValue"
    | "ProjectV2ItemFieldIterationValue"
    | "ProjectV2ItemFieldNumberValue"
    | "ProjectV2ItemFieldSingleSelectValue"
    | "ProjectV2ItemFieldTextValue",
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  item?: Resolver<ResolversTypes["ProjectV2Item"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
};

export type ProjectV2ItemFieldValueConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldValueConnection"] = ResolversParentTypes["ProjectV2ItemFieldValueConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2ItemFieldValueEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2ItemFieldValue"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ItemFieldValueEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ItemFieldValueEdge"] = ResolversParentTypes["ProjectV2ItemFieldValueEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ProjectV2ItemFieldValue"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2IterationFieldResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2IterationField"] = ResolversParentTypes["ProjectV2IterationField"],
> = {
  configuration?: Resolver<
    ResolversTypes["ProjectV2IterationFieldConfiguration"],
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  dataType?: Resolver<
    ResolversTypes["ProjectV2FieldType"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  project?: Resolver<ResolversTypes["ProjectV2"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2IterationFieldConfigurationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2IterationFieldConfiguration"] = ResolversParentTypes["ProjectV2IterationFieldConfiguration"],
> = {
  completedIterations?: Resolver<
    Array<ResolversTypes["ProjectV2IterationFieldIteration"]>,
    ParentType,
    ContextType
  >;
  duration?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  iterations?: Resolver<
    Array<ResolversTypes["ProjectV2IterationFieldIteration"]>,
    ParentType,
    ContextType
  >;
  startDay?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2IterationFieldIterationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2IterationFieldIteration"] = ResolversParentTypes["ProjectV2IterationFieldIteration"],
> = {
  duration?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  startDate?: Resolver<ResolversTypes["Date"], ParentType, ContextType>;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2OwnerResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2Owner"] = ResolversParentTypes["ProjectV2Owner"],
> = {
  __resolveType: TypeResolveFn<
    "Issue" | "Organization" | "PullRequest" | "User",
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectV2OwnerProjectV2Args, "number">
  >;
  projectsV2?: Resolver<
    ResolversTypes["ProjectV2Connection"],
    ParentType,
    ContextType,
    RequireFields<
      ProjectV2OwnerProjectsV2Args,
      "minPermissionLevel" | "orderBy"
    >
  >;
};

export type ProjectV2RecentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2Recent"] = ResolversParentTypes["ProjectV2Recent"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "Repository" | "User",
    ParentType,
    ContextType
  >;
  recentProjects?: Resolver<
    ResolversTypes["ProjectV2Connection"],
    ParentType,
    ContextType,
    Partial<ProjectV2RecentRecentProjectsArgs>
  >;
};

export type ProjectV2SingleSelectFieldResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2SingleSelectField"] = ResolversParentTypes["ProjectV2SingleSelectField"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  dataType?: Resolver<
    ResolversTypes["ProjectV2FieldType"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  options?: Resolver<
    Array<ResolversTypes["ProjectV2SingleSelectFieldOption"]>,
    ParentType,
    ContextType,
    Partial<ProjectV2SingleSelectFieldOptionsArgs>
  >;
  project?: Resolver<ResolversTypes["ProjectV2"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2SingleSelectFieldOptionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2SingleSelectFieldOption"] = ResolversParentTypes["ProjectV2SingleSelectFieldOption"],
> = {
  color?: Resolver<
    ResolversTypes["ProjectV2SingleSelectFieldOptionColor"],
    ParentType,
    ContextType
  >;
  description?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  nameHTML?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2SortByResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2SortBy"] = ResolversParentTypes["ProjectV2SortBy"],
> = {
  direction?: Resolver<
    ResolversTypes["OrderDirection"],
    ParentType,
    ContextType
  >;
  field?: Resolver<ResolversTypes["ProjectV2Field"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2SortByConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2SortByConnection"] = ResolversParentTypes["ProjectV2SortByConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2SortByEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2SortBy"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2SortByEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2SortByEdge"] = ResolversParentTypes["ProjectV2SortByEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ProjectV2SortBy"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2SortByFieldResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2SortByField"] = ResolversParentTypes["ProjectV2SortByField"],
> = {
  direction?: Resolver<
    ResolversTypes["OrderDirection"],
    ParentType,
    ContextType
  >;
  field?: Resolver<
    ResolversTypes["ProjectV2FieldConfiguration"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2SortByFieldConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2SortByFieldConnection"] = ResolversParentTypes["ProjectV2SortByFieldConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2SortByFieldEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2SortByField"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2SortByFieldEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2SortByFieldEdge"] = ResolversParentTypes["ProjectV2SortByFieldEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ProjectV2SortByField"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2StatusUpdateResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2StatusUpdate"] = ResolversParentTypes["ProjectV2StatusUpdate"],
> = {
  body?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  bodyHTML?: Resolver<Maybe<ResolversTypes["HTML"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  project?: Resolver<ResolversTypes["ProjectV2"], ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes["Date"]>, ParentType, ContextType>;
  status?: Resolver<
    Maybe<ResolversTypes["ProjectV2StatusUpdateStatus"]>,
    ParentType,
    ContextType
  >;
  targetDate?: Resolver<Maybe<ResolversTypes["Date"]>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2StatusUpdateConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2StatusUpdateConnection"] = ResolversParentTypes["ProjectV2StatusUpdateConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2StatusUpdateEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2StatusUpdate"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2StatusUpdateEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2StatusUpdateEdge"] = ResolversParentTypes["ProjectV2StatusUpdateEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ProjectV2StatusUpdate"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ViewResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2View"] = ResolversParentTypes["ProjectV2View"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  fields?: Resolver<
    Maybe<ResolversTypes["ProjectV2FieldConfigurationConnection"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectV2ViewFieldsArgs, "orderBy">
  >;
  filter?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  groupBy?: Resolver<
    Maybe<ResolversTypes["ProjectV2FieldConnection"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectV2ViewGroupByArgs, "orderBy">
  >;
  groupByFields?: Resolver<
    Maybe<ResolversTypes["ProjectV2FieldConfigurationConnection"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectV2ViewGroupByFieldsArgs, "orderBy">
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  layout?: Resolver<
    ResolversTypes["ProjectV2ViewLayout"],
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  project?: Resolver<ResolversTypes["ProjectV2"], ParentType, ContextType>;
  sortBy?: Resolver<
    Maybe<ResolversTypes["ProjectV2SortByConnection"]>,
    ParentType,
    ContextType,
    Partial<ProjectV2ViewSortByArgs>
  >;
  sortByFields?: Resolver<
    Maybe<ResolversTypes["ProjectV2SortByFieldConnection"]>,
    ParentType,
    ContextType,
    Partial<ProjectV2ViewSortByFieldsArgs>
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  verticalGroupBy?: Resolver<
    Maybe<ResolversTypes["ProjectV2FieldConnection"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectV2ViewVerticalGroupByArgs, "orderBy">
  >;
  verticalGroupByFields?: Resolver<
    Maybe<ResolversTypes["ProjectV2FieldConfigurationConnection"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectV2ViewVerticalGroupByFieldsArgs, "orderBy">
  >;
  visibleFields?: Resolver<
    Maybe<ResolversTypes["ProjectV2FieldConnection"]>,
    ParentType,
    ContextType,
    RequireFields<ProjectV2ViewVisibleFieldsArgs, "orderBy">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ViewConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ViewConnection"] = ResolversParentTypes["ProjectV2ViewConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2ViewEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2View"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2ViewEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2ViewEdge"] = ResolversParentTypes["ProjectV2ViewEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ProjectV2View"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2WorkflowResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2Workflow"] = ResolversParentTypes["ProjectV2Workflow"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  project?: Resolver<ResolversTypes["ProjectV2"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2WorkflowConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2WorkflowConnection"] = ResolversParentTypes["ProjectV2WorkflowConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2WorkflowEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ProjectV2Workflow"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectV2WorkflowEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ProjectV2WorkflowEdge"] = ResolversParentTypes["ProjectV2WorkflowEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ProjectV2Workflow"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PropertyTargetDefinitionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PropertyTargetDefinition"] = ResolversParentTypes["PropertyTargetDefinition"],
> = {
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  propertyValues?: Resolver<
    Array<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  source?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PublicKeyResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PublicKey"] = ResolversParentTypes["PublicKey"],
> = {
  accessedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  fingerprint?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isReadOnly?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  key?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PublicKeyConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PublicKeyConnection"] = ResolversParentTypes["PublicKeyConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PublicKeyEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PublicKey"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PublicKeyEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PublicKeyEdge"] = ResolversParentTypes["PublicKeyEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["PublicKey"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PublishSponsorsTierPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PublishSponsorsTierPayload"] = ResolversParentTypes["PublishSponsorsTierPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  sponsorsTier?: Resolver<
    Maybe<ResolversTypes["SponsorsTier"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequest"] = ResolversParentTypes["PullRequest"],
> = {
  activeLockReason?: Resolver<
    Maybe<ResolversTypes["LockReason"]>,
    ParentType,
    ContextType
  >;
  additions?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  assignees?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestAssigneesArgs>
  >;
  author?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  authorAssociation?: Resolver<
    ResolversTypes["CommentAuthorAssociation"],
    ParentType,
    ContextType
  >;
  autoMergeRequest?: Resolver<
    Maybe<ResolversTypes["AutoMergeRequest"]>,
    ParentType,
    ContextType
  >;
  baseRef?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  baseRefName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  baseRefOid?: Resolver<ResolversTypes["GitObjectID"], ParentType, ContextType>;
  baseRepository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  canBeRebased?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  changedFiles?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  checksResourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  checksUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  closedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  closingIssuesReferences?: Resolver<
    Maybe<ResolversTypes["IssueConnection"]>,
    ParentType,
    ContextType,
    RequireFields<PullRequestClosingIssuesReferencesArgs, "userLinkedOnly">
  >;
  comments?: Resolver<
    ResolversTypes["IssueCommentConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestCommentsArgs>
  >;
  commits?: Resolver<
    ResolversTypes["PullRequestCommitConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestCommitsArgs>
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  createdViaEmail?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  deletions?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  files?: Resolver<
    Maybe<ResolversTypes["PullRequestChangedFileConnection"]>,
    ParentType,
    ContextType,
    Partial<PullRequestFilesArgs>
  >;
  fullDatabaseId?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  headRef?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  headRefName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  headRefOid?: Resolver<ResolversTypes["GitObjectID"], ParentType, ContextType>;
  headRepository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  headRepositoryOwner?: Resolver<
    Maybe<ResolversTypes["RepositoryOwner"]>,
    ParentType,
    ContextType
  >;
  hovercard?: Resolver<
    ResolversTypes["Hovercard"],
    ParentType,
    ContextType,
    RequireFields<PullRequestHovercardArgs, "includeNotificationContexts">
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isCrossRepository?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isDraft?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isInMergeQueue?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isMergeQueueEnabled?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isReadByViewer?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  labels?: Resolver<
    Maybe<ResolversTypes["LabelConnection"]>,
    ParentType,
    ContextType,
    RequireFields<PullRequestLabelsArgs, "orderBy">
  >;
  lastEditedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  latestOpinionatedReviews?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewConnection"]>,
    ParentType,
    ContextType,
    RequireFields<PullRequestLatestOpinionatedReviewsArgs, "writersOnly">
  >;
  latestReviews?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewConnection"]>,
    ParentType,
    ContextType,
    Partial<PullRequestLatestReviewsArgs>
  >;
  locked?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  maintainerCanModify?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  mergeCommit?: Resolver<
    Maybe<ResolversTypes["Commit"]>,
    ParentType,
    ContextType
  >;
  mergeQueue?: Resolver<
    Maybe<ResolversTypes["MergeQueue"]>,
    ParentType,
    ContextType
  >;
  mergeQueueEntry?: Resolver<
    Maybe<ResolversTypes["MergeQueueEntry"]>,
    ParentType,
    ContextType
  >;
  mergeStateStatus?: Resolver<
    ResolversTypes["MergeStateStatus"],
    ParentType,
    ContextType
  >;
  mergeable?: Resolver<
    ResolversTypes["MergeableState"],
    ParentType,
    ContextType
  >;
  merged?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  mergedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  mergedBy?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  milestone?: Resolver<
    Maybe<ResolversTypes["Milestone"]>,
    ParentType,
    ContextType
  >;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  participants?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestParticipantsArgs>
  >;
  permalink?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  potentialMergeCommit?: Resolver<
    Maybe<ResolversTypes["Commit"]>,
    ParentType,
    ContextType
  >;
  projectCards?: Resolver<
    ResolversTypes["ProjectCardConnection"],
    ParentType,
    ContextType,
    RequireFields<PullRequestProjectCardsArgs, "archivedStates">
  >;
  projectItems?: Resolver<
    ResolversTypes["ProjectV2ItemConnection"],
    ParentType,
    ContextType,
    RequireFields<PullRequestProjectItemsArgs, "includeArchived">
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType,
    RequireFields<PullRequestProjectV2Args, "number">
  >;
  projectsV2?: Resolver<
    ResolversTypes["ProjectV2Connection"],
    ParentType,
    ContextType,
    RequireFields<PullRequestProjectsV2Args, "minPermissionLevel" | "orderBy">
  >;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  reactions?: Resolver<
    ResolversTypes["ReactionConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestReactionsArgs>
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  revertResourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  revertUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  reviewDecision?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewDecision"]>,
    ParentType,
    ContextType
  >;
  reviewRequests?: Resolver<
    Maybe<ResolversTypes["ReviewRequestConnection"]>,
    ParentType,
    ContextType,
    Partial<PullRequestReviewRequestsArgs>
  >;
  reviewThreads?: Resolver<
    ResolversTypes["PullRequestReviewThreadConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestReviewThreadsArgs>
  >;
  reviews?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewConnection"]>,
    ParentType,
    ContextType,
    Partial<PullRequestReviewsArgs>
  >;
  state?: Resolver<ResolversTypes["PullRequestState"], ParentType, ContextType>;
  statusCheckRollup?: Resolver<
    Maybe<ResolversTypes["StatusCheckRollup"]>,
    ParentType,
    ContextType
  >;
  suggestedReviewers?: Resolver<
    Array<Maybe<ResolversTypes["SuggestedReviewer"]>>,
    ParentType,
    ContextType
  >;
  timeline?: Resolver<
    ResolversTypes["PullRequestTimelineConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestTimelineArgs>
  >;
  timelineItems?: Resolver<
    ResolversTypes["PullRequestTimelineItemsConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestTimelineItemsArgs>
  >;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  totalCommentsCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  userContentEdits?: Resolver<
    Maybe<ResolversTypes["UserContentEditConnection"]>,
    ParentType,
    ContextType,
    Partial<PullRequestUserContentEditsArgs>
  >;
  viewerCanApplySuggestion?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanClose?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanDeleteHeadRef?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanDisableAutoMerge?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanEditFiles?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanEnableAutoMerge?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanLabel?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanMergeAsAdmin?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanReact?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanReopen?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanSubscribe?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUpdateBranch?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCannotUpdateReasons?: Resolver<
    Array<ResolversTypes["CommentCannotUpdateReason"]>,
    ParentType,
    ContextType
  >;
  viewerDidAuthor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerLatestReview?: Resolver<
    Maybe<ResolversTypes["PullRequestReview"]>,
    ParentType,
    ContextType
  >;
  viewerLatestReviewRequest?: Resolver<
    Maybe<ResolversTypes["ReviewRequest"]>,
    ParentType,
    ContextType
  >;
  viewerMergeBodyText?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType,
    Partial<PullRequestViewerMergeBodyTextArgs>
  >;
  viewerMergeHeadlineText?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType,
    Partial<PullRequestViewerMergeHeadlineTextArgs>
  >;
  viewerSubscription?: Resolver<
    Maybe<ResolversTypes["SubscriptionState"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestChangedFileResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestChangedFile"] = ResolversParentTypes["PullRequestChangedFile"],
> = {
  additions?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  changeType?: Resolver<ResolversTypes["PatchStatus"], ParentType, ContextType>;
  deletions?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  path?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  viewerViewedState?: Resolver<
    ResolversTypes["FileViewedState"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestChangedFileConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestChangedFileConnection"] = ResolversParentTypes["PullRequestChangedFileConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestChangedFileEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestChangedFile"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestChangedFileEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestChangedFileEdge"] = ResolversParentTypes["PullRequestChangedFileEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PullRequestChangedFile"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestCommitResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestCommit"] = ResolversParentTypes["PullRequestCommit"],
> = {
  commit?: Resolver<ResolversTypes["Commit"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestCommitCommentThreadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestCommitCommentThread"] = ResolversParentTypes["PullRequestCommitCommentThread"],
> = {
  comments?: Resolver<
    ResolversTypes["CommitCommentConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestCommitCommentThreadCommentsArgs>
  >;
  commit?: Resolver<ResolversTypes["Commit"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestCommitConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestCommitConnection"] = ResolversParentTypes["PullRequestCommitConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestCommitEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestCommit"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestCommitEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestCommitEdge"] = ResolversParentTypes["PullRequestCommitEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PullRequestCommit"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestConnection"] = ResolversParentTypes["PullRequestConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequest"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestContributionsByRepositoryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestContributionsByRepository"] = ResolversParentTypes["PullRequestContributionsByRepository"],
> = {
  contributions?: Resolver<
    ResolversTypes["CreatedPullRequestContributionConnection"],
    ParentType,
    ContextType,
    RequireFields<
      PullRequestContributionsByRepositoryContributionsArgs,
      "orderBy"
    >
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestEdge"] = ResolversParentTypes["PullRequestEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestParameters"] = ResolversParentTypes["PullRequestParameters"],
> = {
  dismissStaleReviewsOnPush?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requireCodeOwnerReview?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requireLastPushApproval?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiredApprovingReviewCount?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  requiredReviewThreadResolution?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestReviewResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestReview"] = ResolversParentTypes["PullRequestReview"],
> = {
  author?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  authorAssociation?: Resolver<
    ResolversTypes["CommentAuthorAssociation"],
    ParentType,
    ContextType
  >;
  authorCanPushToRepository?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  comments?: Resolver<
    ResolversTypes["PullRequestReviewCommentConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestReviewCommentsArgs>
  >;
  commit?: Resolver<Maybe<ResolversTypes["Commit"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  createdViaEmail?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  fullDatabaseId?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isMinimized?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  lastEditedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  minimizedReason?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  onBehalfOf?: Resolver<
    ResolversTypes["TeamConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestReviewOnBehalfOfArgs>
  >;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  reactions?: Resolver<
    ResolversTypes["ReactionConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestReviewReactionsArgs>
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  state?: Resolver<
    ResolversTypes["PullRequestReviewState"],
    ParentType,
    ContextType
  >;
  submittedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  userContentEdits?: Resolver<
    Maybe<ResolversTypes["UserContentEditConnection"]>,
    ParentType,
    ContextType,
    Partial<PullRequestReviewUserContentEditsArgs>
  >;
  viewerCanDelete?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanMinimize?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanReact?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCannotUpdateReasons?: Resolver<
    Array<ResolversTypes["CommentCannotUpdateReason"]>,
    ParentType,
    ContextType
  >;
  viewerDidAuthor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestReviewCommentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestReviewComment"] = ResolversParentTypes["PullRequestReviewComment"],
> = {
  author?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  authorAssociation?: Resolver<
    ResolversTypes["CommentAuthorAssociation"],
    ParentType,
    ContextType
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes["Commit"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  createdViaEmail?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  diffHunk?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  draftedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  fullDatabaseId?: Resolver<
    Maybe<ResolversTypes["BigInt"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isMinimized?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  lastEditedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  line?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  minimizedReason?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  originalCommit?: Resolver<
    Maybe<ResolversTypes["Commit"]>,
    ParentType,
    ContextType
  >;
  originalLine?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  originalPosition?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  originalStartLine?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  outdated?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  path?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  pullRequestReview?: Resolver<
    Maybe<ResolversTypes["PullRequestReview"]>,
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  reactions?: Resolver<
    ResolversTypes["ReactionConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestReviewCommentReactionsArgs>
  >;
  replyTo?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewComment"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  startLine?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  state?: Resolver<
    ResolversTypes["PullRequestReviewCommentState"],
    ParentType,
    ContextType
  >;
  subjectType?: Resolver<
    ResolversTypes["PullRequestReviewThreadSubjectType"],
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  userContentEdits?: Resolver<
    Maybe<ResolversTypes["UserContentEditConnection"]>,
    ParentType,
    ContextType,
    Partial<PullRequestReviewCommentUserContentEditsArgs>
  >;
  viewerCanDelete?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanMinimize?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanReact?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCannotUpdateReasons?: Resolver<
    Array<ResolversTypes["CommentCannotUpdateReason"]>,
    ParentType,
    ContextType
  >;
  viewerDidAuthor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestReviewCommentConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestReviewCommentConnection"] = ResolversParentTypes["PullRequestReviewCommentConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestReviewCommentEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestReviewComment"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestReviewCommentEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestReviewCommentEdge"] = ResolversParentTypes["PullRequestReviewCommentEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestReviewConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestReviewConnection"] = ResolversParentTypes["PullRequestReviewConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestReviewEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestReview"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestReviewContributionsByRepositoryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestReviewContributionsByRepository"] = ResolversParentTypes["PullRequestReviewContributionsByRepository"],
> = {
  contributions?: Resolver<
    ResolversTypes["CreatedPullRequestReviewContributionConnection"],
    ParentType,
    ContextType,
    RequireFields<
      PullRequestReviewContributionsByRepositoryContributionsArgs,
      "orderBy"
    >
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestReviewEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestReviewEdge"] = ResolversParentTypes["PullRequestReviewEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PullRequestReview"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestReviewThreadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestReviewThread"] = ResolversParentTypes["PullRequestReviewThread"],
> = {
  comments?: Resolver<
    ResolversTypes["PullRequestReviewCommentConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestReviewThreadCommentsArgs>
  >;
  diffSide?: Resolver<ResolversTypes["DiffSide"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isCollapsed?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isOutdated?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isResolved?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  line?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  originalLine?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  originalStartLine?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  path?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resolvedBy?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  startDiffSide?: Resolver<
    Maybe<ResolversTypes["DiffSide"]>,
    ParentType,
    ContextType
  >;
  startLine?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  subjectType?: Resolver<
    ResolversTypes["PullRequestReviewThreadSubjectType"],
    ParentType,
    ContextType
  >;
  viewerCanReply?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanResolve?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUnresolve?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestReviewThreadConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestReviewThreadConnection"] = ResolversParentTypes["PullRequestReviewThreadConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestReviewThreadEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestReviewThread"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestReviewThreadEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestReviewThreadEdge"] = ResolversParentTypes["PullRequestReviewThreadEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewThread"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestRevisionMarkerResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestRevisionMarker"] = ResolversParentTypes["PullRequestRevisionMarker"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  lastSeenCommit?: Resolver<ResolversTypes["Commit"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestTemplateResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestTemplate"] = ResolversParentTypes["PullRequestTemplate"],
> = {
  body?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  filename?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestThreadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestThread"] = ResolversParentTypes["PullRequestThread"],
> = {
  comments?: Resolver<
    ResolversTypes["PullRequestReviewCommentConnection"],
    ParentType,
    ContextType,
    Partial<PullRequestThreadCommentsArgs>
  >;
  diffSide?: Resolver<ResolversTypes["DiffSide"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isCollapsed?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isOutdated?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isResolved?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  line?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resolvedBy?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  startDiffSide?: Resolver<
    Maybe<ResolversTypes["DiffSide"]>,
    ParentType,
    ContextType
  >;
  startLine?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  subjectType?: Resolver<
    ResolversTypes["PullRequestReviewThreadSubjectType"],
    ParentType,
    ContextType
  >;
  viewerCanReply?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanResolve?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUnresolve?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestTimelineConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestTimelineConnection"] = ResolversParentTypes["PullRequestTimelineConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestTimelineItemEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestTimelineItem"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestTimelineItemResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestTimelineItem"] = ResolversParentTypes["PullRequestTimelineItem"],
> = {
  __resolveType: TypeResolveFn<
    | "AssignedEvent"
    | "BaseRefDeletedEvent"
    | "BaseRefForcePushedEvent"
    | "ClosedEvent"
    | "Commit"
    | "CommitCommentThread"
    | "CrossReferencedEvent"
    | "DemilestonedEvent"
    | "DeployedEvent"
    | "DeploymentEnvironmentChangedEvent"
    | "HeadRefDeletedEvent"
    | "HeadRefForcePushedEvent"
    | "HeadRefRestoredEvent"
    | "IssueComment"
    | "LabeledEvent"
    | "LockedEvent"
    | "MergedEvent"
    | "MilestonedEvent"
    | "PullRequestReview"
    | "PullRequestReviewComment"
    | "PullRequestReviewThread"
    | "ReferencedEvent"
    | "RenamedTitleEvent"
    | "ReopenedEvent"
    | "ReviewDismissedEvent"
    | "ReviewRequestRemovedEvent"
    | "ReviewRequestedEvent"
    | "SubscribedEvent"
    | "UnassignedEvent"
    | "UnlabeledEvent"
    | "UnlockedEvent"
    | "UnsubscribedEvent"
    | "UserBlockedEvent",
    ParentType,
    ContextType
  >;
};

export type PullRequestTimelineItemEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestTimelineItemEdge"] = ResolversParentTypes["PullRequestTimelineItemEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PullRequestTimelineItem"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestTimelineItemsResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestTimelineItems"] = ResolversParentTypes["PullRequestTimelineItems"],
> = {
  __resolveType: TypeResolveFn<
    | "AddedToMergeQueueEvent"
    | "AddedToProjectEvent"
    | "AssignedEvent"
    | "AutoMergeDisabledEvent"
    | "AutoMergeEnabledEvent"
    | "AutoRebaseEnabledEvent"
    | "AutoSquashEnabledEvent"
    | "AutomaticBaseChangeFailedEvent"
    | "AutomaticBaseChangeSucceededEvent"
    | "BaseRefChangedEvent"
    | "BaseRefDeletedEvent"
    | "BaseRefForcePushedEvent"
    | "ClosedEvent"
    | "CommentDeletedEvent"
    | "ConnectedEvent"
    | "ConvertToDraftEvent"
    | "ConvertedNoteToIssueEvent"
    | "ConvertedToDiscussionEvent"
    | "CrossReferencedEvent"
    | "DemilestonedEvent"
    | "DeployedEvent"
    | "DeploymentEnvironmentChangedEvent"
    | "DisconnectedEvent"
    | "HeadRefDeletedEvent"
    | "HeadRefForcePushedEvent"
    | "HeadRefRestoredEvent"
    | "IssueComment"
    | "LabeledEvent"
    | "LockedEvent"
    | "MarkedAsDuplicateEvent"
    | "MentionedEvent"
    | "MergedEvent"
    | "MilestonedEvent"
    | "MovedColumnsInProjectEvent"
    | "PinnedEvent"
    | "PullRequestCommit"
    | "PullRequestCommitCommentThread"
    | "PullRequestReview"
    | "PullRequestReviewThread"
    | "PullRequestRevisionMarker"
    | "ReadyForReviewEvent"
    | "ReferencedEvent"
    | "RemovedFromMergeQueueEvent"
    | "RemovedFromProjectEvent"
    | "RenamedTitleEvent"
    | "ReopenedEvent"
    | "ReviewDismissedEvent"
    | "ReviewRequestRemovedEvent"
    | "ReviewRequestedEvent"
    | "SubscribedEvent"
    | "TransferredEvent"
    | "UnassignedEvent"
    | "UnlabeledEvent"
    | "UnlockedEvent"
    | "UnmarkedAsDuplicateEvent"
    | "UnpinnedEvent"
    | "UnsubscribedEvent"
    | "UserBlockedEvent",
    ParentType,
    ContextType
  >;
};

export type PullRequestTimelineItemsConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestTimelineItemsConnection"] = ResolversParentTypes["PullRequestTimelineItemsConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestTimelineItemsEdge"]>>>,
    ParentType,
    ContextType
  >;
  filteredCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PullRequestTimelineItems"]>>>,
    ParentType,
    ContextType
  >;
  pageCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PullRequestTimelineItemsEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PullRequestTimelineItemsEdge"] = ResolversParentTypes["PullRequestTimelineItemsEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PullRequestTimelineItems"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PushResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Push"] = ResolversParentTypes["Push"],
> = {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  nextSha?: Resolver<
    Maybe<ResolversTypes["GitObjectID"]>,
    ParentType,
    ContextType
  >;
  permalink?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  previousSha?: Resolver<
    Maybe<ResolversTypes["GitObjectID"]>,
    ParentType,
    ContextType
  >;
  pusher?: Resolver<ResolversTypes["Actor"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PushAllowanceResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PushAllowance"] = ResolversParentTypes["PushAllowance"],
> = {
  actor?: Resolver<
    Maybe<ResolversTypes["PushAllowanceActor"]>,
    ParentType,
    ContextType
  >;
  branchProtectionRule?: Resolver<
    Maybe<ResolversTypes["BranchProtectionRule"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PushAllowanceActorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PushAllowanceActor"] = ResolversParentTypes["PushAllowanceActor"],
> = {
  __resolveType: TypeResolveFn<
    "App" | "Team" | "User",
    ParentType,
    ContextType
  >;
};

export type PushAllowanceConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PushAllowanceConnection"] = ResolversParentTypes["PushAllowanceConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PushAllowanceEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PushAllowance"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PushAllowanceEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["PushAllowanceEdge"] = ResolversParentTypes["PushAllowanceEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["PushAllowance"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Query"] = ResolversParentTypes["Query"],
> = {
  codeOfConduct?: Resolver<
    Maybe<ResolversTypes["CodeOfConduct"]>,
    ParentType,
    ContextType,
    RequireFields<QueryCodeOfConductArgs, "key">
  >;
  codesOfConduct?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["CodeOfConduct"]>>>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType,
    RequireFields<QueryEnterpriseArgs, "slug">
  >;
  enterpriseAdministratorInvitation?: Resolver<
    Maybe<ResolversTypes["EnterpriseAdministratorInvitation"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryEnterpriseAdministratorInvitationArgs,
      "enterpriseSlug" | "role" | "userLogin"
    >
  >;
  enterpriseAdministratorInvitationByToken?: Resolver<
    Maybe<ResolversTypes["EnterpriseAdministratorInvitation"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryEnterpriseAdministratorInvitationByTokenArgs,
      "invitationToken"
    >
  >;
  enterpriseMemberInvitation?: Resolver<
    Maybe<ResolversTypes["EnterpriseMemberInvitation"]>,
    ParentType,
    ContextType,
    RequireFields<
      QueryEnterpriseMemberInvitationArgs,
      "enterpriseSlug" | "userLogin"
    >
  >;
  enterpriseMemberInvitationByToken?: Resolver<
    Maybe<ResolversTypes["EnterpriseMemberInvitation"]>,
    ParentType,
    ContextType,
    RequireFields<QueryEnterpriseMemberInvitationByTokenArgs, "invitationToken">
  >;
  license?: Resolver<
    Maybe<ResolversTypes["License"]>,
    ParentType,
    ContextType,
    RequireFields<QueryLicenseArgs, "key">
  >;
  licenses?: Resolver<
    Array<Maybe<ResolversTypes["License"]>>,
    ParentType,
    ContextType
  >;
  marketplaceCategories?: Resolver<
    Array<ResolversTypes["MarketplaceCategory"]>,
    ParentType,
    ContextType,
    Partial<QueryMarketplaceCategoriesArgs>
  >;
  marketplaceCategory?: Resolver<
    Maybe<ResolversTypes["MarketplaceCategory"]>,
    ParentType,
    ContextType,
    RequireFields<QueryMarketplaceCategoryArgs, "slug">
  >;
  marketplaceListing?: Resolver<
    Maybe<ResolversTypes["MarketplaceListing"]>,
    ParentType,
    ContextType,
    RequireFields<QueryMarketplaceListingArgs, "slug">
  >;
  marketplaceListings?: Resolver<
    ResolversTypes["MarketplaceListingConnection"],
    ParentType,
    ContextType,
    RequireFields<
      QueryMarketplaceListingsArgs,
      "primaryCategoryOnly" | "withFreeTrialsOnly"
    >
  >;
  meta?: Resolver<ResolversTypes["GitHubMetadata"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["Node"]>,
    ParentType,
    ContextType,
    RequireFields<QueryNodeArgs, "id">
  >;
  nodes?: Resolver<
    Array<Maybe<ResolversTypes["Node"]>>,
    ParentType,
    ContextType,
    RequireFields<QueryNodesArgs, "ids">
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType,
    RequireFields<QueryOrganizationArgs, "login">
  >;
  rateLimit?: Resolver<
    Maybe<ResolversTypes["RateLimit"]>,
    ParentType,
    ContextType,
    RequireFields<QueryRateLimitArgs, "dryRun">
  >;
  relay?: Resolver<ResolversTypes["Query"], ParentType, ContextType>;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType,
    RequireFields<QueryRepositoryArgs, "followRenames" | "name" | "owner">
  >;
  repositoryOwner?: Resolver<
    Maybe<ResolversTypes["RepositoryOwner"]>,
    ParentType,
    ContextType,
    RequireFields<QueryRepositoryOwnerArgs, "login">
  >;
  resource?: Resolver<
    Maybe<ResolversTypes["UniformResourceLocatable"]>,
    ParentType,
    ContextType,
    RequireFields<QueryResourceArgs, "url">
  >;
  search?: Resolver<
    ResolversTypes["SearchResultItemConnection"],
    ParentType,
    ContextType,
    RequireFields<QuerySearchArgs, "query" | "type">
  >;
  securityAdvisories?: Resolver<
    ResolversTypes["SecurityAdvisoryConnection"],
    ParentType,
    ContextType,
    RequireFields<QuerySecurityAdvisoriesArgs, "orderBy">
  >;
  securityAdvisory?: Resolver<
    Maybe<ResolversTypes["SecurityAdvisory"]>,
    ParentType,
    ContextType,
    RequireFields<QuerySecurityAdvisoryArgs, "ghsaId">
  >;
  securityVulnerabilities?: Resolver<
    ResolversTypes["SecurityVulnerabilityConnection"],
    ParentType,
    ContextType,
    RequireFields<QuerySecurityVulnerabilitiesArgs, "orderBy">
  >;
  sponsorables?: Resolver<
    ResolversTypes["SponsorableItemConnection"],
    ParentType,
    ContextType,
    RequireFields<QuerySponsorablesArgs, "onlyDependencies" | "orderBy">
  >;
  topic?: Resolver<
    Maybe<ResolversTypes["Topic"]>,
    ParentType,
    ContextType,
    RequireFields<QueryTopicArgs, "name">
  >;
  user?: Resolver<
    Maybe<ResolversTypes["User"]>,
    ParentType,
    ContextType,
    RequireFields<QueryUserArgs, "login">
  >;
  viewer?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
};

export type RateLimitResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RateLimit"] = ResolversParentTypes["RateLimit"],
> = {
  cost?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  limit?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  nodeCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  remaining?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  resetAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  used?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReactableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Reactable"] = ResolversParentTypes["Reactable"],
> = {
  __resolveType: TypeResolveFn<
    | "CommitComment"
    | "Discussion"
    | "DiscussionComment"
    | "Issue"
    | "IssueComment"
    | "PullRequest"
    | "PullRequestReview"
    | "PullRequestReviewComment"
    | "Release"
    | "TeamDiscussion"
    | "TeamDiscussionComment",
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  reactions?: Resolver<
    ResolversTypes["ReactionConnection"],
    ParentType,
    ContextType,
    Partial<ReactableReactionsArgs>
  >;
  viewerCanReact?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
};

export type ReactingUserConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReactingUserConnection"] = ResolversParentTypes["ReactingUserConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ReactingUserEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["User"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReactingUserEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReactingUserEdge"] = ResolversParentTypes["ReactingUserEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  reactedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReactionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Reaction"] = ResolversParentTypes["Reaction"],
> = {
  content?: Resolver<
    ResolversTypes["ReactionContent"],
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  reactable?: Resolver<ResolversTypes["Reactable"], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReactionConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReactionConnection"] = ResolversParentTypes["ReactionConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ReactionEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Reaction"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  viewerHasReacted?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReactionEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReactionEdge"] = ResolversParentTypes["ReactionEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Reaction"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReactionGroupResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReactionGroup"] = ResolversParentTypes["ReactionGroup"],
> = {
  content?: Resolver<
    ResolversTypes["ReactionContent"],
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  reactors?: Resolver<
    ResolversTypes["ReactorConnection"],
    ParentType,
    ContextType,
    Partial<ReactionGroupReactorsArgs>
  >;
  subject?: Resolver<ResolversTypes["Reactable"], ParentType, ContextType>;
  users?: Resolver<
    ResolversTypes["ReactingUserConnection"],
    ParentType,
    ContextType,
    Partial<ReactionGroupUsersArgs>
  >;
  viewerHasReacted?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReactorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Reactor"] = ResolversParentTypes["Reactor"],
> = {
  __resolveType: TypeResolveFn<
    "Bot" | "Mannequin" | "Organization" | "User",
    ParentType,
    ContextType
  >;
};

export type ReactorConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReactorConnection"] = ResolversParentTypes["ReactorConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ReactorEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Reactor"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReactorEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReactorEdge"] = ResolversParentTypes["ReactorEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<ResolversTypes["Reactor"], ParentType, ContextType>;
  reactedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReadyForReviewEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReadyForReviewEvent"] = ResolversParentTypes["ReadyForReviewEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RefResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Ref"] = ResolversParentTypes["Ref"],
> = {
  associatedPullRequests?: Resolver<
    ResolversTypes["PullRequestConnection"],
    ParentType,
    ContextType,
    Partial<RefAssociatedPullRequestsArgs>
  >;
  branchProtectionRule?: Resolver<
    Maybe<ResolversTypes["BranchProtectionRule"]>,
    ParentType,
    ContextType
  >;
  compare?: Resolver<
    Maybe<ResolversTypes["Comparison"]>,
    ParentType,
    ContextType,
    RequireFields<RefCompareArgs, "headRef">
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  prefix?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  refUpdateRule?: Resolver<
    Maybe<ResolversTypes["RefUpdateRule"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  rules?: Resolver<
    Maybe<ResolversTypes["RepositoryRuleConnection"]>,
    ParentType,
    ContextType,
    RequireFields<RefRulesArgs, "orderBy">
  >;
  target?: Resolver<
    Maybe<ResolversTypes["GitObject"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RefConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RefConnection"] = ResolversParentTypes["RefConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RefEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Ref"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RefEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RefEdge"] = ResolversParentTypes["RefEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RefNameConditionTargetResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RefNameConditionTarget"] = ResolversParentTypes["RefNameConditionTarget"],
> = {
  exclude?: Resolver<Array<ResolversTypes["String"]>, ParentType, ContextType>;
  include?: Resolver<Array<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RefUpdateRuleResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RefUpdateRule"] = ResolversParentTypes["RefUpdateRule"],
> = {
  allowsDeletions?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  allowsForcePushes?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  blocksCreations?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  pattern?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  requiredApprovingReviewCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  requiredStatusCheckContexts?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["String"]>>>,
    ParentType,
    ContextType
  >;
  requiresCodeOwnerReviews?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiresConversationResolution?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiresLinearHistory?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiresSignatures?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerAllowedToDismissReviews?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanPush?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReferencedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReferencedEvent"] = ResolversParentTypes["ReferencedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes["Commit"]>, ParentType, ContextType>;
  commitRepository?: Resolver<
    ResolversTypes["Repository"],
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isCrossRepository?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isDirectReference?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  subject?: Resolver<
    ResolversTypes["ReferencedSubject"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReferencedSubjectResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReferencedSubject"] = ResolversParentTypes["ReferencedSubject"],
> = {
  __resolveType: TypeResolveFn<
    "Issue" | "PullRequest",
    ParentType,
    ContextType
  >;
};

export type RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RegenerateEnterpriseIdentityProviderRecoveryCodesPayload"] = ResolversParentTypes["RegenerateEnterpriseIdentityProviderRecoveryCodesPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  identityProvider?: Resolver<
    Maybe<ResolversTypes["EnterpriseIdentityProvider"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegenerateVerifiableDomainTokenPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RegenerateVerifiableDomainTokenPayload"] = ResolversParentTypes["RegenerateVerifiableDomainTokenPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  verificationToken?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RejectDeploymentsPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RejectDeploymentsPayload"] = ResolversParentTypes["RejectDeploymentsPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  deployments?: Resolver<
    Maybe<Array<ResolversTypes["Deployment"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReleaseResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Release"] = ResolversParentTypes["Release"],
> = {
  author?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  descriptionHTML?: Resolver<
    Maybe<ResolversTypes["HTML"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isDraft?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isLatest?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isPrerelease?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  mentions?: Resolver<
    Maybe<ResolversTypes["UserConnection"]>,
    ParentType,
    ContextType,
    Partial<ReleaseMentionsArgs>
  >;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  reactions?: Resolver<
    ResolversTypes["ReactionConnection"],
    ParentType,
    ContextType,
    Partial<ReleaseReactionsArgs>
  >;
  releaseAssets?: Resolver<
    ResolversTypes["ReleaseAssetConnection"],
    ParentType,
    ContextType,
    Partial<ReleaseReleaseAssetsArgs>
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<
    Maybe<ResolversTypes["HTML"]>,
    ParentType,
    ContextType,
    RequireFields<ReleaseShortDescriptionHtmlArgs, "limit">
  >;
  tag?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  tagCommit?: Resolver<
    Maybe<ResolversTypes["Commit"]>,
    ParentType,
    ContextType
  >;
  tagName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReleaseAssetResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReleaseAsset"] = ResolversParentTypes["ReleaseAsset"],
> = {
  contentType?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  downloadCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  downloadUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  release?: Resolver<Maybe<ResolversTypes["Release"]>, ParentType, ContextType>;
  size?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  uploadedBy?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReleaseAssetConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReleaseAssetConnection"] = ResolversParentTypes["ReleaseAssetConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ReleaseAssetEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ReleaseAsset"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReleaseAssetEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReleaseAssetEdge"] = ResolversParentTypes["ReleaseAssetEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ReleaseAsset"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReleaseConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReleaseConnection"] = ResolversParentTypes["ReleaseConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ReleaseEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Release"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReleaseEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReleaseEdge"] = ResolversParentTypes["ReleaseEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Release"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveAssigneesFromAssignablePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemoveAssigneesFromAssignablePayload"] = ResolversParentTypes["RemoveAssigneesFromAssignablePayload"],
> = {
  assignable?: Resolver<
    Maybe<ResolversTypes["Assignable"]>,
    ParentType,
    ContextType
  >;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveEnterpriseAdminPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemoveEnterpriseAdminPayload"] = ResolversParentTypes["RemoveEnterpriseAdminPayload"],
> = {
  admin?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveEnterpriseIdentityProviderPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemoveEnterpriseIdentityProviderPayload"] = ResolversParentTypes["RemoveEnterpriseIdentityProviderPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  identityProvider?: Resolver<
    Maybe<ResolversTypes["EnterpriseIdentityProvider"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveEnterpriseMemberPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemoveEnterpriseMemberPayload"] = ResolversParentTypes["RemoveEnterpriseMemberPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveEnterpriseOrganizationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemoveEnterpriseOrganizationPayload"] = ResolversParentTypes["RemoveEnterpriseOrganizationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  viewer?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveEnterpriseSupportEntitlementPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemoveEnterpriseSupportEntitlementPayload"] = ResolversParentTypes["RemoveEnterpriseSupportEntitlementPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveLabelsFromLabelablePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemoveLabelsFromLabelablePayload"] = ResolversParentTypes["RemoveLabelsFromLabelablePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  labelable?: Resolver<
    Maybe<ResolversTypes["Labelable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveOutsideCollaboratorPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemoveOutsideCollaboratorPayload"] = ResolversParentTypes["RemoveOutsideCollaboratorPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  removedUser?: Resolver<
    Maybe<ResolversTypes["User"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveReactionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemoveReactionPayload"] = ResolversParentTypes["RemoveReactionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  reaction?: Resolver<
    Maybe<ResolversTypes["Reaction"]>,
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  subject?: Resolver<
    Maybe<ResolversTypes["Reactable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveStarPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemoveStarPayload"] = ResolversParentTypes["RemoveStarPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  starrable?: Resolver<
    Maybe<ResolversTypes["Starrable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveUpvotePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemoveUpvotePayload"] = ResolversParentTypes["RemoveUpvotePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  subject?: Resolver<Maybe<ResolversTypes["Votable"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemovedFromMergeQueueEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemovedFromMergeQueueEvent"] = ResolversParentTypes["RemovedFromMergeQueueEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  beforeCommit?: Resolver<
    Maybe<ResolversTypes["Commit"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  enqueuer?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  mergeQueue?: Resolver<
    Maybe<ResolversTypes["MergeQueue"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  reason?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemovedFromProjectEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RemovedFromProjectEvent"] = ResolversParentTypes["RemovedFromProjectEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  projectColumnName?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RenamedTitleEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RenamedTitleEvent"] = ResolversParentTypes["RenamedTitleEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  currentTitle?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  previousTitle?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  subject?: Resolver<
    ResolversTypes["RenamedTitleSubject"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RenamedTitleSubjectResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RenamedTitleSubject"] = ResolversParentTypes["RenamedTitleSubject"],
> = {
  __resolveType: TypeResolveFn<
    "Issue" | "PullRequest",
    ParentType,
    ContextType
  >;
};

export type ReopenDiscussionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReopenDiscussionPayload"] = ResolversParentTypes["ReopenDiscussionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  discussion?: Resolver<
    Maybe<ResolversTypes["Discussion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReopenIssuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReopenIssuePayload"] = ResolversParentTypes["ReopenIssuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  issue?: Resolver<Maybe<ResolversTypes["Issue"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReopenPullRequestPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReopenPullRequestPayload"] = ResolversParentTypes["ReopenPullRequestPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReopenedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReopenedEvent"] = ResolversParentTypes["ReopenedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  closable?: Resolver<ResolversTypes["Closable"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  stateReason?: Resolver<
    Maybe<ResolversTypes["IssueStateReason"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReorderEnvironmentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReorderEnvironmentPayload"] = ResolversParentTypes["ReorderEnvironmentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  environment?: Resolver<
    Maybe<ResolversTypes["Environment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoAccessAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoAccessAuditEntry"] = ResolversParentTypes["RepoAccessAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  visibility?: Resolver<
    Maybe<ResolversTypes["RepoAccessAuditEntryVisibility"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoAddMemberAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoAddMemberAuditEntry"] = ResolversParentTypes["RepoAddMemberAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  visibility?: Resolver<
    Maybe<ResolversTypes["RepoAddMemberAuditEntryVisibility"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoAddTopicAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoAddTopicAuditEntry"] = ResolversParentTypes["RepoAddTopicAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  topic?: Resolver<Maybe<ResolversTypes["Topic"]>, ParentType, ContextType>;
  topicName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoArchivedAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoArchivedAuditEntry"] = ResolversParentTypes["RepoArchivedAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  visibility?: Resolver<
    Maybe<ResolversTypes["RepoArchivedAuditEntryVisibility"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoChangeMergeSettingAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoChangeMergeSettingAuditEntry"] = ResolversParentTypes["RepoChangeMergeSettingAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isEnabled?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  mergeType?: Resolver<
    Maybe<ResolversTypes["RepoChangeMergeSettingAuditEntryMergeType"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoConfigDisableAnonymousGitAccessAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoConfigDisableAnonymousGitAccessAuditEntry"] = ResolversParentTypes["RepoConfigDisableAnonymousGitAccessAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoConfigDisableCollaboratorsOnlyAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoConfigDisableCollaboratorsOnlyAuditEntry"] = ResolversParentTypes["RepoConfigDisableCollaboratorsOnlyAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoConfigDisableContributorsOnlyAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoConfigDisableContributorsOnlyAuditEntry"] = ResolversParentTypes["RepoConfigDisableContributorsOnlyAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoConfigDisableSockpuppetDisallowedAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoConfigDisableSockpuppetDisallowedAuditEntry"] = ResolversParentTypes["RepoConfigDisableSockpuppetDisallowedAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoConfigEnableAnonymousGitAccessAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoConfigEnableAnonymousGitAccessAuditEntry"] = ResolversParentTypes["RepoConfigEnableAnonymousGitAccessAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoConfigEnableCollaboratorsOnlyAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoConfigEnableCollaboratorsOnlyAuditEntry"] = ResolversParentTypes["RepoConfigEnableCollaboratorsOnlyAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoConfigEnableContributorsOnlyAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoConfigEnableContributorsOnlyAuditEntry"] = ResolversParentTypes["RepoConfigEnableContributorsOnlyAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoConfigEnableSockpuppetDisallowedAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoConfigEnableSockpuppetDisallowedAuditEntry"] = ResolversParentTypes["RepoConfigEnableSockpuppetDisallowedAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoConfigLockAnonymousGitAccessAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoConfigLockAnonymousGitAccessAuditEntry"] = ResolversParentTypes["RepoConfigLockAnonymousGitAccessAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoConfigUnlockAnonymousGitAccessAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoConfigUnlockAnonymousGitAccessAuditEntry"] = ResolversParentTypes["RepoConfigUnlockAnonymousGitAccessAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoCreateAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoCreateAuditEntry"] = ResolversParentTypes["RepoCreateAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  forkParentName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  forkSourceName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  visibility?: Resolver<
    Maybe<ResolversTypes["RepoCreateAuditEntryVisibility"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoDestroyAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoDestroyAuditEntry"] = ResolversParentTypes["RepoDestroyAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  visibility?: Resolver<
    Maybe<ResolversTypes["RepoDestroyAuditEntryVisibility"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoRemoveMemberAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoRemoveMemberAuditEntry"] = ResolversParentTypes["RepoRemoveMemberAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  visibility?: Resolver<
    Maybe<ResolversTypes["RepoRemoveMemberAuditEntryVisibility"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepoRemoveTopicAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepoRemoveTopicAuditEntry"] = ResolversParentTypes["RepoRemoveTopicAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  topic?: Resolver<Maybe<ResolversTypes["Topic"]>, ParentType, ContextType>;
  topicName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Repository"] = ResolversParentTypes["Repository"],
> = {
  allowUpdateBranch?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  archivedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  assignableUsers?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryAssignableUsersArgs>
  >;
  autoMergeAllowed?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  branchProtectionRules?: Resolver<
    ResolversTypes["BranchProtectionRuleConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryBranchProtectionRulesArgs>
  >;
  codeOfConduct?: Resolver<
    Maybe<ResolversTypes["CodeOfConduct"]>,
    ParentType,
    ContextType
  >;
  codeowners?: Resolver<
    Maybe<ResolversTypes["RepositoryCodeowners"]>,
    ParentType,
    ContextType,
    Partial<RepositoryCodeownersArgs>
  >;
  collaborators?: Resolver<
    Maybe<ResolversTypes["RepositoryCollaboratorConnection"]>,
    ParentType,
    ContextType,
    Partial<RepositoryCollaboratorsArgs>
  >;
  commitComments?: Resolver<
    ResolversTypes["CommitCommentConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryCommitCommentsArgs>
  >;
  contactLinks?: Resolver<
    Maybe<Array<ResolversTypes["RepositoryContactLink"]>>,
    ParentType,
    ContextType
  >;
  contributingGuidelines?: Resolver<
    Maybe<ResolversTypes["ContributingGuidelines"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  defaultBranchRef?: Resolver<
    Maybe<ResolversTypes["Ref"]>,
    ParentType,
    ContextType
  >;
  deleteBranchOnMerge?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  dependencyGraphManifests?: Resolver<
    Maybe<ResolversTypes["DependencyGraphManifestConnection"]>,
    ParentType,
    ContextType,
    Partial<RepositoryDependencyGraphManifestsArgs>
  >;
  deployKeys?: Resolver<
    ResolversTypes["DeployKeyConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryDeployKeysArgs>
  >;
  deployments?: Resolver<
    ResolversTypes["DeploymentConnection"],
    ParentType,
    ContextType,
    RequireFields<RepositoryDeploymentsArgs, "orderBy">
  >;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  descriptionHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  discussion?: Resolver<
    Maybe<ResolversTypes["Discussion"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryDiscussionArgs, "number">
  >;
  discussionCategories?: Resolver<
    ResolversTypes["DiscussionCategoryConnection"],
    ParentType,
    ContextType,
    RequireFields<RepositoryDiscussionCategoriesArgs, "filterByAssignable">
  >;
  discussionCategory?: Resolver<
    Maybe<ResolversTypes["DiscussionCategory"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryDiscussionCategoryArgs, "slug">
  >;
  discussions?: Resolver<
    ResolversTypes["DiscussionConnection"],
    ParentType,
    ContextType,
    RequireFields<
      RepositoryDiscussionsArgs,
      "answered" | "categoryId" | "orderBy" | "states"
    >
  >;
  diskUsage?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  environment?: Resolver<
    Maybe<ResolversTypes["Environment"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryEnvironmentArgs, "name">
  >;
  environments?: Resolver<
    ResolversTypes["EnvironmentConnection"],
    ParentType,
    ContextType,
    RequireFields<
      RepositoryEnvironmentsArgs,
      "names" | "orderBy" | "pinnedEnvironmentFilter"
    >
  >;
  forkCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  forkingAllowed?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  forks?: Resolver<
    ResolversTypes["RepositoryConnection"],
    ParentType,
    ContextType,
    RequireFields<RepositoryForksArgs, "ownerAffiliations">
  >;
  fundingLinks?: Resolver<
    Array<ResolversTypes["FundingLink"]>,
    ParentType,
    ContextType
  >;
  hasDiscussionsEnabled?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasIssuesEnabled?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasProjectsEnabled?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasSponsorshipsEnabled?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasVulnerabilityAlertsEnabled?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasWikiEnabled?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  homepageUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  interactionAbility?: Resolver<
    Maybe<ResolversTypes["RepositoryInteractionAbility"]>,
    ParentType,
    ContextType
  >;
  isArchived?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isBlankIssuesEnabled?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isDisabled?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isEmpty?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isFork?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isInOrganization?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isLocked?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isMirror?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isSecurityPolicyEnabled?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  isTemplate?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isUserConfigurationRepository?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  issue?: Resolver<
    Maybe<ResolversTypes["Issue"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryIssueArgs, "number">
  >;
  issueOrPullRequest?: Resolver<
    Maybe<ResolversTypes["IssueOrPullRequest"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryIssueOrPullRequestArgs, "number">
  >;
  issueTemplates?: Resolver<
    Maybe<Array<ResolversTypes["IssueTemplate"]>>,
    ParentType,
    ContextType
  >;
  issues?: Resolver<
    ResolversTypes["IssueConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryIssuesArgs>
  >;
  label?: Resolver<
    Maybe<ResolversTypes["Label"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryLabelArgs, "name">
  >;
  labels?: Resolver<
    Maybe<ResolversTypes["LabelConnection"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryLabelsArgs, "orderBy">
  >;
  languages?: Resolver<
    Maybe<ResolversTypes["LanguageConnection"]>,
    ParentType,
    ContextType,
    Partial<RepositoryLanguagesArgs>
  >;
  latestRelease?: Resolver<
    Maybe<ResolversTypes["Release"]>,
    ParentType,
    ContextType
  >;
  licenseInfo?: Resolver<
    Maybe<ResolversTypes["License"]>,
    ParentType,
    ContextType
  >;
  lockReason?: Resolver<
    Maybe<ResolversTypes["RepositoryLockReason"]>,
    ParentType,
    ContextType
  >;
  mentionableUsers?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryMentionableUsersArgs>
  >;
  mergeCommitAllowed?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  mergeCommitMessage?: Resolver<
    ResolversTypes["MergeCommitMessage"],
    ParentType,
    ContextType
  >;
  mergeCommitTitle?: Resolver<
    ResolversTypes["MergeCommitTitle"],
    ParentType,
    ContextType
  >;
  mergeQueue?: Resolver<
    Maybe<ResolversTypes["MergeQueue"]>,
    ParentType,
    ContextType,
    Partial<RepositoryMergeQueueArgs>
  >;
  milestone?: Resolver<
    Maybe<ResolversTypes["Milestone"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryMilestoneArgs, "number">
  >;
  milestones?: Resolver<
    Maybe<ResolversTypes["MilestoneConnection"]>,
    ParentType,
    ContextType,
    Partial<RepositoryMilestonesArgs>
  >;
  mirrorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  nameWithOwner?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  object?: Resolver<
    Maybe<ResolversTypes["GitObject"]>,
    ParentType,
    ContextType,
    Partial<RepositoryObjectArgs>
  >;
  openGraphImageUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes["RepositoryOwner"], ParentType, ContextType>;
  packages?: Resolver<
    ResolversTypes["PackageConnection"],
    ParentType,
    ContextType,
    RequireFields<RepositoryPackagesArgs, "orderBy">
  >;
  parent?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  pinnedDiscussions?: Resolver<
    ResolversTypes["PinnedDiscussionConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryPinnedDiscussionsArgs>
  >;
  pinnedEnvironments?: Resolver<
    Maybe<ResolversTypes["PinnedEnvironmentConnection"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryPinnedEnvironmentsArgs, "orderBy">
  >;
  pinnedIssues?: Resolver<
    Maybe<ResolversTypes["PinnedIssueConnection"]>,
    ParentType,
    ContextType,
    Partial<RepositoryPinnedIssuesArgs>
  >;
  planFeatures?: Resolver<
    ResolversTypes["RepositoryPlanFeatures"],
    ParentType,
    ContextType
  >;
  primaryLanguage?: Resolver<
    Maybe<ResolversTypes["Language"]>,
    ParentType,
    ContextType
  >;
  project?: Resolver<
    Maybe<ResolversTypes["Project"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryProjectArgs, "number">
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryProjectV2Args, "number">
  >;
  projects?: Resolver<
    ResolversTypes["ProjectConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryProjectsArgs>
  >;
  projectsResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  projectsUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  projectsV2?: Resolver<
    ResolversTypes["ProjectV2Connection"],
    ParentType,
    ContextType,
    RequireFields<RepositoryProjectsV2Args, "minPermissionLevel" | "orderBy">
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryPullRequestArgs, "number">
  >;
  pullRequestTemplates?: Resolver<
    Maybe<Array<ResolversTypes["PullRequestTemplate"]>>,
    ParentType,
    ContextType
  >;
  pullRequests?: Resolver<
    ResolversTypes["PullRequestConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryPullRequestsArgs>
  >;
  pushedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  rebaseMergeAllowed?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  recentProjects?: Resolver<
    ResolversTypes["ProjectV2Connection"],
    ParentType,
    ContextType,
    Partial<RepositoryRecentProjectsArgs>
  >;
  ref?: Resolver<
    Maybe<ResolversTypes["Ref"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryRefArgs, "qualifiedName">
  >;
  refs?: Resolver<
    Maybe<ResolversTypes["RefConnection"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryRefsArgs, "refPrefix">
  >;
  release?: Resolver<
    Maybe<ResolversTypes["Release"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryReleaseArgs, "tagName">
  >;
  releases?: Resolver<
    ResolversTypes["ReleaseConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryReleasesArgs>
  >;
  repositoryTopics?: Resolver<
    ResolversTypes["RepositoryTopicConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryRepositoryTopicsArgs>
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  ruleset?: Resolver<
    Maybe<ResolversTypes["RepositoryRuleset"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryRulesetArgs, "databaseId" | "includeParents">
  >;
  rulesets?: Resolver<
    Maybe<ResolversTypes["RepositoryRulesetConnection"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryRulesetsArgs, "includeParents">
  >;
  securityPolicyUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  shortDescriptionHTML?: Resolver<
    ResolversTypes["HTML"],
    ParentType,
    ContextType,
    RequireFields<RepositoryShortDescriptionHtmlArgs, "limit">
  >;
  squashMergeAllowed?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  squashMergeCommitMessage?: Resolver<
    ResolversTypes["SquashMergeCommitMessage"],
    ParentType,
    ContextType
  >;
  squashMergeCommitTitle?: Resolver<
    ResolversTypes["SquashMergeCommitTitle"],
    ParentType,
    ContextType
  >;
  squashPrTitleUsedAsDefault?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  sshUrl?: Resolver<ResolversTypes["GitSSHRemote"], ParentType, ContextType>;
  stargazerCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  stargazers?: Resolver<
    ResolversTypes["StargazerConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryStargazersArgs>
  >;
  submodules?: Resolver<
    ResolversTypes["SubmoduleConnection"],
    ParentType,
    ContextType,
    Partial<RepositorySubmodulesArgs>
  >;
  tempCloneToken?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  templateRepository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  usesCustomOpenGraphImage?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanAdminister?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanCreateProjects?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanSubscribe?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUpdateTopics?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerDefaultCommitEmail?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  viewerDefaultMergeMethod?: Resolver<
    ResolversTypes["PullRequestMergeMethod"],
    ParentType,
    ContextType
  >;
  viewerHasStarred?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerPermission?: Resolver<
    Maybe<ResolversTypes["RepositoryPermission"]>,
    ParentType,
    ContextType
  >;
  viewerPossibleCommitEmails?: Resolver<
    Maybe<Array<ResolversTypes["String"]>>,
    ParentType,
    ContextType
  >;
  viewerSubscription?: Resolver<
    Maybe<ResolversTypes["SubscriptionState"]>,
    ParentType,
    ContextType
  >;
  visibility?: Resolver<
    ResolversTypes["RepositoryVisibility"],
    ParentType,
    ContextType
  >;
  vulnerabilityAlert?: Resolver<
    Maybe<ResolversTypes["RepositoryVulnerabilityAlert"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryVulnerabilityAlertArgs, "number">
  >;
  vulnerabilityAlerts?: Resolver<
    Maybe<ResolversTypes["RepositoryVulnerabilityAlertConnection"]>,
    ParentType,
    ContextType,
    Partial<RepositoryVulnerabilityAlertsArgs>
  >;
  watchers?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<RepositoryWatchersArgs>
  >;
  webCommitSignoffRequired?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryAuditEntryDataResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryAuditEntryData"] = ResolversParentTypes["RepositoryAuditEntryData"],
> = {
  __resolveType: TypeResolveFn<
    | "OrgRestoreMemberMembershipRepositoryAuditEntryData"
    | "PrivateRepositoryForkingDisableAuditEntry"
    | "PrivateRepositoryForkingEnableAuditEntry"
    | "RepoAccessAuditEntry"
    | "RepoAddMemberAuditEntry"
    | "RepoAddTopicAuditEntry"
    | "RepoArchivedAuditEntry"
    | "RepoChangeMergeSettingAuditEntry"
    | "RepoConfigDisableAnonymousGitAccessAuditEntry"
    | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
    | "RepoConfigDisableContributorsOnlyAuditEntry"
    | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
    | "RepoConfigEnableAnonymousGitAccessAuditEntry"
    | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
    | "RepoConfigEnableContributorsOnlyAuditEntry"
    | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
    | "RepoConfigLockAnonymousGitAccessAuditEntry"
    | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
    | "RepoCreateAuditEntry"
    | "RepoDestroyAuditEntry"
    | "RepoRemoveMemberAuditEntry"
    | "RepoRemoveTopicAuditEntry"
    | "TeamAddRepositoryAuditEntry"
    | "TeamRemoveRepositoryAuditEntry",
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
};

export type RepositoryCodeownersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryCodeowners"] = ResolversParentTypes["RepositoryCodeowners"],
> = {
  errors?: Resolver<
    Array<ResolversTypes["RepositoryCodeownersError"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryCodeownersErrorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryCodeownersError"] = ResolversParentTypes["RepositoryCodeownersError"],
> = {
  column?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  line?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  message?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  path?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  source?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  suggestion?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryCollaboratorConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryCollaboratorConnection"] = ResolversParentTypes["RepositoryCollaboratorConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryCollaboratorEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["User"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryCollaboratorEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryCollaboratorEdge"] = ResolversParentTypes["RepositoryCollaboratorEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  permission?: Resolver<
    ResolversTypes["RepositoryPermission"],
    ParentType,
    ContextType
  >;
  permissionSources?: Resolver<
    Maybe<Array<ResolversTypes["PermissionSource"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryConnection"] = ResolversParentTypes["RepositoryConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Repository"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  totalDiskUsage?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryContactLinkResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryContactLink"] = ResolversParentTypes["RepositoryContactLink"],
> = {
  about?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryDiscussionAuthorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryDiscussionAuthor"] = ResolversParentTypes["RepositoryDiscussionAuthor"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "User",
    ParentType,
    ContextType
  >;
  repositoryDiscussions?: Resolver<
    ResolversTypes["DiscussionConnection"],
    ParentType,
    ContextType,
    RequireFields<
      RepositoryDiscussionAuthorRepositoryDiscussionsArgs,
      "answered" | "orderBy" | "states"
    >
  >;
};

export type RepositoryDiscussionCommentAuthorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryDiscussionCommentAuthor"] = ResolversParentTypes["RepositoryDiscussionCommentAuthor"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "User",
    ParentType,
    ContextType
  >;
  repositoryDiscussionComments?: Resolver<
    ResolversTypes["DiscussionCommentConnection"],
    ParentType,
    ContextType,
    RequireFields<
      RepositoryDiscussionCommentAuthorRepositoryDiscussionCommentsArgs,
      "onlyAnswers"
    >
  >;
};

export type RepositoryEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryEdge"] = ResolversParentTypes["RepositoryEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Repository"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryIdConditionTargetResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryIdConditionTarget"] = ResolversParentTypes["RepositoryIdConditionTarget"],
> = {
  repositoryIds?: Resolver<
    Array<ResolversTypes["ID"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryInfoResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryInfo"] = ResolversParentTypes["RepositoryInfo"],
> = {
  __resolveType: TypeResolveFn<"Repository", ParentType, ContextType>;
  archivedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  descriptionHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  forkCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  hasDiscussionsEnabled?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasIssuesEnabled?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasProjectsEnabled?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasSponsorshipsEnabled?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasWikiEnabled?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  homepageUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isFork?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isInOrganization?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isLocked?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isMirror?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isTemplate?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  licenseInfo?: Resolver<
    Maybe<ResolversTypes["License"]>,
    ParentType,
    ContextType
  >;
  lockReason?: Resolver<
    Maybe<ResolversTypes["RepositoryLockReason"]>,
    ParentType,
    ContextType
  >;
  mirrorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  nameWithOwner?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  openGraphImageUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes["RepositoryOwner"], ParentType, ContextType>;
  pushedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<
    ResolversTypes["HTML"],
    ParentType,
    ContextType,
    RequireFields<RepositoryInfoShortDescriptionHtmlArgs, "limit">
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  usesCustomOpenGraphImage?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  visibility?: Resolver<
    ResolversTypes["RepositoryVisibility"],
    ParentType,
    ContextType
  >;
};

export type RepositoryInteractionAbilityResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryInteractionAbility"] = ResolversParentTypes["RepositoryInteractionAbility"],
> = {
  expiresAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  limit?: Resolver<
    ResolversTypes["RepositoryInteractionLimit"],
    ParentType,
    ContextType
  >;
  origin?: Resolver<
    ResolversTypes["RepositoryInteractionLimitOrigin"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryInvitationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryInvitation"] = ResolversParentTypes["RepositoryInvitation"],
> = {
  email?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  invitee?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  inviter?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  permalink?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  permission?: Resolver<
    ResolversTypes["RepositoryPermission"],
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["RepositoryInfo"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryInvitationConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryInvitationConnection"] = ResolversParentTypes["RepositoryInvitationConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryInvitationEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryInvitation"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryInvitationEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryInvitationEdge"] = ResolversParentTypes["RepositoryInvitationEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["RepositoryInvitation"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryMigrationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryMigration"] = ResolversParentTypes["RepositoryMigration"],
> = {
  continueOnError?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  failureReason?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  migrationLogUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  migrationSource?: Resolver<
    ResolversTypes["MigrationSource"],
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  sourceUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  state?: Resolver<ResolversTypes["MigrationState"], ParentType, ContextType>;
  warningsCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryMigrationConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryMigrationConnection"] = ResolversParentTypes["RepositoryMigrationConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryMigrationEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryMigration"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryMigrationEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryMigrationEdge"] = ResolversParentTypes["RepositoryMigrationEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["RepositoryMigration"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryNameConditionTargetResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryNameConditionTarget"] = ResolversParentTypes["RepositoryNameConditionTarget"],
> = {
  exclude?: Resolver<Array<ResolversTypes["String"]>, ParentType, ContextType>;
  include?: Resolver<Array<ResolversTypes["String"]>, ParentType, ContextType>;
  protected?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryNodeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryNode"] = ResolversParentTypes["RepositoryNode"],
> = {
  __resolveType: TypeResolveFn<
    | "CommitComment"
    | "CommitCommentThread"
    | "DependabotUpdate"
    | "Discussion"
    | "DiscussionCategory"
    | "Issue"
    | "IssueComment"
    | "PinnedDiscussion"
    | "PullRequest"
    | "PullRequestCommitCommentThread"
    | "PullRequestReview"
    | "PullRequestReviewComment"
    | "RepositoryVulnerabilityAlert",
    ParentType,
    ContextType
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
};

export type RepositoryOwnerResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryOwner"] = ResolversParentTypes["RepositoryOwner"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "User",
    ParentType,
    ContextType
  >;
  avatarUrl?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType,
    Partial<RepositoryOwnerAvatarUrlArgs>
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  login?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  repositories?: Resolver<
    ResolversTypes["RepositoryConnection"],
    ParentType,
    ContextType,
    RequireFields<RepositoryOwnerRepositoriesArgs, "ownerAffiliations">
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType,
    RequireFields<RepositoryOwnerRepositoryArgs, "followRenames" | "name">
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
};

export type RepositoryPlanFeaturesResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryPlanFeatures"] = ResolversParentTypes["RepositoryPlanFeatures"],
> = {
  codeowners?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  draftPullRequests?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  maximumAssignees?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  maximumManualReviewRequests?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  teamReviewRequests?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryPropertyConditionTargetResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryPropertyConditionTarget"] = ResolversParentTypes["RepositoryPropertyConditionTarget"],
> = {
  exclude?: Resolver<
    Array<ResolversTypes["PropertyTargetDefinition"]>,
    ParentType,
    ContextType
  >;
  include?: Resolver<
    Array<ResolversTypes["PropertyTargetDefinition"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryRuleResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryRule"] = ResolversParentTypes["RepositoryRule"],
> = {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  parameters?: Resolver<
    Maybe<ResolversTypes["RuleParameters"]>,
    ParentType,
    ContextType
  >;
  repositoryRuleset?: Resolver<
    Maybe<ResolversTypes["RepositoryRuleset"]>,
    ParentType,
    ContextType
  >;
  type?: Resolver<
    ResolversTypes["RepositoryRuleType"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryRuleConditionsResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryRuleConditions"] = ResolversParentTypes["RepositoryRuleConditions"],
> = {
  refName?: Resolver<
    Maybe<ResolversTypes["RefNameConditionTarget"]>,
    ParentType,
    ContextType
  >;
  repositoryId?: Resolver<
    Maybe<ResolversTypes["RepositoryIdConditionTarget"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["RepositoryNameConditionTarget"]>,
    ParentType,
    ContextType
  >;
  repositoryProperty?: Resolver<
    Maybe<ResolversTypes["RepositoryPropertyConditionTarget"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryRuleConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryRuleConnection"] = ResolversParentTypes["RepositoryRuleConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryRuleEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryRule"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryRuleEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryRuleEdge"] = ResolversParentTypes["RepositoryRuleEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["RepositoryRule"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryRulesetResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryRuleset"] = ResolversParentTypes["RepositoryRuleset"],
> = {
  bypassActors?: Resolver<
    Maybe<ResolversTypes["RepositoryRulesetBypassActorConnection"]>,
    ParentType,
    ContextType,
    Partial<RepositoryRulesetBypassActorsArgs>
  >;
  conditions?: Resolver<
    ResolversTypes["RepositoryRuleConditions"],
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  enforcement?: Resolver<
    ResolversTypes["RuleEnforcement"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  rules?: Resolver<
    Maybe<ResolversTypes["RepositoryRuleConnection"]>,
    ParentType,
    ContextType,
    Partial<RepositoryRulesetRulesArgs>
  >;
  source?: Resolver<ResolversTypes["RuleSource"], ParentType, ContextType>;
  target?: Resolver<
    Maybe<ResolversTypes["RepositoryRulesetTarget"]>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryRulesetBypassActorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryRulesetBypassActor"] = ResolversParentTypes["RepositoryRulesetBypassActor"],
> = {
  actor?: Resolver<
    Maybe<ResolversTypes["BypassActor"]>,
    ParentType,
    ContextType
  >;
  bypassMode?: Resolver<
    Maybe<ResolversTypes["RepositoryRulesetBypassActorBypassMode"]>,
    ParentType,
    ContextType
  >;
  deployKey?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  organizationAdmin?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  repositoryRoleDatabaseId?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  repositoryRoleName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryRuleset?: Resolver<
    Maybe<ResolversTypes["RepositoryRuleset"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryRulesetBypassActorConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryRulesetBypassActorConnection"] = ResolversParentTypes["RepositoryRulesetBypassActorConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryRulesetBypassActorEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryRulesetBypassActor"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryRulesetBypassActorEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryRulesetBypassActorEdge"] = ResolversParentTypes["RepositoryRulesetBypassActorEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["RepositoryRulesetBypassActor"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryRulesetConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryRulesetConnection"] = ResolversParentTypes["RepositoryRulesetConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryRulesetEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryRuleset"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryRulesetEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryRulesetEdge"] = ResolversParentTypes["RepositoryRulesetEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["RepositoryRuleset"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryTopicResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryTopic"] = ResolversParentTypes["RepositoryTopic"],
> = {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  topic?: Resolver<ResolversTypes["Topic"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryTopicConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryTopicConnection"] = ResolversParentTypes["RepositoryTopicConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryTopicEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryTopic"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryTopicEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryTopicEdge"] = ResolversParentTypes["RepositoryTopicEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["RepositoryTopic"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryVisibilityChangeDisableAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryVisibilityChangeDisableAuditEntry"] = ResolversParentTypes["RepositoryVisibilityChangeDisableAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  enterpriseResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  enterpriseSlug?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterpriseUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryVisibilityChangeEnableAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryVisibilityChangeEnableAuditEntry"] = ResolversParentTypes["RepositoryVisibilityChangeEnableAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  enterpriseResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  enterpriseSlug?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterpriseUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryVulnerabilityAlertResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryVulnerabilityAlert"] = ResolversParentTypes["RepositoryVulnerabilityAlert"],
> = {
  autoDismissedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  dependabotUpdate?: Resolver<
    Maybe<ResolversTypes["DependabotUpdate"]>,
    ParentType,
    ContextType
  >;
  dependencyScope?: Resolver<
    Maybe<ResolversTypes["RepositoryVulnerabilityAlertDependencyScope"]>,
    ParentType,
    ContextType
  >;
  dismissComment?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  dismissReason?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  dismissedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  dismisser?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  fixedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  securityAdvisory?: Resolver<
    Maybe<ResolversTypes["SecurityAdvisory"]>,
    ParentType,
    ContextType
  >;
  securityVulnerability?: Resolver<
    Maybe<ResolversTypes["SecurityVulnerability"]>,
    ParentType,
    ContextType
  >;
  state?: Resolver<
    ResolversTypes["RepositoryVulnerabilityAlertState"],
    ParentType,
    ContextType
  >;
  vulnerableManifestFilename?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  vulnerableManifestPath?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  vulnerableRequirements?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryVulnerabilityAlertConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryVulnerabilityAlertConnection"] = ResolversParentTypes["RepositoryVulnerabilityAlertConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryVulnerabilityAlertEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RepositoryVulnerabilityAlert"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RepositoryVulnerabilityAlertEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RepositoryVulnerabilityAlertEdge"] = ResolversParentTypes["RepositoryVulnerabilityAlertEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["RepositoryVulnerabilityAlert"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RequestReviewsPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RequestReviewsPayload"] = ResolversParentTypes["RequestReviewsPayload"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  requestedReviewersEdge?: Resolver<
    Maybe<ResolversTypes["UserEdge"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RequestedReviewerResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RequestedReviewer"] = ResolversParentTypes["RequestedReviewer"],
> = {
  __resolveType: TypeResolveFn<
    "Bot" | "Mannequin" | "Team" | "User",
    ParentType,
    ContextType
  >;
};

export type RequestedReviewerConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RequestedReviewerConnection"] = ResolversParentTypes["RequestedReviewerConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RequestedReviewerEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["RequestedReviewer"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RequestedReviewerEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RequestedReviewerEdge"] = ResolversParentTypes["RequestedReviewerEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["RequestedReviewer"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RequirableByPullRequestResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RequirableByPullRequest"] = ResolversParentTypes["RequirableByPullRequest"],
> = {
  __resolveType: TypeResolveFn<
    "CheckRun" | "StatusContext",
    ParentType,
    ContextType
  >;
  isRequired?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    Partial<RequirableByPullRequestIsRequiredArgs>
  >;
};

export type RequiredDeploymentsParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RequiredDeploymentsParameters"] = ResolversParentTypes["RequiredDeploymentsParameters"],
> = {
  requiredDeploymentEnvironments?: Resolver<
    Array<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RequiredStatusCheckDescriptionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RequiredStatusCheckDescription"] = ResolversParentTypes["RequiredStatusCheckDescription"],
> = {
  app?: Resolver<Maybe<ResolversTypes["App"]>, ParentType, ContextType>;
  context?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RequiredStatusChecksParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RequiredStatusChecksParameters"] = ResolversParentTypes["RequiredStatusChecksParameters"],
> = {
  doNotEnforceOnCreate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  requiredStatusChecks?: Resolver<
    Array<ResolversTypes["StatusCheckConfiguration"]>,
    ParentType,
    ContextType
  >;
  strictRequiredStatusChecksPolicy?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RerequestCheckSuitePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RerequestCheckSuitePayload"] = ResolversParentTypes["RerequestCheckSuitePayload"],
> = {
  checkSuite?: Resolver<
    Maybe<ResolversTypes["CheckSuite"]>,
    ParentType,
    ContextType
  >;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ResolveReviewThreadPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ResolveReviewThreadPayload"] = ResolversParentTypes["ResolveReviewThreadPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  thread?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewThread"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RestrictedContributionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RestrictedContribution"] = ResolversParentTypes["RestrictedContribution"],
> = {
  isRestricted?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RetireSponsorsTierPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RetireSponsorsTierPayload"] = ResolversParentTypes["RetireSponsorsTierPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  sponsorsTier?: Resolver<
    Maybe<ResolversTypes["SponsorsTier"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RevertPullRequestPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RevertPullRequestPayload"] = ResolversParentTypes["RevertPullRequestPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  revertPullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewDismissalAllowanceResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReviewDismissalAllowance"] = ResolversParentTypes["ReviewDismissalAllowance"],
> = {
  actor?: Resolver<
    Maybe<ResolversTypes["ReviewDismissalAllowanceActor"]>,
    ParentType,
    ContextType
  >;
  branchProtectionRule?: Resolver<
    Maybe<ResolversTypes["BranchProtectionRule"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewDismissalAllowanceActorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReviewDismissalAllowanceActor"] = ResolversParentTypes["ReviewDismissalAllowanceActor"],
> = {
  __resolveType: TypeResolveFn<
    "App" | "Team" | "User",
    ParentType,
    ContextType
  >;
};

export type ReviewDismissalAllowanceConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReviewDismissalAllowanceConnection"] = ResolversParentTypes["ReviewDismissalAllowanceConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ReviewDismissalAllowanceEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ReviewDismissalAllowance"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewDismissalAllowanceEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReviewDismissalAllowanceEdge"] = ResolversParentTypes["ReviewDismissalAllowanceEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ReviewDismissalAllowance"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewDismissedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReviewDismissedEvent"] = ResolversParentTypes["ReviewDismissedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  dismissalMessage?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  dismissalMessageHTML?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  previousReviewState?: Resolver<
    ResolversTypes["PullRequestReviewState"],
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  pullRequestCommit?: Resolver<
    Maybe<ResolversTypes["PullRequestCommit"]>,
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  review?: Resolver<
    Maybe<ResolversTypes["PullRequestReview"]>,
    ParentType,
    ContextType
  >;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewRequestResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReviewRequest"] = ResolversParentTypes["ReviewRequest"],
> = {
  asCodeOwner?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  requestedReviewer?: Resolver<
    Maybe<ResolversTypes["RequestedReviewer"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewRequestConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReviewRequestConnection"] = ResolversParentTypes["ReviewRequestConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ReviewRequestEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["ReviewRequest"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewRequestEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReviewRequestEdge"] = ResolversParentTypes["ReviewRequestEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["ReviewRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewRequestRemovedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReviewRequestRemovedEvent"] = ResolversParentTypes["ReviewRequestRemovedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  requestedReviewer?: Resolver<
    Maybe<ResolversTypes["RequestedReviewer"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewRequestedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReviewRequestedEvent"] = ResolversParentTypes["ReviewRequestedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pullRequest?: Resolver<
    ResolversTypes["PullRequest"],
    ParentType,
    ContextType
  >;
  requestedReviewer?: Resolver<
    Maybe<ResolversTypes["RequestedReviewer"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewStatusHovercardContextResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ReviewStatusHovercardContext"] = ResolversParentTypes["ReviewStatusHovercardContext"],
> = {
  message?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  reviewDecision?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewDecision"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RevokeEnterpriseOrganizationsMigratorRolePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RevokeEnterpriseOrganizationsMigratorRolePayload"] = ResolversParentTypes["RevokeEnterpriseOrganizationsMigratorRolePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizations?: Resolver<
    Maybe<ResolversTypes["OrganizationConnection"]>,
    ParentType,
    ContextType,
    Partial<RevokeEnterpriseOrganizationsMigratorRolePayloadOrganizationsArgs>
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RevokeMigratorRolePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RevokeMigratorRolePayload"] = ResolversParentTypes["RevokeMigratorRolePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  success?: Resolver<Maybe<ResolversTypes["Boolean"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RuleParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RuleParameters"] = ResolversParentTypes["RuleParameters"],
> = {
  __resolveType: TypeResolveFn<
    | "BranchNamePatternParameters"
    | "CodeScanningParameters"
    | "CommitAuthorEmailPatternParameters"
    | "CommitMessagePatternParameters"
    | "CommitterEmailPatternParameters"
    | "FileExtensionRestrictionParameters"
    | "FilePathRestrictionParameters"
    | "MaxFilePathLengthParameters"
    | "MaxFileSizeParameters"
    | "MergeQueueParameters"
    | "PullRequestParameters"
    | "RequiredDeploymentsParameters"
    | "RequiredStatusChecksParameters"
    | "TagNamePatternParameters"
    | "UpdateParameters"
    | "WorkflowsParameters",
    ParentType,
    ContextType
  >;
};

export type RuleSourceResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["RuleSource"] = ResolversParentTypes["RuleSource"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "Repository",
    ParentType,
    ContextType
  >;
};

export type SavedReplyResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SavedReply"] = ResolversParentTypes["SavedReply"],
> = {
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SavedReplyConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SavedReplyConnection"] = ResolversParentTypes["SavedReplyConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SavedReplyEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SavedReply"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SavedReplyEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SavedReplyEdge"] = ResolversParentTypes["SavedReplyEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["SavedReply"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SearchResultItemResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SearchResultItem"] = ResolversParentTypes["SearchResultItem"],
> = {
  __resolveType: TypeResolveFn<
    | "App"
    | "Discussion"
    | "Issue"
    | "MarketplaceListing"
    | "Organization"
    | "PullRequest"
    | "Repository"
    | "User",
    ParentType,
    ContextType
  >;
};

export type SearchResultItemConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SearchResultItemConnection"] = ResolversParentTypes["SearchResultItemConnection"],
> = {
  codeCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  discussionCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SearchResultItemEdge"]>>>,
    ParentType,
    ContextType
  >;
  issueCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SearchResultItem"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  repositoryCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  userCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  wikiCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SearchResultItemEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SearchResultItemEdge"] = ResolversParentTypes["SearchResultItemEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["SearchResultItem"]>,
    ParentType,
    ContextType
  >;
  textMatches?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["TextMatch"]>>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SecurityAdvisoryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SecurityAdvisory"] = ResolversParentTypes["SecurityAdvisory"],
> = {
  classification?: Resolver<
    ResolversTypes["SecurityAdvisoryClassification"],
    ParentType,
    ContextType
  >;
  cvss?: Resolver<ResolversTypes["CVSS"], ParentType, ContextType>;
  cwes?: Resolver<
    ResolversTypes["CWEConnection"],
    ParentType,
    ContextType,
    Partial<SecurityAdvisoryCwesArgs>
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  ghsaId?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  identifiers?: Resolver<
    Array<ResolversTypes["SecurityAdvisoryIdentifier"]>,
    ParentType,
    ContextType
  >;
  notificationsPermalink?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  origin?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  permalink?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  publishedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  references?: Resolver<
    Array<ResolversTypes["SecurityAdvisoryReference"]>,
    ParentType,
    ContextType
  >;
  severity?: Resolver<
    ResolversTypes["SecurityAdvisorySeverity"],
    ParentType,
    ContextType
  >;
  summary?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  vulnerabilities?: Resolver<
    ResolversTypes["SecurityVulnerabilityConnection"],
    ParentType,
    ContextType,
    RequireFields<SecurityAdvisoryVulnerabilitiesArgs, "orderBy">
  >;
  withdrawnAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SecurityAdvisoryConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SecurityAdvisoryConnection"] = ResolversParentTypes["SecurityAdvisoryConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SecurityAdvisoryEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SecurityAdvisory"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SecurityAdvisoryEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SecurityAdvisoryEdge"] = ResolversParentTypes["SecurityAdvisoryEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["SecurityAdvisory"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SecurityAdvisoryIdentifierResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SecurityAdvisoryIdentifier"] = ResolversParentTypes["SecurityAdvisoryIdentifier"],
> = {
  type?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  value?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SecurityAdvisoryPackageResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SecurityAdvisoryPackage"] = ResolversParentTypes["SecurityAdvisoryPackage"],
> = {
  ecosystem?: Resolver<
    ResolversTypes["SecurityAdvisoryEcosystem"],
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SecurityAdvisoryPackageVersionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SecurityAdvisoryPackageVersion"] = ResolversParentTypes["SecurityAdvisoryPackageVersion"],
> = {
  identifier?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SecurityAdvisoryReferenceResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SecurityAdvisoryReference"] = ResolversParentTypes["SecurityAdvisoryReference"],
> = {
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SecurityVulnerabilityResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SecurityVulnerability"] = ResolversParentTypes["SecurityVulnerability"],
> = {
  advisory?: Resolver<
    ResolversTypes["SecurityAdvisory"],
    ParentType,
    ContextType
  >;
  firstPatchedVersion?: Resolver<
    Maybe<ResolversTypes["SecurityAdvisoryPackageVersion"]>,
    ParentType,
    ContextType
  >;
  package?: Resolver<
    ResolversTypes["SecurityAdvisoryPackage"],
    ParentType,
    ContextType
  >;
  severity?: Resolver<
    ResolversTypes["SecurityAdvisorySeverity"],
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  vulnerableVersionRange?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SecurityVulnerabilityConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SecurityVulnerabilityConnection"] = ResolversParentTypes["SecurityVulnerabilityConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SecurityVulnerabilityEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SecurityVulnerability"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SecurityVulnerabilityEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SecurityVulnerabilityEdge"] = ResolversParentTypes["SecurityVulnerabilityEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["SecurityVulnerability"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetEnterpriseIdentityProviderPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SetEnterpriseIdentityProviderPayload"] = ResolversParentTypes["SetEnterpriseIdentityProviderPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  identityProvider?: Resolver<
    Maybe<ResolversTypes["EnterpriseIdentityProvider"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetOrganizationInteractionLimitPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SetOrganizationInteractionLimitPayload"] = ResolversParentTypes["SetOrganizationInteractionLimitPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetRepositoryInteractionLimitPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SetRepositoryInteractionLimitPayload"] = ResolversParentTypes["SetRepositoryInteractionLimitPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetUserInteractionLimitPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SetUserInteractionLimitPayload"] = ResolversParentTypes["SetUserInteractionLimitPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SmimeSignatureResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SmimeSignature"] = ResolversParentTypes["SmimeSignature"],
> = {
  email?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  state?: Resolver<
    ResolversTypes["GitSignatureState"],
    ParentType,
    ContextType
  >;
  wasSignedByGitHub?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SocialAccountResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SocialAccount"] = ResolversParentTypes["SocialAccount"],
> = {
  displayName?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  provider?: Resolver<
    ResolversTypes["SocialAccountProvider"],
    ParentType,
    ContextType
  >;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SocialAccountConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SocialAccountConnection"] = ResolversParentTypes["SocialAccountConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SocialAccountEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SocialAccount"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SocialAccountEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SocialAccountEdge"] = ResolversParentTypes["SocialAccountEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["SocialAccount"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Sponsor"] = ResolversParentTypes["Sponsor"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "User",
    ParentType,
    ContextType
  >;
};

export type SponsorAndLifetimeValueResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorAndLifetimeValue"] = ResolversParentTypes["SponsorAndLifetimeValue"],
> = {
  amountInCents?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  formattedAmount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  sponsor?: Resolver<ResolversTypes["Sponsorable"], ParentType, ContextType>;
  sponsorable?: Resolver<
    ResolversTypes["Sponsorable"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorAndLifetimeValueConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorAndLifetimeValueConnection"] = ResolversParentTypes["SponsorAndLifetimeValueConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SponsorAndLifetimeValueEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SponsorAndLifetimeValue"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorAndLifetimeValueEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorAndLifetimeValueEdge"] = ResolversParentTypes["SponsorAndLifetimeValueEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["SponsorAndLifetimeValue"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorConnection"] = ResolversParentTypes["SponsorConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SponsorEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Sponsor"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorEdge"] = ResolversParentTypes["SponsorEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Sponsor"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Sponsorable"] = ResolversParentTypes["Sponsorable"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "User",
    ParentType,
    ContextType
  >;
  estimatedNextSponsorsPayoutInCents?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  hasSponsorsListing?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isSponsoredBy?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<SponsorableIsSponsoredByArgs, "accountLogin">
  >;
  isSponsoringViewer?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  lifetimeReceivedSponsorshipValues?: Resolver<
    ResolversTypes["SponsorAndLifetimeValueConnection"],
    ParentType,
    ContextType,
    RequireFields<SponsorableLifetimeReceivedSponsorshipValuesArgs, "orderBy">
  >;
  monthlyEstimatedSponsorsIncomeInCents?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  sponsoring?: Resolver<
    ResolversTypes["SponsorConnection"],
    ParentType,
    ContextType,
    RequireFields<SponsorableSponsoringArgs, "orderBy">
  >;
  sponsors?: Resolver<
    ResolversTypes["SponsorConnection"],
    ParentType,
    ContextType,
    RequireFields<SponsorableSponsorsArgs, "orderBy">
  >;
  sponsorsActivities?: Resolver<
    ResolversTypes["SponsorsActivityConnection"],
    ParentType,
    ContextType,
    RequireFields<
      SponsorableSponsorsActivitiesArgs,
      "actions" | "includeAsSponsor" | "includePrivate" | "orderBy" | "period"
    >
  >;
  sponsorsListing?: Resolver<
    Maybe<ResolversTypes["SponsorsListing"]>,
    ParentType,
    ContextType
  >;
  sponsorshipForViewerAsSponsor?: Resolver<
    Maybe<ResolversTypes["Sponsorship"]>,
    ParentType,
    ContextType,
    RequireFields<SponsorableSponsorshipForViewerAsSponsorArgs, "activeOnly">
  >;
  sponsorshipForViewerAsSponsorable?: Resolver<
    Maybe<ResolversTypes["Sponsorship"]>,
    ParentType,
    ContextType,
    RequireFields<
      SponsorableSponsorshipForViewerAsSponsorableArgs,
      "activeOnly"
    >
  >;
  sponsorshipNewsletters?: Resolver<
    ResolversTypes["SponsorshipNewsletterConnection"],
    ParentType,
    ContextType,
    RequireFields<SponsorableSponsorshipNewslettersArgs, "orderBy">
  >;
  sponsorshipsAsMaintainer?: Resolver<
    ResolversTypes["SponsorshipConnection"],
    ParentType,
    ContextType,
    RequireFields<
      SponsorableSponsorshipsAsMaintainerArgs,
      "activeOnly" | "includePrivate"
    >
  >;
  sponsorshipsAsSponsor?: Resolver<
    ResolversTypes["SponsorshipConnection"],
    ParentType,
    ContextType,
    RequireFields<SponsorableSponsorshipsAsSponsorArgs, "activeOnly">
  >;
  totalSponsorshipAmountAsSponsorInCents?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType,
    RequireFields<
      SponsorableTotalSponsorshipAmountAsSponsorInCentsArgs,
      "sponsorableLogins"
    >
  >;
  viewerCanSponsor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerIsSponsoring?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
};

export type SponsorableItemResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorableItem"] = ResolversParentTypes["SponsorableItem"],
> = {
  __resolveType: TypeResolveFn<
    "Organization" | "User",
    ParentType,
    ContextType
  >;
};

export type SponsorableItemConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorableItemConnection"] = ResolversParentTypes["SponsorableItemConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SponsorableItemEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SponsorableItem"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorableItemEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorableItemEdge"] = ResolversParentTypes["SponsorableItemEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["SponsorableItem"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorsActivityResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorsActivity"] = ResolversParentTypes["SponsorsActivity"],
> = {
  action?: Resolver<
    ResolversTypes["SponsorsActivityAction"],
    ParentType,
    ContextType
  >;
  currentPrivacyLevel?: Resolver<
    Maybe<ResolversTypes["SponsorshipPrivacy"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  paymentSource?: Resolver<
    Maybe<ResolversTypes["SponsorshipPaymentSource"]>,
    ParentType,
    ContextType
  >;
  previousSponsorsTier?: Resolver<
    Maybe<ResolversTypes["SponsorsTier"]>,
    ParentType,
    ContextType
  >;
  sponsor?: Resolver<Maybe<ResolversTypes["Sponsor"]>, ParentType, ContextType>;
  sponsorable?: Resolver<
    ResolversTypes["Sponsorable"],
    ParentType,
    ContextType
  >;
  sponsorsTier?: Resolver<
    Maybe<ResolversTypes["SponsorsTier"]>,
    ParentType,
    ContextType
  >;
  timestamp?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  viaBulkSponsorship?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorsActivityConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorsActivityConnection"] = ResolversParentTypes["SponsorsActivityConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SponsorsActivityEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SponsorsActivity"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorsActivityEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorsActivityEdge"] = ResolversParentTypes["SponsorsActivityEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["SponsorsActivity"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorsGoalResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorsGoal"] = ResolversParentTypes["SponsorsGoal"],
> = {
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  kind?: Resolver<ResolversTypes["SponsorsGoalKind"], ParentType, ContextType>;
  percentComplete?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  targetValue?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorsListingResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorsListing"] = ResolversParentTypes["SponsorsListing"],
> = {
  activeGoal?: Resolver<
    Maybe<ResolversTypes["SponsorsGoal"]>,
    ParentType,
    ContextType
  >;
  activeStripeConnectAccount?: Resolver<
    Maybe<ResolversTypes["StripeConnectAccount"]>,
    ParentType,
    ContextType
  >;
  billingCountryOrRegion?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  contactEmailAddress?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  dashboardResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  dashboardUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  featuredItems?: Resolver<
    Array<ResolversTypes["SponsorsListingFeaturedItem"]>,
    ParentType,
    ContextType,
    RequireFields<SponsorsListingFeaturedItemsArgs, "featureableTypes">
  >;
  fiscalHost?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  fullDescription?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  fullDescriptionHTML?: Resolver<
    ResolversTypes["HTML"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isPublic?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  nextPayoutDate?: Resolver<
    Maybe<ResolversTypes["Date"]>,
    ParentType,
    ContextType
  >;
  residenceCountryOrRegion?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  shortDescription?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  slug?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  sponsorable?: Resolver<
    ResolversTypes["Sponsorable"],
    ParentType,
    ContextType
  >;
  tiers?: Resolver<
    Maybe<ResolversTypes["SponsorsTierConnection"]>,
    ParentType,
    ContextType,
    RequireFields<SponsorsListingTiersArgs, "includeUnpublished" | "orderBy">
  >;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorsListingFeatureableItemResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorsListingFeatureableItem"] = ResolversParentTypes["SponsorsListingFeatureableItem"],
> = {
  __resolveType: TypeResolveFn<"Repository" | "User", ParentType, ContextType>;
};

export type SponsorsListingFeaturedItemResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorsListingFeaturedItem"] = ResolversParentTypes["SponsorsListingFeaturedItem"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  featureable?: Resolver<
    ResolversTypes["SponsorsListingFeatureableItem"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  position?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  sponsorsListing?: Resolver<
    ResolversTypes["SponsorsListing"],
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorsTierResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorsTier"] = ResolversParentTypes["SponsorsTier"],
> = {
  adminInfo?: Resolver<
    Maybe<ResolversTypes["SponsorsTierAdminInfo"]>,
    ParentType,
    ContextType
  >;
  closestLesserValueTier?: Resolver<
    Maybe<ResolversTypes["SponsorsTier"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  description?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isCustomAmount?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isOneTime?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  monthlyPriceInCents?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  monthlyPriceInDollars?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  sponsorsListing?: Resolver<
    ResolversTypes["SponsorsListing"],
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorsTierAdminInfoResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorsTierAdminInfo"] = ResolversParentTypes["SponsorsTierAdminInfo"],
> = {
  isDraft?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isPublished?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isRetired?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  sponsorships?: Resolver<
    ResolversTypes["SponsorshipConnection"],
    ParentType,
    ContextType,
    RequireFields<SponsorsTierAdminInfoSponsorshipsArgs, "includePrivate">
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorsTierConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorsTierConnection"] = ResolversParentTypes["SponsorsTierConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SponsorsTierEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SponsorsTier"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorsTierEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorsTierEdge"] = ResolversParentTypes["SponsorsTierEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["SponsorsTier"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorshipResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Sponsorship"] = ResolversParentTypes["Sponsorship"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isOneTimePayment?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isSponsorOptedIntoEmail?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  maintainer?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  paymentSource?: Resolver<
    Maybe<ResolversTypes["SponsorshipPaymentSource"]>,
    ParentType,
    ContextType
  >;
  privacyLevel?: Resolver<
    ResolversTypes["SponsorshipPrivacy"],
    ParentType,
    ContextType
  >;
  sponsor?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  sponsorEntity?: Resolver<
    Maybe<ResolversTypes["Sponsor"]>,
    ParentType,
    ContextType
  >;
  sponsorable?: Resolver<
    ResolversTypes["Sponsorable"],
    ParentType,
    ContextType
  >;
  tier?: Resolver<
    Maybe<ResolversTypes["SponsorsTier"]>,
    ParentType,
    ContextType
  >;
  tierSelectedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorshipConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorshipConnection"] = ResolversParentTypes["SponsorshipConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SponsorshipEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Sponsorship"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  totalRecurringMonthlyPriceInCents?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  totalRecurringMonthlyPriceInDollars?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorshipEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorshipEdge"] = ResolversParentTypes["SponsorshipEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["Sponsorship"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorshipNewsletterResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorshipNewsletter"] = ResolversParentTypes["SponsorshipNewsletter"],
> = {
  author?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isPublished?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  sponsorable?: Resolver<
    ResolversTypes["Sponsorable"],
    ParentType,
    ContextType
  >;
  subject?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorshipNewsletterConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorshipNewsletterConnection"] = ResolversParentTypes["SponsorshipNewsletterConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SponsorshipNewsletterEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SponsorshipNewsletter"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SponsorshipNewsletterEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SponsorshipNewsletterEdge"] = ResolversParentTypes["SponsorshipNewsletterEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["SponsorshipNewsletter"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SshSignatureResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SshSignature"] = ResolversParentTypes["SshSignature"],
> = {
  email?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  keyFingerprint?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  payload?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  state?: Resolver<
    ResolversTypes["GitSignatureState"],
    ParentType,
    ContextType
  >;
  wasSignedByGitHub?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StargazerConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StargazerConnection"] = ResolversParentTypes["StargazerConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["StargazerEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["User"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StargazerEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StargazerEdge"] = ResolversParentTypes["StargazerEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  starredAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StarrableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Starrable"] = ResolversParentTypes["Starrable"],
> = {
  __resolveType: TypeResolveFn<
    "Gist" | "Repository" | "Topic",
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  stargazerCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  stargazers?: Resolver<
    ResolversTypes["StargazerConnection"],
    ParentType,
    ContextType,
    Partial<StarrableStargazersArgs>
  >;
  viewerHasStarred?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
};

export type StarredRepositoryConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StarredRepositoryConnection"] = ResolversParentTypes["StarredRepositoryConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["StarredRepositoryEdge"]>>>,
    ParentType,
    ContextType
  >;
  isOverLimit?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Repository"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StarredRepositoryEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StarredRepositoryEdge"] = ResolversParentTypes["StarredRepositoryEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  starredAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StartOrganizationMigrationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StartOrganizationMigrationPayload"] = ResolversParentTypes["StartOrganizationMigrationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  orgMigration?: Resolver<
    Maybe<ResolversTypes["OrganizationMigration"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StartRepositoryMigrationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StartRepositoryMigrationPayload"] = ResolversParentTypes["StartRepositoryMigrationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryMigration?: Resolver<
    Maybe<ResolversTypes["RepositoryMigration"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Status"] = ResolversParentTypes["Status"],
> = {
  combinedContexts?: Resolver<
    ResolversTypes["StatusCheckRollupContextConnection"],
    ParentType,
    ContextType,
    Partial<StatusCombinedContextsArgs>
  >;
  commit?: Resolver<Maybe<ResolversTypes["Commit"]>, ParentType, ContextType>;
  context?: Resolver<
    Maybe<ResolversTypes["StatusContext"]>,
    ParentType,
    ContextType,
    RequireFields<StatusContextArgs, "name">
  >;
  contexts?: Resolver<
    Array<ResolversTypes["StatusContext"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  state?: Resolver<ResolversTypes["StatusState"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusCheckConfigurationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StatusCheckConfiguration"] = ResolversParentTypes["StatusCheckConfiguration"],
> = {
  context?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  integrationId?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusCheckRollupResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StatusCheckRollup"] = ResolversParentTypes["StatusCheckRollup"],
> = {
  commit?: Resolver<Maybe<ResolversTypes["Commit"]>, ParentType, ContextType>;
  contexts?: Resolver<
    ResolversTypes["StatusCheckRollupContextConnection"],
    ParentType,
    ContextType,
    Partial<StatusCheckRollupContextsArgs>
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  state?: Resolver<ResolversTypes["StatusState"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusCheckRollupContextResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StatusCheckRollupContext"] = ResolversParentTypes["StatusCheckRollupContext"],
> = {
  __resolveType: TypeResolveFn<
    "CheckRun" | "StatusContext",
    ParentType,
    ContextType
  >;
};

export type StatusCheckRollupContextConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StatusCheckRollupContextConnection"] = ResolversParentTypes["StatusCheckRollupContextConnection"],
> = {
  checkRunCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  checkRunCountsByState?: Resolver<
    Maybe<Array<ResolversTypes["CheckRunStateCount"]>>,
    ParentType,
    ContextType
  >;
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["StatusCheckRollupContextEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["StatusCheckRollupContext"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  statusContextCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  statusContextCountsByState?: Resolver<
    Maybe<Array<ResolversTypes["StatusContextStateCount"]>>,
    ParentType,
    ContextType
  >;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusCheckRollupContextEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StatusCheckRollupContextEdge"] = ResolversParentTypes["StatusCheckRollupContextEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["StatusCheckRollupContext"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusContextResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StatusContext"] = ResolversParentTypes["StatusContext"],
> = {
  avatarUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType,
    RequireFields<StatusContextAvatarUrlArgs, "size">
  >;
  commit?: Resolver<Maybe<ResolversTypes["Commit"]>, ParentType, ContextType>;
  context?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isRequired?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    Partial<StatusContextIsRequiredArgs>
  >;
  state?: Resolver<ResolversTypes["StatusState"], ParentType, ContextType>;
  targetUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusContextStateCountResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StatusContextStateCount"] = ResolversParentTypes["StatusContextStateCount"],
> = {
  count?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  state?: Resolver<ResolversTypes["StatusState"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StripeConnectAccountResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["StripeConnectAccount"] = ResolversParentTypes["StripeConnectAccount"],
> = {
  accountId?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  billingCountryOrRegion?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  countryOrRegion?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  isActive?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  sponsorsListing?: Resolver<
    ResolversTypes["SponsorsListing"],
    ParentType,
    ContextType
  >;
  stripeDashboardUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubmitPullRequestReviewPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SubmitPullRequestReviewPayload"] = ResolversParentTypes["SubmitPullRequestReviewPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequestReview?: Resolver<
    Maybe<ResolversTypes["PullRequestReview"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubmoduleResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Submodule"] = ResolversParentTypes["Submodule"],
> = {
  branch?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  gitUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  nameRaw?: Resolver<ResolversTypes["Base64String"], ParentType, ContextType>;
  path?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pathRaw?: Resolver<ResolversTypes["Base64String"], ParentType, ContextType>;
  subprojectCommitOid?: Resolver<
    Maybe<ResolversTypes["GitObjectID"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubmoduleConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SubmoduleConnection"] = ResolversParentTypes["SubmoduleConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["SubmoduleEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Submodule"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubmoduleEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SubmoduleEdge"] = ResolversParentTypes["SubmoduleEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Submodule"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubscribableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Subscribable"] = ResolversParentTypes["Subscribable"],
> = {
  __resolveType: TypeResolveFn<
    | "Commit"
    | "Discussion"
    | "Issue"
    | "PullRequest"
    | "Repository"
    | "Team"
    | "TeamDiscussion",
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerSubscription?: Resolver<
    Maybe<ResolversTypes["SubscriptionState"]>,
    ParentType,
    ContextType
  >;
};

export type SubscribableThreadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SubscribableThread"] = ResolversParentTypes["SubscribableThread"],
> = {
  __resolveType: TypeResolveFn<"Issue", ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  viewerThreadSubscriptionFormAction?: Resolver<
    Maybe<ResolversTypes["ThreadSubscriptionFormAction"]>,
    ParentType,
    ContextType
  >;
  viewerThreadSubscriptionStatus?: Resolver<
    Maybe<ResolversTypes["ThreadSubscriptionState"]>,
    ParentType,
    ContextType
  >;
};

export type SubscribedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SubscribedEvent"] = ResolversParentTypes["SubscribedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  subscribable?: Resolver<
    ResolversTypes["Subscribable"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SuggestedReviewerResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["SuggestedReviewer"] = ResolversParentTypes["SuggestedReviewer"],
> = {
  isAuthor?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isCommenter?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  reviewer?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Tag"] = ResolversParentTypes["Tag"],
> = {
  abbreviatedOid?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes["GitObjectID"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  tagger?: Resolver<Maybe<ResolversTypes["GitActor"]>, ParentType, ContextType>;
  target?: Resolver<ResolversTypes["GitObject"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagNamePatternParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TagNamePatternParameters"] = ResolversParentTypes["TagNamePatternParameters"],
> = {
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Team"] = ResolversParentTypes["Team"],
> = {
  ancestors?: Resolver<
    ResolversTypes["TeamConnection"],
    ParentType,
    ContextType,
    Partial<TeamAncestorsArgs>
  >;
  avatarUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType,
    RequireFields<TeamAvatarUrlArgs, "size">
  >;
  childTeams?: Resolver<
    ResolversTypes["TeamConnection"],
    ParentType,
    ContextType,
    RequireFields<TeamChildTeamsArgs, "immediateOnly">
  >;
  combinedSlug?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  discussion?: Resolver<
    Maybe<ResolversTypes["TeamDiscussion"]>,
    ParentType,
    ContextType,
    RequireFields<TeamDiscussionArgs, "number">
  >;
  discussions?: Resolver<
    ResolversTypes["TeamDiscussionConnection"],
    ParentType,
    ContextType,
    Partial<TeamDiscussionsArgs>
  >;
  discussionsResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  discussionsUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  editTeamResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  editTeamUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  invitations?: Resolver<
    Maybe<ResolversTypes["OrganizationInvitationConnection"]>,
    ParentType,
    ContextType,
    Partial<TeamInvitationsArgs>
  >;
  memberStatuses?: Resolver<
    ResolversTypes["UserStatusConnection"],
    ParentType,
    ContextType,
    RequireFields<TeamMemberStatusesArgs, "orderBy">
  >;
  members?: Resolver<
    ResolversTypes["TeamMemberConnection"],
    ParentType,
    ContextType,
    RequireFields<TeamMembersArgs, "membership">
  >;
  membersResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  membersUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  newTeamResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  newTeamUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  notificationSetting?: Resolver<
    ResolversTypes["TeamNotificationSetting"],
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    ResolversTypes["Organization"],
    ParentType,
    ContextType
  >;
  parentTeam?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  privacy?: Resolver<ResolversTypes["TeamPrivacy"], ParentType, ContextType>;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType,
    RequireFields<TeamProjectV2Args, "number">
  >;
  projectsV2?: Resolver<
    ResolversTypes["ProjectV2Connection"],
    ParentType,
    ContextType,
    RequireFields<
      TeamProjectsV2Args,
      "filterBy" | "minPermissionLevel" | "orderBy" | "query"
    >
  >;
  repositories?: Resolver<
    ResolversTypes["TeamRepositoryConnection"],
    ParentType,
    ContextType,
    Partial<TeamRepositoriesArgs>
  >;
  repositoriesResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  repositoriesUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  reviewRequestDelegationAlgorithm?: Resolver<
    Maybe<ResolversTypes["TeamReviewAssignmentAlgorithm"]>,
    ParentType,
    ContextType
  >;
  reviewRequestDelegationEnabled?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  reviewRequestDelegationMemberCount?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType
  >;
  reviewRequestDelegationNotifyTeam?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  slug?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  teamsResourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  teamsUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanSubscribe?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerSubscription?: Resolver<
    Maybe<ResolversTypes["SubscriptionState"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamAddMemberAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamAddMemberAuditEntry"] = ResolversParentTypes["TeamAddMemberAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isLdapMapped?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  team?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  teamResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  teamUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamAddRepositoryAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamAddRepositoryAuditEntry"] = ResolversParentTypes["TeamAddRepositoryAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isLdapMapped?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  team?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  teamResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  teamUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamAuditEntryDataResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamAuditEntryData"] = ResolversParentTypes["TeamAuditEntryData"],
> = {
  __resolveType: TypeResolveFn<
    | "OrgRestoreMemberMembershipTeamAuditEntryData"
    | "TeamAddMemberAuditEntry"
    | "TeamAddRepositoryAuditEntry"
    | "TeamChangeParentTeamAuditEntry"
    | "TeamRemoveMemberAuditEntry"
    | "TeamRemoveRepositoryAuditEntry",
    ParentType,
    ContextType
  >;
  team?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  teamResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  teamUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
};

export type TeamChangeParentTeamAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamChangeParentTeamAuditEntry"] = ResolversParentTypes["TeamChangeParentTeamAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isLdapMapped?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  parentTeam?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  parentTeamName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  parentTeamNameWas?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  parentTeamResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  parentTeamUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  parentTeamWas?: Resolver<
    Maybe<ResolversTypes["Team"]>,
    ParentType,
    ContextType
  >;
  parentTeamWasResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  parentTeamWasUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  team?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  teamResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  teamUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamConnection"] = ResolversParentTypes["TeamConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["TeamEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Team"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamDiscussionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamDiscussion"] = ResolversParentTypes["TeamDiscussion"],
> = {
  author?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  authorAssociation?: Resolver<
    ResolversTypes["CommentAuthorAssociation"],
    ParentType,
    ContextType
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyVersion?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  comments?: Resolver<
    ResolversTypes["TeamDiscussionCommentConnection"],
    ParentType,
    ContextType,
    Partial<TeamDiscussionCommentsArgs>
  >;
  commentsResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  commentsUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  createdViaEmail?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isPinned?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  lastEditedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  reactions?: Resolver<
    ResolversTypes["ReactionConnection"],
    ParentType,
    ContextType,
    Partial<TeamDiscussionReactionsArgs>
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  team?: Resolver<ResolversTypes["Team"], ParentType, ContextType>;
  title?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  userContentEdits?: Resolver<
    Maybe<ResolversTypes["UserContentEditConnection"]>,
    ParentType,
    ContextType,
    Partial<TeamDiscussionUserContentEditsArgs>
  >;
  viewerCanDelete?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanPin?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCannotUpdateReasons?: Resolver<
    Array<ResolversTypes["CommentCannotUpdateReason"]>,
    ParentType,
    ContextType
  >;
  viewerDidAuthor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerSubscription?: Resolver<
    Maybe<ResolversTypes["SubscriptionState"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamDiscussionCommentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamDiscussionComment"] = ResolversParentTypes["TeamDiscussionComment"],
> = {
  author?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  authorAssociation?: Resolver<
    ResolversTypes["CommentAuthorAssociation"],
    ParentType,
    ContextType
  >;
  body?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  bodyVersion?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  createdViaEmail?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  discussion?: Resolver<
    ResolversTypes["TeamDiscussion"],
    ParentType,
    ContextType
  >;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  lastEditedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  number?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  publishedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  reactionGroups?: Resolver<
    Maybe<Array<ResolversTypes["ReactionGroup"]>>,
    ParentType,
    ContextType
  >;
  reactions?: Resolver<
    ResolversTypes["ReactionConnection"],
    ParentType,
    ContextType,
    Partial<TeamDiscussionCommentReactionsArgs>
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  userContentEdits?: Resolver<
    Maybe<ResolversTypes["UserContentEditConnection"]>,
    ParentType,
    ContextType,
    Partial<TeamDiscussionCommentUserContentEditsArgs>
  >;
  viewerCanDelete?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanReact?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCannotUpdateReasons?: Resolver<
    Array<ResolversTypes["CommentCannotUpdateReason"]>,
    ParentType,
    ContextType
  >;
  viewerDidAuthor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamDiscussionCommentConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamDiscussionCommentConnection"] = ResolversParentTypes["TeamDiscussionCommentConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["TeamDiscussionCommentEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["TeamDiscussionComment"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamDiscussionCommentEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamDiscussionCommentEdge"] = ResolversParentTypes["TeamDiscussionCommentEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["TeamDiscussionComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamDiscussionConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamDiscussionConnection"] = ResolversParentTypes["TeamDiscussionConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["TeamDiscussionEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["TeamDiscussion"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamDiscussionEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamDiscussionEdge"] = ResolversParentTypes["TeamDiscussionEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["TeamDiscussion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamEdge"] = ResolversParentTypes["TeamEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamMemberConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamMemberConnection"] = ResolversParentTypes["TeamMemberConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["TeamMemberEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["User"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamMemberEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamMemberEdge"] = ResolversParentTypes["TeamMemberEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  memberAccessResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  memberAccessUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  node?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  role?: Resolver<ResolversTypes["TeamMemberRole"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamRemoveMemberAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamRemoveMemberAuditEntry"] = ResolversParentTypes["TeamRemoveMemberAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isLdapMapped?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  team?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  teamResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  teamUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamRemoveRepositoryAuditEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamRemoveRepositoryAuditEntry"] = ResolversParentTypes["TeamRemoveRepositoryAuditEntry"],
> = {
  action?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  actor?: Resolver<
    Maybe<ResolversTypes["AuditEntryActor"]>,
    ParentType,
    ContextType
  >;
  actorIp?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  actorLocation?: Resolver<
    Maybe<ResolversTypes["ActorLocation"]>,
    ParentType,
    ContextType
  >;
  actorLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  actorResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  actorUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes["PreciseDateTime"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isLdapMapped?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  operationType?: Resolver<
    Maybe<ResolversTypes["OperationType"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  organizationName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organizationResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  organizationUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  repositoryName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repositoryResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  repositoryUrl?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  team?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  teamResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  teamUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  userLogin?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  userResourcePath?: Resolver<
    Maybe<ResolversTypes["URI"]>,
    ParentType,
    ContextType
  >;
  userUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamRepositoryConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamRepositoryConnection"] = ResolversParentTypes["TeamRepositoryConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["TeamRepositoryEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Repository"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TeamRepositoryEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TeamRepositoryEdge"] = ResolversParentTypes["TeamRepositoryEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  permission?: Resolver<
    ResolversTypes["RepositoryPermission"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TextMatchResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TextMatch"] = ResolversParentTypes["TextMatch"],
> = {
  fragment?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  highlights?: Resolver<
    Array<ResolversTypes["TextMatchHighlight"]>,
    ParentType,
    ContextType
  >;
  property?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TextMatchHighlightResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TextMatchHighlight"] = ResolversParentTypes["TextMatchHighlight"],
> = {
  beginIndice?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  endIndice?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  text?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TopicResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Topic"] = ResolversParentTypes["Topic"],
> = {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  relatedTopics?: Resolver<
    Array<ResolversTypes["Topic"]>,
    ParentType,
    ContextType,
    RequireFields<TopicRelatedTopicsArgs, "first">
  >;
  repositories?: Resolver<
    ResolversTypes["RepositoryConnection"],
    ParentType,
    ContextType,
    RequireFields<
      TopicRepositoriesArgs,
      "ownerAffiliations" | "sponsorableOnly"
    >
  >;
  stargazerCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  stargazers?: Resolver<
    ResolversTypes["StargazerConnection"],
    ParentType,
    ContextType,
    Partial<TopicStargazersArgs>
  >;
  viewerHasStarred?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TopicAuditEntryDataResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TopicAuditEntryData"] = ResolversParentTypes["TopicAuditEntryData"],
> = {
  __resolveType: TypeResolveFn<
    "RepoAddTopicAuditEntry" | "RepoRemoveTopicAuditEntry",
    ParentType,
    ContextType
  >;
  topic?: Resolver<Maybe<ResolversTypes["Topic"]>, ParentType, ContextType>;
  topicName?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
};

export type TransferEnterpriseOrganizationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TransferEnterpriseOrganizationPayload"] = ResolversParentTypes["TransferEnterpriseOrganizationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransferIssuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TransferIssuePayload"] = ResolversParentTypes["TransferIssuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  issue?: Resolver<Maybe<ResolversTypes["Issue"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransferredEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TransferredEvent"] = ResolversParentTypes["TransferredEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  fromRepository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes["Issue"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TreeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Tree"] = ResolversParentTypes["Tree"],
> = {
  abbreviatedOid?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  entries?: Resolver<
    Maybe<Array<ResolversTypes["TreeEntry"]>>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes["GitObjectID"], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TreeEntryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["TreeEntry"] = ResolversParentTypes["TreeEntry"],
> = {
  extension?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  isGenerated?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  language?: Resolver<
    Maybe<ResolversTypes["Language"]>,
    ParentType,
    ContextType
  >;
  lineCount?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  mode?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  nameRaw?: Resolver<ResolversTypes["Base64String"], ParentType, ContextType>;
  object?: Resolver<
    Maybe<ResolversTypes["GitObject"]>,
    ParentType,
    ContextType
  >;
  oid?: Resolver<ResolversTypes["GitObjectID"], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  pathRaw?: Resolver<
    Maybe<ResolversTypes["Base64String"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<ResolversTypes["Repository"], ParentType, ContextType>;
  size?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  submodule?: Resolver<
    Maybe<ResolversTypes["Submodule"]>,
    ParentType,
    ContextType
  >;
  type?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface UriScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["URI"], any> {
  name: "URI";
}

export type UnarchiveProjectV2ItemPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnarchiveProjectV2ItemPayload"] = ResolversParentTypes["UnarchiveProjectV2ItemPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  item?: Resolver<
    Maybe<ResolversTypes["ProjectV2Item"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnarchiveRepositoryPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnarchiveRepositoryPayload"] = ResolversParentTypes["UnarchiveRepositoryPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnassignedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnassignedEvent"] = ResolversParentTypes["UnassignedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  assignable?: Resolver<ResolversTypes["Assignable"], ParentType, ContextType>;
  assignee?: Resolver<
    Maybe<ResolversTypes["Assignee"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnfollowOrganizationPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnfollowOrganizationPayload"] = ResolversParentTypes["UnfollowOrganizationPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnfollowUserPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnfollowUserPayload"] = ResolversParentTypes["UnfollowUserPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UniformResourceLocatableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UniformResourceLocatable"] = ResolversParentTypes["UniformResourceLocatable"],
> = {
  __resolveType: TypeResolveFn<
    | "Bot"
    | "CheckRun"
    | "ClosedEvent"
    | "Commit"
    | "ConvertToDraftEvent"
    | "CrossReferencedEvent"
    | "Gist"
    | "Issue"
    | "Mannequin"
    | "MergedEvent"
    | "Milestone"
    | "Organization"
    | "PullRequest"
    | "PullRequestCommit"
    | "ReadyForReviewEvent"
    | "Release"
    | "Repository"
    | "RepositoryTopic"
    | "ReviewDismissedEvent"
    | "TeamDiscussion"
    | "TeamDiscussionComment"
    | "User"
    | "Workflow"
    | "WorkflowRun"
    | "WorkflowRunFile",
    ParentType,
    ContextType
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
};

export type UnknownSignatureResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnknownSignature"] = ResolversParentTypes["UnknownSignature"],
> = {
  email?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  state?: Resolver<
    ResolversTypes["GitSignatureState"],
    ParentType,
    ContextType
  >;
  wasSignedByGitHub?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnlabeledEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnlabeledEvent"] = ResolversParentTypes["UnlabeledEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  label?: Resolver<ResolversTypes["Label"], ParentType, ContextType>;
  labelable?: Resolver<ResolversTypes["Labelable"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnlinkProjectV2FromRepositoryPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnlinkProjectV2FromRepositoryPayload"] = ResolversParentTypes["UnlinkProjectV2FromRepositoryPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnlinkProjectV2FromTeamPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnlinkProjectV2FromTeamPayload"] = ResolversParentTypes["UnlinkProjectV2FromTeamPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  team?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnlinkRepositoryFromProjectPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnlinkRepositoryFromProjectPayload"] = ResolversParentTypes["UnlinkRepositoryFromProjectPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  project?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnlockLockablePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnlockLockablePayload"] = ResolversParentTypes["UnlockLockablePayload"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  unlockedRecord?: Resolver<
    Maybe<ResolversTypes["Lockable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnlockedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnlockedEvent"] = ResolversParentTypes["UnlockedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lockable?: Resolver<ResolversTypes["Lockable"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnmarkDiscussionCommentAsAnswerPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnmarkDiscussionCommentAsAnswerPayload"] = ResolversParentTypes["UnmarkDiscussionCommentAsAnswerPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  discussion?: Resolver<
    Maybe<ResolversTypes["Discussion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnmarkFileAsViewedPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnmarkFileAsViewedPayload"] = ResolversParentTypes["UnmarkFileAsViewedPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnmarkIssueAsDuplicatePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnmarkIssueAsDuplicatePayload"] = ResolversParentTypes["UnmarkIssueAsDuplicatePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  duplicate?: Resolver<
    Maybe<ResolversTypes["IssueOrPullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnmarkProjectV2AsTemplatePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnmarkProjectV2AsTemplatePayload"] = ResolversParentTypes["UnmarkProjectV2AsTemplatePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnmarkedAsDuplicateEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnmarkedAsDuplicateEvent"] = ResolversParentTypes["UnmarkedAsDuplicateEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  canonical?: Resolver<
    Maybe<ResolversTypes["IssueOrPullRequest"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  duplicate?: Resolver<
    Maybe<ResolversTypes["IssueOrPullRequest"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isCrossRepository?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnminimizeCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnminimizeCommentPayload"] = ResolversParentTypes["UnminimizeCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  unminimizedComment?: Resolver<
    Maybe<ResolversTypes["Minimizable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnpinIssuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnpinIssuePayload"] = ResolversParentTypes["UnpinIssuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<Maybe<ResolversTypes["ID"]>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes["Issue"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnpinnedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnpinnedEvent"] = ResolversParentTypes["UnpinnedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes["Issue"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnresolveReviewThreadPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnresolveReviewThreadPayload"] = ResolversParentTypes["UnresolveReviewThreadPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  thread?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewThread"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnsubscribeFromNotificationsPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnsubscribeFromNotificationsPayload"] = ResolversParentTypes["UnsubscribeFromNotificationsPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  success?: Resolver<Maybe<ResolversTypes["Boolean"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnsubscribedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UnsubscribedEvent"] = ResolversParentTypes["UnsubscribedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  subscribable?: Resolver<
    ResolversTypes["Subscribable"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Updatable"] = ResolversParentTypes["Updatable"],
> = {
  __resolveType: TypeResolveFn<
    | "CommitComment"
    | "Discussion"
    | "DiscussionComment"
    | "GistComment"
    | "Issue"
    | "IssueComment"
    | "Project"
    | "ProjectV2"
    | "PullRequest"
    | "PullRequestReview"
    | "PullRequestReviewComment"
    | "TeamDiscussion"
    | "TeamDiscussionComment",
    ParentType,
    ContextType
  >;
  viewerCanUpdate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
};

export type UpdatableCommentResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdatableComment"] = ResolversParentTypes["UpdatableComment"],
> = {
  __resolveType: TypeResolveFn<
    | "CommitComment"
    | "DiscussionComment"
    | "GistComment"
    | "Issue"
    | "IssueComment"
    | "PullRequest"
    | "PullRequestReview"
    | "PullRequestReviewComment"
    | "TeamDiscussion"
    | "TeamDiscussionComment",
    ParentType,
    ContextType
  >;
  viewerCannotUpdateReasons?: Resolver<
    Array<ResolversTypes["CommentCannotUpdateReason"]>,
    ParentType,
    ContextType
  >;
};

export type UpdateBranchProtectionRulePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateBranchProtectionRulePayload"] = ResolversParentTypes["UpdateBranchProtectionRulePayload"],
> = {
  branchProtectionRule?: Resolver<
    Maybe<ResolversTypes["BranchProtectionRule"]>,
    ParentType,
    ContextType
  >;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateCheckRunPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateCheckRunPayload"] = ResolversParentTypes["UpdateCheckRunPayload"],
> = {
  checkRun?: Resolver<
    Maybe<ResolversTypes["CheckRun"]>,
    ParentType,
    ContextType
  >;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateCheckSuitePreferencesPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateCheckSuitePreferencesPayload"] = ResolversParentTypes["UpdateCheckSuitePreferencesPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDiscussionCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateDiscussionCommentPayload"] = ResolversParentTypes["UpdateDiscussionCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  comment?: Resolver<
    Maybe<ResolversTypes["DiscussionComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDiscussionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateDiscussionPayload"] = ResolversParentTypes["UpdateDiscussionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  discussion?: Resolver<
    Maybe<ResolversTypes["Discussion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseAdministratorRolePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseAdministratorRolePayload"] = ResolversParentTypes["UpdateEnterpriseAdministratorRolePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload"] = ResolversParentTypes["UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseDefaultRepositoryPermissionSettingPayload"] = ResolversParentTypes["UpdateEnterpriseDefaultRepositoryPermissionSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload"] = ResolversParentTypes["UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload"] = ResolversParentTypes["UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseMembersCanDeleteIssuesSettingPayload"] = ResolversParentTypes["UpdateEnterpriseMembersCanDeleteIssuesSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload"] = ResolversParentTypes["UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload"] = ResolversParentTypes["UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseMembersCanMakePurchasesSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseMembersCanMakePurchasesSettingPayload"] = ResolversParentTypes["UpdateEnterpriseMembersCanMakePurchasesSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload"] = ResolversParentTypes["UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload"] = ResolversParentTypes["UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseOrganizationProjectsSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseOrganizationProjectsSettingPayload"] = ResolversParentTypes["UpdateEnterpriseOrganizationProjectsSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseOwnerOrganizationRolePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseOwnerOrganizationRolePayload"] = ResolversParentTypes["UpdateEnterpriseOwnerOrganizationRolePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseProfilePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseProfilePayload"] = ResolversParentTypes["UpdateEnterpriseProfilePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseRepositoryProjectsSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseRepositoryProjectsSettingPayload"] = ResolversParentTypes["UpdateEnterpriseRepositoryProjectsSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseTeamDiscussionsSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseTeamDiscussionsSettingPayload"] = ResolversParentTypes["UpdateEnterpriseTeamDiscussionsSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload"] = ResolversParentTypes["UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  enterprise?: Resolver<
    Maybe<ResolversTypes["Enterprise"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEnvironmentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateEnvironmentPayload"] = ResolversParentTypes["UpdateEnvironmentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  environment?: Resolver<
    Maybe<ResolversTypes["Environment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateIpAllowListEnabledSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateIpAllowListEnabledSettingPayload"] = ResolversParentTypes["UpdateIpAllowListEnabledSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  owner?: Resolver<
    Maybe<ResolversTypes["IpAllowListOwner"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateIpAllowListEntryPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateIpAllowListEntryPayload"] = ResolversParentTypes["UpdateIpAllowListEntryPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  ipAllowListEntry?: Resolver<
    Maybe<ResolversTypes["IpAllowListEntry"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateIpAllowListForInstalledAppsEnabledSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateIpAllowListForInstalledAppsEnabledSettingPayload"] = ResolversParentTypes["UpdateIpAllowListForInstalledAppsEnabledSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  owner?: Resolver<
    Maybe<ResolversTypes["IpAllowListOwner"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateIssueCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateIssueCommentPayload"] = ResolversParentTypes["UpdateIssueCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  issueComment?: Resolver<
    Maybe<ResolversTypes["IssueComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateIssuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateIssuePayload"] = ResolversParentTypes["UpdateIssuePayload"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  issue?: Resolver<Maybe<ResolversTypes["Issue"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateLabelPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateLabelPayload"] = ResolversParentTypes["UpdateLabelPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  label?: Resolver<Maybe<ResolversTypes["Label"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateNotificationRestrictionSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateNotificationRestrictionSettingPayload"] = ResolversParentTypes["UpdateNotificationRestrictionSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  owner?: Resolver<
    Maybe<ResolversTypes["VerifiableDomainOwner"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateOrganizationAllowPrivateRepositoryForkingSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload"] = ResolversParentTypes["UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateOrganizationWebCommitSignoffSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateOrganizationWebCommitSignoffSettingPayload"] = ResolversParentTypes["UpdateOrganizationWebCommitSignoffSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateParameters"] = ResolversParentTypes["UpdateParameters"],
> = {
  updateAllowsFetchAndMerge?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePatreonSponsorabilityPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdatePatreonSponsorabilityPayload"] = ResolversParentTypes["UpdatePatreonSponsorabilityPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  sponsorsListing?: Resolver<
    Maybe<ResolversTypes["SponsorsListing"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateProjectCardPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateProjectCardPayload"] = ResolversParentTypes["UpdateProjectCardPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectCard?: Resolver<
    Maybe<ResolversTypes["ProjectCard"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateProjectColumnPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateProjectColumnPayload"] = ResolversParentTypes["UpdateProjectColumnPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectColumn?: Resolver<
    Maybe<ResolversTypes["ProjectColumn"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateProjectPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateProjectPayload"] = ResolversParentTypes["UpdateProjectPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  project?: Resolver<Maybe<ResolversTypes["Project"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateProjectV2CollaboratorsPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateProjectV2CollaboratorsPayload"] = ResolversParentTypes["UpdateProjectV2CollaboratorsPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  collaborators?: Resolver<
    Maybe<ResolversTypes["ProjectV2ActorConnection"]>,
    ParentType,
    ContextType,
    Partial<UpdateProjectV2CollaboratorsPayloadCollaboratorsArgs>
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateProjectV2DraftIssuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateProjectV2DraftIssuePayload"] = ResolversParentTypes["UpdateProjectV2DraftIssuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  draftIssue?: Resolver<
    Maybe<ResolversTypes["DraftIssue"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateProjectV2ItemFieldValuePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateProjectV2ItemFieldValuePayload"] = ResolversParentTypes["UpdateProjectV2ItemFieldValuePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectV2Item?: Resolver<
    Maybe<ResolversTypes["ProjectV2Item"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateProjectV2ItemPositionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateProjectV2ItemPositionPayload"] = ResolversParentTypes["UpdateProjectV2ItemPositionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  items?: Resolver<
    Maybe<ResolversTypes["ProjectV2ItemConnection"]>,
    ParentType,
    ContextType,
    Partial<UpdateProjectV2ItemPositionPayloadItemsArgs>
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateProjectV2PayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateProjectV2Payload"] = ResolversParentTypes["UpdateProjectV2Payload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateProjectV2StatusUpdatePayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateProjectV2StatusUpdatePayload"] = ResolversParentTypes["UpdateProjectV2StatusUpdatePayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  statusUpdate?: Resolver<
    Maybe<ResolversTypes["ProjectV2StatusUpdate"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePullRequestBranchPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdatePullRequestBranchPayload"] = ResolversParentTypes["UpdatePullRequestBranchPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePullRequestPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdatePullRequestPayload"] = ResolversParentTypes["UpdatePullRequestPayload"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequest?: Resolver<
    Maybe<ResolversTypes["PullRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePullRequestReviewCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdatePullRequestReviewCommentPayload"] = ResolversParentTypes["UpdatePullRequestReviewCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequestReviewComment?: Resolver<
    Maybe<ResolversTypes["PullRequestReviewComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePullRequestReviewPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdatePullRequestReviewPayload"] = ResolversParentTypes["UpdatePullRequestReviewPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  pullRequestReview?: Resolver<
    Maybe<ResolversTypes["PullRequestReview"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateRefPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateRefPayload"] = ResolversParentTypes["UpdateRefPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  ref?: Resolver<Maybe<ResolversTypes["Ref"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateRefsPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateRefsPayload"] = ResolversParentTypes["UpdateRefsPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateRepositoryPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateRepositoryPayload"] = ResolversParentTypes["UpdateRepositoryPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateRepositoryRulesetPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateRepositoryRulesetPayload"] = ResolversParentTypes["UpdateRepositoryRulesetPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  ruleset?: Resolver<
    Maybe<ResolversTypes["RepositoryRuleset"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateRepositoryWebCommitSignoffSettingPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateRepositoryWebCommitSignoffSettingPayload"] = ResolversParentTypes["UpdateRepositoryWebCommitSignoffSettingPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateSponsorshipPreferencesPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateSponsorshipPreferencesPayload"] = ResolversParentTypes["UpdateSponsorshipPreferencesPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  sponsorship?: Resolver<
    Maybe<ResolversTypes["Sponsorship"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateSubscriptionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateSubscriptionPayload"] = ResolversParentTypes["UpdateSubscriptionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  subscribable?: Resolver<
    Maybe<ResolversTypes["Subscribable"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTeamDiscussionCommentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateTeamDiscussionCommentPayload"] = ResolversParentTypes["UpdateTeamDiscussionCommentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  teamDiscussionComment?: Resolver<
    Maybe<ResolversTypes["TeamDiscussionComment"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTeamDiscussionPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateTeamDiscussionPayload"] = ResolversParentTypes["UpdateTeamDiscussionPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  teamDiscussion?: Resolver<
    Maybe<ResolversTypes["TeamDiscussion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTeamReviewAssignmentPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateTeamReviewAssignmentPayload"] = ResolversParentTypes["UpdateTeamReviewAssignmentPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  team?: Resolver<Maybe<ResolversTypes["Team"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTeamsRepositoryPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateTeamsRepositoryPayload"] = ResolversParentTypes["UpdateTeamsRepositoryPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  teams?: Resolver<
    Maybe<Array<ResolversTypes["Team"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTopicsPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateTopicsPayload"] = ResolversParentTypes["UpdateTopicsPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  invalidTopicNames?: Resolver<
    Maybe<Array<ResolversTypes["String"]>>,
    ParentType,
    ContextType
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateUserListPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateUserListPayload"] = ResolversParentTypes["UpdateUserListPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  list?: Resolver<Maybe<ResolversTypes["UserList"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateUserListsForItemPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UpdateUserListsForItemPayload"] = ResolversParentTypes["UpdateUserListsForItemPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  item?: Resolver<
    Maybe<ResolversTypes["UserListItems"]>,
    ParentType,
    ContextType
  >;
  lists?: Resolver<
    Maybe<Array<ResolversTypes["UserList"]>>,
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["User"] = ResolversParentTypes["User"],
> = {
  anyPinnableItems?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    Partial<UserAnyPinnableItemsArgs>
  >;
  avatarUrl?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType,
    Partial<UserAvatarUrlArgs>
  >;
  bio?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  bioHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  canReceiveOrganizationEmailsWhenNotificationsRestricted?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<
      UserCanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs,
      "login"
    >
  >;
  commitComments?: Resolver<
    ResolversTypes["CommitCommentConnection"],
    ParentType,
    ContextType,
    Partial<UserCommitCommentsArgs>
  >;
  company?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  companyHTML?: Resolver<ResolversTypes["HTML"], ParentType, ContextType>;
  contributionsCollection?: Resolver<
    ResolversTypes["ContributionsCollection"],
    ParentType,
    ContextType,
    Partial<UserContributionsCollectionArgs>
  >;
  copilotEndpoints?: Resolver<
    Maybe<ResolversTypes["CopilotEndpoints"]>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  email?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  enterprises?: Resolver<
    Maybe<ResolversTypes["EnterpriseConnection"]>,
    ParentType,
    ContextType,
    RequireFields<UserEnterprisesArgs, "membershipType" | "orderBy">
  >;
  estimatedNextSponsorsPayoutInCents?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  followers?: Resolver<
    ResolversTypes["FollowerConnection"],
    ParentType,
    ContextType,
    Partial<UserFollowersArgs>
  >;
  following?: Resolver<
    ResolversTypes["FollowingConnection"],
    ParentType,
    ContextType,
    Partial<UserFollowingArgs>
  >;
  gist?: Resolver<
    Maybe<ResolversTypes["Gist"]>,
    ParentType,
    ContextType,
    RequireFields<UserGistArgs, "name">
  >;
  gistComments?: Resolver<
    ResolversTypes["GistCommentConnection"],
    ParentType,
    ContextType,
    Partial<UserGistCommentsArgs>
  >;
  gists?: Resolver<
    ResolversTypes["GistConnection"],
    ParentType,
    ContextType,
    Partial<UserGistsArgs>
  >;
  hasSponsorsListing?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hovercard?: Resolver<
    ResolversTypes["Hovercard"],
    ParentType,
    ContextType,
    Partial<UserHovercardArgs>
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  interactionAbility?: Resolver<
    Maybe<ResolversTypes["RepositoryInteractionAbility"]>,
    ParentType,
    ContextType
  >;
  isBountyHunter?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isCampusExpert?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isDeveloperProgramMember?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isEmployee?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isFollowingViewer?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isGitHubStar?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isHireable?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isSiteAdmin?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isSponsoredBy?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<UserIsSponsoredByArgs, "accountLogin">
  >;
  isSponsoringViewer?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isViewer?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  issueComments?: Resolver<
    ResolversTypes["IssueCommentConnection"],
    ParentType,
    ContextType,
    Partial<UserIssueCommentsArgs>
  >;
  issues?: Resolver<
    ResolversTypes["IssueConnection"],
    ParentType,
    ContextType,
    Partial<UserIssuesArgs>
  >;
  itemShowcase?: Resolver<
    ResolversTypes["ProfileItemShowcase"],
    ParentType,
    ContextType
  >;
  lifetimeReceivedSponsorshipValues?: Resolver<
    ResolversTypes["SponsorAndLifetimeValueConnection"],
    ParentType,
    ContextType,
    RequireFields<UserLifetimeReceivedSponsorshipValuesArgs, "orderBy">
  >;
  lists?: Resolver<
    ResolversTypes["UserListConnection"],
    ParentType,
    ContextType,
    Partial<UserListsArgs>
  >;
  location?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  login?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  monthlyEstimatedSponsorsIncomeInCents?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType,
    RequireFields<UserOrganizationArgs, "login">
  >;
  organizationVerifiedDomainEmails?: Resolver<
    Array<ResolversTypes["String"]>,
    ParentType,
    ContextType,
    RequireFields<UserOrganizationVerifiedDomainEmailsArgs, "login">
  >;
  organizations?: Resolver<
    ResolversTypes["OrganizationConnection"],
    ParentType,
    ContextType,
    RequireFields<UserOrganizationsArgs, "orderBy">
  >;
  packages?: Resolver<
    ResolversTypes["PackageConnection"],
    ParentType,
    ContextType,
    RequireFields<UserPackagesArgs, "orderBy">
  >;
  pinnableItems?: Resolver<
    ResolversTypes["PinnableItemConnection"],
    ParentType,
    ContextType,
    Partial<UserPinnableItemsArgs>
  >;
  pinnedItems?: Resolver<
    ResolversTypes["PinnableItemConnection"],
    ParentType,
    ContextType,
    Partial<UserPinnedItemsArgs>
  >;
  pinnedItemsRemaining?: Resolver<
    ResolversTypes["Int"],
    ParentType,
    ContextType
  >;
  project?: Resolver<
    Maybe<ResolversTypes["Project"]>,
    ParentType,
    ContextType,
    RequireFields<UserProjectArgs, "number">
  >;
  projectV2?: Resolver<
    Maybe<ResolversTypes["ProjectV2"]>,
    ParentType,
    ContextType,
    RequireFields<UserProjectV2Args, "number">
  >;
  projects?: Resolver<
    ResolversTypes["ProjectConnection"],
    ParentType,
    ContextType,
    Partial<UserProjectsArgs>
  >;
  projectsResourcePath?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  projectsUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  projectsV2?: Resolver<
    ResolversTypes["ProjectV2Connection"],
    ParentType,
    ContextType,
    RequireFields<UserProjectsV2Args, "minPermissionLevel" | "orderBy">
  >;
  pronouns?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  publicKeys?: Resolver<
    ResolversTypes["PublicKeyConnection"],
    ParentType,
    ContextType,
    Partial<UserPublicKeysArgs>
  >;
  pullRequests?: Resolver<
    ResolversTypes["PullRequestConnection"],
    ParentType,
    ContextType,
    Partial<UserPullRequestsArgs>
  >;
  recentProjects?: Resolver<
    ResolversTypes["ProjectV2Connection"],
    ParentType,
    ContextType,
    Partial<UserRecentProjectsArgs>
  >;
  repositories?: Resolver<
    ResolversTypes["RepositoryConnection"],
    ParentType,
    ContextType,
    RequireFields<UserRepositoriesArgs, "ownerAffiliations">
  >;
  repositoriesContributedTo?: Resolver<
    ResolversTypes["RepositoryConnection"],
    ParentType,
    ContextType,
    Partial<UserRepositoriesContributedToArgs>
  >;
  repository?: Resolver<
    Maybe<ResolversTypes["Repository"]>,
    ParentType,
    ContextType,
    RequireFields<UserRepositoryArgs, "followRenames" | "name">
  >;
  repositoryDiscussionComments?: Resolver<
    ResolversTypes["DiscussionCommentConnection"],
    ParentType,
    ContextType,
    RequireFields<UserRepositoryDiscussionCommentsArgs, "onlyAnswers">
  >;
  repositoryDiscussions?: Resolver<
    ResolversTypes["DiscussionConnection"],
    ParentType,
    ContextType,
    RequireFields<
      UserRepositoryDiscussionsArgs,
      "answered" | "orderBy" | "states"
    >
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  savedReplies?: Resolver<
    Maybe<ResolversTypes["SavedReplyConnection"]>,
    ParentType,
    ContextType,
    RequireFields<UserSavedRepliesArgs, "orderBy">
  >;
  socialAccounts?: Resolver<
    ResolversTypes["SocialAccountConnection"],
    ParentType,
    ContextType,
    Partial<UserSocialAccountsArgs>
  >;
  sponsoring?: Resolver<
    ResolversTypes["SponsorConnection"],
    ParentType,
    ContextType,
    RequireFields<UserSponsoringArgs, "orderBy">
  >;
  sponsors?: Resolver<
    ResolversTypes["SponsorConnection"],
    ParentType,
    ContextType,
    RequireFields<UserSponsorsArgs, "orderBy">
  >;
  sponsorsActivities?: Resolver<
    ResolversTypes["SponsorsActivityConnection"],
    ParentType,
    ContextType,
    RequireFields<
      UserSponsorsActivitiesArgs,
      "actions" | "includeAsSponsor" | "includePrivate" | "orderBy" | "period"
    >
  >;
  sponsorsListing?: Resolver<
    Maybe<ResolversTypes["SponsorsListing"]>,
    ParentType,
    ContextType
  >;
  sponsorshipForViewerAsSponsor?: Resolver<
    Maybe<ResolversTypes["Sponsorship"]>,
    ParentType,
    ContextType,
    RequireFields<UserSponsorshipForViewerAsSponsorArgs, "activeOnly">
  >;
  sponsorshipForViewerAsSponsorable?: Resolver<
    Maybe<ResolversTypes["Sponsorship"]>,
    ParentType,
    ContextType,
    RequireFields<UserSponsorshipForViewerAsSponsorableArgs, "activeOnly">
  >;
  sponsorshipNewsletters?: Resolver<
    ResolversTypes["SponsorshipNewsletterConnection"],
    ParentType,
    ContextType,
    RequireFields<UserSponsorshipNewslettersArgs, "orderBy">
  >;
  sponsorshipsAsMaintainer?: Resolver<
    ResolversTypes["SponsorshipConnection"],
    ParentType,
    ContextType,
    RequireFields<
      UserSponsorshipsAsMaintainerArgs,
      "activeOnly" | "includePrivate"
    >
  >;
  sponsorshipsAsSponsor?: Resolver<
    ResolversTypes["SponsorshipConnection"],
    ParentType,
    ContextType,
    RequireFields<UserSponsorshipsAsSponsorArgs, "activeOnly">
  >;
  starredRepositories?: Resolver<
    ResolversTypes["StarredRepositoryConnection"],
    ParentType,
    ContextType,
    Partial<UserStarredRepositoriesArgs>
  >;
  status?: Resolver<
    Maybe<ResolversTypes["UserStatus"]>,
    ParentType,
    ContextType
  >;
  suggestedListNames?: Resolver<
    Array<ResolversTypes["UserListSuggestion"]>,
    ParentType,
    ContextType
  >;
  topRepositories?: Resolver<
    ResolversTypes["RepositoryConnection"],
    ParentType,
    ContextType,
    RequireFields<UserTopRepositoriesArgs, "orderBy">
  >;
  totalSponsorshipAmountAsSponsorInCents?: Resolver<
    Maybe<ResolversTypes["Int"]>,
    ParentType,
    ContextType,
    RequireFields<
      UserTotalSponsorshipAmountAsSponsorInCentsArgs,
      "sponsorableLogins"
    >
  >;
  twitterUsername?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanCreateProjects?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanFollow?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanSponsor?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerIsFollowing?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerIsSponsoring?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  watching?: Resolver<
    ResolversTypes["RepositoryConnection"],
    ParentType,
    ContextType,
    RequireFields<UserWatchingArgs, "ownerAffiliations">
  >;
  websiteUrl?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserBlockedEventResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserBlockedEvent"] = ResolversParentTypes["UserBlockedEvent"],
> = {
  actor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  blockDuration?: Resolver<
    ResolversTypes["UserBlockDuration"],
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserConnection"] = ResolversParentTypes["UserConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["User"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserContentEditResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserContentEdit"] = ResolversParentTypes["UserContentEdit"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  deletedAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  deletedBy?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  diff?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  editedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes["Actor"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserContentEditConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserContentEditConnection"] = ResolversParentTypes["UserContentEditConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserContentEditEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserContentEdit"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserContentEditEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserContentEditEdge"] = ResolversParentTypes["UserContentEditEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["UserContentEdit"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserEdge"] = ResolversParentTypes["UserEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserEmailMetadataResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserEmailMetadata"] = ResolversParentTypes["UserEmailMetadata"],
> = {
  primary?: Resolver<Maybe<ResolversTypes["Boolean"]>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserListResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserList"] = ResolversParentTypes["UserList"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  items?: Resolver<
    ResolversTypes["UserListItemsConnection"],
    ParentType,
    ContextType,
    Partial<UserListItemsArgs>
  >;
  lastAddedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserListConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserListConnection"] = ResolversParentTypes["UserListConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserListEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserList"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserListEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserListEdge"] = ResolversParentTypes["UserListEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["UserList"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserListItemsResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserListItems"] = ResolversParentTypes["UserListItems"],
> = {
  __resolveType: TypeResolveFn<"Repository", ParentType, ContextType>;
};

export type UserListItemsConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserListItemsConnection"] = ResolversParentTypes["UserListItemsConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserListItemsEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserListItems"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserListItemsEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserListItemsEdge"] = ResolversParentTypes["UserListItemsEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["UserListItems"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserListSuggestionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserListSuggestion"] = ResolversParentTypes["UserListSuggestion"],
> = {
  id?: Resolver<Maybe<ResolversTypes["ID"]>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserStatusResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserStatus"] = ResolversParentTypes["UserStatus"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  emoji?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  emojiHTML?: Resolver<Maybe<ResolversTypes["HTML"]>, ParentType, ContextType>;
  expiresAt?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  indicatesLimitedAvailability?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes["Organization"]>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserStatusConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserStatusConnection"] = ResolversParentTypes["UserStatusConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserStatusEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserStatus"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserStatusEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["UserStatusEdge"] = ResolversParentTypes["UserStatusEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["UserStatus"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VerifiableDomainResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["VerifiableDomain"] = ResolversParentTypes["VerifiableDomain"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  dnsHostName?: Resolver<Maybe<ResolversTypes["URI"]>, ParentType, ContextType>;
  domain?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  hasFoundHostName?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  hasFoundVerificationToken?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isApproved?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isRequiredForPolicyEnforcement?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  isVerified?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  owner?: Resolver<
    ResolversTypes["VerifiableDomainOwner"],
    ParentType,
    ContextType
  >;
  punycodeEncodedDomain?: Resolver<
    ResolversTypes["URI"],
    ParentType,
    ContextType
  >;
  tokenExpirationTime?: Resolver<
    Maybe<ResolversTypes["DateTime"]>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  verificationToken?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VerifiableDomainConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["VerifiableDomainConnection"] = ResolversParentTypes["VerifiableDomainConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["VerifiableDomainEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["VerifiableDomain"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VerifiableDomainEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["VerifiableDomainEdge"] = ResolversParentTypes["VerifiableDomainEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["VerifiableDomain"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VerifiableDomainOwnerResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["VerifiableDomainOwner"] = ResolversParentTypes["VerifiableDomainOwner"],
> = {
  __resolveType: TypeResolveFn<
    "Enterprise" | "Organization",
    ParentType,
    ContextType
  >;
};

export type VerifyVerifiableDomainPayloadResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["VerifyVerifiableDomainPayload"] = ResolversParentTypes["VerifyVerifiableDomainPayload"],
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  domain?: Resolver<
    Maybe<ResolversTypes["VerifiableDomain"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ViewerHovercardContextResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["ViewerHovercardContext"] = ResolversParentTypes["ViewerHovercardContext"],
> = {
  message?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  viewer?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VotableResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Votable"] = ResolversParentTypes["Votable"],
> = {
  __resolveType: TypeResolveFn<
    "Discussion" | "DiscussionComment",
    ParentType,
    ContextType
  >;
  upvoteCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  viewerCanUpvote?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerHasUpvoted?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
};

export type WorkflowResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["Workflow"] = ResolversParentTypes["Workflow"],
> = {
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  runs?: Resolver<
    ResolversTypes["WorkflowRunConnection"],
    ParentType,
    ContextType,
    RequireFields<WorkflowRunsArgs, "orderBy">
  >;
  state?: Resolver<ResolversTypes["WorkflowState"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkflowFileReferenceResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["WorkflowFileReference"] = ResolversParentTypes["WorkflowFileReference"],
> = {
  path?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  repositoryId?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  sha?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkflowRunResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["WorkflowRun"] = ResolversParentTypes["WorkflowRun"],
> = {
  checkSuite?: Resolver<ResolversTypes["CheckSuite"], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  deploymentReviews?: Resolver<
    ResolversTypes["DeploymentReviewConnection"],
    ParentType,
    ContextType,
    Partial<WorkflowRunDeploymentReviewsArgs>
  >;
  event?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  file?: Resolver<
    Maybe<ResolversTypes["WorkflowRunFile"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  pendingDeploymentRequests?: Resolver<
    ResolversTypes["DeploymentRequestConnection"],
    ParentType,
    ContextType,
    Partial<WorkflowRunPendingDeploymentRequestsArgs>
  >;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  runNumber?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes["DateTime"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  workflow?: Resolver<ResolversTypes["Workflow"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkflowRunConnectionResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["WorkflowRunConnection"] = ResolversParentTypes["WorkflowRunConnection"],
> = {
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["WorkflowRunEdge"]>>>,
    ParentType,
    ContextType
  >;
  nodes?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["WorkflowRun"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkflowRunEdgeResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["WorkflowRunEdge"] = ResolversParentTypes["WorkflowRunEdge"],
> = {
  cursor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["WorkflowRun"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkflowRunFileResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["WorkflowRunFile"] = ResolversParentTypes["WorkflowRunFile"],
> = {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  path?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  repositoryFileUrl?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  repositoryName?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  run?: Resolver<ResolversTypes["WorkflowRun"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["URI"], ParentType, ContextType>;
  viewerCanPushRepository?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  viewerCanReadRepository?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkflowsParametersResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes["WorkflowsParameters"] = ResolversParentTypes["WorkflowsParameters"],
> = {
  doNotEnforceOnCreate?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  workflows?: Resolver<
    Array<ResolversTypes["WorkflowFileReference"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface X509CertificateScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["X509Certificate"], any> {
  name: "X509Certificate";
}

export type Resolvers<ContextType = any> = {
  AbortQueuedMigrationsPayload?: AbortQueuedMigrationsPayloadResolvers<ContextType>;
  AbortRepositoryMigrationPayload?: AbortRepositoryMigrationPayloadResolvers<ContextType>;
  AcceptEnterpriseAdministratorInvitationPayload?: AcceptEnterpriseAdministratorInvitationPayloadResolvers<ContextType>;
  AcceptEnterpriseMemberInvitationPayload?: AcceptEnterpriseMemberInvitationPayloadResolvers<ContextType>;
  AcceptTopicSuggestionPayload?: AcceptTopicSuggestionPayloadResolvers<ContextType>;
  Actor?: ActorResolvers<ContextType>;
  ActorLocation?: ActorLocationResolvers<ContextType>;
  AddAssigneesToAssignablePayload?: AddAssigneesToAssignablePayloadResolvers<ContextType>;
  AddCommentPayload?: AddCommentPayloadResolvers<ContextType>;
  AddDiscussionCommentPayload?: AddDiscussionCommentPayloadResolvers<ContextType>;
  AddDiscussionPollVotePayload?: AddDiscussionPollVotePayloadResolvers<ContextType>;
  AddEnterpriseOrganizationMemberPayload?: AddEnterpriseOrganizationMemberPayloadResolvers<ContextType>;
  AddEnterpriseSupportEntitlementPayload?: AddEnterpriseSupportEntitlementPayloadResolvers<ContextType>;
  AddLabelsToLabelablePayload?: AddLabelsToLabelablePayloadResolvers<ContextType>;
  AddProjectCardPayload?: AddProjectCardPayloadResolvers<ContextType>;
  AddProjectColumnPayload?: AddProjectColumnPayloadResolvers<ContextType>;
  AddProjectV2DraftIssuePayload?: AddProjectV2DraftIssuePayloadResolvers<ContextType>;
  AddProjectV2ItemByIdPayload?: AddProjectV2ItemByIdPayloadResolvers<ContextType>;
  AddPullRequestReviewCommentPayload?: AddPullRequestReviewCommentPayloadResolvers<ContextType>;
  AddPullRequestReviewPayload?: AddPullRequestReviewPayloadResolvers<ContextType>;
  AddPullRequestReviewThreadPayload?: AddPullRequestReviewThreadPayloadResolvers<ContextType>;
  AddPullRequestReviewThreadReplyPayload?: AddPullRequestReviewThreadReplyPayloadResolvers<ContextType>;
  AddReactionPayload?: AddReactionPayloadResolvers<ContextType>;
  AddStarPayload?: AddStarPayloadResolvers<ContextType>;
  AddUpvotePayload?: AddUpvotePayloadResolvers<ContextType>;
  AddVerifiableDomainPayload?: AddVerifiableDomainPayloadResolvers<ContextType>;
  AddedToMergeQueueEvent?: AddedToMergeQueueEventResolvers<ContextType>;
  AddedToProjectEvent?: AddedToProjectEventResolvers<ContextType>;
  AnnouncementBanner?: AnnouncementBannerResolvers<ContextType>;
  App?: AppResolvers<ContextType>;
  ApproveDeploymentsPayload?: ApproveDeploymentsPayloadResolvers<ContextType>;
  ApproveVerifiableDomainPayload?: ApproveVerifiableDomainPayloadResolvers<ContextType>;
  ArchiveProjectV2ItemPayload?: ArchiveProjectV2ItemPayloadResolvers<ContextType>;
  ArchiveRepositoryPayload?: ArchiveRepositoryPayloadResolvers<ContextType>;
  Assignable?: AssignableResolvers<ContextType>;
  AssignedEvent?: AssignedEventResolvers<ContextType>;
  Assignee?: AssigneeResolvers<ContextType>;
  AuditEntry?: AuditEntryResolvers<ContextType>;
  AuditEntryActor?: AuditEntryActorResolvers<ContextType>;
  AutoMergeDisabledEvent?: AutoMergeDisabledEventResolvers<ContextType>;
  AutoMergeEnabledEvent?: AutoMergeEnabledEventResolvers<ContextType>;
  AutoMergeRequest?: AutoMergeRequestResolvers<ContextType>;
  AutoRebaseEnabledEvent?: AutoRebaseEnabledEventResolvers<ContextType>;
  AutoSquashEnabledEvent?: AutoSquashEnabledEventResolvers<ContextType>;
  AutomaticBaseChangeFailedEvent?: AutomaticBaseChangeFailedEventResolvers<ContextType>;
  AutomaticBaseChangeSucceededEvent?: AutomaticBaseChangeSucceededEventResolvers<ContextType>;
  Base64String?: GraphQLScalarType;
  BaseRefChangedEvent?: BaseRefChangedEventResolvers<ContextType>;
  BaseRefDeletedEvent?: BaseRefDeletedEventResolvers<ContextType>;
  BaseRefForcePushedEvent?: BaseRefForcePushedEventResolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  Blame?: BlameResolvers<ContextType>;
  BlameRange?: BlameRangeResolvers<ContextType>;
  Blob?: BlobResolvers<ContextType>;
  Bot?: BotResolvers<ContextType>;
  BranchActorAllowanceActor?: BranchActorAllowanceActorResolvers<ContextType>;
  BranchNamePatternParameters?: BranchNamePatternParametersResolvers<ContextType>;
  BranchProtectionRule?: BranchProtectionRuleResolvers<ContextType>;
  BranchProtectionRuleConflict?: BranchProtectionRuleConflictResolvers<ContextType>;
  BranchProtectionRuleConflictConnection?: BranchProtectionRuleConflictConnectionResolvers<ContextType>;
  BranchProtectionRuleConflictEdge?: BranchProtectionRuleConflictEdgeResolvers<ContextType>;
  BranchProtectionRuleConnection?: BranchProtectionRuleConnectionResolvers<ContextType>;
  BranchProtectionRuleEdge?: BranchProtectionRuleEdgeResolvers<ContextType>;
  BypassActor?: BypassActorResolvers<ContextType>;
  BypassForcePushAllowance?: BypassForcePushAllowanceResolvers<ContextType>;
  BypassForcePushAllowanceConnection?: BypassForcePushAllowanceConnectionResolvers<ContextType>;
  BypassForcePushAllowanceEdge?: BypassForcePushAllowanceEdgeResolvers<ContextType>;
  BypassPullRequestAllowance?: BypassPullRequestAllowanceResolvers<ContextType>;
  BypassPullRequestAllowanceConnection?: BypassPullRequestAllowanceConnectionResolvers<ContextType>;
  BypassPullRequestAllowanceEdge?: BypassPullRequestAllowanceEdgeResolvers<ContextType>;
  CVSS?: CvssResolvers<ContextType>;
  CWE?: CweResolvers<ContextType>;
  CWEConnection?: CweConnectionResolvers<ContextType>;
  CWEEdge?: CweEdgeResolvers<ContextType>;
  CancelEnterpriseAdminInvitationPayload?: CancelEnterpriseAdminInvitationPayloadResolvers<ContextType>;
  CancelEnterpriseMemberInvitationPayload?: CancelEnterpriseMemberInvitationPayloadResolvers<ContextType>;
  CancelSponsorshipPayload?: CancelSponsorshipPayloadResolvers<ContextType>;
  ChangeUserStatusPayload?: ChangeUserStatusPayloadResolvers<ContextType>;
  CheckAnnotation?: CheckAnnotationResolvers<ContextType>;
  CheckAnnotationConnection?: CheckAnnotationConnectionResolvers<ContextType>;
  CheckAnnotationEdge?: CheckAnnotationEdgeResolvers<ContextType>;
  CheckAnnotationPosition?: CheckAnnotationPositionResolvers<ContextType>;
  CheckAnnotationSpan?: CheckAnnotationSpanResolvers<ContextType>;
  CheckRun?: CheckRunResolvers<ContextType>;
  CheckRunConnection?: CheckRunConnectionResolvers<ContextType>;
  CheckRunEdge?: CheckRunEdgeResolvers<ContextType>;
  CheckRunStateCount?: CheckRunStateCountResolvers<ContextType>;
  CheckStep?: CheckStepResolvers<ContextType>;
  CheckStepConnection?: CheckStepConnectionResolvers<ContextType>;
  CheckStepEdge?: CheckStepEdgeResolvers<ContextType>;
  CheckSuite?: CheckSuiteResolvers<ContextType>;
  CheckSuiteConnection?: CheckSuiteConnectionResolvers<ContextType>;
  CheckSuiteEdge?: CheckSuiteEdgeResolvers<ContextType>;
  Claimable?: ClaimableResolvers<ContextType>;
  ClearLabelsFromLabelablePayload?: ClearLabelsFromLabelablePayloadResolvers<ContextType>;
  ClearProjectV2ItemFieldValuePayload?: ClearProjectV2ItemFieldValuePayloadResolvers<ContextType>;
  CloneProjectPayload?: CloneProjectPayloadResolvers<ContextType>;
  CloneTemplateRepositoryPayload?: CloneTemplateRepositoryPayloadResolvers<ContextType>;
  Closable?: ClosableResolvers<ContextType>;
  CloseDiscussionPayload?: CloseDiscussionPayloadResolvers<ContextType>;
  CloseIssuePayload?: CloseIssuePayloadResolvers<ContextType>;
  ClosePullRequestPayload?: ClosePullRequestPayloadResolvers<ContextType>;
  ClosedEvent?: ClosedEventResolvers<ContextType>;
  Closer?: CloserResolvers<ContextType>;
  CodeOfConduct?: CodeOfConductResolvers<ContextType>;
  CodeScanningParameters?: CodeScanningParametersResolvers<ContextType>;
  CodeScanningTool?: CodeScanningToolResolvers<ContextType>;
  Comment?: CommentResolvers<ContextType>;
  CommentDeletedEvent?: CommentDeletedEventResolvers<ContextType>;
  Commit?: CommitResolvers<ContextType>;
  CommitAuthorEmailPatternParameters?: CommitAuthorEmailPatternParametersResolvers<ContextType>;
  CommitComment?: CommitCommentResolvers<ContextType>;
  CommitCommentConnection?: CommitCommentConnectionResolvers<ContextType>;
  CommitCommentEdge?: CommitCommentEdgeResolvers<ContextType>;
  CommitCommentThread?: CommitCommentThreadResolvers<ContextType>;
  CommitConnection?: CommitConnectionResolvers<ContextType>;
  CommitContributionsByRepository?: CommitContributionsByRepositoryResolvers<ContextType>;
  CommitEdge?: CommitEdgeResolvers<ContextType>;
  CommitHistoryConnection?: CommitHistoryConnectionResolvers<ContextType>;
  CommitMessagePatternParameters?: CommitMessagePatternParametersResolvers<ContextType>;
  CommitterEmailPatternParameters?: CommitterEmailPatternParametersResolvers<ContextType>;
  Comparison?: ComparisonResolvers<ContextType>;
  ComparisonCommitConnection?: ComparisonCommitConnectionResolvers<ContextType>;
  ConnectedEvent?: ConnectedEventResolvers<ContextType>;
  ContributingGuidelines?: ContributingGuidelinesResolvers<ContextType>;
  Contribution?: ContributionResolvers<ContextType>;
  ContributionCalendar?: ContributionCalendarResolvers<ContextType>;
  ContributionCalendarDay?: ContributionCalendarDayResolvers<ContextType>;
  ContributionCalendarMonth?: ContributionCalendarMonthResolvers<ContextType>;
  ContributionCalendarWeek?: ContributionCalendarWeekResolvers<ContextType>;
  ContributionsCollection?: ContributionsCollectionResolvers<ContextType>;
  ConvertProjectCardNoteToIssuePayload?: ConvertProjectCardNoteToIssuePayloadResolvers<ContextType>;
  ConvertProjectV2DraftIssueItemToIssuePayload?: ConvertProjectV2DraftIssueItemToIssuePayloadResolvers<ContextType>;
  ConvertPullRequestToDraftPayload?: ConvertPullRequestToDraftPayloadResolvers<ContextType>;
  ConvertToDraftEvent?: ConvertToDraftEventResolvers<ContextType>;
  ConvertedNoteToIssueEvent?: ConvertedNoteToIssueEventResolvers<ContextType>;
  ConvertedToDiscussionEvent?: ConvertedToDiscussionEventResolvers<ContextType>;
  CopilotEndpoints?: CopilotEndpointsResolvers<ContextType>;
  CopyProjectV2Payload?: CopyProjectV2PayloadResolvers<ContextType>;
  CreateAttributionInvitationPayload?: CreateAttributionInvitationPayloadResolvers<ContextType>;
  CreateBranchProtectionRulePayload?: CreateBranchProtectionRulePayloadResolvers<ContextType>;
  CreateCheckRunPayload?: CreateCheckRunPayloadResolvers<ContextType>;
  CreateCheckSuitePayload?: CreateCheckSuitePayloadResolvers<ContextType>;
  CreateCommitOnBranchPayload?: CreateCommitOnBranchPayloadResolvers<ContextType>;
  CreateDeploymentPayload?: CreateDeploymentPayloadResolvers<ContextType>;
  CreateDeploymentStatusPayload?: CreateDeploymentStatusPayloadResolvers<ContextType>;
  CreateDiscussionPayload?: CreateDiscussionPayloadResolvers<ContextType>;
  CreateEnterpriseOrganizationPayload?: CreateEnterpriseOrganizationPayloadResolvers<ContextType>;
  CreateEnvironmentPayload?: CreateEnvironmentPayloadResolvers<ContextType>;
  CreateIpAllowListEntryPayload?: CreateIpAllowListEntryPayloadResolvers<ContextType>;
  CreateIssuePayload?: CreateIssuePayloadResolvers<ContextType>;
  CreateLabelPayload?: CreateLabelPayloadResolvers<ContextType>;
  CreateLinkedBranchPayload?: CreateLinkedBranchPayloadResolvers<ContextType>;
  CreateMigrationSourcePayload?: CreateMigrationSourcePayloadResolvers<ContextType>;
  CreateProjectPayload?: CreateProjectPayloadResolvers<ContextType>;
  CreateProjectV2FieldPayload?: CreateProjectV2FieldPayloadResolvers<ContextType>;
  CreateProjectV2Payload?: CreateProjectV2PayloadResolvers<ContextType>;
  CreateProjectV2StatusUpdatePayload?: CreateProjectV2StatusUpdatePayloadResolvers<ContextType>;
  CreatePullRequestPayload?: CreatePullRequestPayloadResolvers<ContextType>;
  CreateRefPayload?: CreateRefPayloadResolvers<ContextType>;
  CreateRepositoryPayload?: CreateRepositoryPayloadResolvers<ContextType>;
  CreateRepositoryRulesetPayload?: CreateRepositoryRulesetPayloadResolvers<ContextType>;
  CreateSponsorsListingPayload?: CreateSponsorsListingPayloadResolvers<ContextType>;
  CreateSponsorsTierPayload?: CreateSponsorsTierPayloadResolvers<ContextType>;
  CreateSponsorshipPayload?: CreateSponsorshipPayloadResolvers<ContextType>;
  CreateSponsorshipsPayload?: CreateSponsorshipsPayloadResolvers<ContextType>;
  CreateTeamDiscussionCommentPayload?: CreateTeamDiscussionCommentPayloadResolvers<ContextType>;
  CreateTeamDiscussionPayload?: CreateTeamDiscussionPayloadResolvers<ContextType>;
  CreateUserListPayload?: CreateUserListPayloadResolvers<ContextType>;
  CreatedCommitContribution?: CreatedCommitContributionResolvers<ContextType>;
  CreatedCommitContributionConnection?: CreatedCommitContributionConnectionResolvers<ContextType>;
  CreatedCommitContributionEdge?: CreatedCommitContributionEdgeResolvers<ContextType>;
  CreatedIssueContribution?: CreatedIssueContributionResolvers<ContextType>;
  CreatedIssueContributionConnection?: CreatedIssueContributionConnectionResolvers<ContextType>;
  CreatedIssueContributionEdge?: CreatedIssueContributionEdgeResolvers<ContextType>;
  CreatedIssueOrRestrictedContribution?: CreatedIssueOrRestrictedContributionResolvers<ContextType>;
  CreatedPullRequestContribution?: CreatedPullRequestContributionResolvers<ContextType>;
  CreatedPullRequestContributionConnection?: CreatedPullRequestContributionConnectionResolvers<ContextType>;
  CreatedPullRequestContributionEdge?: CreatedPullRequestContributionEdgeResolvers<ContextType>;
  CreatedPullRequestOrRestrictedContribution?: CreatedPullRequestOrRestrictedContributionResolvers<ContextType>;
  CreatedPullRequestReviewContribution?: CreatedPullRequestReviewContributionResolvers<ContextType>;
  CreatedPullRequestReviewContributionConnection?: CreatedPullRequestReviewContributionConnectionResolvers<ContextType>;
  CreatedPullRequestReviewContributionEdge?: CreatedPullRequestReviewContributionEdgeResolvers<ContextType>;
  CreatedRepositoryContribution?: CreatedRepositoryContributionResolvers<ContextType>;
  CreatedRepositoryContributionConnection?: CreatedRepositoryContributionConnectionResolvers<ContextType>;
  CreatedRepositoryContributionEdge?: CreatedRepositoryContributionEdgeResolvers<ContextType>;
  CreatedRepositoryOrRestrictedContribution?: CreatedRepositoryOrRestrictedContributionResolvers<ContextType>;
  CrossReferencedEvent?: CrossReferencedEventResolvers<ContextType>;
  Date?: GraphQLScalarType;
  DateTime?: GraphQLScalarType;
  DeclineTopicSuggestionPayload?: DeclineTopicSuggestionPayloadResolvers<ContextType>;
  Deletable?: DeletableResolvers<ContextType>;
  DeleteBranchProtectionRulePayload?: DeleteBranchProtectionRulePayloadResolvers<ContextType>;
  DeleteDeploymentPayload?: DeleteDeploymentPayloadResolvers<ContextType>;
  DeleteDiscussionCommentPayload?: DeleteDiscussionCommentPayloadResolvers<ContextType>;
  DeleteDiscussionPayload?: DeleteDiscussionPayloadResolvers<ContextType>;
  DeleteEnvironmentPayload?: DeleteEnvironmentPayloadResolvers<ContextType>;
  DeleteIpAllowListEntryPayload?: DeleteIpAllowListEntryPayloadResolvers<ContextType>;
  DeleteIssueCommentPayload?: DeleteIssueCommentPayloadResolvers<ContextType>;
  DeleteIssuePayload?: DeleteIssuePayloadResolvers<ContextType>;
  DeleteLabelPayload?: DeleteLabelPayloadResolvers<ContextType>;
  DeleteLinkedBranchPayload?: DeleteLinkedBranchPayloadResolvers<ContextType>;
  DeletePackageVersionPayload?: DeletePackageVersionPayloadResolvers<ContextType>;
  DeleteProjectCardPayload?: DeleteProjectCardPayloadResolvers<ContextType>;
  DeleteProjectColumnPayload?: DeleteProjectColumnPayloadResolvers<ContextType>;
  DeleteProjectPayload?: DeleteProjectPayloadResolvers<ContextType>;
  DeleteProjectV2FieldPayload?: DeleteProjectV2FieldPayloadResolvers<ContextType>;
  DeleteProjectV2ItemPayload?: DeleteProjectV2ItemPayloadResolvers<ContextType>;
  DeleteProjectV2Payload?: DeleteProjectV2PayloadResolvers<ContextType>;
  DeleteProjectV2StatusUpdatePayload?: DeleteProjectV2StatusUpdatePayloadResolvers<ContextType>;
  DeleteProjectV2WorkflowPayload?: DeleteProjectV2WorkflowPayloadResolvers<ContextType>;
  DeletePullRequestReviewCommentPayload?: DeletePullRequestReviewCommentPayloadResolvers<ContextType>;
  DeletePullRequestReviewPayload?: DeletePullRequestReviewPayloadResolvers<ContextType>;
  DeleteRefPayload?: DeleteRefPayloadResolvers<ContextType>;
  DeleteRepositoryRulesetPayload?: DeleteRepositoryRulesetPayloadResolvers<ContextType>;
  DeleteTeamDiscussionCommentPayload?: DeleteTeamDiscussionCommentPayloadResolvers<ContextType>;
  DeleteTeamDiscussionPayload?: DeleteTeamDiscussionPayloadResolvers<ContextType>;
  DeleteUserListPayload?: DeleteUserListPayloadResolvers<ContextType>;
  DeleteVerifiableDomainPayload?: DeleteVerifiableDomainPayloadResolvers<ContextType>;
  DemilestonedEvent?: DemilestonedEventResolvers<ContextType>;
  DependabotUpdate?: DependabotUpdateResolvers<ContextType>;
  DependabotUpdateError?: DependabotUpdateErrorResolvers<ContextType>;
  DependencyGraphDependency?: DependencyGraphDependencyResolvers<ContextType>;
  DependencyGraphDependencyConnection?: DependencyGraphDependencyConnectionResolvers<ContextType>;
  DependencyGraphDependencyEdge?: DependencyGraphDependencyEdgeResolvers<ContextType>;
  DependencyGraphManifest?: DependencyGraphManifestResolvers<ContextType>;
  DependencyGraphManifestConnection?: DependencyGraphManifestConnectionResolvers<ContextType>;
  DependencyGraphManifestEdge?: DependencyGraphManifestEdgeResolvers<ContextType>;
  DeployKey?: DeployKeyResolvers<ContextType>;
  DeployKeyConnection?: DeployKeyConnectionResolvers<ContextType>;
  DeployKeyEdge?: DeployKeyEdgeResolvers<ContextType>;
  DeployedEvent?: DeployedEventResolvers<ContextType>;
  Deployment?: DeploymentResolvers<ContextType>;
  DeploymentConnection?: DeploymentConnectionResolvers<ContextType>;
  DeploymentEdge?: DeploymentEdgeResolvers<ContextType>;
  DeploymentEnvironmentChangedEvent?: DeploymentEnvironmentChangedEventResolvers<ContextType>;
  DeploymentProtectionRule?: DeploymentProtectionRuleResolvers<ContextType>;
  DeploymentProtectionRuleConnection?: DeploymentProtectionRuleConnectionResolvers<ContextType>;
  DeploymentProtectionRuleEdge?: DeploymentProtectionRuleEdgeResolvers<ContextType>;
  DeploymentRequest?: DeploymentRequestResolvers<ContextType>;
  DeploymentRequestConnection?: DeploymentRequestConnectionResolvers<ContextType>;
  DeploymentRequestEdge?: DeploymentRequestEdgeResolvers<ContextType>;
  DeploymentReview?: DeploymentReviewResolvers<ContextType>;
  DeploymentReviewConnection?: DeploymentReviewConnectionResolvers<ContextType>;
  DeploymentReviewEdge?: DeploymentReviewEdgeResolvers<ContextType>;
  DeploymentReviewer?: DeploymentReviewerResolvers<ContextType>;
  DeploymentReviewerConnection?: DeploymentReviewerConnectionResolvers<ContextType>;
  DeploymentReviewerEdge?: DeploymentReviewerEdgeResolvers<ContextType>;
  DeploymentStatus?: DeploymentStatusResolvers<ContextType>;
  DeploymentStatusConnection?: DeploymentStatusConnectionResolvers<ContextType>;
  DeploymentStatusEdge?: DeploymentStatusEdgeResolvers<ContextType>;
  DequeuePullRequestPayload?: DequeuePullRequestPayloadResolvers<ContextType>;
  DisablePullRequestAutoMergePayload?: DisablePullRequestAutoMergePayloadResolvers<ContextType>;
  DisconnectedEvent?: DisconnectedEventResolvers<ContextType>;
  Discussion?: DiscussionResolvers<ContextType>;
  DiscussionCategory?: DiscussionCategoryResolvers<ContextType>;
  DiscussionCategoryConnection?: DiscussionCategoryConnectionResolvers<ContextType>;
  DiscussionCategoryEdge?: DiscussionCategoryEdgeResolvers<ContextType>;
  DiscussionComment?: DiscussionCommentResolvers<ContextType>;
  DiscussionCommentConnection?: DiscussionCommentConnectionResolvers<ContextType>;
  DiscussionCommentEdge?: DiscussionCommentEdgeResolvers<ContextType>;
  DiscussionConnection?: DiscussionConnectionResolvers<ContextType>;
  DiscussionEdge?: DiscussionEdgeResolvers<ContextType>;
  DiscussionPoll?: DiscussionPollResolvers<ContextType>;
  DiscussionPollOption?: DiscussionPollOptionResolvers<ContextType>;
  DiscussionPollOptionConnection?: DiscussionPollOptionConnectionResolvers<ContextType>;
  DiscussionPollOptionEdge?: DiscussionPollOptionEdgeResolvers<ContextType>;
  DismissPullRequestReviewPayload?: DismissPullRequestReviewPayloadResolvers<ContextType>;
  DismissRepositoryVulnerabilityAlertPayload?: DismissRepositoryVulnerabilityAlertPayloadResolvers<ContextType>;
  DraftIssue?: DraftIssueResolvers<ContextType>;
  EnablePullRequestAutoMergePayload?: EnablePullRequestAutoMergePayloadResolvers<ContextType>;
  EnqueuePullRequestPayload?: EnqueuePullRequestPayloadResolvers<ContextType>;
  Enterprise?: EnterpriseResolvers<ContextType>;
  EnterpriseAdministratorConnection?: EnterpriseAdministratorConnectionResolvers<ContextType>;
  EnterpriseAdministratorEdge?: EnterpriseAdministratorEdgeResolvers<ContextType>;
  EnterpriseAdministratorInvitation?: EnterpriseAdministratorInvitationResolvers<ContextType>;
  EnterpriseAdministratorInvitationConnection?: EnterpriseAdministratorInvitationConnectionResolvers<ContextType>;
  EnterpriseAdministratorInvitationEdge?: EnterpriseAdministratorInvitationEdgeResolvers<ContextType>;
  EnterpriseAuditEntryData?: EnterpriseAuditEntryDataResolvers<ContextType>;
  EnterpriseBillingInfo?: EnterpriseBillingInfoResolvers<ContextType>;
  EnterpriseConnection?: EnterpriseConnectionResolvers<ContextType>;
  EnterpriseEdge?: EnterpriseEdgeResolvers<ContextType>;
  EnterpriseFailedInvitationConnection?: EnterpriseFailedInvitationConnectionResolvers<ContextType>;
  EnterpriseFailedInvitationEdge?: EnterpriseFailedInvitationEdgeResolvers<ContextType>;
  EnterpriseIdentityProvider?: EnterpriseIdentityProviderResolvers<ContextType>;
  EnterpriseMember?: EnterpriseMemberResolvers<ContextType>;
  EnterpriseMemberConnection?: EnterpriseMemberConnectionResolvers<ContextType>;
  EnterpriseMemberEdge?: EnterpriseMemberEdgeResolvers<ContextType>;
  EnterpriseMemberInvitation?: EnterpriseMemberInvitationResolvers<ContextType>;
  EnterpriseMemberInvitationConnection?: EnterpriseMemberInvitationConnectionResolvers<ContextType>;
  EnterpriseMemberInvitationEdge?: EnterpriseMemberInvitationEdgeResolvers<ContextType>;
  EnterpriseOrganizationMembershipConnection?: EnterpriseOrganizationMembershipConnectionResolvers<ContextType>;
  EnterpriseOrganizationMembershipEdge?: EnterpriseOrganizationMembershipEdgeResolvers<ContextType>;
  EnterpriseOutsideCollaboratorConnection?: EnterpriseOutsideCollaboratorConnectionResolvers<ContextType>;
  EnterpriseOutsideCollaboratorEdge?: EnterpriseOutsideCollaboratorEdgeResolvers<ContextType>;
  EnterpriseOwnerInfo?: EnterpriseOwnerInfoResolvers<ContextType>;
  EnterprisePendingMemberInvitationConnection?: EnterprisePendingMemberInvitationConnectionResolvers<ContextType>;
  EnterprisePendingMemberInvitationEdge?: EnterprisePendingMemberInvitationEdgeResolvers<ContextType>;
  EnterpriseRepositoryInfo?: EnterpriseRepositoryInfoResolvers<ContextType>;
  EnterpriseRepositoryInfoConnection?: EnterpriseRepositoryInfoConnectionResolvers<ContextType>;
  EnterpriseRepositoryInfoEdge?: EnterpriseRepositoryInfoEdgeResolvers<ContextType>;
  EnterpriseServerInstallation?: EnterpriseServerInstallationResolvers<ContextType>;
  EnterpriseServerInstallationConnection?: EnterpriseServerInstallationConnectionResolvers<ContextType>;
  EnterpriseServerInstallationEdge?: EnterpriseServerInstallationEdgeResolvers<ContextType>;
  EnterpriseServerInstallationMembershipConnection?: EnterpriseServerInstallationMembershipConnectionResolvers<ContextType>;
  EnterpriseServerInstallationMembershipEdge?: EnterpriseServerInstallationMembershipEdgeResolvers<ContextType>;
  EnterpriseServerUserAccount?: EnterpriseServerUserAccountResolvers<ContextType>;
  EnterpriseServerUserAccountConnection?: EnterpriseServerUserAccountConnectionResolvers<ContextType>;
  EnterpriseServerUserAccountEdge?: EnterpriseServerUserAccountEdgeResolvers<ContextType>;
  EnterpriseServerUserAccountEmail?: EnterpriseServerUserAccountEmailResolvers<ContextType>;
  EnterpriseServerUserAccountEmailConnection?: EnterpriseServerUserAccountEmailConnectionResolvers<ContextType>;
  EnterpriseServerUserAccountEmailEdge?: EnterpriseServerUserAccountEmailEdgeResolvers<ContextType>;
  EnterpriseServerUserAccountsUpload?: EnterpriseServerUserAccountsUploadResolvers<ContextType>;
  EnterpriseServerUserAccountsUploadConnection?: EnterpriseServerUserAccountsUploadConnectionResolvers<ContextType>;
  EnterpriseServerUserAccountsUploadEdge?: EnterpriseServerUserAccountsUploadEdgeResolvers<ContextType>;
  EnterpriseUserAccount?: EnterpriseUserAccountResolvers<ContextType>;
  Environment?: EnvironmentResolvers<ContextType>;
  EnvironmentConnection?: EnvironmentConnectionResolvers<ContextType>;
  EnvironmentEdge?: EnvironmentEdgeResolvers<ContextType>;
  ExternalIdentity?: ExternalIdentityResolvers<ContextType>;
  ExternalIdentityAttribute?: ExternalIdentityAttributeResolvers<ContextType>;
  ExternalIdentityConnection?: ExternalIdentityConnectionResolvers<ContextType>;
  ExternalIdentityEdge?: ExternalIdentityEdgeResolvers<ContextType>;
  ExternalIdentitySamlAttributes?: ExternalIdentitySamlAttributesResolvers<ContextType>;
  ExternalIdentityScimAttributes?: ExternalIdentityScimAttributesResolvers<ContextType>;
  FileExtensionRestrictionParameters?: FileExtensionRestrictionParametersResolvers<ContextType>;
  FilePathRestrictionParameters?: FilePathRestrictionParametersResolvers<ContextType>;
  FollowOrganizationPayload?: FollowOrganizationPayloadResolvers<ContextType>;
  FollowUserPayload?: FollowUserPayloadResolvers<ContextType>;
  FollowerConnection?: FollowerConnectionResolvers<ContextType>;
  FollowingConnection?: FollowingConnectionResolvers<ContextType>;
  FundingLink?: FundingLinkResolvers<ContextType>;
  GenericHovercardContext?: GenericHovercardContextResolvers<ContextType>;
  Gist?: GistResolvers<ContextType>;
  GistComment?: GistCommentResolvers<ContextType>;
  GistCommentConnection?: GistCommentConnectionResolvers<ContextType>;
  GistCommentEdge?: GistCommentEdgeResolvers<ContextType>;
  GistConnection?: GistConnectionResolvers<ContextType>;
  GistEdge?: GistEdgeResolvers<ContextType>;
  GistFile?: GistFileResolvers<ContextType>;
  GitActor?: GitActorResolvers<ContextType>;
  GitActorConnection?: GitActorConnectionResolvers<ContextType>;
  GitActorEdge?: GitActorEdgeResolvers<ContextType>;
  GitHubMetadata?: GitHubMetadataResolvers<ContextType>;
  GitObject?: GitObjectResolvers<ContextType>;
  GitObjectID?: GraphQLScalarType;
  GitRefname?: GraphQLScalarType;
  GitSSHRemote?: GraphQLScalarType;
  GitSignature?: GitSignatureResolvers<ContextType>;
  GitTimestamp?: GraphQLScalarType;
  GpgSignature?: GpgSignatureResolvers<ContextType>;
  GrantEnterpriseOrganizationsMigratorRolePayload?: GrantEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType>;
  GrantMigratorRolePayload?: GrantMigratorRolePayloadResolvers<ContextType>;
  HTML?: GraphQLScalarType;
  HeadRefDeletedEvent?: HeadRefDeletedEventResolvers<ContextType>;
  HeadRefForcePushedEvent?: HeadRefForcePushedEventResolvers<ContextType>;
  HeadRefRestoredEvent?: HeadRefRestoredEventResolvers<ContextType>;
  Hovercard?: HovercardResolvers<ContextType>;
  HovercardContext?: HovercardContextResolvers<ContextType>;
  ImportProjectPayload?: ImportProjectPayloadResolvers<ContextType>;
  InviteEnterpriseAdminPayload?: InviteEnterpriseAdminPayloadResolvers<ContextType>;
  InviteEnterpriseMemberPayload?: InviteEnterpriseMemberPayloadResolvers<ContextType>;
  IpAllowListEntry?: IpAllowListEntryResolvers<ContextType>;
  IpAllowListEntryConnection?: IpAllowListEntryConnectionResolvers<ContextType>;
  IpAllowListEntryEdge?: IpAllowListEntryEdgeResolvers<ContextType>;
  IpAllowListOwner?: IpAllowListOwnerResolvers<ContextType>;
  Issue?: IssueResolvers<ContextType>;
  IssueComment?: IssueCommentResolvers<ContextType>;
  IssueCommentConnection?: IssueCommentConnectionResolvers<ContextType>;
  IssueCommentEdge?: IssueCommentEdgeResolvers<ContextType>;
  IssueConnection?: IssueConnectionResolvers<ContextType>;
  IssueContributionsByRepository?: IssueContributionsByRepositoryResolvers<ContextType>;
  IssueEdge?: IssueEdgeResolvers<ContextType>;
  IssueOrPullRequest?: IssueOrPullRequestResolvers<ContextType>;
  IssueTemplate?: IssueTemplateResolvers<ContextType>;
  IssueTimelineConnection?: IssueTimelineConnectionResolvers<ContextType>;
  IssueTimelineItem?: IssueTimelineItemResolvers<ContextType>;
  IssueTimelineItemEdge?: IssueTimelineItemEdgeResolvers<ContextType>;
  IssueTimelineItems?: IssueTimelineItemsResolvers<ContextType>;
  IssueTimelineItemsConnection?: IssueTimelineItemsConnectionResolvers<ContextType>;
  IssueTimelineItemsEdge?: IssueTimelineItemsEdgeResolvers<ContextType>;
  JoinedGitHubContribution?: JoinedGitHubContributionResolvers<ContextType>;
  Label?: LabelResolvers<ContextType>;
  LabelConnection?: LabelConnectionResolvers<ContextType>;
  LabelEdge?: LabelEdgeResolvers<ContextType>;
  Labelable?: LabelableResolvers<ContextType>;
  LabeledEvent?: LabeledEventResolvers<ContextType>;
  Language?: LanguageResolvers<ContextType>;
  LanguageConnection?: LanguageConnectionResolvers<ContextType>;
  LanguageEdge?: LanguageEdgeResolvers<ContextType>;
  License?: LicenseResolvers<ContextType>;
  LicenseRule?: LicenseRuleResolvers<ContextType>;
  LinkProjectV2ToRepositoryPayload?: LinkProjectV2ToRepositoryPayloadResolvers<ContextType>;
  LinkProjectV2ToTeamPayload?: LinkProjectV2ToTeamPayloadResolvers<ContextType>;
  LinkRepositoryToProjectPayload?: LinkRepositoryToProjectPayloadResolvers<ContextType>;
  LinkedBranch?: LinkedBranchResolvers<ContextType>;
  LinkedBranchConnection?: LinkedBranchConnectionResolvers<ContextType>;
  LinkedBranchEdge?: LinkedBranchEdgeResolvers<ContextType>;
  LockLockablePayload?: LockLockablePayloadResolvers<ContextType>;
  Lockable?: LockableResolvers<ContextType>;
  LockedEvent?: LockedEventResolvers<ContextType>;
  Mannequin?: MannequinResolvers<ContextType>;
  MannequinConnection?: MannequinConnectionResolvers<ContextType>;
  MannequinEdge?: MannequinEdgeResolvers<ContextType>;
  MarkDiscussionCommentAsAnswerPayload?: MarkDiscussionCommentAsAnswerPayloadResolvers<ContextType>;
  MarkFileAsViewedPayload?: MarkFileAsViewedPayloadResolvers<ContextType>;
  MarkNotificationAsDonePayload?: MarkNotificationAsDonePayloadResolvers<ContextType>;
  MarkProjectV2AsTemplatePayload?: MarkProjectV2AsTemplatePayloadResolvers<ContextType>;
  MarkPullRequestReadyForReviewPayload?: MarkPullRequestReadyForReviewPayloadResolvers<ContextType>;
  MarkedAsDuplicateEvent?: MarkedAsDuplicateEventResolvers<ContextType>;
  MarketplaceCategory?: MarketplaceCategoryResolvers<ContextType>;
  MarketplaceListing?: MarketplaceListingResolvers<ContextType>;
  MarketplaceListingConnection?: MarketplaceListingConnectionResolvers<ContextType>;
  MarketplaceListingEdge?: MarketplaceListingEdgeResolvers<ContextType>;
  MaxFilePathLengthParameters?: MaxFilePathLengthParametersResolvers<ContextType>;
  MaxFileSizeParameters?: MaxFileSizeParametersResolvers<ContextType>;
  MemberFeatureRequestNotification?: MemberFeatureRequestNotificationResolvers<ContextType>;
  MemberStatusable?: MemberStatusableResolvers<ContextType>;
  MembersCanDeleteReposClearAuditEntry?: MembersCanDeleteReposClearAuditEntryResolvers<ContextType>;
  MembersCanDeleteReposDisableAuditEntry?: MembersCanDeleteReposDisableAuditEntryResolvers<ContextType>;
  MembersCanDeleteReposEnableAuditEntry?: MembersCanDeleteReposEnableAuditEntryResolvers<ContextType>;
  MentionedEvent?: MentionedEventResolvers<ContextType>;
  MergeBranchPayload?: MergeBranchPayloadResolvers<ContextType>;
  MergePullRequestPayload?: MergePullRequestPayloadResolvers<ContextType>;
  MergeQueue?: MergeQueueResolvers<ContextType>;
  MergeQueueConfiguration?: MergeQueueConfigurationResolvers<ContextType>;
  MergeQueueEntry?: MergeQueueEntryResolvers<ContextType>;
  MergeQueueEntryConnection?: MergeQueueEntryConnectionResolvers<ContextType>;
  MergeQueueEntryEdge?: MergeQueueEntryEdgeResolvers<ContextType>;
  MergeQueueParameters?: MergeQueueParametersResolvers<ContextType>;
  MergedEvent?: MergedEventResolvers<ContextType>;
  Migration?: MigrationResolvers<ContextType>;
  MigrationSource?: MigrationSourceResolvers<ContextType>;
  Milestone?: MilestoneResolvers<ContextType>;
  MilestoneConnection?: MilestoneConnectionResolvers<ContextType>;
  MilestoneEdge?: MilestoneEdgeResolvers<ContextType>;
  MilestoneItem?: MilestoneItemResolvers<ContextType>;
  MilestonedEvent?: MilestonedEventResolvers<ContextType>;
  Minimizable?: MinimizableResolvers<ContextType>;
  MinimizeCommentPayload?: MinimizeCommentPayloadResolvers<ContextType>;
  MoveProjectCardPayload?: MoveProjectCardPayloadResolvers<ContextType>;
  MoveProjectColumnPayload?: MoveProjectColumnPayloadResolvers<ContextType>;
  MovedColumnsInProjectEvent?: MovedColumnsInProjectEventResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  OIDCProvider?: OidcProviderResolvers<ContextType>;
  OauthApplicationAuditEntryData?: OauthApplicationAuditEntryDataResolvers<ContextType>;
  OauthApplicationCreateAuditEntry?: OauthApplicationCreateAuditEntryResolvers<ContextType>;
  OrgAddBillingManagerAuditEntry?: OrgAddBillingManagerAuditEntryResolvers<ContextType>;
  OrgAddMemberAuditEntry?: OrgAddMemberAuditEntryResolvers<ContextType>;
  OrgBlockUserAuditEntry?: OrgBlockUserAuditEntryResolvers<ContextType>;
  OrgConfigDisableCollaboratorsOnlyAuditEntry?: OrgConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  OrgConfigEnableCollaboratorsOnlyAuditEntry?: OrgConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  OrgCreateAuditEntry?: OrgCreateAuditEntryResolvers<ContextType>;
  OrgDisableOauthAppRestrictionsAuditEntry?: OrgDisableOauthAppRestrictionsAuditEntryResolvers<ContextType>;
  OrgDisableSamlAuditEntry?: OrgDisableSamlAuditEntryResolvers<ContextType>;
  OrgDisableTwoFactorRequirementAuditEntry?: OrgDisableTwoFactorRequirementAuditEntryResolvers<ContextType>;
  OrgEnableOauthAppRestrictionsAuditEntry?: OrgEnableOauthAppRestrictionsAuditEntryResolvers<ContextType>;
  OrgEnableSamlAuditEntry?: OrgEnableSamlAuditEntryResolvers<ContextType>;
  OrgEnableTwoFactorRequirementAuditEntry?: OrgEnableTwoFactorRequirementAuditEntryResolvers<ContextType>;
  OrgInviteMemberAuditEntry?: OrgInviteMemberAuditEntryResolvers<ContextType>;
  OrgInviteToBusinessAuditEntry?: OrgInviteToBusinessAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessApprovedAuditEntry?: OrgOauthAppAccessApprovedAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessBlockedAuditEntry?: OrgOauthAppAccessBlockedAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessDeniedAuditEntry?: OrgOauthAppAccessDeniedAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessRequestedAuditEntry?: OrgOauthAppAccessRequestedAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessUnblockedAuditEntry?: OrgOauthAppAccessUnblockedAuditEntryResolvers<ContextType>;
  OrgRemoveBillingManagerAuditEntry?: OrgRemoveBillingManagerAuditEntryResolvers<ContextType>;
  OrgRemoveMemberAuditEntry?: OrgRemoveMemberAuditEntryResolvers<ContextType>;
  OrgRemoveOutsideCollaboratorAuditEntry?: OrgRemoveOutsideCollaboratorAuditEntryResolvers<ContextType>;
  OrgRestoreMemberAuditEntry?: OrgRestoreMemberAuditEntryResolvers<ContextType>;
  OrgRestoreMemberAuditEntryMembership?: OrgRestoreMemberAuditEntryMembershipResolvers<ContextType>;
  OrgRestoreMemberMembershipOrganizationAuditEntryData?: OrgRestoreMemberMembershipOrganizationAuditEntryDataResolvers<ContextType>;
  OrgRestoreMemberMembershipRepositoryAuditEntryData?: OrgRestoreMemberMembershipRepositoryAuditEntryDataResolvers<ContextType>;
  OrgRestoreMemberMembershipTeamAuditEntryData?: OrgRestoreMemberMembershipTeamAuditEntryDataResolvers<ContextType>;
  OrgUnblockUserAuditEntry?: OrgUnblockUserAuditEntryResolvers<ContextType>;
  OrgUpdateDefaultRepositoryPermissionAuditEntry?: OrgUpdateDefaultRepositoryPermissionAuditEntryResolvers<ContextType>;
  OrgUpdateMemberAuditEntry?: OrgUpdateMemberAuditEntryResolvers<ContextType>;
  OrgUpdateMemberRepositoryCreationPermissionAuditEntry?: OrgUpdateMemberRepositoryCreationPermissionAuditEntryResolvers<ContextType>;
  OrgUpdateMemberRepositoryInvitationPermissionAuditEntry?: OrgUpdateMemberRepositoryInvitationPermissionAuditEntryResolvers<ContextType>;
  Organization?: OrganizationResolvers<ContextType>;
  OrganizationAuditEntry?: OrganizationAuditEntryResolvers<ContextType>;
  OrganizationAuditEntryConnection?: OrganizationAuditEntryConnectionResolvers<ContextType>;
  OrganizationAuditEntryData?: OrganizationAuditEntryDataResolvers<ContextType>;
  OrganizationAuditEntryEdge?: OrganizationAuditEntryEdgeResolvers<ContextType>;
  OrganizationConnection?: OrganizationConnectionResolvers<ContextType>;
  OrganizationEdge?: OrganizationEdgeResolvers<ContextType>;
  OrganizationEnterpriseOwnerConnection?: OrganizationEnterpriseOwnerConnectionResolvers<ContextType>;
  OrganizationEnterpriseOwnerEdge?: OrganizationEnterpriseOwnerEdgeResolvers<ContextType>;
  OrganizationIdentityProvider?: OrganizationIdentityProviderResolvers<ContextType>;
  OrganizationInvitation?: OrganizationInvitationResolvers<ContextType>;
  OrganizationInvitationConnection?: OrganizationInvitationConnectionResolvers<ContextType>;
  OrganizationInvitationEdge?: OrganizationInvitationEdgeResolvers<ContextType>;
  OrganizationMemberConnection?: OrganizationMemberConnectionResolvers<ContextType>;
  OrganizationMemberEdge?: OrganizationMemberEdgeResolvers<ContextType>;
  OrganizationMigration?: OrganizationMigrationResolvers<ContextType>;
  OrganizationOrUser?: OrganizationOrUserResolvers<ContextType>;
  OrganizationTeamsHovercardContext?: OrganizationTeamsHovercardContextResolvers<ContextType>;
  OrganizationsHovercardContext?: OrganizationsHovercardContextResolvers<ContextType>;
  Package?: PackageResolvers<ContextType>;
  PackageConnection?: PackageConnectionResolvers<ContextType>;
  PackageEdge?: PackageEdgeResolvers<ContextType>;
  PackageFile?: PackageFileResolvers<ContextType>;
  PackageFileConnection?: PackageFileConnectionResolvers<ContextType>;
  PackageFileEdge?: PackageFileEdgeResolvers<ContextType>;
  PackageOwner?: PackageOwnerResolvers<ContextType>;
  PackageStatistics?: PackageStatisticsResolvers<ContextType>;
  PackageTag?: PackageTagResolvers<ContextType>;
  PackageVersion?: PackageVersionResolvers<ContextType>;
  PackageVersionConnection?: PackageVersionConnectionResolvers<ContextType>;
  PackageVersionEdge?: PackageVersionEdgeResolvers<ContextType>;
  PackageVersionStatistics?: PackageVersionStatisticsResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  PermissionGranter?: PermissionGranterResolvers<ContextType>;
  PermissionSource?: PermissionSourceResolvers<ContextType>;
  PinEnvironmentPayload?: PinEnvironmentPayloadResolvers<ContextType>;
  PinIssuePayload?: PinIssuePayloadResolvers<ContextType>;
  PinnableItem?: PinnableItemResolvers<ContextType>;
  PinnableItemConnection?: PinnableItemConnectionResolvers<ContextType>;
  PinnableItemEdge?: PinnableItemEdgeResolvers<ContextType>;
  PinnedDiscussion?: PinnedDiscussionResolvers<ContextType>;
  PinnedDiscussionConnection?: PinnedDiscussionConnectionResolvers<ContextType>;
  PinnedDiscussionEdge?: PinnedDiscussionEdgeResolvers<ContextType>;
  PinnedEnvironment?: PinnedEnvironmentResolvers<ContextType>;
  PinnedEnvironmentConnection?: PinnedEnvironmentConnectionResolvers<ContextType>;
  PinnedEnvironmentEdge?: PinnedEnvironmentEdgeResolvers<ContextType>;
  PinnedEvent?: PinnedEventResolvers<ContextType>;
  PinnedIssue?: PinnedIssueResolvers<ContextType>;
  PinnedIssueConnection?: PinnedIssueConnectionResolvers<ContextType>;
  PinnedIssueEdge?: PinnedIssueEdgeResolvers<ContextType>;
  PreciseDateTime?: GraphQLScalarType;
  PrivateRepositoryForkingDisableAuditEntry?: PrivateRepositoryForkingDisableAuditEntryResolvers<ContextType>;
  PrivateRepositoryForkingEnableAuditEntry?: PrivateRepositoryForkingEnableAuditEntryResolvers<ContextType>;
  ProfileItemShowcase?: ProfileItemShowcaseResolvers<ContextType>;
  ProfileOwner?: ProfileOwnerResolvers<ContextType>;
  Project?: ProjectResolvers<ContextType>;
  ProjectCard?: ProjectCardResolvers<ContextType>;
  ProjectCardConnection?: ProjectCardConnectionResolvers<ContextType>;
  ProjectCardEdge?: ProjectCardEdgeResolvers<ContextType>;
  ProjectCardItem?: ProjectCardItemResolvers<ContextType>;
  ProjectColumn?: ProjectColumnResolvers<ContextType>;
  ProjectColumnConnection?: ProjectColumnConnectionResolvers<ContextType>;
  ProjectColumnEdge?: ProjectColumnEdgeResolvers<ContextType>;
  ProjectConnection?: ProjectConnectionResolvers<ContextType>;
  ProjectEdge?: ProjectEdgeResolvers<ContextType>;
  ProjectOwner?: ProjectOwnerResolvers<ContextType>;
  ProjectProgress?: ProjectProgressResolvers<ContextType>;
  ProjectV2?: ProjectV2Resolvers<ContextType>;
  ProjectV2Actor?: ProjectV2ActorResolvers<ContextType>;
  ProjectV2ActorConnection?: ProjectV2ActorConnectionResolvers<ContextType>;
  ProjectV2ActorEdge?: ProjectV2ActorEdgeResolvers<ContextType>;
  ProjectV2Connection?: ProjectV2ConnectionResolvers<ContextType>;
  ProjectV2Edge?: ProjectV2EdgeResolvers<ContextType>;
  ProjectV2Field?: ProjectV2FieldResolvers<ContextType>;
  ProjectV2FieldCommon?: ProjectV2FieldCommonResolvers<ContextType>;
  ProjectV2FieldConfiguration?: ProjectV2FieldConfigurationResolvers<ContextType>;
  ProjectV2FieldConfigurationConnection?: ProjectV2FieldConfigurationConnectionResolvers<ContextType>;
  ProjectV2FieldConfigurationEdge?: ProjectV2FieldConfigurationEdgeResolvers<ContextType>;
  ProjectV2FieldConnection?: ProjectV2FieldConnectionResolvers<ContextType>;
  ProjectV2FieldEdge?: ProjectV2FieldEdgeResolvers<ContextType>;
  ProjectV2Item?: ProjectV2ItemResolvers<ContextType>;
  ProjectV2ItemConnection?: ProjectV2ItemConnectionResolvers<ContextType>;
  ProjectV2ItemContent?: ProjectV2ItemContentResolvers<ContextType>;
  ProjectV2ItemEdge?: ProjectV2ItemEdgeResolvers<ContextType>;
  ProjectV2ItemFieldDateValue?: ProjectV2ItemFieldDateValueResolvers<ContextType>;
  ProjectV2ItemFieldIterationValue?: ProjectV2ItemFieldIterationValueResolvers<ContextType>;
  ProjectV2ItemFieldLabelValue?: ProjectV2ItemFieldLabelValueResolvers<ContextType>;
  ProjectV2ItemFieldMilestoneValue?: ProjectV2ItemFieldMilestoneValueResolvers<ContextType>;
  ProjectV2ItemFieldNumberValue?: ProjectV2ItemFieldNumberValueResolvers<ContextType>;
  ProjectV2ItemFieldPullRequestValue?: ProjectV2ItemFieldPullRequestValueResolvers<ContextType>;
  ProjectV2ItemFieldRepositoryValue?: ProjectV2ItemFieldRepositoryValueResolvers<ContextType>;
  ProjectV2ItemFieldReviewerValue?: ProjectV2ItemFieldReviewerValueResolvers<ContextType>;
  ProjectV2ItemFieldSingleSelectValue?: ProjectV2ItemFieldSingleSelectValueResolvers<ContextType>;
  ProjectV2ItemFieldTextValue?: ProjectV2ItemFieldTextValueResolvers<ContextType>;
  ProjectV2ItemFieldUserValue?: ProjectV2ItemFieldUserValueResolvers<ContextType>;
  ProjectV2ItemFieldValue?: ProjectV2ItemFieldValueResolvers<ContextType>;
  ProjectV2ItemFieldValueCommon?: ProjectV2ItemFieldValueCommonResolvers<ContextType>;
  ProjectV2ItemFieldValueConnection?: ProjectV2ItemFieldValueConnectionResolvers<ContextType>;
  ProjectV2ItemFieldValueEdge?: ProjectV2ItemFieldValueEdgeResolvers<ContextType>;
  ProjectV2IterationField?: ProjectV2IterationFieldResolvers<ContextType>;
  ProjectV2IterationFieldConfiguration?: ProjectV2IterationFieldConfigurationResolvers<ContextType>;
  ProjectV2IterationFieldIteration?: ProjectV2IterationFieldIterationResolvers<ContextType>;
  ProjectV2Owner?: ProjectV2OwnerResolvers<ContextType>;
  ProjectV2Recent?: ProjectV2RecentResolvers<ContextType>;
  ProjectV2SingleSelectField?: ProjectV2SingleSelectFieldResolvers<ContextType>;
  ProjectV2SingleSelectFieldOption?: ProjectV2SingleSelectFieldOptionResolvers<ContextType>;
  ProjectV2SortBy?: ProjectV2SortByResolvers<ContextType>;
  ProjectV2SortByConnection?: ProjectV2SortByConnectionResolvers<ContextType>;
  ProjectV2SortByEdge?: ProjectV2SortByEdgeResolvers<ContextType>;
  ProjectV2SortByField?: ProjectV2SortByFieldResolvers<ContextType>;
  ProjectV2SortByFieldConnection?: ProjectV2SortByFieldConnectionResolvers<ContextType>;
  ProjectV2SortByFieldEdge?: ProjectV2SortByFieldEdgeResolvers<ContextType>;
  ProjectV2StatusUpdate?: ProjectV2StatusUpdateResolvers<ContextType>;
  ProjectV2StatusUpdateConnection?: ProjectV2StatusUpdateConnectionResolvers<ContextType>;
  ProjectV2StatusUpdateEdge?: ProjectV2StatusUpdateEdgeResolvers<ContextType>;
  ProjectV2View?: ProjectV2ViewResolvers<ContextType>;
  ProjectV2ViewConnection?: ProjectV2ViewConnectionResolvers<ContextType>;
  ProjectV2ViewEdge?: ProjectV2ViewEdgeResolvers<ContextType>;
  ProjectV2Workflow?: ProjectV2WorkflowResolvers<ContextType>;
  ProjectV2WorkflowConnection?: ProjectV2WorkflowConnectionResolvers<ContextType>;
  ProjectV2WorkflowEdge?: ProjectV2WorkflowEdgeResolvers<ContextType>;
  PropertyTargetDefinition?: PropertyTargetDefinitionResolvers<ContextType>;
  PublicKey?: PublicKeyResolvers<ContextType>;
  PublicKeyConnection?: PublicKeyConnectionResolvers<ContextType>;
  PublicKeyEdge?: PublicKeyEdgeResolvers<ContextType>;
  PublishSponsorsTierPayload?: PublishSponsorsTierPayloadResolvers<ContextType>;
  PullRequest?: PullRequestResolvers<ContextType>;
  PullRequestChangedFile?: PullRequestChangedFileResolvers<ContextType>;
  PullRequestChangedFileConnection?: PullRequestChangedFileConnectionResolvers<ContextType>;
  PullRequestChangedFileEdge?: PullRequestChangedFileEdgeResolvers<ContextType>;
  PullRequestCommit?: PullRequestCommitResolvers<ContextType>;
  PullRequestCommitCommentThread?: PullRequestCommitCommentThreadResolvers<ContextType>;
  PullRequestCommitConnection?: PullRequestCommitConnectionResolvers<ContextType>;
  PullRequestCommitEdge?: PullRequestCommitEdgeResolvers<ContextType>;
  PullRequestConnection?: PullRequestConnectionResolvers<ContextType>;
  PullRequestContributionsByRepository?: PullRequestContributionsByRepositoryResolvers<ContextType>;
  PullRequestEdge?: PullRequestEdgeResolvers<ContextType>;
  PullRequestParameters?: PullRequestParametersResolvers<ContextType>;
  PullRequestReview?: PullRequestReviewResolvers<ContextType>;
  PullRequestReviewComment?: PullRequestReviewCommentResolvers<ContextType>;
  PullRequestReviewCommentConnection?: PullRequestReviewCommentConnectionResolvers<ContextType>;
  PullRequestReviewCommentEdge?: PullRequestReviewCommentEdgeResolvers<ContextType>;
  PullRequestReviewConnection?: PullRequestReviewConnectionResolvers<ContextType>;
  PullRequestReviewContributionsByRepository?: PullRequestReviewContributionsByRepositoryResolvers<ContextType>;
  PullRequestReviewEdge?: PullRequestReviewEdgeResolvers<ContextType>;
  PullRequestReviewThread?: PullRequestReviewThreadResolvers<ContextType>;
  PullRequestReviewThreadConnection?: PullRequestReviewThreadConnectionResolvers<ContextType>;
  PullRequestReviewThreadEdge?: PullRequestReviewThreadEdgeResolvers<ContextType>;
  PullRequestRevisionMarker?: PullRequestRevisionMarkerResolvers<ContextType>;
  PullRequestTemplate?: PullRequestTemplateResolvers<ContextType>;
  PullRequestThread?: PullRequestThreadResolvers<ContextType>;
  PullRequestTimelineConnection?: PullRequestTimelineConnectionResolvers<ContextType>;
  PullRequestTimelineItem?: PullRequestTimelineItemResolvers<ContextType>;
  PullRequestTimelineItemEdge?: PullRequestTimelineItemEdgeResolvers<ContextType>;
  PullRequestTimelineItems?: PullRequestTimelineItemsResolvers<ContextType>;
  PullRequestTimelineItemsConnection?: PullRequestTimelineItemsConnectionResolvers<ContextType>;
  PullRequestTimelineItemsEdge?: PullRequestTimelineItemsEdgeResolvers<ContextType>;
  Push?: PushResolvers<ContextType>;
  PushAllowance?: PushAllowanceResolvers<ContextType>;
  PushAllowanceActor?: PushAllowanceActorResolvers<ContextType>;
  PushAllowanceConnection?: PushAllowanceConnectionResolvers<ContextType>;
  PushAllowanceEdge?: PushAllowanceEdgeResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  RateLimit?: RateLimitResolvers<ContextType>;
  Reactable?: ReactableResolvers<ContextType>;
  ReactingUserConnection?: ReactingUserConnectionResolvers<ContextType>;
  ReactingUserEdge?: ReactingUserEdgeResolvers<ContextType>;
  Reaction?: ReactionResolvers<ContextType>;
  ReactionConnection?: ReactionConnectionResolvers<ContextType>;
  ReactionEdge?: ReactionEdgeResolvers<ContextType>;
  ReactionGroup?: ReactionGroupResolvers<ContextType>;
  Reactor?: ReactorResolvers<ContextType>;
  ReactorConnection?: ReactorConnectionResolvers<ContextType>;
  ReactorEdge?: ReactorEdgeResolvers<ContextType>;
  ReadyForReviewEvent?: ReadyForReviewEventResolvers<ContextType>;
  Ref?: RefResolvers<ContextType>;
  RefConnection?: RefConnectionResolvers<ContextType>;
  RefEdge?: RefEdgeResolvers<ContextType>;
  RefNameConditionTarget?: RefNameConditionTargetResolvers<ContextType>;
  RefUpdateRule?: RefUpdateRuleResolvers<ContextType>;
  ReferencedEvent?: ReferencedEventResolvers<ContextType>;
  ReferencedSubject?: ReferencedSubjectResolvers<ContextType>;
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload?: RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadResolvers<ContextType>;
  RegenerateVerifiableDomainTokenPayload?: RegenerateVerifiableDomainTokenPayloadResolvers<ContextType>;
  RejectDeploymentsPayload?: RejectDeploymentsPayloadResolvers<ContextType>;
  Release?: ReleaseResolvers<ContextType>;
  ReleaseAsset?: ReleaseAssetResolvers<ContextType>;
  ReleaseAssetConnection?: ReleaseAssetConnectionResolvers<ContextType>;
  ReleaseAssetEdge?: ReleaseAssetEdgeResolvers<ContextType>;
  ReleaseConnection?: ReleaseConnectionResolvers<ContextType>;
  ReleaseEdge?: ReleaseEdgeResolvers<ContextType>;
  RemoveAssigneesFromAssignablePayload?: RemoveAssigneesFromAssignablePayloadResolvers<ContextType>;
  RemoveEnterpriseAdminPayload?: RemoveEnterpriseAdminPayloadResolvers<ContextType>;
  RemoveEnterpriseIdentityProviderPayload?: RemoveEnterpriseIdentityProviderPayloadResolvers<ContextType>;
  RemoveEnterpriseMemberPayload?: RemoveEnterpriseMemberPayloadResolvers<ContextType>;
  RemoveEnterpriseOrganizationPayload?: RemoveEnterpriseOrganizationPayloadResolvers<ContextType>;
  RemoveEnterpriseSupportEntitlementPayload?: RemoveEnterpriseSupportEntitlementPayloadResolvers<ContextType>;
  RemoveLabelsFromLabelablePayload?: RemoveLabelsFromLabelablePayloadResolvers<ContextType>;
  RemoveOutsideCollaboratorPayload?: RemoveOutsideCollaboratorPayloadResolvers<ContextType>;
  RemoveReactionPayload?: RemoveReactionPayloadResolvers<ContextType>;
  RemoveStarPayload?: RemoveStarPayloadResolvers<ContextType>;
  RemoveUpvotePayload?: RemoveUpvotePayloadResolvers<ContextType>;
  RemovedFromMergeQueueEvent?: RemovedFromMergeQueueEventResolvers<ContextType>;
  RemovedFromProjectEvent?: RemovedFromProjectEventResolvers<ContextType>;
  RenamedTitleEvent?: RenamedTitleEventResolvers<ContextType>;
  RenamedTitleSubject?: RenamedTitleSubjectResolvers<ContextType>;
  ReopenDiscussionPayload?: ReopenDiscussionPayloadResolvers<ContextType>;
  ReopenIssuePayload?: ReopenIssuePayloadResolvers<ContextType>;
  ReopenPullRequestPayload?: ReopenPullRequestPayloadResolvers<ContextType>;
  ReopenedEvent?: ReopenedEventResolvers<ContextType>;
  ReorderEnvironmentPayload?: ReorderEnvironmentPayloadResolvers<ContextType>;
  RepoAccessAuditEntry?: RepoAccessAuditEntryResolvers<ContextType>;
  RepoAddMemberAuditEntry?: RepoAddMemberAuditEntryResolvers<ContextType>;
  RepoAddTopicAuditEntry?: RepoAddTopicAuditEntryResolvers<ContextType>;
  RepoArchivedAuditEntry?: RepoArchivedAuditEntryResolvers<ContextType>;
  RepoChangeMergeSettingAuditEntry?: RepoChangeMergeSettingAuditEntryResolvers<ContextType>;
  RepoConfigDisableAnonymousGitAccessAuditEntry?: RepoConfigDisableAnonymousGitAccessAuditEntryResolvers<ContextType>;
  RepoConfigDisableCollaboratorsOnlyAuditEntry?: RepoConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  RepoConfigDisableContributorsOnlyAuditEntry?: RepoConfigDisableContributorsOnlyAuditEntryResolvers<ContextType>;
  RepoConfigDisableSockpuppetDisallowedAuditEntry?: RepoConfigDisableSockpuppetDisallowedAuditEntryResolvers<ContextType>;
  RepoConfigEnableAnonymousGitAccessAuditEntry?: RepoConfigEnableAnonymousGitAccessAuditEntryResolvers<ContextType>;
  RepoConfigEnableCollaboratorsOnlyAuditEntry?: RepoConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  RepoConfigEnableContributorsOnlyAuditEntry?: RepoConfigEnableContributorsOnlyAuditEntryResolvers<ContextType>;
  RepoConfigEnableSockpuppetDisallowedAuditEntry?: RepoConfigEnableSockpuppetDisallowedAuditEntryResolvers<ContextType>;
  RepoConfigLockAnonymousGitAccessAuditEntry?: RepoConfigLockAnonymousGitAccessAuditEntryResolvers<ContextType>;
  RepoConfigUnlockAnonymousGitAccessAuditEntry?: RepoConfigUnlockAnonymousGitAccessAuditEntryResolvers<ContextType>;
  RepoCreateAuditEntry?: RepoCreateAuditEntryResolvers<ContextType>;
  RepoDestroyAuditEntry?: RepoDestroyAuditEntryResolvers<ContextType>;
  RepoRemoveMemberAuditEntry?: RepoRemoveMemberAuditEntryResolvers<ContextType>;
  RepoRemoveTopicAuditEntry?: RepoRemoveTopicAuditEntryResolvers<ContextType>;
  Repository?: RepositoryResolvers<ContextType>;
  RepositoryAuditEntryData?: RepositoryAuditEntryDataResolvers<ContextType>;
  RepositoryCodeowners?: RepositoryCodeownersResolvers<ContextType>;
  RepositoryCodeownersError?: RepositoryCodeownersErrorResolvers<ContextType>;
  RepositoryCollaboratorConnection?: RepositoryCollaboratorConnectionResolvers<ContextType>;
  RepositoryCollaboratorEdge?: RepositoryCollaboratorEdgeResolvers<ContextType>;
  RepositoryConnection?: RepositoryConnectionResolvers<ContextType>;
  RepositoryContactLink?: RepositoryContactLinkResolvers<ContextType>;
  RepositoryDiscussionAuthor?: RepositoryDiscussionAuthorResolvers<ContextType>;
  RepositoryDiscussionCommentAuthor?: RepositoryDiscussionCommentAuthorResolvers<ContextType>;
  RepositoryEdge?: RepositoryEdgeResolvers<ContextType>;
  RepositoryIdConditionTarget?: RepositoryIdConditionTargetResolvers<ContextType>;
  RepositoryInfo?: RepositoryInfoResolvers<ContextType>;
  RepositoryInteractionAbility?: RepositoryInteractionAbilityResolvers<ContextType>;
  RepositoryInvitation?: RepositoryInvitationResolvers<ContextType>;
  RepositoryInvitationConnection?: RepositoryInvitationConnectionResolvers<ContextType>;
  RepositoryInvitationEdge?: RepositoryInvitationEdgeResolvers<ContextType>;
  RepositoryMigration?: RepositoryMigrationResolvers<ContextType>;
  RepositoryMigrationConnection?: RepositoryMigrationConnectionResolvers<ContextType>;
  RepositoryMigrationEdge?: RepositoryMigrationEdgeResolvers<ContextType>;
  RepositoryNameConditionTarget?: RepositoryNameConditionTargetResolvers<ContextType>;
  RepositoryNode?: RepositoryNodeResolvers<ContextType>;
  RepositoryOwner?: RepositoryOwnerResolvers<ContextType>;
  RepositoryPlanFeatures?: RepositoryPlanFeaturesResolvers<ContextType>;
  RepositoryPropertyConditionTarget?: RepositoryPropertyConditionTargetResolvers<ContextType>;
  RepositoryRule?: RepositoryRuleResolvers<ContextType>;
  RepositoryRuleConditions?: RepositoryRuleConditionsResolvers<ContextType>;
  RepositoryRuleConnection?: RepositoryRuleConnectionResolvers<ContextType>;
  RepositoryRuleEdge?: RepositoryRuleEdgeResolvers<ContextType>;
  RepositoryRuleset?: RepositoryRulesetResolvers<ContextType>;
  RepositoryRulesetBypassActor?: RepositoryRulesetBypassActorResolvers<ContextType>;
  RepositoryRulesetBypassActorConnection?: RepositoryRulesetBypassActorConnectionResolvers<ContextType>;
  RepositoryRulesetBypassActorEdge?: RepositoryRulesetBypassActorEdgeResolvers<ContextType>;
  RepositoryRulesetConnection?: RepositoryRulesetConnectionResolvers<ContextType>;
  RepositoryRulesetEdge?: RepositoryRulesetEdgeResolvers<ContextType>;
  RepositoryTopic?: RepositoryTopicResolvers<ContextType>;
  RepositoryTopicConnection?: RepositoryTopicConnectionResolvers<ContextType>;
  RepositoryTopicEdge?: RepositoryTopicEdgeResolvers<ContextType>;
  RepositoryVisibilityChangeDisableAuditEntry?: RepositoryVisibilityChangeDisableAuditEntryResolvers<ContextType>;
  RepositoryVisibilityChangeEnableAuditEntry?: RepositoryVisibilityChangeEnableAuditEntryResolvers<ContextType>;
  RepositoryVulnerabilityAlert?: RepositoryVulnerabilityAlertResolvers<ContextType>;
  RepositoryVulnerabilityAlertConnection?: RepositoryVulnerabilityAlertConnectionResolvers<ContextType>;
  RepositoryVulnerabilityAlertEdge?: RepositoryVulnerabilityAlertEdgeResolvers<ContextType>;
  RequestReviewsPayload?: RequestReviewsPayloadResolvers<ContextType>;
  RequestedReviewer?: RequestedReviewerResolvers<ContextType>;
  RequestedReviewerConnection?: RequestedReviewerConnectionResolvers<ContextType>;
  RequestedReviewerEdge?: RequestedReviewerEdgeResolvers<ContextType>;
  RequirableByPullRequest?: RequirableByPullRequestResolvers<ContextType>;
  RequiredDeploymentsParameters?: RequiredDeploymentsParametersResolvers<ContextType>;
  RequiredStatusCheckDescription?: RequiredStatusCheckDescriptionResolvers<ContextType>;
  RequiredStatusChecksParameters?: RequiredStatusChecksParametersResolvers<ContextType>;
  RerequestCheckSuitePayload?: RerequestCheckSuitePayloadResolvers<ContextType>;
  ResolveReviewThreadPayload?: ResolveReviewThreadPayloadResolvers<ContextType>;
  RestrictedContribution?: RestrictedContributionResolvers<ContextType>;
  RetireSponsorsTierPayload?: RetireSponsorsTierPayloadResolvers<ContextType>;
  RevertPullRequestPayload?: RevertPullRequestPayloadResolvers<ContextType>;
  ReviewDismissalAllowance?: ReviewDismissalAllowanceResolvers<ContextType>;
  ReviewDismissalAllowanceActor?: ReviewDismissalAllowanceActorResolvers<ContextType>;
  ReviewDismissalAllowanceConnection?: ReviewDismissalAllowanceConnectionResolvers<ContextType>;
  ReviewDismissalAllowanceEdge?: ReviewDismissalAllowanceEdgeResolvers<ContextType>;
  ReviewDismissedEvent?: ReviewDismissedEventResolvers<ContextType>;
  ReviewRequest?: ReviewRequestResolvers<ContextType>;
  ReviewRequestConnection?: ReviewRequestConnectionResolvers<ContextType>;
  ReviewRequestEdge?: ReviewRequestEdgeResolvers<ContextType>;
  ReviewRequestRemovedEvent?: ReviewRequestRemovedEventResolvers<ContextType>;
  ReviewRequestedEvent?: ReviewRequestedEventResolvers<ContextType>;
  ReviewStatusHovercardContext?: ReviewStatusHovercardContextResolvers<ContextType>;
  RevokeEnterpriseOrganizationsMigratorRolePayload?: RevokeEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType>;
  RevokeMigratorRolePayload?: RevokeMigratorRolePayloadResolvers<ContextType>;
  RuleParameters?: RuleParametersResolvers<ContextType>;
  RuleSource?: RuleSourceResolvers<ContextType>;
  SavedReply?: SavedReplyResolvers<ContextType>;
  SavedReplyConnection?: SavedReplyConnectionResolvers<ContextType>;
  SavedReplyEdge?: SavedReplyEdgeResolvers<ContextType>;
  SearchResultItem?: SearchResultItemResolvers<ContextType>;
  SearchResultItemConnection?: SearchResultItemConnectionResolvers<ContextType>;
  SearchResultItemEdge?: SearchResultItemEdgeResolvers<ContextType>;
  SecurityAdvisory?: SecurityAdvisoryResolvers<ContextType>;
  SecurityAdvisoryConnection?: SecurityAdvisoryConnectionResolvers<ContextType>;
  SecurityAdvisoryEdge?: SecurityAdvisoryEdgeResolvers<ContextType>;
  SecurityAdvisoryIdentifier?: SecurityAdvisoryIdentifierResolvers<ContextType>;
  SecurityAdvisoryPackage?: SecurityAdvisoryPackageResolvers<ContextType>;
  SecurityAdvisoryPackageVersion?: SecurityAdvisoryPackageVersionResolvers<ContextType>;
  SecurityAdvisoryReference?: SecurityAdvisoryReferenceResolvers<ContextType>;
  SecurityVulnerability?: SecurityVulnerabilityResolvers<ContextType>;
  SecurityVulnerabilityConnection?: SecurityVulnerabilityConnectionResolvers<ContextType>;
  SecurityVulnerabilityEdge?: SecurityVulnerabilityEdgeResolvers<ContextType>;
  SetEnterpriseIdentityProviderPayload?: SetEnterpriseIdentityProviderPayloadResolvers<ContextType>;
  SetOrganizationInteractionLimitPayload?: SetOrganizationInteractionLimitPayloadResolvers<ContextType>;
  SetRepositoryInteractionLimitPayload?: SetRepositoryInteractionLimitPayloadResolvers<ContextType>;
  SetUserInteractionLimitPayload?: SetUserInteractionLimitPayloadResolvers<ContextType>;
  SmimeSignature?: SmimeSignatureResolvers<ContextType>;
  SocialAccount?: SocialAccountResolvers<ContextType>;
  SocialAccountConnection?: SocialAccountConnectionResolvers<ContextType>;
  SocialAccountEdge?: SocialAccountEdgeResolvers<ContextType>;
  Sponsor?: SponsorResolvers<ContextType>;
  SponsorAndLifetimeValue?: SponsorAndLifetimeValueResolvers<ContextType>;
  SponsorAndLifetimeValueConnection?: SponsorAndLifetimeValueConnectionResolvers<ContextType>;
  SponsorAndLifetimeValueEdge?: SponsorAndLifetimeValueEdgeResolvers<ContextType>;
  SponsorConnection?: SponsorConnectionResolvers<ContextType>;
  SponsorEdge?: SponsorEdgeResolvers<ContextType>;
  Sponsorable?: SponsorableResolvers<ContextType>;
  SponsorableItem?: SponsorableItemResolvers<ContextType>;
  SponsorableItemConnection?: SponsorableItemConnectionResolvers<ContextType>;
  SponsorableItemEdge?: SponsorableItemEdgeResolvers<ContextType>;
  SponsorsActivity?: SponsorsActivityResolvers<ContextType>;
  SponsorsActivityConnection?: SponsorsActivityConnectionResolvers<ContextType>;
  SponsorsActivityEdge?: SponsorsActivityEdgeResolvers<ContextType>;
  SponsorsGoal?: SponsorsGoalResolvers<ContextType>;
  SponsorsListing?: SponsorsListingResolvers<ContextType>;
  SponsorsListingFeatureableItem?: SponsorsListingFeatureableItemResolvers<ContextType>;
  SponsorsListingFeaturedItem?: SponsorsListingFeaturedItemResolvers<ContextType>;
  SponsorsTier?: SponsorsTierResolvers<ContextType>;
  SponsorsTierAdminInfo?: SponsorsTierAdminInfoResolvers<ContextType>;
  SponsorsTierConnection?: SponsorsTierConnectionResolvers<ContextType>;
  SponsorsTierEdge?: SponsorsTierEdgeResolvers<ContextType>;
  Sponsorship?: SponsorshipResolvers<ContextType>;
  SponsorshipConnection?: SponsorshipConnectionResolvers<ContextType>;
  SponsorshipEdge?: SponsorshipEdgeResolvers<ContextType>;
  SponsorshipNewsletter?: SponsorshipNewsletterResolvers<ContextType>;
  SponsorshipNewsletterConnection?: SponsorshipNewsletterConnectionResolvers<ContextType>;
  SponsorshipNewsletterEdge?: SponsorshipNewsletterEdgeResolvers<ContextType>;
  SshSignature?: SshSignatureResolvers<ContextType>;
  StargazerConnection?: StargazerConnectionResolvers<ContextType>;
  StargazerEdge?: StargazerEdgeResolvers<ContextType>;
  Starrable?: StarrableResolvers<ContextType>;
  StarredRepositoryConnection?: StarredRepositoryConnectionResolvers<ContextType>;
  StarredRepositoryEdge?: StarredRepositoryEdgeResolvers<ContextType>;
  StartOrganizationMigrationPayload?: StartOrganizationMigrationPayloadResolvers<ContextType>;
  StartRepositoryMigrationPayload?: StartRepositoryMigrationPayloadResolvers<ContextType>;
  Status?: StatusResolvers<ContextType>;
  StatusCheckConfiguration?: StatusCheckConfigurationResolvers<ContextType>;
  StatusCheckRollup?: StatusCheckRollupResolvers<ContextType>;
  StatusCheckRollupContext?: StatusCheckRollupContextResolvers<ContextType>;
  StatusCheckRollupContextConnection?: StatusCheckRollupContextConnectionResolvers<ContextType>;
  StatusCheckRollupContextEdge?: StatusCheckRollupContextEdgeResolvers<ContextType>;
  StatusContext?: StatusContextResolvers<ContextType>;
  StatusContextStateCount?: StatusContextStateCountResolvers<ContextType>;
  StripeConnectAccount?: StripeConnectAccountResolvers<ContextType>;
  SubmitPullRequestReviewPayload?: SubmitPullRequestReviewPayloadResolvers<ContextType>;
  Submodule?: SubmoduleResolvers<ContextType>;
  SubmoduleConnection?: SubmoduleConnectionResolvers<ContextType>;
  SubmoduleEdge?: SubmoduleEdgeResolvers<ContextType>;
  Subscribable?: SubscribableResolvers<ContextType>;
  SubscribableThread?: SubscribableThreadResolvers<ContextType>;
  SubscribedEvent?: SubscribedEventResolvers<ContextType>;
  SuggestedReviewer?: SuggestedReviewerResolvers<ContextType>;
  Tag?: TagResolvers<ContextType>;
  TagNamePatternParameters?: TagNamePatternParametersResolvers<ContextType>;
  Team?: TeamResolvers<ContextType>;
  TeamAddMemberAuditEntry?: TeamAddMemberAuditEntryResolvers<ContextType>;
  TeamAddRepositoryAuditEntry?: TeamAddRepositoryAuditEntryResolvers<ContextType>;
  TeamAuditEntryData?: TeamAuditEntryDataResolvers<ContextType>;
  TeamChangeParentTeamAuditEntry?: TeamChangeParentTeamAuditEntryResolvers<ContextType>;
  TeamConnection?: TeamConnectionResolvers<ContextType>;
  TeamDiscussion?: TeamDiscussionResolvers<ContextType>;
  TeamDiscussionComment?: TeamDiscussionCommentResolvers<ContextType>;
  TeamDiscussionCommentConnection?: TeamDiscussionCommentConnectionResolvers<ContextType>;
  TeamDiscussionCommentEdge?: TeamDiscussionCommentEdgeResolvers<ContextType>;
  TeamDiscussionConnection?: TeamDiscussionConnectionResolvers<ContextType>;
  TeamDiscussionEdge?: TeamDiscussionEdgeResolvers<ContextType>;
  TeamEdge?: TeamEdgeResolvers<ContextType>;
  TeamMemberConnection?: TeamMemberConnectionResolvers<ContextType>;
  TeamMemberEdge?: TeamMemberEdgeResolvers<ContextType>;
  TeamRemoveMemberAuditEntry?: TeamRemoveMemberAuditEntryResolvers<ContextType>;
  TeamRemoveRepositoryAuditEntry?: TeamRemoveRepositoryAuditEntryResolvers<ContextType>;
  TeamRepositoryConnection?: TeamRepositoryConnectionResolvers<ContextType>;
  TeamRepositoryEdge?: TeamRepositoryEdgeResolvers<ContextType>;
  TextMatch?: TextMatchResolvers<ContextType>;
  TextMatchHighlight?: TextMatchHighlightResolvers<ContextType>;
  Topic?: TopicResolvers<ContextType>;
  TopicAuditEntryData?: TopicAuditEntryDataResolvers<ContextType>;
  TransferEnterpriseOrganizationPayload?: TransferEnterpriseOrganizationPayloadResolvers<ContextType>;
  TransferIssuePayload?: TransferIssuePayloadResolvers<ContextType>;
  TransferredEvent?: TransferredEventResolvers<ContextType>;
  Tree?: TreeResolvers<ContextType>;
  TreeEntry?: TreeEntryResolvers<ContextType>;
  URI?: GraphQLScalarType;
  UnarchiveProjectV2ItemPayload?: UnarchiveProjectV2ItemPayloadResolvers<ContextType>;
  UnarchiveRepositoryPayload?: UnarchiveRepositoryPayloadResolvers<ContextType>;
  UnassignedEvent?: UnassignedEventResolvers<ContextType>;
  UnfollowOrganizationPayload?: UnfollowOrganizationPayloadResolvers<ContextType>;
  UnfollowUserPayload?: UnfollowUserPayloadResolvers<ContextType>;
  UniformResourceLocatable?: UniformResourceLocatableResolvers<ContextType>;
  UnknownSignature?: UnknownSignatureResolvers<ContextType>;
  UnlabeledEvent?: UnlabeledEventResolvers<ContextType>;
  UnlinkProjectV2FromRepositoryPayload?: UnlinkProjectV2FromRepositoryPayloadResolvers<ContextType>;
  UnlinkProjectV2FromTeamPayload?: UnlinkProjectV2FromTeamPayloadResolvers<ContextType>;
  UnlinkRepositoryFromProjectPayload?: UnlinkRepositoryFromProjectPayloadResolvers<ContextType>;
  UnlockLockablePayload?: UnlockLockablePayloadResolvers<ContextType>;
  UnlockedEvent?: UnlockedEventResolvers<ContextType>;
  UnmarkDiscussionCommentAsAnswerPayload?: UnmarkDiscussionCommentAsAnswerPayloadResolvers<ContextType>;
  UnmarkFileAsViewedPayload?: UnmarkFileAsViewedPayloadResolvers<ContextType>;
  UnmarkIssueAsDuplicatePayload?: UnmarkIssueAsDuplicatePayloadResolvers<ContextType>;
  UnmarkProjectV2AsTemplatePayload?: UnmarkProjectV2AsTemplatePayloadResolvers<ContextType>;
  UnmarkedAsDuplicateEvent?: UnmarkedAsDuplicateEventResolvers<ContextType>;
  UnminimizeCommentPayload?: UnminimizeCommentPayloadResolvers<ContextType>;
  UnpinIssuePayload?: UnpinIssuePayloadResolvers<ContextType>;
  UnpinnedEvent?: UnpinnedEventResolvers<ContextType>;
  UnresolveReviewThreadPayload?: UnresolveReviewThreadPayloadResolvers<ContextType>;
  UnsubscribeFromNotificationsPayload?: UnsubscribeFromNotificationsPayloadResolvers<ContextType>;
  UnsubscribedEvent?: UnsubscribedEventResolvers<ContextType>;
  Updatable?: UpdatableResolvers<ContextType>;
  UpdatableComment?: UpdatableCommentResolvers<ContextType>;
  UpdateBranchProtectionRulePayload?: UpdateBranchProtectionRulePayloadResolvers<ContextType>;
  UpdateCheckRunPayload?: UpdateCheckRunPayloadResolvers<ContextType>;
  UpdateCheckSuitePreferencesPayload?: UpdateCheckSuitePreferencesPayloadResolvers<ContextType>;
  UpdateDiscussionCommentPayload?: UpdateDiscussionCommentPayloadResolvers<ContextType>;
  UpdateDiscussionPayload?: UpdateDiscussionPayloadResolvers<ContextType>;
  UpdateEnterpriseAdministratorRolePayload?: UpdateEnterpriseAdministratorRolePayloadResolvers<ContextType>;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload?: UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload?: UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload?: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload?: UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanDeleteIssuesSettingPayload?: UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload?: UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload?: UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanMakePurchasesSettingPayload?: UpdateEnterpriseMembersCanMakePurchasesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload?: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload?: UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseOrganizationProjectsSettingPayload?: UpdateEnterpriseOrganizationProjectsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseOwnerOrganizationRolePayload?: UpdateEnterpriseOwnerOrganizationRolePayloadResolvers<ContextType>;
  UpdateEnterpriseProfilePayload?: UpdateEnterpriseProfilePayloadResolvers<ContextType>;
  UpdateEnterpriseRepositoryProjectsSettingPayload?: UpdateEnterpriseRepositoryProjectsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseTeamDiscussionsSettingPayload?: UpdateEnterpriseTeamDiscussionsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload?: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadResolvers<ContextType>;
  UpdateEnvironmentPayload?: UpdateEnvironmentPayloadResolvers<ContextType>;
  UpdateIpAllowListEnabledSettingPayload?: UpdateIpAllowListEnabledSettingPayloadResolvers<ContextType>;
  UpdateIpAllowListEntryPayload?: UpdateIpAllowListEntryPayloadResolvers<ContextType>;
  UpdateIpAllowListForInstalledAppsEnabledSettingPayload?: UpdateIpAllowListForInstalledAppsEnabledSettingPayloadResolvers<ContextType>;
  UpdateIssueCommentPayload?: UpdateIssueCommentPayloadResolvers<ContextType>;
  UpdateIssuePayload?: UpdateIssuePayloadResolvers<ContextType>;
  UpdateLabelPayload?: UpdateLabelPayloadResolvers<ContextType>;
  UpdateNotificationRestrictionSettingPayload?: UpdateNotificationRestrictionSettingPayloadResolvers<ContextType>;
  UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload?: UpdateOrganizationAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType>;
  UpdateOrganizationWebCommitSignoffSettingPayload?: UpdateOrganizationWebCommitSignoffSettingPayloadResolvers<ContextType>;
  UpdateParameters?: UpdateParametersResolvers<ContextType>;
  UpdatePatreonSponsorabilityPayload?: UpdatePatreonSponsorabilityPayloadResolvers<ContextType>;
  UpdateProjectCardPayload?: UpdateProjectCardPayloadResolvers<ContextType>;
  UpdateProjectColumnPayload?: UpdateProjectColumnPayloadResolvers<ContextType>;
  UpdateProjectPayload?: UpdateProjectPayloadResolvers<ContextType>;
  UpdateProjectV2CollaboratorsPayload?: UpdateProjectV2CollaboratorsPayloadResolvers<ContextType>;
  UpdateProjectV2DraftIssuePayload?: UpdateProjectV2DraftIssuePayloadResolvers<ContextType>;
  UpdateProjectV2ItemFieldValuePayload?: UpdateProjectV2ItemFieldValuePayloadResolvers<ContextType>;
  UpdateProjectV2ItemPositionPayload?: UpdateProjectV2ItemPositionPayloadResolvers<ContextType>;
  UpdateProjectV2Payload?: UpdateProjectV2PayloadResolvers<ContextType>;
  UpdateProjectV2StatusUpdatePayload?: UpdateProjectV2StatusUpdatePayloadResolvers<ContextType>;
  UpdatePullRequestBranchPayload?: UpdatePullRequestBranchPayloadResolvers<ContextType>;
  UpdatePullRequestPayload?: UpdatePullRequestPayloadResolvers<ContextType>;
  UpdatePullRequestReviewCommentPayload?: UpdatePullRequestReviewCommentPayloadResolvers<ContextType>;
  UpdatePullRequestReviewPayload?: UpdatePullRequestReviewPayloadResolvers<ContextType>;
  UpdateRefPayload?: UpdateRefPayloadResolvers<ContextType>;
  UpdateRefsPayload?: UpdateRefsPayloadResolvers<ContextType>;
  UpdateRepositoryPayload?: UpdateRepositoryPayloadResolvers<ContextType>;
  UpdateRepositoryRulesetPayload?: UpdateRepositoryRulesetPayloadResolvers<ContextType>;
  UpdateRepositoryWebCommitSignoffSettingPayload?: UpdateRepositoryWebCommitSignoffSettingPayloadResolvers<ContextType>;
  UpdateSponsorshipPreferencesPayload?: UpdateSponsorshipPreferencesPayloadResolvers<ContextType>;
  UpdateSubscriptionPayload?: UpdateSubscriptionPayloadResolvers<ContextType>;
  UpdateTeamDiscussionCommentPayload?: UpdateTeamDiscussionCommentPayloadResolvers<ContextType>;
  UpdateTeamDiscussionPayload?: UpdateTeamDiscussionPayloadResolvers<ContextType>;
  UpdateTeamReviewAssignmentPayload?: UpdateTeamReviewAssignmentPayloadResolvers<ContextType>;
  UpdateTeamsRepositoryPayload?: UpdateTeamsRepositoryPayloadResolvers<ContextType>;
  UpdateTopicsPayload?: UpdateTopicsPayloadResolvers<ContextType>;
  UpdateUserListPayload?: UpdateUserListPayloadResolvers<ContextType>;
  UpdateUserListsForItemPayload?: UpdateUserListsForItemPayloadResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserBlockedEvent?: UserBlockedEventResolvers<ContextType>;
  UserConnection?: UserConnectionResolvers<ContextType>;
  UserContentEdit?: UserContentEditResolvers<ContextType>;
  UserContentEditConnection?: UserContentEditConnectionResolvers<ContextType>;
  UserContentEditEdge?: UserContentEditEdgeResolvers<ContextType>;
  UserEdge?: UserEdgeResolvers<ContextType>;
  UserEmailMetadata?: UserEmailMetadataResolvers<ContextType>;
  UserList?: UserListResolvers<ContextType>;
  UserListConnection?: UserListConnectionResolvers<ContextType>;
  UserListEdge?: UserListEdgeResolvers<ContextType>;
  UserListItems?: UserListItemsResolvers<ContextType>;
  UserListItemsConnection?: UserListItemsConnectionResolvers<ContextType>;
  UserListItemsEdge?: UserListItemsEdgeResolvers<ContextType>;
  UserListSuggestion?: UserListSuggestionResolvers<ContextType>;
  UserStatus?: UserStatusResolvers<ContextType>;
  UserStatusConnection?: UserStatusConnectionResolvers<ContextType>;
  UserStatusEdge?: UserStatusEdgeResolvers<ContextType>;
  VerifiableDomain?: VerifiableDomainResolvers<ContextType>;
  VerifiableDomainConnection?: VerifiableDomainConnectionResolvers<ContextType>;
  VerifiableDomainEdge?: VerifiableDomainEdgeResolvers<ContextType>;
  VerifiableDomainOwner?: VerifiableDomainOwnerResolvers<ContextType>;
  VerifyVerifiableDomainPayload?: VerifyVerifiableDomainPayloadResolvers<ContextType>;
  ViewerHovercardContext?: ViewerHovercardContextResolvers<ContextType>;
  Votable?: VotableResolvers<ContextType>;
  Workflow?: WorkflowResolvers<ContextType>;
  WorkflowFileReference?: WorkflowFileReferenceResolvers<ContextType>;
  WorkflowRun?: WorkflowRunResolvers<ContextType>;
  WorkflowRunConnection?: WorkflowRunConnectionResolvers<ContextType>;
  WorkflowRunEdge?: WorkflowRunEdgeResolvers<ContextType>;
  WorkflowRunFile?: WorkflowRunFileResolvers<ContextType>;
  WorkflowsParameters?: WorkflowsParametersResolvers<ContextType>;
  X509Certificate?: GraphQLScalarType;
};

export type DirectiveResolvers<ContextType = any> = {
  possibleTypes?: PossibleTypesDirectiveResolver<any, any, ContextType>;
  preview?: PreviewDirectiveResolver<any, any, ContextType>;
  requiredCapabilities?: RequiredCapabilitiesDirectiveResolver<
    any,
    any,
    ContextType
  >;
};
